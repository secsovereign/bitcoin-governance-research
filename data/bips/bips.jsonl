{"bip_number": 443, "filename": "bip-0443.mediawiki", "content": "<pre>\n  BIP: 443\n  Layer: Consensus (soft fork)\n  Title: OP_CHECKCONTRACTVERIFY\n  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0443\n  Status: Draft\n  Type: Standards Track\n  Created: 2025-05-08\n  License: BSD-3-Clause\n  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n</pre>\n\n\n== Abstract ==\n\nThis BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions:\n<code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n\nThis opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be\nvalidated during the execution of the script, allowing introspection to the committed data. Moreover, a script can\nconstrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n\nIn conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that\nallow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to\nan entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector\ncommitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and\ncompose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition\ndepends on the conditions that can be expressed in the program (scripts in the taptree).\n\n=== Copyright ===\n\nThis document is licensed under the 3-clause BSD license.\n\n=== Motivation ===\n\nThe ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of\nnumerous attempts to improve bitcoin. Some of the proposed applications include:\n\n* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-0119.mediawiki|BIP-119]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n\nConstructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry\nstate with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely\nhigh cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible\nexecution paths. Moreover, the design of fully trustless bridges remains elusive.\n\nRather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building\nblock that is widely applicable, and common to many constructions.\n\n== Design ==\n\n<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called\n''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the\nexecution of the script, and ''carry'' a (possibly dynamically computed) piece of data to the new UTXOs that are\nproduced.\n\nWe consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and\na Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined\nin BIP-341.\n\nIf the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data.\nThe resulting key is the taproot internal key per BIP-341.\n\nThis allows to embed a commitment to the data that can be validated during the script execution, while staying fully\ncompatible with taproot. Notably:\n* the committed data does not make the UTXO any larger;\n* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data\u2019s hash)<ref>For example, in a multi-party contract, the naked key could be an aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the\n  cheapest way of spending the UTXO \u2014 albeit not always possible in practice.</ref>;\n* if multiple scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n\n<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the\ntransaction (typically, the UTXO being spent, in order to access its committed data), or one of the outputs of the\ntransaction (in order to define its program, and possibly its committed data).\n\n=== Output amounts ===\n\nWhen checking the script of one or more outputs with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to\nalso check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the\noutputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n\nThere are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code>\nparameter:\n* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n* ''ignore'': the output amount is ignored.\n* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n\nThe ''default'' logic covers the common case where a UTXO\u2019s full amount is required to be sent to a specific output.\n\nThe ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked\nwith a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n\nThe following figures illustrate some common examples of supported use cases for the amount logic. This list is not\nexhaustive, as there are many more possible combinations.\n\n'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic\nin the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting\nof the same amounts.\n\n'''Remark:''' it is allowed for multiple inputs to check the same output with the ''default'' logic. This\nallows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n\n-----\n\n::[[File:bip-0443/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n\n-----\n\n::[[File:bip-0443/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n\n-----\n\n::[[File:bip-0443/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n\n-----\n\n::[[File:bip-0443/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n\n-----\n\nNote that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using\na scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with future\nintrospection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n\n=== Paying fees ===\n\nSince the amount-checking semantics of <code>OP_CHECKCONTRACTVERIFY</code> are designed to preserve the entire input\namount across one or more outputs, transaction fees must be paid exogenously. This can be achieved by adding an extra\ninput to the transaction, by using an anchor output, or with other future mechanisms.\n\nThe ''ignore'' amount mode is not a safe mechanism for paying endogenous fees. An output checked with this mode has no\namount constraint, which would allow a miner to claim the entire value of that input. This mode is included for forward\ncompatibility with potential future soft forks that may introduce other amount-related logic that is compatible with\n<code>OP_CHECKCONTRACTVERIFY</code>'s script checks.\n\n\n== Specification ==\n\nThe tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement\n<code>OP_CHECKCONTRACTVERIFY</code>.\n\nWhen evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n<code>0xbb</code>), the expected format of the stack, shown bottom-to-top, is:\n\n<source>\n<data> <index> <pk> <taptree> <mode>\n</source>\n\nwhere:\n\n* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n* <code><data></code> is a buffer of arbitrary length.\n\nIn short, the semantics of the opcode with respect to the script can be summarized as follows:\n\n<blockquote>\nVerify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk',\ntweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n</blockquote>\n\nIf the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n\n<source lang=\"python\">\n  data_tweak = sha256(pk || data)\n</source>\n\nIn the following, the ''current input'' is the input whose script is being executed.\n\nThe following values of the <code><mode></code> are defined:\n* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n\nAny other value of the <code><mode></code> makes the opcode succeed validation immediately for the current\ninput<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode\nwould always be hard-coded via a push in the script, the risk of mistakes seems negligible.</ref>.\n\nThe following values of the other parameters have special meanings:\n* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n* If the <code><pk></code> is 0, it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-0341.mediawiki|BIP-341]]. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n* If the <code><index></code> is -1, it is replaced with the index of the current input.\n* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n\nAny other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters\nis invalid, and makes the opcode immediately fail validation.\n\n=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n\nThe specification is divided into three parts:\n* the transaction-wide initialization;\n* the input initialization;\n* the opcode evaluation.\n\nThe following helper function is a variant of <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]],\nexcept that a regular SHA256-hash is used instead of a tagged hash, and the pubkey is returned unchanged if the length\nof <code>data</code> is 0.\n\n<source lang=\"python\">\ndef tweak_embed_data(pubkey, data):\n    assert len(pubkey) == 32\n\n    if len(data) == 0:\n      return None, pubkey\n\n    data_tweak = sha256(pubkey + data)\n\n    t = int_from_bytes(data_tweak)\n    if t >= SECP256K1_ORDER:\n        raise ValueError\n    P = lift_x(int_from_bytes(pubkey))\n    if P is None:\n        raise ValueError\n    Q = point_add(P, point_mul(G, t))\n    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n</source>\n\nThe <code>taproot_tweak_pubkey</code> function is also used as a helper in the pseudocode below.\n\nThe following notations are used in the pseudocode below:\n* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n* <code>inputs[i]</code> is the i-th input of the transaction;\n* <code>outputs[i]</code> is the i-th output of the transaction;\n* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index,\n  taproot internal key and taproot Merkle root of the current input, respectively.\n* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n\n==== Transaction-wide initialization ====\n\nThis is executed once for the entire transaction, before any of the transaction input's scripts are evaluated.\nIt initializes three arrays that are used to keep track of the amount information of the output.\n\n<source lang=\"python\">\n  output_min_amount = [0] * n_outputs\n  output_checked_default = [False] * n_outputs\n  output_checked_deduct = [False] * n_outputs\n</source>\n\n==== Input initialization ====\n\nThis is executed at the beginning of the evaluation of each input's script. It initializes the residual amount to equal\nthe full amount of the current input.\n\n<source lang=\"python\">\n  residual_input_amount = inputs[this_input_index].amount\n</source>\n\n==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n\nThe following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the\nevaluation of a taproot script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and\n<code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n\n<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>\ndefined in [[bip-0341.mediawiki|BIP-341]].\n\n<source lang=\"python\">\n  if mode < CCV_MODE_CHECK_INPUT or mode > CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT:\n    return success()  # undefined mode is OP_SUCCESS\n\n  if index == -1:\n    index = this_input_index\n\n  if mode == CCV_MODE_CHECK_INPUT:\n    if index < 0 or index >= n_inputs:\n      return fail()  # input index out of bounds\n\n    target_script = inputs[index].scriptPubKey\n  else:\n    if index < 0 or index >= n_outputs:\n      return fail()  # output index out of bounds\n\n    target_script = outputs[index].scriptPubKey\n\n  if taptree == <-1>:\n    taptree = this_input_taptree\n\n  if pk == <0>:\n    naked_key = BIP341_NUMS_KEY\n  elif pk == <-1>:\n    naked_key = this_input_internal_key\n  elif len(pk) == 32:\n    naked_key = pk\n  else:\n    return fail()\n\n  # Verify the target contract data and program\n  _, internal_key = tweak_embed_data(naked_key, data)\n\n  if len(taptree) != 0:\n    if len(taptree) != 32:\n      return fail()\n\n    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n  else:\n    final_key = internal_key\n\n  if target_script != P2TR(final_key):\n    return fail()\n\n  # Amount checks\n\n  if mode == CCV_MODE_CHECK_OUTPUT:\n    # default amount semantic\n    if output_checked_deduct[index]:\n      return fail()\n\n    output_min_amount[index] += residual_input_amount\n    residual_input_amount = 0\n\n    if outputs[index].amount < output_min_amount[index]:\n      return fail()\n\n    output_checked_default[index] = True\n  elif mode == CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT:\n    # 'deduct' amount semantic\n    if residual_input_amount < outputs[index].amount:\n      return fail()\n\n    if output_checked_default[index] or output_checked_deduct[index]:\n      return fail()\n\n    residual_input_amount = residual_input_amount - outputs[index].amount\n    output_checked_deduct[index] = True\n\n  stack.pop(5)  # drop all 5 stack elements\n</source>\n\n==== sigops budget ====\n\nTODO\n\n== Policy changes ==\n\nTODO\n\n== Implementation ==\n\nA reference implementation is provided as a bitcoin-core [https://github.com/bitcoin/bitcoin/pull/32080 pull request].\n\n== Examples ==\n\nThis section documents some common script fragments that use <code>OP_CHECKCONTRACTVERIFY</code> for various common\nchoices of the parameters. Depending on the use case, some of the parameters might be passed via the witness stack.\nIn these examples, <code><></code> (empty buffer) and <code>0</code> both refer to an empty stack element.\n\n----\n\nCheck data embedded in the current input:\n<source>\n<data=data>\n<index=-1>\n<pk=naked_pk>\n<taptree=-1>\n<mode=-1 (CCV_MODE_CHECK_INPUT)>\nOP_CHECKCONTRACTVERIFY\n</source>\n\nThis would be used to access the data committed in the current input. The <code><data></code> parameter, of course,\nwould be passed via the witness stack.\n\n----\n\nCheck that the input with index <code>in_i</code> is a specific contract with embedded <code>input_data</code>:\n<source>\n<data=input_data>\n<index=in_i>\n<pk=input_i_naked_pk>\n<taptree=input_i_taptree>\n<mode=-1 (CCV_MODE_CHECK_INPUT)>\nOP_CHECKCONTRACTVERIFY\n</source>\n\nThis allows introspecting the program (naked key and taptree) and data of another input of the transaction.\n\n----\n\nCheck that the output with index <code>out_i</code> is a certain contract (pubkey and taptree) with the specified\nembedded <code><data></code>, preserving input amount:\n<source>\n<data=data>\n<index=out_i>\n<pk=output_naked_pk>\n<taptree=output_taptree>\n<mode=0 (CCV_MODE_CHECK_OUTPUT)>\nOP_CHECKCONTRACTVERIFY\n</source>\n\nThis allows introspecting an output's program and data, and sending the full residual amount to it. Logically, it can be\nthought as a state transition, moving money to a different state, but still under the control of the pre-set rules.\nTypically, the <code>data</code> would be computed based on the witness stack, while the output program would be\nhard-coded in Script.\n\n----\n\nCheck that the output with index <code>out_i</code> is a P2TR with pubkey <code>output_pk</code>, preserving amount:\n<source>\n<data=<>>  # no data\n<index=out_i>\n<pk=output_pk>\n<taptree=<>>  # no taptweak\n<mode=0 (CCV_MODE_CHECK_OUTPUT)>\nOP_CHECKCONTRACTVERIFY\n</source>\n\nUnlike the previous example, here there is no computation over the destination taproot public key, since both\n<code>data</code> and <code>taptweak</code> are omitted.\n\n----\n\nCheck that the output with index <code>out_i</code> is a certain contract (pubkey and taptree) with the specified\nembedded <code>data</code>; don't check amount:\n<source>\n<data=data>\n<index=out_i>\n<pk=output_i_naked_pk>\n<taptree=output_i_taptree>\n<mode=1 (CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT)>\nOP_CHECKCONTRACTVERIFY\n</source>\n\n'''Remark:''' amounts are malleable with this check alone; therefore, it is expected that the amount is also checked\nwith separate introspection opcodes.\n\n----\n\nCheck that the amount of the current input is partially sent to the first output (that must have a certain pubkey), and\nall the remaining amount is sent to the second output, which has the same internal key and taptree as the current input:\n<source>\n<data=<>>     # no data\n<index=0>\n<pk=<output_0_pk>>\n<taptree=<>>  # no tweak\n<mode=2 (CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT)>\nOP_CHECKCONTRACTVERIFY\n\n<data=<>>     # no data\n<index=1>\n<pk=-1>\n<taptree=-1>\n<mode=0 (CCV_MODE_CHECK_OUTPUT)>\nOP_CHECKCONTRACTVERIFY\n</source>\n\n'''Remark:''' in some applications, it might be desirable to check the exact amount of the first output with separate\nintrospection opcodes.\n\n== Applications ==\n\nTODO\n\n== Deployment ==\n\nThe activation mechanism, and the set of other BIPs to be concurrently deployed, are to be determined.\n\n== Backwards compatibility ==\n\n<code>OP_CHECKCONTRACTVERIFY</code> replaces the witness v1-only opcode OP_SUCCESS187 with stricter verification\nsemantics. Consequently, scripts using those opcodes which previously were valid will cease to be valid with this change.\n\nStricter verification semantics for an OP_SUCCESSx opcode are a soft fork, so existing software will be fully functional\nwithout upgrade except for mining and block validation.\n\n== Footnotes ==\n\n<references />\n\n\n== Acknowledgements ==\n\nTODO\n", "content_length": 21985}
{"bip_number": 431, "filename": "bip-0431.mediawiki", "content": "<pre>\n  BIP: 431\n  Layer: Applications\n  Title: Topology Restrictions for Pinning\n  Author: Gloria Zhao <gloriajzhao@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0431\n  Status: Draft\n  Type: Informational\n  Created: 2024-01-10\n  License: BSD-3-Clause\n  Post-History: 2022-01-27: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html [bitcoin-dev] discussion\n                2022-01-27: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff gist discussion\n                2022-09-23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html [bitcoin-dev] proposal\n                2024-01-02: https://delvingbitcoin.org/t/v3-transaction-policy-for-anti-pinning/340 Delving Bitcoin post\n                2024-01-16: https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 Delving Bitcoin post\n</pre>\n\n==Abstract==\n\nThis document describes pinning problems that can arise from limitations in mempool policy.\n\nIt also describes a type of policy with adjusted topology limits which, combined with other policy rules, helps minimize the potential pinning problems.  These restrictions simplify the assessment of incentive compatibility of accepting or replacing such transactions, thus helping ensure any replacements are more profitable for the node. Within the context of nodes that implement this policy, fee-bumping is more reliable for users.\n\n==Motivation==\n\nMempools typically accept and relay transactions that spend outputs from other unconfirmed transactions, but restrict package sizes through ancestor and descendant limits\n<ref>https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-limits.md</ref>\nto limit the computational complexity of mempool operations and mitigate Denial of Service attacks.\n\nUsers may also create unconfirmed transactions that conflict with -- or are \"double spends\" of -- each other by spending the same input(s) in both.\nInstead of always keeping the first-seen transaction, many mempools also have some kind of Replace by Fee (RBF) policy\n<ref>\n[https://github.com/bitcoin/bitcoin/blob/632a2bb731804dffe52bd4cbd90bfee352d25ede/doc/policy/mempool-replacements.md Bitcoin Core's RBF policy] at the time of writing. It is slightly different from what is described in BIP 125.\n</ref>\nto keep the more incentive compatible transaction, i.e. one that would earn a miner more fees. Users utilize these rules when they create higher feerate double-spends (replacements) to expedite confirmation of their transactions.\n\nHowever, these policies make imperfect trade-offs between incentive compatibility and DoS-resistance. For example, malicious actors may sometimes exploit limitations to prevent incentive-compatible transactions from being accepted or fee-bumped (''pinning'').\n\nPinning is consequential to contracting protocols in which untrusted parties construct and sign time-sensitive transactions to be broadcast on-chain later\n<ref>Posts about pinning in LN and LN-Symmetry:\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html \"RBF Pinning with Counterparties and Competing Interest\"]\n* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html \"Pinning : The Good, The Bad, The Ugly\"]\n* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md \"Pinning Attacks\"]\n* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 \"Eltoo Pinning\"]\n</ref>.\nWhen the funds available to be redeemed by each party depend on a transaction confirming within a specific time window, a malicious party may be able to steal money if the honest party cannot get their transaction confirmed. As such, the ability to fee-bump a transaction to entice miners to include it in their blocks is crucial to the security of the protocol.\n\n===RBF pinning through absolute fees===\n\nImagine that counterparties Alice and Mallory have transactions (or packages) A and B, respectively, which conflict with each other. Alice broadcasts A and Mallory broadcasts B. RBF rules require the replacement transaction pay a higher absolute fee than the aggregate fees paid by all original transactions ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 3\"]). This means Mallory may increase the fees required to replace B beyond what Alice was planning to pay for A's fees.\n\n1. Adding transaction(s) that descend from B and pay a low feerate (too low to fee-bump B through CPFP)<ref>Example: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-December/022216.html</ref>.\n\n2. Adding a high-fee descendant of B that also spends from another large, low-feerate mempool transaction (where the fee of the descendant is too low to fee-bump both B and its other parent through CPFP)<ref>Example: https://github.com/bitcoin/bitcoin/pull/25038#issuecomment-1320295394</ref>.\n\n===RBF pinning through number of conflicts===\n\nRBF rules require that no replacement trigger the removal of more than 100 transactions ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 5\"]). This number includes the descendants of the conflicted mempool transactions. Mallory can make it more difficult to replace transactions by attaching lots of descendants to them. For example, if Alice wants to batch-replace 5 transactions but each has 21 descendants, her replacement will be rejected regardless of its fees.\n\n===RBF incentive compatibility requirements===\n\nThere is currently no effective rule to enforce that a replacement transaction would be more incentive compatible to keep in the mempool. It is difficult to quantify the incentive compatibility of a set of transactions, especially in comparison with another set of transactions<ref>https://delvingbitcoin.org/t/mempool-incentive-compatibility/553</ref>, but the requirement of a feerate increase ([https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md#current-replace-by-fee-policy \"Rule 6\"]) is far too simplistic.\n\nFor example, a user could create a replacement transaction that pays more fees and is higher feerate, but has a low feerate ancestor and would confirm slower than the original transaction. As a result, all transactions signed with SIGHASH_ANYONECANPAY are vulnerable to being replaced by a transaction that will confirm later than the original<ref>https://github.com/bitcoin/bitcoin/pull/23121#pullrequestreview-766271585</ref>.\n\n===Child fees don't count towards RBF rules===\n\nA transaction must meet all fee-related requirements (Rules 3, 4, 6) alone; its child's fees cannot be used. A ''Package RBF'' policy would allow a transaction's child to be used for its RBF requirements.\n\nIn LN Penalty, conflicting commitment transactions signed with the same fees cannot replace each other, even if accompanied by a fee-bumping child. This limitation necessitates the presence of two anchor outputs, allowing both parties to fee-bump either commitment transaction that enters their mempool.\n\n===Package limit pinning and replacing CPFP Carve Out===\n\nMempool policies limit the number and total virtual size of an unconfirmed transaction's descendants. A fee-bumping child of an unconfirmed transaction (CPFP) may be rejected for exceeding the descendant limit. When a transaction has multiple outputs owned by different parties, a malicious party can prevent the other(s) from CPFPing their transaction by attaching enough descendants to monopolize the descendant limit (''package limit pinning'').\n\nLN commitment transactions rely on CPFP carve out <ref>[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html \"CPFP Carve-Out for Fee-Prediction Issues in Contracting Applications (eg Lightning)\"]</ref> to avoid package limit pinning.\n\nThere are weaknesses with this approach of using 2 anchors and CPFP Carve Out. This proposal helps address a few of them (see Related Work for how other weaknesses are addressed):\n\n* Cluster Mempool necessitates the removal of CPFP Carve Out <ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>.\n* CPFP Carve Out only allows ''one more'' child to be added to the transaction. This means it cannot guarantee the ability to CPFP for more than 2 parties of a shared transaction.\n\n==Topologically Restricted Until Confirmation==\n\nThis section describes one approach for opt-in policy rules that can realistically be deployed today and is useful to today's applications.\nIt is based on the idea that most limitations stem from existing ancestor/descendant package limits being too permissive for the majority of use cases.\n\nThe scope of the policy's anti-pinning benefits is limited to the individual node's mempool, and the degree to which a user's transaction is safe from pinning depends how much of the network has adopted this policy.\n\nSimilarly, there are multiple approaches to creating a policy to minimize pinning, more may become available over time (see Related Work section), and the details of this approach can be tweaked if conditions change. For example, if loosening one of the topology restrictions enables a new use case while still providing acceptable pinning bounds, it can be changed.\n\n===Specification===\n\nSenders can signal that they want a transaction to be Topologically Restricted Until Confirmation (TRUC). Specifically, set <code>nVersion=3</code>.\nA node that implements this policy would apply their existing standardness and policy rules, along with the following set of rules, to TRUC transactions:\n\n1. A TRUC transaction signals replaceability, even if it does not signal BIP125 replaceability.\n\n2. Any TRUC transaction's unconfirmed ancestors must all be TRUC. Any descendant of an unconfirmed TRUC transaction must also be TRUC.\n<ref>Rationale:\n* Requiring packages to be all-or-none TRUC makes it possible to enforce the topology limits. For example, the TRUC descendant limit would not be very meaningful if it could be bypassed by creating a non-TRUC child.\n* Combined with Rule 1, this requirement creates \"inherited signaling\" when descendants of unconfirmed transactions are created. Checking whether a transaction signals replaceability this way does not require mempool traversal, and does not change based on what transactions are mined.\n</ref>\nNote: A TRUC transaction can spend outputs from ''confirmed'' non-TRUC transactions. A non-TRUC transaction can spend outputs from ''confirmed'' TRUC transactions.\n\n3. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed ancestor. An unconfirmed TRUC transaction cannot have more than 1 unconfirmed descendant. CPFP Carve Out is not granted to TRUC transactions.\n<ref>Rationale:\n* The larger the descendant limit, the more transactions may need to be replaced. See #1 in Rule 3 Pinning section above. This also makes pinning using Rule 5 more difficult, since a directly conflicting transaction has fewer possible descendants.\n* These two limits (ancestor count 2, descendant count 2) effectively create a cluster limit using the existing ancestor and descendant limits. Increasing them to 3 would imply an infinite cluster count limit.\n* This 1-parent-1-child topology makes it possible to use ancestor score (minimum of ancestor feerate and individual feerate) as a measure of incentive compatibility.\n\n<br />Q: Why not allow multiple parents to enable batched fee-bumping?\n<br />To mitigate pinning through absolute fees, we need to prevent a child of an unconfirmed TRUC transaction from bringing in more unconfirmed ancestors. See #2 in \"RBF pinning through absolute fees\" section above.\n\n<br />Q: Why not allow another child?\n<br />Allowing another child disables the ability to use ancestor score to measure incentive compatibility. Imagine the original transaction, A, has a child B and co-parent C (i.e. B spends from A and C). C also has another child, D. B is one of the original transactions and thus its ancestor feerate must be lower than the package's feerate. However, this may be an underestimation because D can bump C without B's help. This is resolved if TRUC transactions can only have TRUC ancestors, as then C cannot have another child.\n\n<br />Q: Why allow any descendants at all?\n<br />At least 1 descendant is required to allow CPFP of the presigned transaction. Without package RBF, multiple anchor outputs would be required to allow each counterparty to fee-bump any presigned transaction. With package RBF, since the presigned transactions can replace each other, 1 anchor output is sufficient.\n</ref>\n\n4. A TRUC transaction cannot have a sigop-adjusted virtual size larger than 10,000 vB.\n<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for payments, HTLCs, or other uses of the transaction. Generally, having a smaller maximum size helps to better define bounds for algorithms and memory usage, and the existing limit of 100,000 vB seems much larger than necessary.\n</ref>\n\n5. A TRUC transaction that has an unconfirmed TRUC ancestor cannot have a sigop-adjusted virtual size larger than 1000 vB.\n<ref>Rationale: Limit the amount of virtual bytes (and thus fees) that may need to be replaced, while leaving a comfortable amount of space for inputs to fund the transaction.\n<br />Q: Why not bigger?\n<br />The larger the descendant size limit, the more vbytes may need to be replaced. With default limits, if the child is e.g. 100,000 vB, that might be an additional 100,000 sats (at 1 sat/vbyte) or more, depending on the feerate. Restricting all children to 1000 vB reduces the upper bound of the additional fees by a factor of 100.\n\n<br />This rule is also easily tacked on to existing logic for policy and wallets. A maximum size standard transaction (100 kvB) can have up to 1000 vB of descendants to be within the default descendant limit (101 kvB).\n\n<br />Q: Why not smaller?\n<br/>The smaller this limit, the fewer UTXOs a child may use to fund this fee-bump. For example, only allowing the TRUC child to have 2 inputs would require wallets to maintain a pool of high-value confirmed UTXOs. However, as the fee-bumping child only needs to fund fees (as opposed to payments), just a few UTXOs should suffice. With a limit of 1000 vB and usage of taproot outputs, the child can have 15 inputs and 2 outputs (calculated using [https://bitcoinops.org/en/tools/calc-size/ this tool]).\n</ref>\n\n6. An individual TRUC transaction is permitted to be below the mempool min relay feerate, assuming it is considered within a package that meets the mempool's feerate requirements.\n<ref>Rationale: This allows contracting protocols to create presigned transactions with 0 fees and fee-bump them using CPFP at broadcast time.\n</ref>\n\n====Implementation====\n\n* https://github.com/bitcoin/bitcoin/pull/28948\n* https://github.com/bitcoin/bitcoin/pull/29873\n* https://github.com/bitcoin/bitcoin/pull/29496\n\n====Related Work====\n\nThis 1-parent-1-child (aka cluster size 2) topology restriction makes the transactions much easier to reason about, which enables additional features like\nfeerate diagram comparisons\n<ref>\n[https://github.com/bitcoin/bitcoin/pull/29242 this PR] implements feerate diagram creation and comparison for sets of transactions in which the maximum cluster size is 2, e.g. all TRUC transactions.\n</ref>,\npackage RBF\n<ref>\n[https://github.com/bitcoin/bitcoin/pull/28984 this PR] implements package RBF, enforcing incentive compatibility by comparing the feerate diagrams of the mempool before and after replacement. The feerate diagrams are easy to build when the relevant clusters are of size 2 and below, so package RBF is restricted to those scenarios. As TRUC transactions always have this property, package RBF is enabled for TRUC transactions.\n</ref>,\nand sibling eviction\n<ref>\n[https://github.com/bitcoin/bitcoin/pull/29306 This PR] implements sibling eviction for TRUC transactions: if a new transaction would exceed a transaction's descendant limit, it considers evicting the existing descendant using replacement rules. Sibling eviction is feasible for TRUC transactions because there is no difficulty in identifying which descendant to evict (there can only be 1).\n</ref>.\n\nThe [https://github.com/bitcoin/bips/pull/1524 Ephemeral Anchors] proposal builds on top of this one to add more features.\nIt changes the anchor script to be anyone can spend, allowing anybody to add fees and reducing the onchain footprint and fee costs.\nIt also allows anchor outputs to have 0 value, eliminating the need to deduct value from the input amount in order to create anchors.\n\nThe [https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393/7 Cluster Mempool] proposal makes fundamental changes to mempool structure and policy rules, enabling the accurate assessment of the incentive compatibility of accepting or removing a transaction, among other things. Notably, Cluster Mempool introduces a limit to all transactions' cluster size to make incentive compatibility calculations feasible. This cluster limit is similar to TRUC limits in that it bounds computation to enable improved policies, but is applied to all transactions (not just ones that opt in) and is much less restrictive than TRUC limits.\n\nCluster Mempool provides a more holistic solution to some of the problems listed (such as adding an incentive compatibility requirement to RBF and safely enabling package RBF for more complex topologies). However, it does not help resolve all problems (such as RBF Pinning through absolute fees and number of conflicts). Also, since Cluster Mempool is incompatible with CPFP Carve Out<ref>https://delvingbitcoin.org/t/an-overview-of-the-cluster-mempool-proposal/393#the-cpfp-carveout-rule-can-no-longer-be-supported-12</ref>, TRUC with sibling eviction and package RBF provide an alternative solution to applications that rely on it.\n\nBuilding on top of Cluster Mempool, there are also various ideas for extending TRUC transactions and creating another anti-pinning policy\n<ref>https://delvingbitcoin.org/t/v3-and-some-possible-futures/523/3</ref>.\n\n[https://bitcoinops.org/en/topics/package-relay Package Relay] includes changes in p2p protocol, transaction relay logic, and mempool policy to enable nodes to accept and relay packages of transactions. Much of this proposal's utility relies on the existence of package relay for 1-parent-1-child packages (the topology TRUC supports).\n\n====Backward Compatibility====\n\nTransactions with <code>nVersion=3</code> were previously nonstandard. There are no known conflicts with previous usage.\n\n====Intended Usage====\n\nGenerally, users with no interest in spending unconfirmed outputs from a transaction can make them TRUC transactions for more robust RBF abilities.\n\nThis proposal allows for a different solution to fee-bumping in LN, in which commitment transactions are signed with 0 fees and include a single anchor that can later be used to add fees at broadcast time\n<ref>Proposals for changes to LN commitment transaction format using TRUC and a single anchor:\n* [https://delvingbitcoin.org/t/lightning-transactions-with-v3-and-ephemeral-anchors/418 \"Lightning transactions with v3 and ephemeral anchors\"]\n* [https://github.com/instagibbs/bolts/commits/zero_fee_commitment bolts proposal branch]\n* See \"Intended usage for LN\" section in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html \"New transaction policies (nVersion=3) for contracting protocols\"]\n</ref>.\nA similar fee-bumping model can also be used in other contracting protocols\n<ref>Examples of non-LN protocols that have shown interest in, designed, or built fee-bumping using TRUC:\n* A LN-Symmetry implementation using TRUC and ephemeral anchors: [https://delvingbitcoin.org/t/ln-symmetry-project-recap/359 LN-Symmetry Project Recap] [https://github.com/instagibbs/lightning/tree/eltoo_support branch]\n* See \"Managing Fees Safely\" mentioning ephemeral anchors in [https://jameso.be/vaults.pdf \"Vaults and Covenants\"]\n</ref>.\n\n==Alternatives==\n\nVarious alternatives for RBF\n<ref>Proposals and discussions dedicated to improving RBF:\n* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff \"RBF Improvements\"]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html \"Improving RBF Policy\"]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n</ref>\nand new fee-bumping mechanisms\n<ref>\n<br />Proposals and discussions dedicated to improving or creating new fee-bumping mechanisms:\n* [https://github.com/lightning/bolts/pull/1036 \"Add option to sign commitments at various feerates\"]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019243.html \"A Stroll through Fee-Bumping Techniques : Input-Based vs Child-Pay-For-Parent\"]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html \"A Replacement for RBF and CPFP: Non-Destructive TXID Dependencies for Fee Sponsoring\"]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html \"Thoughts on fee bumping\"]\n</ref>\nhave been proposed across multiple discussion threads.\nMost alternatives do not conflict with TRUC, and some work in conjunction with this proposal - see Related Work.\nA few popular ideas that were not incorporated into this work are summarized here.\n\n===Alternatives: add static incentive compatibility rule in RBF policy===\n\nAdd incentive compatibility requirement to RBF policy using some existing score or static calculation\n<ref>Examples of incentive compatibility score proposals and suggestions:\n* [https://github.com/bitcoin/bitcoin/pull/23121 \"check ancestor feerate in RBF, remove BIP125 Rule2\"]\n* [https://github.com/bitcoin/bitcoin/pull/26451 \"Enforce incentive compatibility for all RBF replacements\"]\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019841.html\n* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n</ref>.\n\nAs the incentive compatibility \"score\" of a transaction must be dynamically calculated given the structure of mempools today, there is no satisfactory solution. A full calculation is too computationally expensive. Static values can overestimate or underestimate, leading to more pinning problems <ref>Four examples of static calculations and an example in which they are all inaccurate: https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction</ref>.\nThe ability to calculate incentive compatibility scores efficiently is a primary feature and motivation for both TRUC transactions and Cluster Mempool.\n\n===Alternatives: replace by feerate===\n\n\"Instead of using Rule 3 and/or 4 (requiring an increase in absolute fees), allow replacements with a higher feerate.\"\n\nOne variation of this proposal is to apply this rule in certain exceptional scenarios or when the replacement would confirm \"soon\"\n<ref>Examples of Replace by Feerate proposals and suggestions:\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016998.html \"[PROPOSAL] Emergency RBF (BIP 125)\"]\n* [https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#fees-in-next-block-and-feerate-for-the-rest-of-the-mempool]\n* [https://petertodd.org/2024/one-shot-replace-by-fee-rate \"One-Shot Replace-by-Fee-Rate\"]\n</ref>.\n\nThe primary problem with these proposals is the potential for free relay and DDoS attacks.\n\nRemoving Rule 3 and 4 in general would allow free relay\n<ref>Examples of free relay with the removal of Rule 3 and/or 4:\n<br/> Consider a rule where the fee can be decreased (remove Rule 3 and 4) but the feerate must double. In this scenario, a 100 kvB transaction can be replaced by a 100 vB transaction paying 200 sats. That's 200 sats to relay 100,200 vB of transaction data, which is less than 0.002 sat/vB. It becomes quite cheap to replace large portions of the mempool, decreasing both its average feerate and total absolute fees.\n\n<br/>Consider a rule where the fee can stay the same (keep Rule 3 but drop Rule 4) but the feerate must double. The attacker can start out with 100 kvB transaction, paying 1 sat/vB. A user can reduce its size over and over again, doubling the feerate each time until it gets too small, and end up paying 100 ksat for 100 kvB(1 + 1/2 + 1/4 + ... + log2(mintxsize)) -> approaches 200 kvB. This means the attacker pays a rate of 0.5 sat/vB to relay transactions, which is below our \"free relay\" threshold of 1 sat/vB.\n</ref>.\n\nAnother issue is the complexity of defining and implementing a \"would confirm soon\" or \"is in the top N portion of the mempool.\" These proposals require an efficient way to assess the incentive compatibility score of a transaction and where it ranks amongst the other mempool transactions. This isn't feasible without something like cluster mempool (also see the \"add static incentive compatibility rule in RBF policy\" section above)\n<ref>Concerns about Replace by Feerate proposals\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017020.html\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017002.html\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019879.html\n* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4044451#gistcomment-4044451\n</ref>.\n\n===Alternatives: implement rate-limiting without fee rules===\n\"Since Rule 3 and 4 (requiring an increase in absolute fees) are for rate-limiting, replace them with a mempool-wide or per-peer rate limits on replacements by outpoint and/or bandwidth\n<ref>Examples of general rate-limiting proposals and suggestions:\n* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081349#gistcomment-4081349\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019820.html\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017024.html\n<br />Related proposal for changing the amount of bandwidth that replacement transactions use:\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019820.html\n</ref>.\"\n\nA problem with any global rate limit is that, in the absence of reputation or identities, the limit could be exhausted by an attacker, thus restricting replacements for honest users. For example, an outpoint-based rate limit could be exhausted by one dishonest participant of a shared transaction, preventing the other participants from making any replacements. There are also other concerns about implementation complexity, free relay issues, and other unresolved edge cases\n<ref>Concerns\n* https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4081559#gistcomment-4081559\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019921.html\n* https://docs.google.com/document/d/1LpYF17HdbXPGHKSl3WYdxG4XTJBNJKSn-c2UJ2yphhE/edit?usp=sharing\n</ref>.\n\n\n==Acknowledgements==\n\nThank you to everyone who contributed to this proposal and document, including\nJon Atack,\nMatt Corallo,\nSuhas Daftuar,\nMark Erhardt,\nAntoine Poinsot,\nAntoine Riard,\nGregory Sanders,\nand Bastien Teinturier.\n\n==References and Rationale==\n\n<references/>\n\n", "content_length": 27656}
{"bip_number": 390, "filename": "bip-0390.mediawiki", "content": "<pre>\n  BIP: 390\n  Layer: Applications\n  Title: musig() Descriptor Key Expression\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0390\n  Status: Draft\n  Type: Informational\n  Created: 2024-06-04\n  License: CC0-1.0\n  Requires: 380, 328\n</pre>\n\n==Abstract==\n\nThis document specifies a <tt>musig()</tt> key expression for output script descriptors.\n<tt>musig()</tt> expressions take multiple keys and produce an aggregate public key using [[bip-0327.mediawiki|BIP-327]].\n\n==Copyright==\n\nThis BIP is licensed under the Creative Commons CC0 1.0 Universal license.\n\n==Motivation==\n\n[[bip-0327.mediawiki|BIP-327]] introduces the MuSig2 Multi-Signature scheme. It is useful to have a way for keys to be used\nin a MuSig2 aggregate key to be expressed in descriptors so that wallets can more easily use MuSig2.\n\n==Specification==\n\nA new key expression is defined: <tt>musig()</tt>.\n\nIn the following sections, the term <tt>KEY</tt> refers to key expressions as defined in [[bip-0380.mediawiki|BIP-380]]\nand [[bip-0389.mediawiki|BIP-389]].\n\n===<tt>musig(KEY, KEY, ..., KEY)</tt>===\n\nThe <tt>musig(KEY, KEY, ..., KEY)</tt> expression can only be used inside of a <tt>tr()</tt> or\n<tt>rawtr()</tt> expression as a key expression. It additionally cannot be nested within another <tt>musig()</tt>\nexpression. Participant public keys may be repeated. The aggregate public key is produced\nby using the <tt>KeyAgg</tt> algorithm on all KEYs specified in the expression after performing all\nspecified derivation. As with script expressions, KEY can contain child derivation specified by\n<tt>/*</tt>. A new aggregate public key will be computed for each child index. Keys must be sorted\nwith the <tt>KeySort</tt> algorithm after all derivation and prior to aggregation<ref>'''Why must\nthe keys be sorted prior to aggregation?''' Although the descriptor's written form sets an order\nfor the keys that could be used for aggregation, the order should not matter as MuSig2 philosophically\noperates over a set of keys, with the order merely being an implementation detail in aggregation\nitself. Requiring sorting of keys prior to aggregation enforces this philosophy as keys can be\nwritten in the descriptor in any order with the end result still being the same. Furthermore, this\naids with recovery where the descriptor was not backed up as users will not need to also have\nbacked up, or guess, the correct order of keys.</ref>.\n\n===<tt>musig(KEY, KEY, ..., KEY)/NUM/.../*</tt>===\n\n<tt>musig(KEY, KEY, ..., KEY)/NUM/.../*</tt> expressions are also allowed if no KEY expression\ncontains child derivation as specified by <tt>/*</tt> or multipath as specified with\n<tt>/<NUM;NUM;...></tt>, in addition to the same usage restrictions as in the previous section. The KEY expressions\nadditionally must be xpubs or derived from xpubs. The aggregate public key is first computed as\ndescribed above, with the keys also being sorted after all derivation and prior to aggregation.\nThen further [[bip-0032.mediawiki|BIP-32]] derivation will be performed on the aggregate public key as described in\n[[bip-0328.mediawiki|BIP-328]]. The <tt>/NUM/.../*</tt> following the <tt>musig()</tt> specifies\nthe derivation path to be used when deriving from the aggregate public key. <tt>/*</tt> is also\noptional. As there is no aggregate private key, only unhardened derivation from the aggregate public\nkey is allowed. Thus these derivation steps cannot contain <tt>/NUMh</tt> or <tt>/NUM'</tt>\nnor can child derivation be specified as <tt>/*h</tt>, or <tt>/*'</tt>.\n\n==Test Vectors==\n\nValid descriptors containing followed by the scripts they produce. Descriptors involving derived child keys\nwill have the 0th, 1st, and 2nd scripts listed.\n\n* <tt>rawtr(musig(KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgd9M7rFU74sHUHy8S,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n** <tt>5120789d937bade6673538f3e28d8368dda4d0512f94da44cf477a505716d26a1575</tt>\n* <tt>tr(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n** <tt>512079e6c3e628c9bfbce91de6b7fb28e2aec7713d377cf260ab599dcbc40e542312</tt>\n* <tt>rawtr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/0/*)</tt>\n** <tt>51209508c08832f3bb9d5e8baf8cb5cfa3669902e2f2da19acea63ff47b93faa9bfc</tt>\n** <tt>51205ca1102663025a83dd9b5dbc214762c5a6309af00d48167d2d6483808525a298</tt>\n** <tt>51207dbed1b89c338df6a1ae137f133a19cae6e03d481196ee6f1a5c7d1aeb56b166</tt>\n* <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/0/*,pk(f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9))</tt>\n** <tt>51201d377b637b5c73f670f5c8a96a2c0bb0d1a682a1fca6aba91fe673501a189782</tt>\n** <tt>51208950c83b117a6c208d5205ffefcf75b187b32512eb7f0d8577db8d9102833036</tt>\n** <tt>5120a49a477c61df73691b77fcd563a80a15ea67bb9c75470310ce5c0f25918db60d</tt>\n* <tt>tr(f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,pk(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/0/*))</tt>\n** <tt>512068983d461174afc90c26f3b2821d8a9ced9534586a756763b68371a404635cc8</tt>\n** <tt>5120368e2d864115181bdc8bb5dc8684be8d0760d5c33315570d71a21afce4afd43e</tt>\n** <tt>512097a1e6270b33ad85744677418bae5f59ea9136027223bc6e282c47c167b471d5</tt>\n* <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1)/2)</tt>\n** <tt>5120a17ceacd6422bd5ffd9f165807b254b7d68ad39f179cc4f11545a6835227e97c</tt>\n\nInvalid descriptors\n\n* <tt>musig()</tt> is not allowed in top-level <tt>pk()</tt>: <tt>pk(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n* <tt>musig()</tt> is not allowed in top-level <tt>pkh()</tt>: <tt>pkh(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n* <tt>musig()</tt> is not allowed in <tt>wpkh()</tt>: <tt>wpkh(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n* <tt>musig()</tt> is not allowed in <tt>combo()</tt>: <tt>combo(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n* <tt>musig()</tt> is not allowed in <tt>sh(wpkh())</tt>: <tt>sh(wpkh(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66)))</tt>\n* <tt>musig()</tt> is not allowed in <tt>sh(wsh())</tt>: <tt>sh(wsh(pk(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))))</tt>\n* <tt>musig()</tt> is not allowed in <tt>wsh()</tt>: <tt>wsh(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n* <tt>musig()</tt> is not allowed in <tt>sh()</tt>: <tt>sh(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66))</tt>\n* Ranged <tt>musig()</tt> requires all participants to be xpubs: <tt>tr(musig(02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9,03dff1d77f2a671c5f36183726db2341be58feae1da2deced843240f7b502ba659,023590a94e768f8e1815c2f24b4d80a8e3149316c3518ce7b7ad338368d038ca66)/0/0)</tt>\n* Cannot have ranged participants if <tt>musig()</tt> is also ranged: <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/0/*)</tt>\n* Cannot have multipath participants if <tt>musig()</tt> is also multipath: <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/<2;3>)</tt>\n* <tt>musig()</tt> cannot have hardened derivation steps: <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/0h/*)</tt>\n* <tt>musig()</tt> cannot have hardened child derivation: <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y)/0/*h)</tt>\n* <tt>musig()</tt> cannot have participants with child derivation when <tt>musig()</tt> has derivation steps: <tt>tr(musig(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/*)/1/2</tt>\n\n==Backwards Compatibility==\n\n<tt>musig()</tt> expressions use the format and general operation specified in\n[[bip-0380.mediawiki|BIP-380]]. As these are a set of wholly new expressions, they are not compatible\nwith any implementation. However the keys are produced using a standard process so existing software\nare likely to be familiar with them.\n\n==Rationale==\n\n<references/>\n\n==Reference Implementation==\n\nThe reference implementation is available in Bitcoin Core [[https://github.com/bitcoin/bitcoin/pull/31244|PR #31244]].\n\n==Acknowledgements==\n\nThanks to Pieter Wuille, Andrew Poelstra, Sanket Kanjalkar, Salvatore Ingala, and all others who\nparticipated in discussions on this topic.\n", "content_length": 11213}
{"bip_number": 389, "filename": "bip-0389.mediawiki", "content": "<pre>\n  BIP: 389\n  Layer: Applications\n  Title: Multipath Descriptor Key Expressions\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0389\n  Status: Draft\n  Type: Informational\n  Created: 2022-07-26\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies a modification to Key Expressions of Descriptors that are described in BIP 380.\nThis modification allows Key Expressions to indicate BIP 32 derivation path steps that can have multiple values.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nDescriptors can describe the scripts that are used in a wallet, but wallets often require at least two descriptors for all of the scripts that they watch for.\nWallets typically have one descriptor for producing receiving addresses, and the other for change addresses.\nThese descriptors are often extremely similar - they produce the same types of scripts, derive keys from the same master key, and use derivation paths that are almost identical.\nThe only differences are in the derivation path where one of the steps will be different between the descriptors.\nThus it is useful to have a notation to represent both descriptors as a single descriptor where one of the derivation steps is a pair of values.\n\n==Specification==\n\nFor extended keys and their derivations paths in a Key Expression, BIP 380 states:\n\n* <tt>xpub</tt> encoded extended public key or <tt>xprv</tt> encoded extended private key (as defined in BIP 32)\n** Followed by zero or more <tt>/NUM</tt> or <tt>/NUMh</tt> path elements indicating BIP 32 derivation steps to be taken after the given extended key.\n** Optionally followed by a single <tt>/*</tt> or <tt>/*h</tt> final step to denote all direct unhardened or hardened children.\n\nThis is modified to state:\n\n* <tt>xpub</tt> encoded extended public key or <tt>xprv</tt> encoded extended private key (as defined in BIP 32)\n** Followed by zero or more <tt>/NUM</tt> (may be followed by <tt>h</tt>, <tt>H</tt>, or <tt>'</tt> to indicate a hardened step) path elements indicating BIP 32 derivation steps to be taken after the given extended key.\n** Followed by zero or one <tt>/<NUM;NUM</tt> (each <tt>NUM</tt> may be followed by <tt>h</tt>, <tt>H</tt>, or <tt>'</tt> to indicate a hardened step) path element indicating a tuple of BIP 32 derivation steps to be taken after the given extended key.\n*** Followed by zero or more <tt>;NUM</tt> (may be followed by <tt>h</tt>, <tt>H</tt>, or <tt>'</tt> to indicate a hardened step) additional tuple values of BIP 32 derivation steps\n*** Followed by a single <tt>>/</tt>\n** Followed by zero or more <tt>/NUM</tt> (may be followed by <tt>h</tt>, <tt>H</tt>, or <tt>'</tt> to indicate a hardened step) path elements indicating BIP 32 derivation steps to be taken after the given extended key.\n** Optionally followed by a single <tt>/*</tt> (may be followed by <tt>h</tt>, <tt>H</tt>, or <tt>'</tt> to indicate a hardened step) final step to denote all direct unhardened or hardened children.\n\nWhen a <tt>/<NUM;NUM;...;NUM></tt> is encountered, parsers should account for a presence of multiple descriptors where the first descriptor uses the first <tt>NUM</tt>, and a second descriptor uses the second <tt>NUM</tt>, and so on, until each <tt>NUM</tt> is accounted for in the production of public keys, scripts, and addresses, as well as descriptor import and export operations.\nDescriptors that contain multiple Key Expressions that each have a <tt>/<NUM;NUM;...;NUM></tt> must have tuples of exactly the same length so that they are derived in lockstep in the same way that <tt>/*</tt> paths in multiple Key expressions are handled.\nDuplicate <tt>NUM</tt>s within a tuple are not allowed.\n\nThe common use case for this is to represent descriptors for producing receiving and change addresses.\nWhen interpreting for this use case, wallets should use the first descriptor for producing receiving addresses, and the second descriptor for producing change addresses.\nFor this use case, the element will commonly be the value <tt>/<0;1></tt>\n\nNote that only one <tt>/<NUM;NUM;...;NUM></tt> specifier is allowed in a Key Expression.\n\n==Test Vectors==\n\nValid multipath descriptors followed by the descriptors they expand into as sub-bullets\n\n* <tt>pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/<0;1>)</tt>\n** <tt>pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)</tt>\n** <tt>pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/1)</tt>\n* <tt>pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/<2147483647h;0>/0)</tt>\n** <tt>pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647h/0)</tt>\n** <tt>pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/0/0)</tt>\n* <tt>wpkh([ffffffff/13h]xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/<1;3>/2/*</tt>\n** <tt>wpkh([ffffffff/13h]xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*)</tt>\n** <tt>wpkh([ffffffff/13h]xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/3/2/*)</tt>\n* <tt>multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<1;2>/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/<3;4>/0/*)</tt>\n** <tt>multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/3/0/*)</tt>\n** <tt>multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/2/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/4/0/*)</tt>\n* <tt>pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<0;1;2>)</tt>\n** <tt>pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/0)</tt>\n** <tt>pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/1)</tt>\n** <tt>pkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/2)</tt>\n* <tt>sh(multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<1;2;3>/0/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/*,xpub661MyMwAqRbcGDZQUKLqmWodYLcoBQnQH33yYkkF3jjxeLvY8qr2wWGEWkiKFaaQfJCoi3HeEq3Dc5DptfbCyjD38fNhSqtKc1UHaP4ba3t/0/0/<3;4;5>/*))</tt>\n** <tt>sh(multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/0/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/*,xpub661MyMwAqRbcGDZQUKLqmWodYLcoBQnQH33yYkkF3jjxeLvY8qr2wWGEWkiKFaaQfJCoi3HeEq3Dc5DptfbCyjD38fNhSqtKc1UHaP4ba3t/0/0/3/*))</tt>\n** <tt>sh(multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/2/0/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/*,xpub661MyMwAqRbcGDZQUKLqmWodYLcoBQnQH33yYkkF3jjxeLvY8qr2wWGEWkiKFaaQfJCoi3HeEq3Dc5DptfbCyjD38fNhSqtKc1UHaP4ba3t/0/0/4/*))</tt>\n** <tt>sh(multi(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/3/0/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/*,xpub661MyMwAqRbcGDZQUKLqmWodYLcoBQnQH33yYkkF3jjxeLvY8qr2wWGEWkiKFaaQfJCoi3HeEq3Dc5DptfbCyjD38fNhSqtKc1UHaP4ba3t/0/0/5/*))</tt>\n\nInvalid descriptors\n\n* Multiple multipath specifiers: <tt>pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/<0;1>/<2;3>)</tt>\n* Multipath specifier in origin: <tt>pkh([deadbeef/<0;1>]xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/0)</tt>\n* Multipath specifiers of mismatched lengths: <tt>tr(xpub661MyMwAqRbcF3yVrV2KyYetLMYA5mCbv4BhrKwUrFE9LZM6JRR1AEt8Jq4V4C8LwtTke6YEEdCZqgXp85YRk2j74EfJKhe3QybQ9kcUjs4/<6;7;8;9>/*,{pk(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<1;2;3>/0/*),pk(xpub661MyMwAqRbcGDZQUKLqmWodYLcoBQnQH33yYkkF3jjxeLvY8qr2wWGEWkiKFaaQfJCoi3HeEq3Dc5DptfbCyjD38fNhSqtKc1UHaP4ba3t/0/0/<3;4;5>/*)})</tt>\n* Multipath specifiers of mismatched lengths: <tt>sh(multi(2,xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/<1;2;3>/0/*,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0/*,xprv9s21ZrQH143K3jUwNHoqQNrtzJnJmx4Yup8NkNLdVQCymYbPbJXnPhwkfTfxZfptcs3rLAPUXS39oDLgrNKQGwbGsEmJJ8BU3RzQuvShEG4/0/0/<3;4>/*))</tt>\n* Empty multipath specifier: <tt>wpkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<>/*)</tt>\n* Missing multipath start: <tt>wpkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/0>/*)</tt>\n* Missing multipath end: <tt>wpkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<0/*)</tt>\n* Missing index in multipath specifier: <tt>wpkh(xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<0;>/*)</tt>\n\n==Backwards Compatibility==\n\nThis is an addition to the Key Expressions defined in BIP 380.\nKey Expressions using the format described in BIP 380 are compatible with this modification and parsers that implement this will still be able to parse such descriptors.\nHowever as this is an addition to Key Expressions, older parsers will not be able to understand such descriptors.\n\nThis modification to Key Expressions uses two new characters: <tt><</tt> and <tt>;</tt>.\nThese are part of the descriptor character set and so are covered by the checksum algorithm.\nAs these are previously unused characters, old parsers will not accidentally mistake them for indicating something else.\n\nThis proposal is in contrast to similar proposals such as BIP 88 which allow for multiple derivation indexes in a single element.\nThis limitation exists in order to reduce the number of descriptors that are expanded, avoid confusion about how to expand the descriptor, and avoid having expanded descriptors that users are not expecting.\n\n==Reference Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/22838\n", "content_length": 11438}
{"bip_number": 388, "filename": "bip-0388.mediawiki", "content": "<pre>\n  BIP: 388\n  Layer: Applications\n  Title: Wallet Policies for Descriptor Wallets\n  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0388\n  Status: Proposed\n  Type: Standards Track\n  Created: 2022-11-16\n  License: BSD-2-Clause\n  Post-History: 2022-05-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html\n</pre>\n\n== Abstract ==\n\nSoftware wallets and hardware signing devices typically partition funds into separate \"accounts\". When signing or visualizing a transaction, aggregate flows of funds of all accounts affected by the transaction may (and should) be displayed to the user.\n\nWallet policies build on top of output script descriptors to represent such accounts in a compact, reviewable way.\nAn account encompasses a logical group of receive and change addresses, and each wallet policy represents all descriptors necessary to describe an account in its entirety.\n\nWe simplify the language to suit devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle, by reducing the generality of descriptors to just the essential features and by separating the extended pubkeys and other key information from the descriptor.\n\nThis results in a more compact representation and simplifies the inspection of the policy by the user.\n\nThe compilation of wallet policies to the corresponding descriptor is trivial, and the reverse process is easy for supported descriptors, because the language is kept similar to that of output script descriptors.\n\n== Copyright ==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n== Motivation ==\n\n''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in Bitcoin Core as a way to represent collections of output scripts. It is a general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n\nUnfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running Bitcoin Core:\n\n* they are embedded devices with limited RAM and computational power;\n* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n\nMoreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the amount of information shown on-screen is important for a good user experience. The ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is crucial for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n\nA more native, compact representation of the wallet receive and change addresses might also benefit the UX of software wallets when they use descriptors (possibly with miniscript) for representing complex locking conditions.\n\nWe remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to [[bip-0379.md|miniscript]].\n\n=== Security, privacy and UX concerns for hardware signing devices ===\n\nThe usage of complex scripts presents challenges in terms of both security and user experience for a hardware signing device.\n\n==== Security issues ====\n\nHardware signing devices strive to guarantee that no action can be performed without the user\u2019s consent as long as the user correctly verifies the information that is shown on the device\u2019s screen before approving.\n\nThis must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n\nTherefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\nThe hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n\nThis makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n\n==== Avoiding key reuse ====\n\nReusing public keys within a script is a source of malleability when using miniscript policies, which has potential security implications.\n\nReusing keys across different UTXOs harms user privacy by allowing external parties to link these UTXOs to the same entity once they are spent.\n\nBy constraining the derivation path patterns to have a uniform structure, wallet policies prevent key reuse among the same or different UTXOs of the same account.\n\nIt is strongly recommended to avoid key reuse across accounts. Distinct public keys per account can be guaranteed by using distinct hardened derivation paths. This specification does not mandate hardened derivation in order to maintain compatibility with existing deployments that do not adhere to this recommendation.\n\nIt is out of scope for this document to guarantee that users do not reuse extended public keys among different wallet accounts. This is still very important, but the responsibility is left to the users and their software wallet.\n\n==== UX issues ====\n\nMiniscript (and taproot trees) allow substantially more complex spending policies. It is a challenge to ensure that the user can practically verify such spending policies on the screen.\n\nWe set two fundamental design goals:\n* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n* Minimize the number of times the user has to validate such information.\n\nDesigning a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of the scope of this document. See [[bip-0129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisig wallets. Regardless of the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n\n=== Policy registration as a solution ===\n\nA solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n\nBefore a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n\n# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n# The device shows the wallet policy to the user using the secure screen.\n# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n\nThe '''proof of registration''' will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n\nOnce a policy is registered, the hardware signing device can perform the typical operations securely:\n* generating receive and change addresses;\n* showing addresses on the secure screen;\n* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n\nBefore any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the proof of registration before using the wallet policy provided by the client.\n\nOnce the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n\n=== Avoiding blowup in descriptor size ===\n\nWhile reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n\nIn fact, there are many reasonable spending policies with a quadratic size in the number of participants. For example, using Taproot, a 3-of-5 threshold wallet could use:\n* a key path with a 5-of-5 [[bip-0327.mediawiki|MuSig2]] aggregated key\n* a script tree with 11 leaves:\n** 10 different scripts using a 3-of-3 MuSig2 aggregated key, plus\n** a final leaf with a fallback 3-of-5 multisig using <tt>multi_a</tt> (in case interactive signing is not available).\n\nWith each xpub being 118 bytes long, the repetition of xpubs makes the descriptor become extremely large.\n\nReplacing the common part of the key with a short key placeholder and organizing all the key expressions in a separate list helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n\n== Specification ==\n\nThis section formally defines wallet policies, and how they relate to output script descriptors.\n\n=== Formal definition ===\n\nA ''wallet policy'' is composed of a ''wallet descriptor template'', together with a vector of ''key information items''.\n\n==== Wallet descriptor template ====\n\nA ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n\n<tt>SCRIPT</tt> expressions:\n* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n* <tt>pkh(KEY)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n* <tt>wpkh(KEY)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n* <tt>multi(k,KEY_1,KEY_2,...,KEY_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n* <tt>sortedmulti(k,KEY_1,KEY_2,...,KEY_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n* <tt>tr(KEY)</tt> or <tt>tr(KEY,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n\nSee [[bip-0379.md|BIP-379]] for a precise specification of all the valid miniscript <tt>SCRIPT</tt> expressions.\n\n<tt>TREE</tt> expressions:\n* any <tt>SCRIPT</tt> expression\n* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n\n\n<tt>KEY</tt> expressions consist of\n* a <tt>KP</tt> expression\n* ''always'' followed by either:\n** the string  <tt>/**</tt>, or\n** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations, or\n** any of the additional, implementation-specific valid derivation path patterns (see [[#optional-derivation-paths|Optional derivation paths]] below).\n\n<tt>KP</tt> expressions (key placeholders) consist of either:\n* a <tt>KI</tt> (key index) expression, or\n* (only inside <tt>tr</tt>): <tt>musig(KI_1,KI_2,...,KI_n)</tt>\n\nA <tt>KI</tt> (key index) expression consists of:\n* a single character <tt>@</tt>\n* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n\nThe <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt>/<0;1>/*</tt>.\n\nNote that while [[bip-0389.mediawiki|BIP-389]] allows multipath <tt>/<NUM;NUM;...;NUM></tt> expressions with an arbitrary number of options, this specification restricts it to exactly 2 choices (with the typical meaning of receive/change addresses).\n\n<tt>SCRIPT</tt>, <tt>TREE</tt> and <tt>KEY</tt> expressions map directly to the corresponding concepts defined in [[bip-0380.mediawiki|BIP-380]] for output script descriptors.\n\nEach <tt>KEY</tt> expression always corresponds to a precise public key in the final bitcoin Script. Therefore, all the derivation steps in the BIP-32 hierarchy are included in a <tt>KEY</tt> expression.\n\nEach <tt>KP</tt> (key placeholder) expression, on the other hand, maps to the root of all the corresponding public keys for all the possible UTXOs that belong to the account represented in the wallet policy. Therefore, no derivation steps are allowed in a <tt>KP</tt> expression.\n\nA <tt>KI</tt> (key index) <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n\nNote: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization), it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n\n==== Key information vector ====\n\nEach element of the key origin information vector is a <tt>KEY_INFO</tt> expression, containing an extended public key, and (optionally) its key origin.\n\n* Optionally, key origin information, consisting of:\n** An open bracket <tt>[</tt>\n** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n** A closing bracket <tt>]</tt>\n* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n\n==== Additional rules ====\n\nA wallet policy must have at least one key placeholder and the corresponding key.\n\nThe public keys obtained by deserializing elements of the key information vector must be pairwise distinct<ref>'''Why must public keys be distinct?''' Reusing pubkeys could be insecure in the context of wallet policies containing [https://bitcoin.sipa.be/miniscript/ miniscript]. Avoiding repeated public keys altogether avoids the problem at the source.</ref>.\n\nIf two <tt>KEY</tt> are <tt>KP/<M;N>/*</tt> and <tt>KP/<P;Q>/*</tt> for the same key placeholder <tt>KP</tt>, then the sets <tt>{M, N}</tt> and <tt>{P, Q}</tt> must be disjoint. Two <tt>musig</tt> key placeholders are the same if they have exactly the same set of key indexes (regardless of the order).\n\nRepeated <tt>KI</tt> expressions are not allowed inside a <tt>musig</tt> placeholder.\n\nThe key information vector should be ordered so that placeholder <tt>@i</tt> never appears for the first time before an occurrence of <tt>@j</tt>  for some <tt>j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n\n=== Descriptor derivation ===\n\nFrom a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n\n* replacing each key placeholder with the corresponding key origin information;\n* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n\nFor example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\nproduces the following multipath descriptor:\n\n<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n\n=== Implementation guidelines ===\n\nIt is acceptable to implement only a subset of the possible wallet policies defined by this standard. It is recommended that any limitations are clearly documented.\n\nImplementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n\nAny implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n\n=== Optional derivation paths ===\n\nIn order to allow supporting legacy derivation schemes (for example, using simply <tt>/*</tt> instead of the more common <tt>/<M;N>/*</tt> scheme most software wallets use today), or other schemes that are not covered in this document, implementations might choose to permit additional derivation patterns for the key placeholder (<tt>KP</tt>) expressions.\n\nHowever, care needs to be taken in view of the following considerations:\n\n* Allowing derivation schemes with a different length or cardinality in the same wallet policy would make it difficult to guarantee that there are no repeated pubkeys for every possible address generated by the policy. For example, <tt>@0/<0;1>/*</tt> and <tt>@1/*</tt> would generate the same pubkeys if the second public key in the key information vector is one of the first two unhardened children of the first public key. This could cause malleability with potential security implications (for example, in policies containing miniscript).\n* Allowing naked pubkeys with no <tt>/*</tt> suffix (for example a descriptor template like <tt>wsh(multi(2,@0,@1/<0;1>/*))</tt>) would cause a pubkey to be repeated in every output generated from the policy, which would result in a total loss of privacy.\n\n== Examples ==\n\nIn the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n\nCommon single-signature account patterns:\n* <tt>pkh(@0/**)</tt> (legacy).\n* <tt>wpkh(@0/**)</tt> (native segwit).\n* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n* <tt>tr(@0/**)</tt> (taproot single-signature account).\n\nCommon multisig schemes:\n* <tt>wsh(multi(2,@0/**,@1/**))</tt> - SegWit 2-of-2 multisig, keys in order.\n* <tt>sh(sortedmulti(2,@0/**,@1/**,@2/**))</tt> - Legacy 2-of-3 multisig, sorted keys.\n* <tt>tr(musig(@0,@1)/**)</tt> - MuSig2 2-of-2 in the taproot keypath\n\nSome miniscript policies in <tt>wsh</tt>:\n* <tt>wsh(and_v(v:pk(@0/**),or_d(pk(@1/**),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n* <tt>wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n\n== Test Vectors ==\n\n=== Valid policies ===\n\n[[bip-0044.mediawiki|BIP-44]], first account\n Descriptor template: pkh(@0/**)\n Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n Descriptor: pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb/<0;1>/*)\n<br>\n[[bip-0049.mediawiki|BIP-49]], second account\n Descriptor template: sh(wpkh(@0/**))\n Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n Descriptor: sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9/<0;1>/*))\n<br>\n[[bip-0084.mediawiki|BIP-84]], third account\n Descriptor template: wpkh(@0/**)\n Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n Descriptor: wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt/<0;1>/*)\n<br>\n[[bip-0086.mediawiki|BIP-86]], first account\n Descriptor template: tr(@0/**)\n Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n Descriptor: tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL/<0;1>/*)\n<br>\n[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n Descriptor template: wsh(sortedmulti(2,@0/**,@1/**))\n Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n Descriptor: wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw/<0;1>/*,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7/<0;1>/*))\n<br>\nMiniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n Descriptor: wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0;1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0;1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0;1>/*),sln:older(12960)))\n<br>\nMiniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n Descriptor template: wsh(or_d(pk(@0/**),and_v(v:multi(2,@1/**,@2/**,@3/**),older(65535))))\n Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n Descriptor: wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0;1>/*),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0;1>/*,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0;1>/*,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ/<0;1>/*),older(65535))))\n<br>\nTaproot wallet policy with sortedmulti_a and a miniscript leaf\n Descriptor template: tr(@0/**,{sortedmulti_a(1,@0/<2;3>/*,@1/**),or_b(pk(@2/**),s:pk(@3/**))})\n Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"xpub6Fc2TRaCWNgfT49nRGG2G78d1dPnjhW66gEXi7oYZML7qEFN8e21b2DLDipTZZnfV6V7ivrMkvh4VbnHY2ChHTS9qM3XVLJiAgcfagYQk6K\", \"xpub6GxHB9kRdFfTqYka8tgtX9Gh3Td3A9XS8uakUGVcJ9NGZ1uLrGZrRVr67DjpMNCHprZmVmceFTY4X4wWfksy8nVwPiNvzJ5pjLxzPtpnfEM\", \"xpub6GjFUVVYewLj5no5uoNKCWuyWhQ1rKGvV8DgXBG9Uc6DvAKxt2dhrj1EZFrTNB5qxAoBkVW3wF8uCS3q1ri9fueAa6y7heFTcf27Q4gyeh6\"]\n Descriptor: tr([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0;1>/*,{sortedmulti_a(1,[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<2;3>/*,xpub6Fc2TRaCWNgfT49nRGG2G78d1dPnjhW66gEXi7oYZML7qEFN8e21b2DLDipTZZnfV6V7ivrMkvh4VbnHY2ChHTS9qM3XVLJiAgcfagYQk6K/<0;1>/*),or_b(pk(xpub6GxHB9kRdFfTqYka8tgtX9Gh3Td3A9XS8uakUGVcJ9NGZ1uLrGZrRVr67DjpMNCHprZmVmceFTY4X4wWfksy8nVwPiNvzJ5pjLxzPtpnfEM/<0;1>/*),s:pk(xpub6GjFUVVYewLj5no5uoNKCWuyWhQ1rKGvV8DgXBG9Uc6DvAKxt2dhrj1EZFrTNB5qxAoBkVW3wF8uCS3q1ri9fueAa6y7heFTcf27Q4gyeh6/<0;1>/*))})\n<br>\nTaproot MuSig2 3-of-3 in the key path, with three 2-of-2 MuSig2 recovery paths after 90 days in the script paths\n Descriptor template: tr(musig(@0,@1,@2)/**,{and_v(v:pk(musig(@0,@1)/**),older(12960)),{and_v(v:pk(musig(@0,@2)/**),older(12960)),and_v(v:pk(musig(@1,@2)/**),older(12960))}})\n Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n Descriptor: tr(musig([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2)/<0;1>/*,{and_v(v:pk(musig([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js)/<0;1>/*),older(12960)),{and_v(v:pk(musig([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2)/<0;1>/*),older(12960)),and_v(v:pk(musig([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2)/<0;1>/*),older(12960))}})\n\n=== Invalid policies ===\n\nThe following descriptor templates are invalid:\n\n* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n* <tt>pkh(@0/0/**)</tt>: Key placeholder with an explicit path present\n* <tt>sh(multi(1,@1/**,@0/**))</tt>: Key placeholders out of order\n* <tt>sh(multi(1,@0/**,@2/**))</tt>: Skipped key placeholder <tt>@1</tt>\n* <tt>sh(multi(1,@0/**,@0/**))</tt>: Repeated keys with the same path expression\n* <tt>sh(multi(1,@0/<0;1>/*,@0/<1;2>/*))</tt>: Non-disjoint multipath expressions (<tt>@0/1/*</tt> appears twice)\n* <tt>sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))</tt>: Expression with a non-KP key present\n* <tt>pkh(@0/<0;1;2>/*)</tt>: Allowed cardinality > 2\n* <tt>tr(musig(@0/**,@1/**))</tt>: Derivation before aggregation is not allowed in wallet policies (despite being allowed in [[bip-0390.mediawiki|BIP-390]])\n\nRemark: some of the examples of invalid descriptor templates may be valid via optional extensions.\n\n== Backwards Compatibility ==\n\nThe <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor with at least one <tt>KEY</tt> expression is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.\n\nAdoption of wallet policies in software and hardware wallets is opt-in. Conversion from wallet policies to the corresponding descriptors is programmatically extremely easy, and conversion from descriptors to wallet policies (when respecting the required patterns) can be automated. See the reference implementation below for some examples of conversion.\n\nSoftware wallets are recommended to allow exporting plain descriptors for the purposes of interoperability with software not using wallet policies.\n\n== Reference Implementation ==\n\nWallet policies are implemented in\n* the [https://github.com/LedgerHQ/app-bitcoin-new Ledger bitcoin application] since version 2.1.0;\n* the [https://github.com/digitalbitbox/bitbox02-firmware BitBox02 firmware] since version v9.15.0;\n* [https://github.com/Blockstream/Jade Blockstream Jade] since version v1.0.24, via [https://github.com/ElementsProject/libwally-core libwally-core] v1.0.0.\n* [https://github.com/btcpayserver/btcpayserver BTCPay Server] from version [https://github.com/btcpayserver/btcpayserver/pull/6684 v2.1.1]. (Currently only a limited subset of singlesig and multisig policies)\n* [https://github.com/MetacoSA/NBitcoin/ NBitcoin] through <tt>Miniscript.Parse</tt>.\n\nFor development and testing purposes, we provide a [[bip-0388/wallet_policies.py|Python 3.7 reference implementation]] of simple classes to handle wallet policies, and the conversion to/from output script descriptors.\nThe reference implementation is for demonstration purposes only and not to be used in production environments.\n\n== Change Log ==\n\n* '''1.1.0''' (2024-11):\n** Added support for <tt>musig</tt> key placeholders in descriptor templates.\n* '''1.0.0''' (2024-05):\n** Initial version.\n\n== Footnotes ==\n\n<references />\n\n== Acknowledgments ==\n\nThe authors would like to thank the people who provided feedback in the bitcoin-dev list, and in person.\n", "content_length": 32016}
{"bip_number": 387, "filename": "bip-0387.mediawiki", "content": "<pre>\n  BIP: 387\n  Layer: Applications\n  Title: Tapscript Multisig Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0387\n  Status: Final\n  Type: Informational\n  Created: 2024-04-17\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>multi_a()</tt> and <tt>sortedmulti_a()</tt> output script descriptors.\nLike BIP 383's <tt>multi()</tt> and <tt>sortedmulti()</tt>, both functions take a threshold and one\nor more public keys and produce a multisig script. The primary distinction is that <tt>multi_a()</tt>\nand <tt>sortedmulti_a()</tt> only produce tapscripts and are only allowed in a tapscript context.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nThe most common complex script used in Bitcoin is a threshold multisig.\nThese expressions allow specifying multisig scripts as a descriptor.\n\n==Specification==\n\nTwo new script expressions are defined: <tt>multi_a()</tt> and <tt>sortedmulti_a()</tt>.\nBoth expressions produce the scripts of the same template and take the same arguments.\nThey are written as <tt>multi_a(k,KEY_1,KEY_2,...,KEY_n)</tt>.\n<tt>k</tt> is the threshold - the number of keys that must sign the input for the script to be valid.\n<tt>KEY_1,KEY_2,...,KEY_n</tt> are the key expressions for the multisig. <tt>k</tt> must be less than or equal to <tt>n</tt>.\n\n<tt>multi_a()</tt> and <tt>sortedmulti_a()</tt> expressions can only be used inside of a <tt>tr()</tt> descriptor.\nThe maximum number of keys is 999.\n\nThe output script produced also depends on the value of <tt>k</tt>. If <tt>k</tt> is less than or equal to 16:\n<pre>\nKEY_1 OP_CHECKSIG KEY_2 OP_CHECKSIGADD ... KEY_n OP_CHECKSIGADD OP_k OP_NUMEQUAL\n</pre>\n\nif <tt>k</tt> is greater than 16:\n<pre>\nKEY_1 OP_CHECKSIG KEY_2 OP_CHECKSIGADD ... KEY_n OP_CHECKSIGADD k OP_NUMEQUAL\n</pre>\n\n===<tt>sortedmulti_a()</tt>===\n\nThe only change for <tt>sortedmulti_a()</tt> is that the x-only public keys are sorted lexicographically prior to the creation of the output script.\nThis sorting is on the keys that are to be put into the output script, i.e. after all extended keys are derived.\n\n===Multiple Extended Keys</tt>===\n\nWhen one or more of the key expressions in a <tt>multi_a()</tt> or <tt>sortedmulti_a()</tt> expression are extended keys, the derived keys use the same child index.\nThis changes the keys in lockstep and allows for output scripts to be indexed in the same way that the derived keys are indexed.\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce. Descriptors involving derived child keys will have the 0th, 1st, and 2nd scripts listed.\n\n* <tt>tr(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,multi_a(1,KzoAz5CanayRKex3fSLQ2BwJpN7U52gZvxMyk78nDMHuqrUxuSJy))</tt>\n** <tt>5120eb5bd3894327d75093891cc3a62506df7d58ec137fcd104cdd285d67816074f3</tt>\n* <tt>tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,multi_a(1,669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0))</tt>\n** <tt>5120eb5bd3894327d75093891cc3a62506df7d58ec137fcd104cdd285d67816074f3</tt>\n* <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,multi_a(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))</tt>\n** <tt>51202eea93581594a43c0c8423b70dc112e5651df63984d108d4fc8ccd3b63b4eafa</tt>\n* <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,sortedmulti_a(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))</tt>\n** <tt>512016fa6a6ba7e98c54b5bf43b3144912b78a61b60b02f6a74172b8dcb35b12bc30</tt>\n* <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,sortedmulti_a(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/0/*))</tt>\n** <tt>5120abd47468515223f58a1a18edfde709a7a2aab2b696d59ecf8c34f0ba274ef772</tt>\n** <tt>5120fe62e7ed20705bd1d3678e072bc999acb014f07795fa02cb8f25a7aa787e8cbd</tt>\n** <tt>51201311093750f459039adaa2a5ed23b0f7a8ae2c2ffb07c5390ea37e2fb1050b41</tt>\n* <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,multi_a(2,xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0,xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*,xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))</tt>\n** <tt>5120e4c8f2b0a7d3a688ac131cb03248c0d4b0a59bbd4f37211c848cfbd22a981192</tt>\n** <tt>5120827faedaa21e52fca2ac83b53afd1ab7d4d1e6ce67ff42b19f2723d48b5a19ab</tt>\n** <tt>5120647495ed09de61a3a324704f9203c130d655bf3141f9b748df8f7be7e9af55a4</tt>\n\nInvalid descriptors\n\n* Unsupported top level: <tt>multi_a(1,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0)</tt>\n* Unsupported <tt>sh()</tt> context: <tt>sh(multi_a(1,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0))</tt>\n* Unsupported <tt>wsh()</tt> context: <tt>wsh(multi_a(1,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0))</tt>\n* Invalid threshold: <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,multi_a(a,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* Threshold of 0: <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,multi_a(0,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* Uncompressed pubkey: <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,multi_a(1,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235))</tt>\n* Threshold larger than keys: <tt>tr(50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0,multi_a(3,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss))</tt>\n\n==Backwards Compatibility==\n\n<tt>multi_a()</tt> and <tt>sortedmulti_a()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs these are wholly new descriptors, they are not compatible with any implementation.\nHowever, the scripts produced are standard scripts, so existing software are likely to be familiar with them.\n\n==Reference Implementation==\n\n<tt>multi_a()</tt> and <tt>sortedmulti_a()</tt> descriptors were implemented in Bitcoin Core in https://github.com/bitcoin/bitcoin/pull/24043 and have been available since version 24.0.\n", "content_length": 7148}
{"bip_number": 386, "filename": "bip-0386.mediawiki", "content": "<pre>\n  BIP: 386\n  Layer: Applications\n  Title: tr() Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0386\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>tr()</tt> output script descriptors.\n<tt>tr()</tt> descriptors take a key and optionally a tree of scripts and produces a P2TR output script.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nTaproot added one additional standard output script format: P2TR.\nThese expressions allow specifying those formats as a descriptor.\n\n==Specification==\n\nA new script expression is defined: <tt>tr()</tt>.\nA new expression is defined: Tree Expressions\n\n===Tree Expression===\n\nA Tree Expression (denoted <tt>TREE</tt>) is an expression which represents a tree of scripts.\nThe way the tree is represented in an output script is dependent on the higher level expressions.\n\nA Tree Expression is:\n* Any Script Expression that is allowed at the level this Tree Expression is in.\n* A pair of Tree Expressions consisting of:\n** An open brace <tt>{</tt>\n** A Tree Expression\n** A comma <tt>,</tt>\n** A Tree Expression\n** A closing brace <tt>}</tt>\n\n===<tt>tr()</tt>===\n\nThe <tt>tr(KEY)</tt> or <tt>tr(KEY, TREE)</tt> expression can only be used as a top level expression.\nAll key expressions under any <tt>tr()</tt> expression must create x-only public keys.\n\n<tt>tr(KEY)</tt> takes a single key expression as an argument and produces a P2TR output script which does not have a script path.\nEach key produced by the key expression is used as the internal key of a P2TR output as specified by [[bip-0341.mediawiki#cite_ref-22-0|BIP 341]].\nSpecifically, \"If the spending conditions do not require a script path, the output key should commit to an unspendable script path instead of having no script path.\nThis can be achieved by computing the output key point as ''Q = P + int(hash<sub>TapTweak</sub>(bytes(P)))G''.\"\n\n<pre>\ninternal_key:       lift_x(KEY)\n32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)))G\nscriptPubKey:       OP_1 <32_byte_output_key>\n</pre>\n\n<tt>tr(KEY, TREE)</tt> takes a key expression as the first argument, and a tree expression as the second argument and produces a P2TR output script which has a script path.\nThe keys produced by the first key expression are used as the internal key as specified by [[bip-0341.mediawiki#Constructing_and_spending_Taproot_outputs|BIP 341]].\nThe Tree expression becomes the Taproot script tree as described in BIP 341.\nA merkle root is computed from this tree and combined with the internal key to create the Taproot output key.\n\n<pre>\ninternal_key:       lift_x(KEY)\nmerkle_root:        HashTapBranch(TREE)\n32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key) || merkle_root))G\nscriptPubKey:       OP_1 <32_byte_output_key>\n</pre>\n\n===Modified Key Expression===\n\nKey Expressions within a <tt>tr()</tt> expression must only create x-only public keys.\nUncompressed public keys are not allowed, but compressed public keys would be implicitly converted to x-only public keys.\nThe keys derived from extended keys must be serialized as x-only public keys.\nAn additional key expression is defined only for use within a <tt>tr()</tt> descriptor:\n\n* A 64 hex character string representing an x-only public key\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce. Descriptors involving derived child keys will have the 0th, 1st, and 2nd scripts listed.\n\n* <tt>tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n** <tt>512077aab6e066f8a7419c5ab714c12c67d25007ed55a43cadcacb4d7a970a093f11</tt>\n* <tt>tr(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)</tt>\n** <tt>512077aab6e066f8a7419c5ab714c12c67d25007ed55a43cadcacb4d7a970a093f11</tt>\n* <tt>tr(xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/0/*,pk(xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/1/*))</tt>\n** <tt>512078bc707124daa551b65af74de2ec128b7525e10f374dc67b64e00ce0ab8b3e12</tt>\n** <tt>512001f0a02a17808c20134b78faab80ef93ffba82261ccef0a2314f5d62b6438f11</tt>\n** <tt>512021024954fcec88237a9386fce80ef2ced5f1e91b422b26c59ccfc174c8d1ad25</tt>\n* <tt>tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,pk(669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0))</tt>\n** <tt>512017cf18db381d836d8923b1bdb246cfcd818da1a9f0e6e7907f187f0b2f937754</tt>\n* <tt>tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,{pk(xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334/0),{{pk(xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL),pk(02df12b7035bdac8e3bab862a3a83d06ea6b17b6753d52edecba9be46f5d09e076)},pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)}})</tt>\n** <tt>512071fff39599a7b78bc02623cbe814efebf1a404f5d8ad34ea80f213bd8943f574</tt>\n\nInvalid Descriptors\n\n* Uncompressed private key: <tt>tr(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)</tt>\n* Uncompressed public key: <tt>tr(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n* <tt>tr()</tt> nested in <tt>wsh</tt>: <tt>wsh(tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* <tt>tr()</tt> nested in <tt>sh</tt>: <tt>sh(tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* <tt>pkh()</tt> nested in <tt>tr</tt>: <tt>tr(a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd, pkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))</tt>\n\n==Backwards Compatibility==\n\n<tt>tr()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs these are a set of wholly new descriptors, they are not compatible with any implementation.\nHowever the scripts produced are standard scripts so existing software are likely to be familiar with them.\n\nTree Expressions are largely incompatible with existing script expressions due to the restrictions in those expressions.\nAs of 2021-06-27, the only allowed script expression that can be used in a tree expression is <tt>pk()</tt>.\nHowever there will be future BIPs that specify script expressions that can be used in tree expressions.\n\n==Reference Implementation==\n\n<tt>tr()</tt> descriptors have been implemented in Bitcoin Core since version 22.0.\n", "content_length": 6756}
{"bip_number": 385, "filename": "bip-0385.mediawiki", "content": "<pre>\n  BIP: 385\n  Layer: Applications\n  Title: raw() and addr() Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0385\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>raw()</tt> and <tt>addr()</tt> output script descriptors.\n<tt>raw()</tt> encapsulates a raw script as a descriptor.\n<tt>addr()</tt> encapsulates an address as a descriptor.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nIn order to make descriptors maximally compatible with scripts in use today, it is useful to be able to wrap any arbitrary output script or an address into a descriptor.\n\n==Specification==\n\nTwo new script expressions are defined: <tt>raw()</tt> and <tt>addr()</tt>.\n\n===<tt>raw()</tt>===\n\nThe <tt>raw(HEX)</tt> expression can only be used as a top level descriptor.\nAs the argument, it takes a hex string representing a Bitcoin script.\nThe output script produced by this descriptor is the script represented by <tt>HEX</tt>.\n\n===<tt>addr()</tt>===\n\nThe <tt>addr(ADDR)</tt> expression can only be used as a top level descriptor.\nIt takes an address as its single argument.\nThe output script produced by this descriptor is the output script produced by the address <tt>ADDR</tt>.\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce.\n\n* <tt>raw(deadbeef)</tt>\n** <tt>deadbeef</tt>\n* <tt>raw(512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae)</tt>\n** <tt>512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae</tt>\n* <tt>raw(a9149a4d9901d6af519b2a23d4a2f51650fcba87ce7b87)</tt>\n** <tt>a9149a4d9901d6af519b2a23d4a2f51650fcba87ce7b87</tt>\n* <tt>addr(3PUNyaW7M55oKWJ3kDukwk9bsKvryra15j)</tt>\n** <tt>a914eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee87</tt>\n\nInvalid descriptors\n\n* Non-hex script: <tt>raw(asdf)</tt>\n* Invalid address: <tt>addr(asdf)</tt>\n* <tt>raw</tt> nested in <tt>sh</tt>: <tt>sh(raw(deadbeef))</tt>\n* <tt>raw</tt> nested in <tt>wsh</tt>: <tt>wsh(raw(deadbeef))</tt>\n* <tt>addr</tt> nested in <tt>sh</tt>: <tt>sh(addr(3PUNyaW7M55oKWJ3kDukwk9bsKvryra15j))</tt>\n* <tt>addr</tt> nested in <tt>wsh</tt>: <tt>wsh(addr(3PUNyaW7M55oKWJ3kDukwk9bsKvryra15j))</tt>\n\n==Backwards Compatibility==\n\n<tt>raw()</tt> and <tt>addr()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs this is a wholly new descriptor, it is not compatible with any implementation.\nThe reuse of existing Bitcoin addresses allows for this to be more easily implemented.\n\n==Reference Implementation==\n\n<tt>raw()</tt> and <tt>addr()</tt> descriptors have been implemented in Bitcoin Core since version 0.17.\n", "content_length": 3142}
{"bip_number": 384, "filename": "bip-0384.mediawiki", "content": "<pre>\n  BIP: 384\n  Layer: Applications\n  Title: combo() Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0384\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>combo()</tt> output script descriptors.\nThese take a key and produce P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH output scripts if applicable to the key.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nIn order to make the transition from traditional key based wallets to descriptor based wallets easier, it is useful to be able to take a key and produce the scripts which have traditionally been produced by wallet software.\n\n==Specification==\n\nA new top level script expression is defined: <tt>combo(KEY)</tt>.\nThis expression can only be used as a top level expression.\nIt takes a single key expression as an argument and produces either 2 or 4 output scripts, depending on the key.\nA <tt>combo()</tt> expression always produces a P2PK and P2PKH script, the same as putting the key in both a <tt>pk()</tt> and a <tt>pkh()</tt> expression.\nIf the key is/has a compressed public key, then P2WPKH and P2SH-P2WPKH scripts are also produced, the same as putting the key in both a <tt>wpkh()</tt> and <tt>sh(wpkh())</tt> expression.\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce. Descriptors involving derived child keys will have the 0th, and 1st scripts in additional sub-bullets.\n\n* <tt>combo(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)</tt>\n** <tt>2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac</tt>\n** <tt>76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac</tt>\n** <tt>00149a1c78a507689f6f54b847ad1cef1e614ee23f1e</tt>\n** <tt>a91484ab21b1b2fd065d4504ff693d832434b6108d7b87</tt>\n* <tt>combo(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n** <tt>4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac</tt>\n** <tt>76a914b5bd079c4d57cc7fc28ecf8213a6b791625b818388ac</tt>\n* <tt>combo([01234567]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL)</tt>\n** <tt>2102d2b36900396c9282fa14628566582f206a5dd0bcc8d5e892611806cafb0301f0ac</tt>\n** <tt>76a91431a507b815593dfc51ffc7245ae7e5aee304246e88ac</tt>\n** <tt>001431a507b815593dfc51ffc7245ae7e5aee304246e</tt>\n** <tt>a9142aafb926eb247cb18240a7f4c07983ad1f37922687</tt>\n* <tt>combo(xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334/*)</tt>\n** Child 0\n*** <tt>2102df12b7035bdac8e3bab862a3a83d06ea6b17b6753d52edecba9be46f5d09e076ac</tt>\n*** <tt>76a914f90e3178ca25f2c808dc76624032d352fdbdfaf288ac</tt>\n*** <tt>0014f90e3178ca25f2c808dc76624032d352fdbdfaf2</tt>\n*** <tt>a91408f3ea8c68d4a7585bf9e8bda226723f70e445f087</tt>\n** Child 1\n*** <tt>21032869a233c9adff9a994e4966e5b821fd5bac066da6c3112488dc52383b4a98ecac</tt>\n*** <tt>76a914a8409d1b6dfb1ed2a3e8aa5e0ef2ff26b15b75b788ac</tt>\n*** <tt>0014a8409d1b6dfb1ed2a3e8aa5e0ef2ff26b15b75b7</tt>\n*** <tt>a91473e39884cb71ae4e5ac9739e9225026c99763e6687</tt>\n\nInvalid descriptors\n\n* <tt>combo()</tt> in <tt>sh</tt> : <tt>sh(combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* <tt>combo()</tt> in <tt>wsh</tt> : <tt>wsh(combo(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* Script in <tt>combo()</tt>: <tt>combo(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n\n==Backwards Compatibility==\n\n<tt>combo()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs this is a wholly new descriptor, it is not compatible with any implementation.\nHowever the scripts produced are standard scripts so existing software are likely to be familiar with them.\n\n==Reference Implementation==\n\n<tt>combo()</tt> descriptors have been implemented in Bitcoin Core since version 0.17.\n", "content_length": 4274}
{"bip_number": 383, "filename": "bip-0383.mediawiki", "content": "<pre>\n  BIP: 383\n  Layer: Applications\n  Title: Multisig Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0383\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>multi()</tt>, and <tt>sortedmulti()</tt> output script descriptors.\nBoth functions take a threshold and one or more public keys and produce a multisig output script.\n<tt>multi()</tt> specifies the public keys in the output script in the order given in the descriptor while <tt>sortedmulti()</tt> sorts the public keys lexicographically when the output script is produced.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nThe most common complex script used in Bitcoin is a threshold multisig.\nThese expressions allow specifying multisig scripts as a descriptor.\n\n==Specification==\n\nTwo new script expressions are defined: <tt>multi()</tt>, and <tt>sortedmulti()</tt>.\nBoth expressions produce the scripts of the same template and take the same arguments.\nThey are written as <tt>multi(k,KEY_1,KEY_2,...,KEY_n)</tt>.\n<tt>k</tt> is the threshold - the number of keys that must sign the input for the script to be valid.\n<tt>KEY_1,KEY_2,...,KEY_n</tt> are the key expressions for the multisig. <tt>k</tt> must be less than or equal to <tt>n</tt>.\n\n<tt>multi()</tt> and <tt>sortedmulti()</tt> expressions can be used as a top level expression, or inside of either a <tt>sh()</tt> or <tt>wsh()</tt> descriptor.\nDepending on the higher level descriptors, there may be restrictions on the type of public keys that can be included.\n\nDepending on the higher level descriptors, there are also restrictions on the number of keys that can be present, i.e. the maximum value of <tt>n</tt>.\nWhen used at the top level, there can only be at most 3 keys.\nWhen used inside of a <tt>sh()</tt> expression, there can only be most 15 compressed public keys (this is limited by the P2SH script limit).\nOtherwise the maximum number of keys is 20.\n\nThe output script produced will be\n<pre>\nk KEY_1 KEY_2 ... KEY_n n OP_CHECKMULTISIG\n</pre>\n\nThe values <tt>k</tt> and <tt>n</tt> must be minimally encoded integers.\nFor values less than or equal to 16, they must be encoded using <tt>OP_0</tt> through <tt>OP_16</tt>.\nFor values greater than 16, they must be a push of the signed little endian encoded value without padding.\n\n===<tt>sortedmulti()</tt>===\n\nThe only change for <tt>sortedmulti()</tt> is that the keys are sorted lexicographically prior to the creation of the output script.\nThis sorting is on the keys that are to be put into the output script, i.e. after all extended keys are derived.\n\n===Multiple Extended Keys</tt>===\n\nWhen one or more the key expressions in a <tt>multi()</tt> or <tt>sortedmulti()</tt> expression are extended keys, the derived keys use the same child index.\nThis changes the keys in lockstep and allows for output scripts to be indexed in the same way that the derived keys are indexed.\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce. Descriptors involving derived child keys will have the 0th, 1st, and 2nd scripts listed.\n\n* <tt>multi(1,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)</tt>\n** <tt>512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae</tt>\n* <tt>multi(1,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n** <tt>512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae</tt>\n* <tt>sortedmulti(1,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n** <tt>512103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea23552ae</tt>\n* <tt>sh(multi(2,[00000000/111'/222]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc,xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0))</tt>\n** <tt>a91445a9a622a8b0a1269944be477640eedc447bbd8487</tt>\n* <tt>sortedmulti(2,xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/*,xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0/0/*)</tt>\n** <tt>5221025d5fc65ebb8d44a5274b53bac21ff8307fec2334a32df05553459f8b1f7fe1b62102fbd47cc8034098f0e6a94c6aeee8528abf0a2153a5d8e46d325b7284c046784652ae</tt>\n** <tt>52210264fd4d1f5dea8ded94c61e9641309349b62f27fbffe807291f664e286bfbe6472103f4ece6dfccfa37b211eb3d0af4d0c61dba9ef698622dc17eecdf764beeb005a652ae</tt>\n** <tt>5221022ccabda84c30bad578b13c89eb3b9544ce149787e5b538175b1d1ba259cbb83321024d902e1a2fc7a8755ab5b694c575fce742c48d9ff192e63df5193e4c7afe1f9c52ae</tt>\n* <tt>wsh(multi(2,xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0,xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/*,xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))</tt>\n** <tt>0020b92623201f3bb7c3771d45b2ad1d0351ea8fbf8cfe0a0e570264e1075fa1948f</tt>\n** <tt>002036a08bbe4923af41cf4316817c93b8d37e2f635dd25cfff06bd50df6ae7ea203</tt>\n** <tt>0020a96e7ab4607ca6b261bfe3245ffda9c746b28d3f59e83d34820ec0e2b36c139c</tt>\n* <tt>sh(wsh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232)))</tt>\n** <tt>a9147fc63e13dc25e8a95a3cee3d9a714ac3afd96f1e87</tt>\n* <tt>wsh(multi(20,KzoAz5CanayRKex3fSLQ2BwJpN7U52gZvxMyk78nDMHuqrUxuSJy,KwGNz6YCCQtYvFzMtrC6D3tKTKdBBboMrLTsjr2NYVBwapCkn7Mr,KxogYhiNfwxuswvXV66eFyKcCpm7dZ7TqHVqujHAVUjJxyivxQ9X,L2BUNduTSyZwZjwNHynQTF14mv2uz2NRq5n5sYWTb4FkkmqgEE9f,L1okJGHGn1kFjdXHKxXjwVVtmCMR2JA5QsbKCSpSb7ReQjezKeoD,KxDCNSST75HFPaW5QKpzHtAyaCQC7p9Vo3FYfi2u4dXD1vgMiboK,L5edQjFtnkcf5UWURn6UuuoFrabgDQUHdheKCziwN42aLwS3KizU,KzF8UWFcEC7BYTq8Go1xVimMkDmyNYVmXV5PV7RuDicvAocoPB8i,L3nHUboKG2w4VSJ5jYZ5CBM97oeK6YuKvfZxrefdShECcjEYKMWZ,KyjHo36dWkYhimKmVVmQTq3gERv3pnqA4xFCpvUgbGDJad7eS8WE,KwsfyHKRUTZPQtysN7M3tZ4GXTnuov5XRgjdF2XCG8faAPmFruRF,KzCUbGhN9LJhdeFfL9zQgTJMjqxdBKEekRGZX24hXdgCNCijkkap,KzgpMBwwsDLwkaC5UrmBgCYaBD2WgZ7PBoGYXR8KT7gCA9UTN5a3,KyBXTPy4T7YG4q9tcAM3LkvfRpD1ybHMvcJ2ehaWXaSqeGUxEdkP,KzJDe9iwJRPtKP2F2AoN6zBgzS7uiuAwhWCfGdNeYJ3PC1HNJ8M8,L1xbHrxynrqLKkoYc4qtoQPx6uy5qYXR5ZDYVYBSRmCV5piU3JG9,KzRedjSwMggebB3VufhbzpYJnvHfHe9kPJSjCU5QpJdAW3NSZxYS,Kyjtp5858xL7JfeV4PNRCKy2t6XvgqNNepArGY9F9F1SSPqNEMs3,L2D4RLHPiHBidkHS8ftx11jJk1hGFELvxh8LoxNQheaGT58dKenW,KyLPZdwY4td98bKkXqEXTEBX3vwEYTQo1yyLjX2jKXA63GBpmSjv))</tt>\n** <tt>0020376bd8344b8b6ebe504ff85ef743eaa1aa9272178223bcb6887e9378efb341ac</tt>\n* <tt>sh(wsh(multi(20,KzoAz5CanayRKex3fSLQ2BwJpN7U52gZvxMyk78nDMHuqrUxuSJy,KwGNz6YCCQtYvFzMtrC6D3tKTKdBBboMrLTsjr2NYVBwapCkn7Mr,KxogYhiNfwxuswvXV66eFyKcCpm7dZ7TqHVqujHAVUjJxyivxQ9X,L2BUNduTSyZwZjwNHynQTF14mv2uz2NRq5n5sYWTb4FkkmqgEE9f,L1okJGHGn1kFjdXHKxXjwVVtmCMR2JA5QsbKCSpSb7ReQjezKeoD,KxDCNSST75HFPaW5QKpzHtAyaCQC7p9Vo3FYfi2u4dXD1vgMiboK,L5edQjFtnkcf5UWURn6UuuoFrabgDQUHdheKCziwN42aLwS3KizU,KzF8UWFcEC7BYTq8Go1xVimMkDmyNYVmXV5PV7RuDicvAocoPB8i,L3nHUboKG2w4VSJ5jYZ5CBM97oeK6YuKvfZxrefdShECcjEYKMWZ,KyjHo36dWkYhimKmVVmQTq3gERv3pnqA4xFCpvUgbGDJad7eS8WE,KwsfyHKRUTZPQtysN7M3tZ4GXTnuov5XRgjdF2XCG8faAPmFruRF,KzCUbGhN9LJhdeFfL9zQgTJMjqxdBKEekRGZX24hXdgCNCijkkap,KzgpMBwwsDLwkaC5UrmBgCYaBD2WgZ7PBoGYXR8KT7gCA9UTN5a3,KyBXTPy4T7YG4q9tcAM3LkvfRpD1ybHMvcJ2ehaWXaSqeGUxEdkP,KzJDe9iwJRPtKP2F2AoN6zBgzS7uiuAwhWCfGdNeYJ3PC1HNJ8M8,L1xbHrxynrqLKkoYc4qtoQPx6uy5qYXR5ZDYVYBSRmCV5piU3JG9,KzRedjSwMggebB3VufhbzpYJnvHfHe9kPJSjCU5QpJdAW3NSZxYS,Kyjtp5858xL7JfeV4PNRCKy2t6XvgqNNepArGY9F9F1SSPqNEMs3,L2D4RLHPiHBidkHS8ftx11jJk1hGFELvxh8LoxNQheaGT58dKenW,KyLPZdwY4td98bKkXqEXTEBX3vwEYTQo1yyLjX2jKXA63GBpmSjv)))</tt>\n** <tt>a914c2c9c510e9d7f92fd6131e94803a8d34a8ef675e87</tt>\n\nInvalid descriptors\n\n* More than 15 keys in P2SH multisig: <tt>sh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232))</tt>\n* Invalid threshold: <tt>multi(a,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n* Threshold of 0: <tt>multi(0,03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd,04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n* Threshold larger than keys: <tt>multi(3,L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1,5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)</tt>\n\n==Backwards Compatibility==\n\n<tt>multi()</tt>, and <tt>sortedmulti()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs these are a wholly new descriptors, they are not compatible with any implementation.\nHowever the scripts produced are standard scripts so existing software are likely to be familiar with them.\n\n==Reference Implementation==\n\n<tt>multi()</tt>, and <tt>sortedmulti()</tt> descriptors have been implemented in Bitcoin Core since version 0.17.\n", "content_length": 12000}
{"bip_number": 382, "filename": "bip-0382.mediawiki", "content": "<pre>\n  BIP: 382\n  Layer: Applications\n  Title: Segwit Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0382\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>wpkh()</tt>, and <tt>wsh()</tt> output script descriptors.\n<tt>wpkh()</tt> descriptors take a key and produces a P2WPKH output script.\n<tt>wsh()</tt> descriptors take a script and produces a P2WSH output script.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nSegregated Witness added 2 additional standard output script formats: P2WPKH and P2WSH.\nThese expressions allow specifying those formats as a descriptor.\n\n==Specification==\n\nTwo new script expressions are defined: <tt>wpkh()</tt>, and <tt>wsh()</tt>.\n\n===<tt>wpkh()</tt>===\n\nThe <tt>wpkh(KEY)</tt> expression can be used as a top level expression, or inside of a <tt>sh()</tt> descriptor.\nIt takes a single key expression as an argument and produces a P2WPKH output script.\nOnly keys which are/have compressed public keys can be contained in a <tt>wpkh()</tt> expression.\n\nThe output script produced is:\n<pre>\nOP_0 <KEY_hash160>\n</pre>\n\n===<tt>wsh()</tt>===\n\nThe <tt>wsh(SCRIPT)</tt> expression can be used as a top level expression, or inside of a <tt>sh()</tt> descriptor.\nIt takes a single script expression as an argument and produces a P2WSH output script.\n<tt>wsh()</tt> expressions also create a witnessScript which is required in order to spend outputs which use its output script.\nThis redeemScript is the output script produced by the <tt>SCRIPT</tt> argument to <tt>wsh()</tt>.\nAny key expression found in any script expression contained by a <tt>wsh()</tt> expression must only produce compressed public keys.\n\nThe output script produced is:\n<pre>\nOP_0 <SCRIPT_sha256>\n</pre>\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce. Descriptors involving derived child keys will have the 0th, 1st, and 2nd scripts listed.\n\n* <tt>wpkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)</tt>\n** <tt>00149a1c78a507689f6f54b847ad1cef1e614ee23f1e</tt>\n* <tt>wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n** <tt>00149a1c78a507689f6f54b847ad1cef1e614ee23f1e</tt>\n* <tt>wpkh([ffffffff/13']xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt/1/2/0)</tt>\n** <tt>0014326b2249e3a25d5dc60935f044ee835d090ba859</tt>\n* <tt>wpkh([ffffffff/13']xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH/1/2/*)</tt>\n** <tt>0014326b2249e3a25d5dc60935f044ee835d090ba859</tt>\n** <tt>0014af0bd98abc2f2cae66e36896a39ffe2d32984fb7</tt>\n** <tt>00141fa798efd1cbf95cebf912c031b8a4a6e9fb9f27</tt>\n* <tt>sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*'))</tt>\n** <tt>a9149a4d9901d6af519b2a23d4a2f51650fcba87ce7b87</tt>\n** <tt>a914bed59fc0024fae941d6e20a3b44a109ae740129287</tt>\n** <tt>a9148483aa1116eb9c05c482a72bada4b1db24af654387</tt>\n* <tt>sh(wpkh(xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi/10/20/30/40/*h))</tt>\n** <tt>a9149a4d9901d6af519b2a23d4a2f51650fcba87ce7b87</tt>\n** <tt>a914bed59fc0024fae941d6e20a3b44a109ae740129287</tt>\n** <tt>a9148483aa1116eb9c05c482a72bada4b1db24af654387</tt>\n* <tt>wsh(pkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))</tt>\n** <tt>0020338e023079b91c58571b20e602d7805fb808c22473cbc391a41b1bd3a192e75b</tt>\n* <tt>wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n** <tt>0020338e023079b91c58571b20e602d7805fb808c22473cbc391a41b1bd3a192e75b</tt>\n* <tt>wsh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))</tt>\n** <tt>00202e271faa2325c199d25d22e1ead982e45b64eeb4f31e73dbdf41bd4b5fec23fa</tt>\n* <tt>wsh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n** <tt>00202e271faa2325c199d25d22e1ead982e45b64eeb4f31e73dbdf41bd4b5fec23fa</tt>\n* <tt>sh(wsh(pkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)))</tt>\n** <tt>a914b61b92e2ca21bac1e72a3ab859a742982bea960a87</tt>\n* <tt>sh(wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))</tt>\n** <tt>a914b61b92e2ca21bac1e72a3ab859a742982bea960a87</tt>\n\nInvalid descriptors with descriptions\n\n* Uncompressed public key in <tt>wpkh()</tt>: <tt>wpkh(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)</tt>\n* Uncompressed public key in <tt>wpkh()</tt>: <tt>sh(wpkh(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss))</tt>\n* Uncompressed public key in <tt>wpkh()</tt>: <tt>wpkh(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n* Uncompressed public key in <tt>wpkh()</tt>: <tt>sh(wpkh(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235))</tt>\n* Uncompressed public keys under <tt>wsh()</tt>: <tt>wsh(pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss))</tt>\n* Uncompressed public keys under <tt>wsh()</tt>: <tt>wsh(pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235))</tt>\n* <tt>wpkh()</tt> nested in <tt>wsh()</tt>: <tt>wsh(wpkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* <tt>wsh()</tt> nested in <tt>wsh()</tt>: <tt>wsh(wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))</tt>\n* <tt>wsh()</tt> nested in <tt>wsh()</tt>: <tt>sh(wsh(wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))))</tt>\n* Script in <tt>wpkh()</tt>: <tt>wpkh(wsh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))</tt>\n* Key in <tt>wsh()</tt>: <tt>wsh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n\n==Backwards Compatibility==\n\n<tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs these are a wholly new descriptors, they are not compatible with any implementation.\nHowever the scripts produced are standard scripts so existing software are likely to be familiar with them.\n\n==Reference Implementation==\n\n<tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors have been implemented in Bitcoin Core since version 0.17.\n", "content_length": 6643}
{"bip_number": 381, "filename": "bip-0381.mediawiki", "content": "<pre>\n  BIP: 381\n  Layer: Applications\n  Title: Non-Segwit Output Script Descriptors\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0381\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n  Requires: 380\n</pre>\n\n==Abstract==\n\nThis document specifies <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> output script descriptors.\n<tt>pk()</tt> descriptors take a key and produces a P2PK output script.\n<tt>pkh()</tt> descriptors take a key and produces a P2PKH output script.\n<tt>sh()</tt> descriptors take a script and produces a P2SH output script.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nPrior to the activation of Segregated Witness, there were 3 main standard output script formats: P2PK, P2PKH, and P2SH.\nThese expressions allow specifying those formats as a descriptor.\n\n==Specification==\n\nThree new script expressions are defined: <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt>.\n\n===<tt>pk()</tt>===\n\nThe <tt>pk(KEY)</tt> expression can be used in any context or level of a descriptor.\nIt takes a single key expression as an argument and produces a P2PK output script.\nDepending on the higher level descriptors, there may be restrictions on the type of public keys that can be included.\nSuch restrictions will be specified by those descriptors.\n\nThe output script produced is:\n<pre>\n<KEY> OP_CHECKSIG\n</pre>\n\n===<tt>pkh()</tt>===\n\nThe <tt>pkh(KEY)</tt> expression can be used as a top level expression, or inside of either a <tt>sh()</tt> or <tt>wsh()</tt> descriptor.\nIt takes a single key expression as an argument and produces a P2PKH output script.\nDepending on the higher level descriptors, there may be restrictions on the type of public keys that can be included.\nSuch restrictions will be specified by those descriptors.\n\nThe output script produced is:\n<pre>\nOP_DUP OP_HASH160 <KEY_hash160> OP_EQUALVERIFY OP_CHECKSIG\n</pre>\n\n===<tt>sh()</tt>===\n\nThe <tt>sh(SCRIPT)</tt> expression can only be used as a top level expression.\nIt takes a single script expression as an argument and produces a P2SH output script.\n<tt>sh()</tt> expressions also create a redeemScript which is required in order to spend outputs which use its output script.\nThis redeemScript is the output script produced by the <tt>SCRIPT</tt> argument to <tt>sh()</tt>.\n\nThe output script produced is:\n<pre>\nOP_HASH160 <SCRIPT_hash160> OP_EQUAL\n</pre>\n\n==Test Vectors==\n\nValid descriptors followed by the scripts they produce. Descriptors involving derived child keys will have the 0th, 1st, and 2nd scripts listed.\n\n* <tt>pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)</tt>\n** <tt>2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac</tt>\n* <tt>pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n** <tt>2103a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bdac</tt>\n* <tt>pkh([deadbeef/1/2'/3/4']L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1)</tt>\n** <tt>76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac</tt>\n* <tt>pkh([deadbeef/1/2'/3/4']03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n** <tt>76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac</tt>\n* <tt>pkh([deadbeef/1/2h/3/4h]03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n** <tt>76a9149a1c78a507689f6f54b847ad1cef1e614ee23f1e88ac</tt>\n* <tt>pk(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)</tt>\n** <tt>4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac</tt>\n* <tt>pk(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n** <tt>4104a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235ac</tt>\n* <tt>pkh(5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss)</tt>\n** <tt>76a914b5bd079c4d57cc7fc28ecf8213a6b791625b818388ac</tt>\n* <tt>pkh(04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235)</tt>\n** <tt>76a914b5bd079c4d57cc7fc28ecf8213a6b791625b818388ac</tt>\n* <tt>sh(pk(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))</tt>\n** <tt>a9141857af51a5e516552b3086430fd8ce55f7c1a52487</tt>\n* <tt>sh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n** <tt>a9141857af51a5e516552b3086430fd8ce55f7c1a52487</tt>\n* <tt>sh(pkh(L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1))</tt>\n** <tt>a9141a31ad23bf49c247dd531a623c2ef57da3c400c587</tt>\n* <tt>sh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n** <tt>a9141a31ad23bf49c247dd531a623c2ef57da3c400c587</tt>\n* <tt>pkh(xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0)</tt>\n** <tt>76a914ebdc90806a9c4356c1c88e42216611e1cb4c1c1788ac</tt>\n* <tt>pkh([bd16bee5/2147483647h]xpub69H7F5dQzmVd3vPuLKtcXJziMEQByuDidnX3YdwgtNsecY5HRGtAAQC5mXTt4dsv9RzyjgDjAQs9VGVV6ydYCHnprc9vvaA5YtqWyL6hyds/0)</tt>\n** <tt>76a914ebdc90806a9c4356c1c88e42216611e1cb4c1c1788ac</tt>\n* <tt>pk(xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L/0)</tt>\n** <tt>210379e45b3cf75f9c5f9befd8e9506fb962f6a9d185ac87001ec44a8d3df8d4a9e3ac</tt>\n* <tt>pk(xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y/0)</tt>\n** <tt>210379e45b3cf75f9c5f9befd8e9506fb962f6a9d185ac87001ec44a8d3df8d4a9e3ac</tt>\n\nInvalid descriptors\n\n* <tt>pk()</tt> only accepts key expressions: <tt>pk(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* <tt>pkh()</tt> only accepts key expressions: <tt>pkh(pk(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd))</tt>\n* <tt>sh()</tt> only accepts script expressions: <tt>sh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)</tt>\n* <tt>sh()</tt> is top level only: <tt>sh(sh(pkh(03a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd)))</tt>\n\n==Backwards Compatibility==\n\n<tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors use the format and general operation specified in [[bip-0380.mediawiki|380]].\nAs these are wholly new descriptors, they are not compatible with any implementation.\nHowever the scripts produced are standard scripts so existing software are likely to be familiar with them.\n\n==Reference Implementation==\n\n<tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors have been implemented in Bitcoin Core since version 0.17.\n", "content_length": 6809}
{"bip_number": 380, "filename": "bip-0380.mediawiki", "content": "<pre>\n  BIP: 380\n  Layer: Applications\n  Title: Output Script Descriptors General Operation\n  Author: Pieter Wuille <pieter@wuille.net>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0380\n  Status: Final\n  Type: Informational\n  Created: 2021-06-27\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nOutput Script Descriptors are a simple language which can be used to describe collections of output scripts.\nThere can be many different descriptor fragments and functions.\nThis document describes the general syntax for descriptors, descriptor checksums, and common expressions.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nBitcoin wallets traditionally have stored a set of keys which are later serialized and mutated to produce the output scripts that the wallet watches and the addresses it provides to users.\nTypically backups have consisted of solely the private keys, nowadays primarily in the form of BIP 39 mnemonics.\nHowever this backup solution is insufficient, especially since the introduction of Segregated Witness which added new output types.\nGiven just the private keys, it is not possible for restored wallets to know which kinds of output scripts and addresses to produce.\nThis has lead to incompatibilities between wallets when restoring a backup or exporting data for a watch only wallet.\n\nFurther complicating matters are BIP 32 derivation paths.\nAlthough BIPs 44, 49, and 84 have specified standard BIP 32 derivation paths for different output scripts and addresses, not all wallets support those derivation paths nor use them.\nThe lack of derivation path information in these backups and exports leads to further incompatibilities between wallets.\n\nCurrent solutions to these issues have not been generic and can be viewed as being layer violations.\nSolutions such as introducing different version bytes for extended key serialization both are a layer violation (key derivation should be separate from script type meaning) and specific only to a particular derivation path and script type.\n\nOutput Script Descriptors introduce a generic solution to these issues.\nScript types are specified explicitly through the use of Script Expressions.\nKey derivation paths are specified explicitly in Key Expressions.\nThese allow for creating wallet backups and exports which specify the exact scripts, subscripts (redeemScript, witnessScript, etc.), and keys to produce.\nWith the general structure specified in this BIP, new Script Expressions can be introduced as new script types are added.\nLastly, the use of common terminology and existing standards allow for Output Script Descriptors to be engineer readable so that the results can be understood at a glance.\n\n==Specification==\n\nDescriptors consist of several types of expressions.\nThe top level expression is a <tt>SCRIPT</tt>.\nThis expression may be followed by <tt>#CHECKSUM</tt>, where <tt>CHECKSUM</tt> is an 8 character alphanumeric descriptor checksum.\nAlthough the checksum is optional for parsing, applications may choose to reject descriptors that do not contain a checksum.\n\n===Script Expressions===\n\nScript Expressions (denoted <tt>SCRIPT</tt>) are expressions which correspond directly with a Bitcoin script.\nThese expressions are written as functions and take arguments.\nSuch expressions have a script template which is filled with the arguments correspondingly.\nExpressions are written with a human readable identifier string with the arguments enclosed with parentheses.\nThe identifier string should be alphanumeric and may include underscores.\n\nThe arguments to a script expression are defined by that expression itself.\nThey could be a script expression, a key expression, or some other expression entirely.\n\n===Key Expressions===\n\nA common expression used as an argument to script expressions are key expressions (denoted <tt>KEY</tt>).\nThese represent a public or private key and, optionally, information about the origin of that key.\nKey expressions can only be used as arguments to script expressions.\n\nKey expressions consist of:\n* Optionally, key origin information, consisting of:\n** An open bracket <tt>[</tt>\n** Exactly 8 hex characters for the fingerprint of the key where the derivation starts (see BIP 32 for details)\n** Followed by zero or more <tt>/NUM</tt> or <tt>/NUMh</tt>  path elements to indicate the unhardened or hardened derivation steps between the fingerprint and the key that follows.\n** A closing bracket <tt>]</tt>\n* Followed by the actual key, which is either:\n** A hex encoded public key, which depending on the script expression, may be either:\n*** 66 hex character string beginning with <tt>02</tt> or <tt>03</tt> representing a compressed public key\n*** 130 hex character string beginning with <tt>04</tt> representing an uncompressed public key\n** A [[https://en.bitcoin.it/wiki/Wallet_import_format|WIF]] encoded private key\n** <tt>xpub</tt> encoded extended public key or <tt>xprv</tt> encoded extended private key (as defined in BIP 32)\n*** Followed by zero or more <tt>/NUM</tt> or <tt>/NUMh</tt> path elements indicating BIP 32 derivation steps to be taken after the given extended key.\n*** Optionally followed by a single <tt>/*</tt> or <tt>/*h</tt> final step to denote all direct unhardened or hardened children.\n\nIf the <tt>KEY</tt> is a BIP 32 extended key, before output scripts can be created, child keys must be derived using the derivation information that follows the extended key.\nWhen the final step is <tt>/*</tt> or <tt>/*'</tt>, an output script will be produced for every child key index.\nThe derived key must be not be serialized as an uncompressed public key.\nScript Expressions may have further requirements on how derived public keys are serialized for script creation.\n\nIn the above specification, the hardened indicator <tt>h</tt> may be replaced with alternative hardened indicator of <tt>'</tt>.\n\n====Normalization of Key Expressions with Hardened Derivation====\n\nWhen a descriptor is exported without private keys, it is necessary to do additional derivation to remove any intermediate hardened derivation steps for the exported descriptor to be useful.\nThe exporter should derive the extended public key at the last hardened derivation step and use that extended public key as the key in the descriptor.\nThe derivation steps that were taken to get to that key must be added to the previous key origin information.\nIf there is no key origin information, then one must be added for the newly derived extended public key.\nIf the final derivation is hardened, then it is not necessary to do additional derivation.\n\n===Character Set===\n\nThe expressions used in descriptors must only contain characters within this character set so that the descriptor checksum will work.\n\nThe allowed characters are:\n<pre>\n0123456789()[],'/*abcdefgh@:$%{}\nIJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~\nijklmnopqrstuvwxyzABCDEFGH`#\"\\<space>\n</pre>\nNote that <tt><space></tt> on the last line is a space character.\n\nThis character set is written as 3 groups of 32 characters in this specific order so that the checksum below can identify more errors.\nThe first group are the most common \"unprotected\" characters (i.e. things such as hex and keypaths that do not already have their own checksums).\nCase errors cause an offset that is a multiple of 32 while as many alphabetic characters are in the same group while following the previous restrictions.\n\n===Checksum===\n\nFollowing the top level script expression is a single octothorpe (<tt>#</tt>) followed by the 8 character checksum.\nThe checksum is an error correcting checksum similar to bech32.\n\nThe checksum has the following properties:\n* Mistakes in a descriptor string are measured in \"symbol errors\". The higher the number of symbol errors, the harder it is to detect:\n** An error substituting a character from <tt>0123456789()[],'/*abcdefgh@:$%{}</tt> for another in that set always counts as 1 symbol error.\n*** Note that hex encoded keys are covered by these characters. Extended keys (<tt>xpub</tt> and <tt>xprv</tt>) use other characters too, but also have their own checksum mechanism.\n*** <tt>SCRIPT</tt> expression function names use other characters, but mistakes in these would generally result in an unparsable descriptor.\n** A case error always counts as 1 symbol error.\n** Any other 1 character substitution error counts as 1 or 2 symbol errors.\n* Any 1 symbol error is always detected.\n* Any 2 or 3 symbol error in a descriptor of up to 49154 characters is always detected.\n* Any 4 symbol error in a descriptor of up to 507 characters is always detected.\n* Any 5 symbol error in a descriptor of up to 77 characters is always detected.\n* Is optimized to minimize the chance of a 5 symbol error in a descriptor up to 387 characters is undetected\n* Random errors have a chance of 1 in 2<super>40</super> of being undetected.\n\nThe checksum itself uses the same character set as bech32: <tt>qpzry9x8gf2tvdw0s3jn54khce6mua7l</tt>\n\nValid descriptor strings with a checksum must pass the criteria for validity specified by the Python3 code snippet below.\nThe function <tt>descsum_check</tt> must return true when its argument <tt>s</tt> is a descriptor consisting in the form <tt>SCRIPT#CHECKSUM</tt>.\n\n<pre>\nINPUT_CHARSET = \"0123456789()[],'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#\\\"\\\\ \"\nCHECKSUM_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\nGENERATOR = [0xf5dee51989, 0xa9fdca3312, 0x1bab10e32d, 0x3706b1677a, 0x644d626ffd]\n\ndef descsum_polymod(symbols):\n    \"\"\"Internal function that computes the descriptor checksum.\"\"\"\n    chk = 1\n    for value in symbols:\n        top = chk >> 35\n        chk = (chk & 0x7ffffffff) << 5 ^ value\n        for i in range(5):\n            chk ^= GENERATOR[i] if ((top >> i) & 1) else 0\n    return chk\n\ndef descsum_expand(s):\n    \"\"\"Internal function that does the character to symbol expansion\"\"\"\n    groups = []\n    symbols = []\n    for c in s:\n        if not c in INPUT_CHARSET:\n            return None\n        v = INPUT_CHARSET.find(c)\n        symbols.append(v & 31)\n        groups.append(v >> 5)\n        if len(groups) == 3:\n            symbols.append(groups[0] * 9 + groups[1] * 3 + groups[2])\n            groups = []\n    if len(groups) == 1:\n        symbols.append(groups[0])\n    elif len(groups) == 2:\n        symbols.append(groups[0] * 3 + groups[1])\n    return symbols\n\ndef descsum_check(s):\n    \"\"\"Verify that the checksum is correct in a descriptor\"\"\"\n    if s[-9] != '#':\n        return False\n    if not all(x in CHECKSUM_CHARSET for x in s[-8:]):\n        return False\n    symbols = descsum_expand(s[:-9]) + [CHECKSUM_CHARSET.find(x) for x in s[-8:]]\n    return descsum_polymod(symbols) == 1\n</pre>\n\nThis implements a BCH code that has the properties described above.\nThe entire descriptor string is first processed into an array of symbols.\nThe symbol for each character is its position within its group.\nAfter every 3rd symbol, a 4th symbol is inserted which represents the group numbers combined together.\nThis means that a change that only affects the position within a group, or only a group number change, will only affect a single symbol.\n\nTo construct a valid checksum given a script expression, the code below can be used:\n\n<pre>\ndef descsum_create(s):\n    \"\"\"Add a checksum to a descriptor without\"\"\"\n    symbols = descsum_expand(s) + [0, 0, 0, 0, 0, 0, 0, 0]\n    checksum = descsum_polymod(symbols) ^ 1\n    return s + '#' + ''.join(CHECKSUM_CHARSET[(checksum >> (5 * (7 - i))) & 31] for i in range(8))\n\n</pre>\n\n==Test Vectors==\n\nThe following tests cover the checksum and character set:\n\n* Valid checksum: <tt>raw(deadbeef)#89f8spxm</tt>\n* No checksum: <tt>raw(deadbeef)</tt>\n* Missing checksum: <tt>raw(deadbeef)#</tt>\n* Too long checksum (9 chars): <tt>raw(deadbeef)#89f8spxmx</tt>\n* Too short checksum (7 chars): <tt>raw(deadbeef)#89f8spx</tt>\n* Error in payload: <tt>raw(deedbeef)#89f8spxm</tt>\n* Error in checksum: <tt>raw(deedbeef)##9f8spxm</tt>\n* Invalid characters in payload: <tt>raw(\u00dc)#00000000</tt>\n\nThe following tests cover key expressions:\n\nValid expressions:\n\n* Compressed public key: <tt>0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Uncompressed public key: <tt>04a34b99f22c790c4e36b2b3c2c35a36db06226e41c692fc82b8b56ac1c540c5bd5b8dec5235a0fa8722476c7709c02559e3aa73aa03918ba2d492eea75abea235</tt>\n* Public key with key origin: <tt>[deadbeef/0h/0h/0h]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Public key with key origin (<tt>'</tt> as hardened indicator): <tt>[deadbeef/0'/0'/0']0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Public key with key origin (mixed hardened indicator): <tt>[deadbeef/0'/0h/0']0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* WIF uncompressed private key <tt>5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss</tt>\n* WIF compressed private key <tt>L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1</tt>\n* Extended public key: <tt>xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL</tt>\n* Extended public key with key origin: <tt>[deadbeef/0h/1h/2h]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL</tt>\n* Extended public key with derivation: <tt>[deadbeef/0h/1h/2h]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/3/4/5</tt>\n* Extended public key with derivation and children: <tt>[deadbeef/0h/1h/2h]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/3/4/5/*</tt>\n* Extended public key with hardened derivation and unhardened children: <tt>xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/3h/4h/5h/*</tt>\n* Extended public key with hardened derivation and children: <tt>xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/3h/4h/5h/*h</tt>\n* Extended public key with key origin, hardened derivation and children: <tt>[deadbeef/0h/1h/2]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/3h/4h/5h/*h</tt>\n* Extended private key: <tt>xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc</tt>\n* Extended private key with key origin: <tt>[deadbeef/0h/1h/2h]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc</tt>\n* Extended private key with derivation: <tt>[deadbeef/0h/1h/2h]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/3/4/5</tt>\n* Extended private key with derivation and children: <tt>[deadbeef/0h/1h/2h]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/3/4/5/*</tt>\n* Extended private key with hardened derivation and unhardened children: <tt>xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/3h/4h/5h/*</tt>\n* Extended private key with hardened derivation and children: <tt>xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/3h/4h/5h/*h</tt>\n* Extended private key with key origin, hardened derivation and children: <tt>[deadbeef/0h/1h/2]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/3h/4h/5h/*h</tt>\n\nInvalid expression:\n\n* Children indicator in key origin: <tt>[deadbeef/0h/0h/0h/*]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Trailing slash in key origin: <tt>[deadbeef/0h/0h/0h/]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Too short fingerprint: <tt>[deadbef/0h/0h/0h]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Too long fingerprint: <tt>[deadbeeef/0h/0h/0h]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Invalid hardened indicators: <tt>[deadbeef/0f/0f/0f]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Invalid hardened indicators: <tt>[deadbeef/-0/-0/-0]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Invalid hardened indicators: <tt>[deadbeef/0H/0H/0H]0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600</tt>\n* Invalid hardened indicators: <tt>[deadbeef/0h/1h/2]xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc/3H/4h/5h/*H</tt>\n* Private key with derivation: <tt>L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1/0</tt>\n* Private key with derivation children: <tt>L4rK1yDtCWekvXuE6oXD9jCYfFNV2cWRpVuPLBcCU2z8TrisoyY1/*</tt>\n* Derivation index out of range: <tt>xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483648</tt>\n* Invalid derivation index: <tt>xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/1aa</tt>\n* Multiple key origins: <tt>[aaaaaaaa][aaaaaaaa]xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0</tt>\n* Missing key origin start: <tt>aaaaaaaa]xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0</tt>\n* Non hex fingerprint: <tt>[gaaaaaaa]xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U/2147483647'/0</tt>\n* Key origin with no public key: <tt>[deadbeef]</tt>\n\n==Backwards Compatibility==\n\nOutput script descriptors are an entirely new language which is not compatible with any existing software.\nHowever many components of the expressions reuse encodings and serializations defined by previous BIPs.\n\nOutput script descriptors are designed for future extension with further fragment types and new script expressions.\nThese will be specified in additional BIPs.\n\n==Reference Implementation==\n\nDescriptors have been implemented in Bitcoin Core since version 0.17.\n\n==Appendix A: Index of Expressions==\n\nFuture BIPs may specify additional types of expressions.\nAll available expression types are listed in this table.\n\n{|\n! Name\n! Denoted As\n! BIP\n|-\n| Script\n| <tt>SCRIPT</tt>\n| 380\n|-\n| Key\n| <tt>KEY</tt>\n| 380\n|-\n| Tree\n| <tt>TREE</tt>\n| [[bip-0386.mediawiki|386]]\n|}\n\n==Appendix B: Index of Script Expressions==\n\nScript expressions will be specified in additional BIPs.\nThis Table lists all available Script expressions and the BIPs specifying them.\n\n{|\n! Expression\n! BIP\n|-\n| <tt>pk(KEY)</tt>\n| [[bip-0381.mediawiki|381]]\n|-\n| <tt>pkh(KEY)</tt>\n| [[bip-0381.mediawiki|381]]\n|-\n| <tt>sh(SCRIPT)</tt>\n| [[bip-0381.mediawiki|381]]\n|-\n| <tt>wpkh(KEY)</tt>\n| [[bip-0382.mediawiki|382]]\n|-\n| <tt>wsh(SCRIPT)</tt>\n| [[bip-0382.mediawiki|382]]\n|-\n| <tt>multi(NUM, KEY, ..., KEY)</tt>\n| [[bip-0383.mediawiki|383]]\n|-\n| <tt>sortedmulti(NUM, KEY, ..., KEY)</tt>\n| [[bip-0383.mediawiki|383]]\n|-\n| <tt>combo(KEY)</tt>\n| [[bip-0384.mediawiki|384]]\n|-\n| <tt>raw(HEX)</tt>\n| [[bip-0385.mediawiki|385]]\n|-\n| <tt>addr(ADDR)</tt>\n| [[bip-0385.mediawiki|385]]\n|-\n| <tt>tr(KEY)</tt>, <tt>tr(KEY, TREE)</tt>\n| [[bip-0386.mediawiki|386]]\n|-\n| <tt>musig(KEY, KEY, ..., KEY)</tt>\n| [[bip-0390.mediawiki|390]]\n|}\n", "content_length": 19631}
{"bip_number": 375, "filename": "bip-0375.mediawiki", "content": "<pre>\n  BIP: 375\n  Layer: Applications\n  Title: Sending Silent Payments with PSBTs\n  Author: Andrew Toth <andrewstoth@gmail.com>\n          Ava Chow <me@achow101.com>\n          josibake <josibake@protonmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0375\n  Status: Draft\n  Type: Standards Track\n  Created: 2025-01-08\n  License: BSD-2-Clause\n  Post-History: https://groups.google.com/g/bitcoindev/c/5G5wzqUXyk4\n  Requires: 352, 370, 374\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes additional fields and updated role responsibilities for BIP370 PSBTv2\nwhich adds support for sending to silent payments as described in BIP352.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nPartially Signed Bitcoin Transaction Version 2 as described in BIP370 is not compatible with sending to silent payments as described in BIP352. \nIn particular, the output script of a silent payment cannot be computed until after all transaction inputs have been added.\nAdditionally, the silent payment outputs computed by a signer must be verifiable by other entities, otherwise funds could be sent to an incorrect output script.\nTherefore, new fields and role responsibilities must be added to carry, compute, and verify the silent payment data.\n\n==Specification==\n\nThis document specifies new fields and new field inclusion/exclusion requirements.\n\nThe new global types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Silent Payment Global ECDH Share\n| <tt>PSBT_GLOBAL_SP_ECDH_SHARE = 0x07</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this ECDH share is for.\n| <tt><33 byte share></tt>\n| An ECDH share for a scan key. The ECDH shared is computed with ''a * B_scan'', where ''a'' is the sum of all private keys of all eligible inputs, and ''B_scan'' is the scan key of a recipient.\n|\n| 0\n| 2\n|-\n| Silent Payment Global DLEQ Proof\n| <tt>PSBT_GLOBAL_SP_DLEQ = 0x08</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this proof covers.\n| <tt><64-byte proof></tt>\n| A BIP374 DLEQ proof computed for the matching ECDH share.\n|\n| 0\n| 2\n|}\n\nThe new per-input types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Silent Payment Input ECDH Share\n| <tt>PSBT_IN_SP_ECDH_SHARE = 0x1d</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this ECDH share is for.\n| <tt><33 byte share></tt>\n| An ECDH share for a scan key. The ECDH shared is computed with ''a * B_scan'', where ''a'' is the private key of the corresponding prevout public key, and ''B_scan'' is the scan key of a recipient.\n|\n| 0\n| 2\n|-\n| Silent Payment Input DLEQ Proof\n| <tt>PSBT_IN_SP_DLEQ = 0x1e</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this proof covers.\n| <tt><64-byte proof></tt>\n| A BIP374 DLEQ proof computed for the matching ECDH share.\n|\n| 0\n| 2\n|}\n\nThe new per-output types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Silent Payment Data\n| <tt>PSBT_OUT_SP_V0_INFO = 0x09</tt>\n| None\n| No key data\n| <tt><33 byte scan key> <33 byte spend key></tt>\n| The scan and spend public keys from the silent payments address.\n|\n| 0\n| 2\n|-\n| Silent Payment Label\n| <tt>PSBT_OUT_SP_V0_LABEL = 0x0a</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint label></tt>\n| The label to use to compute the spend key of the silent payments address to verify change.\n|\n| 0\n| 2\n|}\n\n<tt>PSBT_OUT_SCRIPT</tt> is modified to be optional for outputs in silent payments capable PSBTs. If this field is not included in the output, then the field PSBT_OUT_SP_V0_INFO must be included.\nIf a PSBT_OUT_SCRIPT is not present for an output, then that output is being sent to a silent payment address represented by PSBT_OUT_SP_V0_INFO but the script has not yet been computed.\nIf both PSBT_OUT_SCRIPT and PSBT_OUT_SP_V0_INFO are present for an output, then the PSBT_OUT_SCRIPT is the computed output script corresponding to the silent payment address in PSBT_OUT_SP_V0_INFO.\nIf only PSBT_OUT_SCRIPT is present for an output, then the output is not being sent to a silent payment address.\n\n===Unique Identification===\n\nSilent payment capable PSBTs can be uniquely identified the same way as PSBTv2s, except when including silent payment outputs. If an output contains the PSBT_OUT_SP_V0_INFO field, it must use that field instead of PSBT_OUT_SCRIPT as the output script when creating the unsigned transaction used for unique identification.<ref name=\"why_use_sp_info_field\"> ''' Why use PSBT_OUT_SP_V0_INFO when serializing for a unique identifier?''' Since the same silent payment capable PSBT is valid whether or not a PSBT_OUT_SCRIPT is included in an output that has PSBT_OUT_SP_V0_INFO set, using the PSBT_OUT_SCRIPT if present for the unique identifier will cause malleability. The identifier will be different depending on whether PSBT_OUT_SCRIPT is present, so always using PSBT_OUT_SP_V0_INFO if it exists makes sure the PSBT is always identified uniquely.</ref>\nThe PSBT_OUT_SP_V0_INFO should be serialized as a zero byte for the version, followed by the 33 bytes of the scan key and then 33 bytes for the spend key.\n\n\n==Roles==\n\nThis document modifies some existing roles.\n\n===Constructor===\n\nAll rules must be followed from PSBTv2 for this role, with the following exception:\nWhen an output is added, it must have either PSBT_OUT_SCRIPT or PSBT_OUT_SP_V0_INFO, or both, set.\n\nAdditionally to PSBTv2, the Constructor must also follow additional rules:\n\nInputs spending an output with script using Segwit version > 1 may only be added if there are no outputs with PSBT_OUT_SP_V0_INFO set.\nOutputs with PSBT_OUT_SP_V0_INFO set may only be added if there are no inputs spending an output script using Segwit version > 1.\n\n===Updater===\n\nThe updater should add a PSBT_IN_BIP32_DERIVATION for any p2wpkh, p2sh-p2wpkh, or p2pkh input so the public key is available for creating the ecdh_shared_secret when the private key is not known. If the updater does not want to reveal the fingerprint or derivation path, it can set the value of the field to zero.\n\n====Change Detection====\n\nUpdaters may add two PSBT_OUT_BIP32_DERIVATION key-value-pairs with the corresponding derivation path of both the scan and spend keys. A label can be specified in PSBT_OUT_SP_V0_LABEL. The Signer can then use these fields to verify that the silent payment code is change.\n\n===Signer===\n\nAll rules must be followed from PSBTv2 for this role. If there are any outputs with PSBT_OUT_SP_V0_INFO set, then the following additional rules must also be adhered to:\n\nIf any input is spending an output with script using Segwit version > 1, the Signer must fail.\n\nFor each output with PSBT_OUT_SP_V0_INFO set, the Signer should:\n* Compute and set an ECDH share and DLEQ proof for each input it has the private key for, or set a global ECDH share and DLEQ proof if it has private keys for all eligible inputs.\n* Verify the DLEQ proofs for all inputs it does not have the private keys for, or the global DLEQ proof if it is set.\n* If all eligible inputs have an ECDH share or the global ECDH share is set, compute and set the PSBT_OUT_SCRIPT.\n\nIf the Signer sets any missing PSBT_OUT_SCRIPTs, it must set the Inputs Modifiable and Outputs Modifiable flags to False.\n\nIf any output does not have PSBT_OUT_SCRIPT set, the Signer must not yet add a signature.\n\nThe Signer should additionally compute the silent payment addresses, optionally showing this data to the user instead of the computed segwit v1 addresses.\n\nIf a sighash type is provided and there are silent payment outputs present, the signer must fail if the sighash type is not SIGHASH_ALL.\nIf a sighash type is not provided and there are silent payment outputs present, the signer must sign using SIGHASH_ALL.<ref name=\"why_use_sighash_all\"> ''' Why use only SIGHASH_ALL?''' BIP352 allows signing with SIGHASH_NONE and SIGHASH_SINGLE. However, silent payment capable PSBTs compute the output scripts deterministically based on the number and position of silent payment codes with the same scan key. SIGHASH_NONE and SIGHASH_SINGLE allow changing the amount or position of silent payment codes with the same scan and spend keys, which would invalidate computed output scripts.</ref>\n\n====Computing the ECDH Shares and DLEQ Proofs====\n\nFor each output with PSBT_OUT_SP_V0_INFO set, the Signer may generate a proof for other entities to generate the output scripts and verify that the output scripts were generated correctly.\n\nIf the Signer has the private keys for all eligible inputs, the Signer should generate a global ECDH share for each scan key ''B<sub>scan</sub>'' as follows:\n\nUsing the notation from [https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#specification BIP352]\n\n* Let ''a<sub>n</sub>'' be the sum of the private keys ''a'' of all eligible inputs\n* Let ''C =  a<sub>n</sub>\u00b7B<sub>scan</sub>''\n\nSet the key as ''B<sub>scan</sub>'' and the value as ''C'' for the PSBT_GLOBAL_SP_ECDH_SHARE field.\n\nCompute the DLEQ proof for ''C'' using [https://github.com/bitcoin/bips/blob/master/bip-0374.mediawiki#user-content-DLEQ_Proof_Generation BIP374 GenerateProof] and passing ''a<sub>n</sub>'' as ''a'' and ''B<sub>scan</sub>'' as ''B''.\nSet the key as ''B<sub>scan</sub>'' and the value as the proof for the PSBT_GLOBAL_SP_DLEQ field.\n\nIf the Signer has the private keys for some eligible inputs or does not want to create a global ECDH share, the Signer should generate a per-input ECDH share for each scan key ''B<sub>scan</sub>'' as follows:\n\nUsing the notation from [https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#specification BIP352], for each eligible input:\n\n* Let ''a'' be the private key of the input\n* Let ''C =  a\u00b7B<sub>scan</sub>''\n\nSet the key as ''B<sub>scan</sub>'' and the value as ''C'' for the PSBT_IN_SP_ECDH_SHARE field of the input.\n\nCompute the DLEQ proof for ''C'' using [https://github.com/bitcoin/bips/blob/master/bip-0374.mediawiki#user-content-DLEQ_Proof_Generation BIP374 GenerateProof] and passing ''B<sub>scan</sub>'' as ''B''.\nSet the key as ''B<sub>scan</sub>'' and the value as the proof for the PSBT_IN_SP_DLEQ field of the input.\n\n====Verifying the DLEQ Proof====\n\nFor each output with PSBT_OUT_SP_V0_INFO set, the Signer should verify the ECDH shares for all eligible inputs it does not have the private key for using the proofs provided by other Signers.\n\nIf PSBT_GLOBAL_SP_ECDH_SHARE and PSBT_GLOBAL_SP_DLEQ are set, verify as follows:\n\n* Let ''A<sub>n</sub>'' be the sum of the public keys ''A'' of all eligible inputs\n\nUsing [https://github.com/bitcoin/bips/blob/master/bip-0374.mediawiki#dleq-proof-verification BIP374 VerifyProof] and passing ''A'' as ''A<sub>n</sub>'', ''B'' as ''B<sub>scan</sub>'', ''C'' as the value of PSBT_GLOBAL_SP_ECDH_SHARE, and ''proof'' as the value of PSBT_GLOBAL_SP_DLEQ.\n\nIf PSBT_IN_SP_ECDH_SHARE and PSBT_IN_SP_DLEQ are set for a particular input, verify as follows:\n\nUsing [https://github.com/bitcoin/bips/blob/master/bip-0374.mediawiki#dleq-proof-verification BIP374 VerifyProof] and passing ''A'' as the public key of the input, ''B'' as ''B<sub>scan</sub>'', ''C'' as the value of PSBT_IN_SP_ECDH_SHARE, and ''proof'' as the value of PSBT_IN_SP_DLEQ.\n\n\n====Computing the Output Scripts====\n\nCompute the PSBT_OUT_SCRIPT using the procedure in [https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#user-content-Creating_outputs BIP352] but substituting ''a\u00b7B<sub>scan</sub>'' with the PSBT_GLOBAL_SP_ECDH_SHARE for that scan key if available, or the sum of all PSBT_IN_SP_ECDH_SHAREs for that scan key.\nIf there are multiple silent payment codes with the same scan key, sort the codes lexicographically in ascending order to determine the ordering of the ''k'' value.\nIf there are multiple silent payment codes with both the same scan and spend keys, sort the subgroup by output index in ascending order.\n\n===Transaction Extractor===\n\nFor silent payment capable PSBTs, the transaction extractor should compute all output scripts for silent payment codes and verify they are correct using the ECDH shares and DLEQ proofs, otherwise fail.\n\n==Backwards Compatibility==\n\nSilent payment capable PSBTs are backwards compatible with PSBTv2 once all outputs have PSBT_OUT_SCRIPT set. Otherwise they are not backwards compatible.\n\n==Test Vectors==\n\nTodo\n\n==Rationale==\n\n<references/>\n\n==Reference implementation==\n\nTodo\n", "content_length": 12952}
{"bip_number": 374, "filename": "bip-0374.mediawiki", "content": "<pre>\n  BIP: 374\n  Layer: Applications\n  Title: Discrete Log Equality Proofs\n  Author: Andrew Toth <andrewstoth@gmail.com>\n          Ruben Somsen <rsomsen@gmail.com>\n          Sebastian Falbesoner <sebastian.falbesoner@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0374\n  Status: Draft\n  Type: Standards Track\n  Created: 2024-12-26\n  License: BSD-2-Clause\n  Post-History: https://gist.github.com/andrewtoth/df97c3260cc8d12f09d3855ee61322ea\n                https://groups.google.com/g/bitcoindev/c/MezoKV5md7s\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\n\nThis document proposes a standard for 64-byte zero-knowledge ''discrete logarithm equality proofs'' (DLEQ proofs) over an elliptic curve. For given elliptic curve points ''A'', ''B'', ''C'', ''G'', and a scalar ''a'' known only to the prover where ''A = a\u22c5G'' and ''C = a\u22c5B'', the prover proves knowledge of ''a'' without revealing anything about ''a''. This can, for instance, be useful in ECDH: if ''A'' and ''B'' are ECDH public keys, and ''C'' is their ECDH shared secret computed as ''C = a\u22c5B'', the proof establishes that the same secret key ''a'' is used for generating both ''A'' and ''C'' without revealing ''a''.\n\n=== Copyright ===\n\nThis document is licensed under the 2-clause BSD license.\n\n=== Motivation ===\n\n[https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki#specification BIP352] requires senders to compute output scripts using ECDH shared secrets from the same secret keys used to sign the inputs. Generating an incorrect signature will produce an invalid transaction that will be rejected by consensus. An incorrectly generated output script can still be consensus-valid, meaning funds may be lost if it gets broadcast.\nBy producing a DLEQ proof for the generated ECDH shared secrets, the signing entity can prove to other entities that the output scripts have been generated correctly without revealing the private keys.\n\n== Specification ==\n\nAll conventions and notations are used as defined in [https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki#user-content-Notation BIP327].\n\n=== Description ===\n\nThe basic proof generation uses a random scalar ''k'', the secret ''a'', and the point being proven ''C = a\u22c5B''.\n\n* Let ''R<sub>1</sub> = k\u22c5G''.\n* Let ''R<sub>2</sub> = k\u22c5B''.\n* Let ''e = hash(R<sub>1</sub> || R<sub>2</sub>)''.\n* Let ''s = (k + e\u22c5a)''.\n\nProviding only ''C'', ''e'' and ''s'' as a proof does not reveal ''a'' or ''k''.\n\nVerifying the proof involves recreating ''R<sub>1</sub>'' and ''R<sub>2</sub>'' with only ''e'' and ''s'' as follows:\n\n* Let ''R<sub>1</sub> = s\u22c5G - e\u22c5A''.\n* Let ''R<sub>2</sub> = s\u22c5B - e\u22c5C''.\n\nThis can be verified by substituting ''s = (k + e\u22c5a)'':\n\n* ''s\u22c5G - e\u22c5A = (k + e\u22c5a)\u22c5G - e\u22c5A = k\u22c5G + e\u22c5(a\u22c5G) - e\u22c5A = k\u22c5G + e\u22c5A - e\u22c5A = k\u22c5G''.\n* ''s\u22c5B - e\u22c5C = (k + e\u22c5a)\u22c5B - e\u22c5C = k\u22c5B + e\u22c5(a\u22c5B) - e\u22c5C = k\u22c5B + e\u22c5C - e\u22c5C = k\u22c5B''.\n\nThus verifying ''e = hash(R<sub>1</sub> || R<sub>2</sub>)'' proves the discrete logarithm equivalency of ''A'' and ''C''.\n\n=== DLEQ Proof Generation ===\n\nThe following generates a proof that the result of ''a\u22c5B'' and the result of ''a\u22c5G'' are both generated from the same scalar ''a'' without having to reveal ''a''.\n\nInput:\n* The secret key ''a'': a 256-bit unsigned integer\n* The public key ''B'': a point on the curve\n* Auxiliary random data ''r'': a 32-byte array<ref name=\"why_include_auxiliary_random_data\"> ''' Why include auxiliary random data?''' The auxiliary random data should be set to fresh randomness for each proof. The same rationale and recommendations from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#default-signing BIP340] should be applied.</ref> \n* The generator point ''G'': a point on the curve<ref name=\"why_include_G\"> ''' Why include the generator point G as an input?''' While all other BIPs have used the generator point from secp256k1, passing it as an input here lets this algorithm be used for other curves.</ref>\n* An optional message ''m'': a 32-byte array<ref name=\"why_include_a_message\"> ''' Why include a message as an input?''' This could be useful for protocols that want to authorize on a compound statement, not just knowledge of a scalar. This allows the protocol to combine knowledge of the scalar and the statement.</ref>\n\nThe algorithm ''GenerateProof(a, B, r, G, m)'' is defined as:\n* Fail if ''a = 0'' or ''a &ge; n''.\n* Fail if ''is_infinite(B)''.\n* Let ''A = a\u22c5G''.\n* Let ''C = a\u22c5B''.\n* Let ''t'' be the byte-wise xor of ''bytes(32, a)'' and ''hash<sub>BIP0374/aux</sub>(r)''.\n* Let ''m' = m if m is provided, otherwise an empty byte array''.\n* Let ''rand = hash<sub>BIP0374/nonce</sub>(t || cbytes(A) || cbytes(C) || m')''.<ref name=\"why_include_m_in_rand\"> ''' Why include the message in the rand computation?''' Not including the message in the rand computation could leak ''a'' if two proofs were constructed for the same ''a'', ''B'', and ''G'' but a different message ''m'' and an all-zero ''r''.</ref>\n* Let ''k = int(rand) mod n''.\n* Fail if ''k = 0''.\n* Let ''R<sub>1</sub> = k\u22c5G''.\n* Let ''R<sub>2</sub> = k\u22c5B''.\n* Let ''e = int(hash<sub>BIP0374/challenge</sub>(cbytes(A) || cbytes(B) || cbytes(C) || cbytes(G) || cbytes(R<sub>1</sub>) || cbytes(R<sub>2</sub>) || m'))''.\n* Let ''s = (k + e\u22c5a) mod n''.\n* Let ''proof = bytes(32, e) || bytes(32, s)''.\n* If ''VerifyProof(A, B, C, proof, G, m)'' (see below) returns failure, abort.\n* Return the proof ''proof''.\n\n=== DLEQ Proof Verification ===\n\nThe following verifies the proof generated in the previous section. If the following algorithm succeeds, the points ''A'' and ''C'' were both generated from the same scalar. The former from multiplying by ''G'', and the latter from multiplying by ''B''.\n\nInput:\n* The public key of the secret key used in the proof generation ''A'': a point on the curve\n* The public key used in the proof generation ''B'': a point on the curve\n* The result of multiplying the secret and public keys used in the proof generation ''C'': a point on the curve\n* A proof ''proof'': a 64-byte array\n* The generator point used in the proof generation ''G'': a point on the curve<ref name=\"why_include_G\"> ''' Why include the generator point G as an input?''' While all other BIPs have used the generator point from Secp256k1, passing it as an input here lets this algorithm be used for other curves.</ref>\n* An optional message ''m'': a 32-byte array<ref name=\"why_include_a_message\"> ''' Why include a message as an input?''' This could be useful for protocols that want to authorize on a compound statement, not just knowledge of a scalar. This allows the protocol to combine knowledge of the scalar and the statement.</ref>\n\nThe algorithm ''VerifyProof(A, B, C, proof, G, m)'' is defined as:\n* Fail if any of ''is_infinite(A)'', ''is_infinite(B)'', ''is_infinite(C)'', ''is_infinite(G)''\n* Let ''e = int(proof[0:32])''.\n* Let ''s = int(proof[32:64])''; fail if ''s &ge; n''.\n* Let ''R<sub>1</sub> = s\u22c5G - e\u22c5A''.\n* Fail if ''is_infinite(R<sub>1</sub>)''.\n* Let ''R<sub>2</sub> = s\u22c5B - e\u22c5C''.\n* Fail if ''is_infinite(R<sub>2</sub>)''.\n* Let ''m' = m if m is provided, otherwise an empty byte array''.\n* Fail if ''e \u2260 int(hash<sub>BIP0374/challenge</sub>(cbytes(A) || cbytes(B) || cbytes(C) || cbytes(G) || cbytes(R<sub>1</sub>) || cbytes(R<sub>2</sub>) || m'))''.\n* Return success iff no failure occurred before reaching this point.\n\n==Backwards Compatibility==\n\nThis proposal is compatible with all older clients.\n\n== Test Vectors and Reference Code ==\n\nA reference python implementation is included [https://github.com/bitcoin/bips/blob/master/bip-0374/reference.py here].\nTest vectors can be generated by running <code>./bip-0374/gen_test_vectors.py</code> which will produce a CSV file of random test vectors for both generating and verifying proofs. These can be run against the reference implementation with <code>./bip-0374/run_test_vectors.py</code>.\n\n== Changelog ==\n\n* 0.2.0 (2025-02-27):\n** Add the message to the rand computation\n* 0.1.0 (2024-12-26):\n** Initial version\n\n== Footnotes ==\n\n<references />\n\n== Acknowledgements ==\n\nThanks to josibake, Tim Ruffing, benma, stratospher, waxwing, Yuval Kogman and all others who\nparticipated in discussions on this topic.\n", "content_length": 8216}
{"bip_number": 373, "filename": "bip-0373.mediawiki", "content": "<pre>\n  BIP: 373\n  Layer: Applications\n  Title: MuSig2 PSBT Fields\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0373\n  Status: Proposed\n  Type: Standards Track\n  Created: 2024-06-04\n  License: CC0-1.0\n  Requires: 32, 174, 327, 328, 370\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes additional fields for [[bip-0174.mediawiki|BIP 174]] PSBTv0 and [[bip-0370.mediawiki|BIP 370]] PSBTv2 that allow for \n[[bip-0327.mediawiki|BIP 327]] MuSig2 Multi-Signature data to be included in a PSBT of any version. These will be fields for\nthe participants' keys, the public nonces, and the partial signatures produced with MuSig2.\n\n===Copyright===\n\nThis BIP is licensed under the Creative Commons CC0 1.0 Universal license.\n\n===Motivation===\n\n[[bip-0327.mediawiki|BIP 327]] specifies a way to create [[bip-0340.mediawiki|BIP 340]] compatible public keys and signatures using the MuSig2\nMulti-Signature scheme. The existing PSBT fields are unable to support MuSig2 as it introduces new\nconcepts and additional rounds of communication. Therefore new fields must be defined to allow PSBTs\nto carry the information necessary to produce a valid signature with MuSig2.\n\n==Specification==\n\nThe new per-input types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><valuedata></tt>\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| rowspan=\"2\"|MuSig2 Participant Public Keys\n| rowspan=\"2\"|<tt>PSBT_IN_MUSIG2_PARTICIPANT_PUBKEYS = 0x1a</tt>\n| <tt><33 byte aggregate pubkey (compressed)></tt>\n| <tt><33 byte participant pubkey (compressed)>*</tt>\n| rowspan=\"2\"|\n| rowspan=\"2\"|\n| rowspan=\"2\"| 0, 2\n|-\n| The MuSig2 aggregate public key (compressed) <ref>'''Why the compressed aggregate public key instead of x-only?'''\n[[bip-0032.mediawiki|BIP 32]] public keys can be derived from a [[bip-0327.mediawiki|BIP 327]] MuSig2 aggregate public key (see: [[bip-0328.mediawiki|BIP 328]]).\nBut since BIP 32 requires public keys to include their evenness byte, BIP 327 MuSig2 aggregate public keys must\ninclude their evenness byte as well. Furthermore, PSBT_IN_TAP_BIP32_DERIVATION fields include fingerprints to identify\nmaster keys, and these fingerprints require the y-coordinate of the public key, so x-only serialization can't be used.\nBy including the aggregate key as a full public key, signers that are unaware of the MuSig2 outside of the PSBT will\nstill be able to identify which keys are derived from the aggregate key by computing and then comparing the\nfingerprints. This is necessary for the signer to apply the correct tweaks to their partial signature.</ref> from the\n<tt>KeyAgg</tt> algorithm. This key may or may not appear (as x-only) in the Taproot output key, the internal key, or\nin a script. It may instead be a parent public key from which the Taproot output key, internal key, or keys in a script\nwere derived.\n| A list of the compressed public keys of the participants in the MuSig2 aggregate key in the order\nrequired for aggregation. If sorting was done, then the keys must be in the sorted order.\n|-\n| rowspan=\"2\"|MuSig2 Public Nonce\n| rowspan=\"2\"|<tt>PSBT_IN_MUSIG2_PUB_NONCE = 0x1b</tt>\n| <tt><33 byte participant pubkey (compressed)> <33 byte aggregate pubkey (compressed)> <32 byte hash or omitted></tt>\n| <tt><66 byte public nonce></tt>\n| rowspan=\"2\"|\n| rowspan=\"2\"|\n| rowspan=\"2\"| 0, 2\n|-\n| The compressed public key of the participant providing this nonce, followed by the compressed aggregate public\nkey the participant is providing the nonce for, followed by the [[bip-0341.mediawiki|BIP 341]] tapleaf hash of\nthe Taproot leaf script that will be signed. If the aggregate key is the Taproot internal key or the\nTaproot output key, then the tapleaf hash must be omitted. The compressed participant public key must be\nthe Taproot output key or found in a script. It is not the internal key nor the aggregate public key that\nit was derived from, if it was derived from an aggregate key.\n| The public nonce produced by the <tt>NonceGen</tt> algorithm.\n|-\n| rowspan=\"2\"|MuSig2 Participant Partial Signature\n| rowspan=\"2\"|<tt>PSBT_IN_MUSIG2_PARTIAL_SIG = 0x1c</tt>\n| <tt><33 byte participant pubkey (compressed)> <33 byte aggregate pubkey (compressed)> <32 byte hash or omitted></tt>\n| <tt><32 byte partial signature></tt>\n| rowspan=\"2\"|\n| rowspan=\"2\"|\n| rowspan=\"2\"| 0, 2\n|-\n| The compressed public key of the participant providing this partial signature, followed by the\ncompressed aggregate public key the participant is providing the signature for, followed by the [[bip-0341.mediawiki|BIP 341]] tapleaf hash\nof the Taproot leaf script that will be signed. If the aggregate key is the Taproot internal key or\nthe Taproot output key, then the tapleaf hash must be omitted. Note that the compressed participant public key must be\nthe Taproot output key or found in a script. It is not the internal key nor the aggregate public key that\nit was derived from, if it was derived from an aggregate key.\n| The partial signature produced by the <tt>Sign</tt> algorithm.\n|}\n\nThe new per-output types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><valuedata></tt>\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| rowspan=\"2\"|MuSig2 Participant Public Keys\n| rowspan=\"2\"|<tt>PSBT_OUT_MUSIG2_PARTICIPANT_PUBKEYS = 0x08</tt>\n| <tt><33 byte aggregate pubkey (compressed)></tt>\n| <tt><33 byte participant pubkey (compressed)>*</tt>\n| rowspan=\"2\"|\n| rowspan=\"2\"|\n| rowspan=\"2\"|0, 2\n|-\n| The MuSig2 compressed aggregate public key from the <tt>KeyAgg</tt> algorithm. This key may or may not\nappear (as x-only) in the Taproot output key, the internal key, or in a script. It may instead be a parent\npublic key from which the Taproot output key, internal key, or keys in a script were derived.\n| A list of the compressed public keys of the participants in the MuSig2 aggregate key in the order\nrequired for aggregation. If sorting was done, then the keys must be in the sorted order.\n|}\n\n==Roles==\n\n===Updater===\n\nWhen an updater observes a Taproot output which involves a MuSig2 aggregate public key that it is\naware of, it can add a <tt>PSBT_IN_MUSIG2_PARTICIPANT_PUBKEYS</tt> field containing the public keys\nof the participants. This aggregate public key may be directly in the script, the Taproot internal\nkey, the Taproot output key, or a public key from which the key in the script was derived from.\n\nAn aggregate public key that appears directly in the script or internal key may be from the result\nof deriving child pubkeys from participant xpubs. If the updater has this derivation information, it\nshould also add <tt>PSBT_IN_TAP_BIP32_DERIVATION</tt> for each participant public key.\n\nIf the public key found was derived from an aggregate public key, then all MuSig2 PSBT fields for\nthat public key should contain the aggregate public key rather than the found pubkey itself. The\nupdater should also add <tt>PSBT_IN_TAP_BIP32_DERIVATION</tt> that contains the derivation path used\nto derive the found pubkey from the aggregate pubkey.\nDerivation from the aggregate pubkey can be assumed to follow [[bip-0328.mediawiki|BIP 328]]\nif there is no <tt>PSBT_GLOBAL_XPUB</tt> that specifies the synthetic xpub for the aggregate\npublic key.\n\nUpdaters should add <tt>PSBT_OUT_MUSIG2_PARTICIPANT_PUBKEYS</tt> and\n<tt>PSBT_OUT_TAP_BIP32_DERIVATION</tt> similarly to inputs to aid in change detection.\n\n===Signer===\n\nTo determine whether a signer is a participant in the MuSig2 aggregate key, the signer should first\nlook at all <tt>PSBT_IN_MUSIG2_PARTICIPANT_PUBKEYS</tt> and see if any key which it knows the\nprivate key for appears as a participant in any aggregate pubkey. Signers should also check whether\nany of the keys in <tt>PSBT_IN_TAP_BIP32_DERIVATION</tt> belong to it, and if any of those keys\nappear in as a participant in <tt>PSBT_IN_MUSIG2_PARTICIPANT_PUBKEYS</tt>.\n\nFor each aggregate public key that the signer is a participant of that it wants\nto produce a signature for, if the signer does not find an existing\n<tt>PSBT_IN_MUSIG2_PUB_NONCE</tt> field for its key, then it should add one using\nthe <tt>NonceGen</tt> algorithm (or one of its variations) to produce a public\nnonce that is added in a <tt>PSBT_IN_MUSIG2_PUB_NONCE</tt> field. However\nsigners must keep in mind that '''improper nonce usage can compromise private\nkeys.''' Please see [[bip-0327.mediawiki|BIP 327]] for best practices on nonce generation and usage.\n\nOnce all signers have added their <tt>PSBT_IN_MUSIG2_PUB_NONCE</tt> fields, each signer will perform\nthe <tt>NonceAgg</tt> algorithm followed by the <tt>Sign</tt> algorithm in order to produce the\npartial signature for their key. The result will be added to the PSBT in a\n<tt>PSBT_IN_MUSIG2_PARTIAL_SIG</tt> field.\n\nSigners must remember to apply any relevant tweaks such as a tweak that is the result of performing\nBIP 32 unhardened derivation with the aggregate public key as the parent key.\n\nIf all other signers have provided a <tt>PSBT_IN_MUSIG2_PARTIAL_SIG</tt>, then the final signer may\nperform the <tt>PartialSigAgg</tt> algorithm and produce a [[bip-0340.mediawiki|BIP 340]] compatible signature that can be\nplaced into a <tt>PSBT_IN_TAP_KEY_SIG</tt> or a <tt>PSBT_IN_TAP_SCRIPT_SIG</tt>.\n\n===Finalizer===\n\nA finalizer may perform the same <tt>PartialSigAgg</tt> step as the final signer if it has not\nalready been done.\n\nOtherwise, the resulting signature is a [[bip-0340.mediawiki|BIP 340]] compatible signature and finalizers should treat it\nas such.\n\n==Backwards Compatibility==\n\nThese are simply new fields added to the existing PSBT format. Because PSBT is designed to be\nextensible, old software will ignore the new fields.\n\nReusing <tt>PSBT_IN_TAP_BIP32_DERIVATION</tt> to provide derivation paths for participant public\nkeys may cause software unaware of MuSig2 to produce a signature for that public key. This is still\nsafe. If that public key does not directly appear in the leaf script that was signed, then the\nsignature produced will not be useful and so cannot be replayed. If the public key does directly\nappear in the leaf script, then the signer will have validated the script as if it did not involve a\nMuSig2 and will have found it acceptable in order for it to have produced a signature. In either\ncase, producing a signature does not give rise to the possibility of losing funds.\n\n==Test Vectors==\n\nThe following are valid PSBTs\n\nAll of the following test cases use the aggregate pubkey <tt>030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4</tt>\nwhich has the following participant keys:\n\n# <tt>02346B99593357107C9D3459E9DEBA8D3EAF44E6636C85C7F853EB90BA52E8CD00</tt>, <tt>L2XJhGmS9rkNwzn1eFJVD5ydKpA5K5p54uk9qqWpURj85VkEPuNE</tt>, <tt>cStJABmHavSe7SFH2f7caQUgx3TUyXum8wtcxFyKyYP8LEqnMiEh</tt>\n# <tt>024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c</tt>, <tt>L19kEzCkrce5E3v7CWKn9pTceVzFwwdorjNXfqtUc5nKLXz4qXSX</tt>, <tt>cRWjhuCcHgLLPVPNav8uX8xgGjHfcPjVvmWznGLz7CSKbGzmfvRQ</tt>\n# <tt>02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9</tt>, <tt>KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgd9M7rFU74sHUHy8S</tt>, <tt>cMahea7zqjxrtgAbB7LSGbcQUr1uX1ojuat9jZodMN87KcLPVfXz</tt>\n\n* Case: Spend of a Taproot output where the output key is a MuSig2 Aggregate Pubkey\n** With participant pubkeys only\n*** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f90000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5AAA=</pre>\n** With all pubnonces\n*** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44202529b19d7879ccc04c915487f5f1341bc6858b0bc74e5036c643d37b53a4371b503b7f8afe3263fcb3ef2454fe16f3a6759c5600c78e637b8dfa0d83e8552882056431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44203a81d973499e74f82d2b5ab13f1e69e9e11a5fdb40f5466ef672e6e4ceba0be7903499593767150394eece384d051c45b615c52dbe1c8eb3610d7b344b43b7dad6d431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d442033949dbff31b9d50251d8821e66cc5c97b7e3afd7d95bfdc77500fda8947f3ae0023f20e4f0bf0b76f0d40cd3abfe7ce373d6685bbd77b5fa28e7f49fb429d189b00000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5QxsCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RCAlKbGdeHnMwEyRVIf18TQbxoWLC8dOUDbGQ9N7U6Q3G1A7f4r+MmP8s+8kVP4W86Z1nFYAx45je436DYPoVSiCBWQxsCT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RCA6gdlzSZ50+C0rWrE/Hmnp4Rpf20D1Rm72cubkzroL55A0mVk3ZxUDlO7OOE0FHEW2FcUtvhyOs2ENezRLQ7fa1tQxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RCAzlJ2/8xudUCUdiCHmbMXJe346/X2Vv9x3UA/aiUfzrgAj8g5PC/C3bw1AzTq/5843PWaFu9d7X6KOf0n7Qp0YmwAAA=</pre>\n** With all partial signatures\n*** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44202529b19d7879ccc04c915487f5f1341bc6858b0bc74e5036c643d37b53a4371b503b7f8afe3263fcb3ef2454fe16f3a6759c5600c78e637b8dfa0d83e8552882056431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44203a81d973499e74f82d2b5ab13f1e69e9e11a5fdb40f5466ef672e6e4ceba0be7903499593767150394eece384d051c45b615c52dbe1c8eb3610d7b344b43b7dad6d431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d442033949dbff31b9d50251d8821e66cc5c97b7e3afd7d95bfdc77500fda8947f3ae0023f20e4f0bf0b76f0d40cd3abfe7ce373d6685bbd77b5fa28e7f49fb429d189b0431c02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4200e57ca4ca0de1a3116d3fd6baf19d38572e47e8ff024e7efc39512751e54ed31431c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4207254079cab166b0d50b54283fccb4aea15f776747a5d2a53d7da06239340dbcc431c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42001245e8861e62ac5bfc0008418fd057ce6b03c17b1d6b5c6980413c5c4e358970000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5QxsCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RCAlKbGdeHnMwEyRVIf18TQbxoWLC8dOUDbGQ9N7U6Q3G1A7f4r+MmP8s+8kVP4W86Z1nFYAx45je436DYPoVSiCBWQxsCT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RCA6gdlzSZ50+C0rWrE/Hmnp4Rpf20D1Rm72cubkzroL55A0mVk3ZxUDlO7OOE0FHEW2FcUtvhyOs2ENezRLQ7fa1tQxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RCAzlJ2/8xudUCUdiCHmbMXJe346/X2Vv9x3UA/aiUfzrgAj8g5PC/C3bw1AzTq/5843PWaFu9d7X6KOf0n7Qp0YmwQxwCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QgDlfKTKDeGjEW0/1rrxnThXLkfo/wJOfvw5USdR5U7TFDHAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1CByVAecqxZrDVC1QoP8y0rqFfd2dHpdKlPX2gYjk0DbzEMcAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5AwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUIAEkXohh5irFv8AAhBj9BXzmsDwXsda1xpgEE8XE41iXAAA=</pre>\n* Case: Spend of a Taproot output where the internal key is a MuSig2 Aggregate Pubkey\n** With participant pubkeys only\n*** Bytes in Hex: <pre>70736274ff01005202000000015818a9cd644b369c306c7fb191ec014ff625e63c283f00f9d17a959fefa3e8f60000000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251202967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a3494221160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655920117200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f90000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAVgYqc1kSzacMGx/sZHsAU/2JeY8KD8A+dF6lZ/vo+j2AAAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSARcgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QiGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkAAA==</pre>\n** With all pubnonces\n*** Bytes in Hex: <pre>70736274ff01005202000000015818a9cd644b369c306c7fb191ec014ff625e63c283f00f9d17a959fefa3e8f60000000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251202967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a3494221160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655920117200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349424203cc17485ca01c2ebb0eba1c80b3eadaf5ee9cc14629fa4f1071d19820e2d07fcc02adfcad45a68cfb67759c9849cdd579639e4d1867272b991a0363d1ca76283efc431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349424202343bb8359c434f5f6a9d6b46f7573258fbfbb561bb5212cbf5850a82a9a02f7e0246e83221664427aca6d13c10809a2cb4b54dae9a7b2f5ab764213dd479a6a942431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a3494242039dee4258b8dfe34460086ff1703209e478437c6ab0f598a2e6e809fd30a9ff3a03e06b4e04ec4de4f757c84d51acdaf6cb1ef4bccbfd8103703bc01a845dcf33650000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAVgYqc1kSzacMGx/sZHsAU/2JeY8KD8A+dF6lZ/vo+j2AAAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSARcgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QiGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvlDGwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMpZ9LQIKl5XacrUb5PP8oluw5X6RxbPnqBq/pyMqNJQkIDzBdIXKAcLrsOuhyAs+ra9e6cwUYp+k8QcdGYIOLQf8wCrfytRaaM+2d1nJhJzdV5Y55NGGcnK5kaA2PRynYoPvxDGwJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMpZ9LQIKl5XacrUb5PP8oluw5X6RxbPnqBq/pyMqNJQkICNDu4NZxDT19qnWtG91cyWPv7tWG7UhLL9YUKgqmgL34CRugyIWZEJ6ym0TwQgJostLVNrpp7L1q3ZCE91HmmqUJDGwL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QMpZ9LQIKl5XacrUb5PP8oluw5X6RxbPnqBq/pyMqNJQkIDne5CWLjf40RgCG/xcDIJ5HhDfGqw9Zii5ugJ/TCp/zoD4GtOBOxN5PdXyE1RrNr2yx70vMv9gQNwO8AahF3PM2UAAA==</pre>\n** With all partial signatures\n*** Bytes in Hex: <pre>70736274ff01005202000000015818a9cd644b369c306c7fb191ec014ff625e63c283f00f9d17a959fefa3e8f60000000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251202967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349420113402e89a7bdf9085c6438d15ddf1a86772a65222244276e9302ffdd9fa93b1c20ae58a6b11a6be98b151d8582daa84c10017c994d9235b13ec518a94782c67c40e221160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655920117200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349424203cc17485ca01c2ebb0eba1c80b3eadaf5ee9cc14629fa4f1071d19820e2d07fcc02adfcad45a68cfb67759c9849cdd579639e4d1867272b991a0363d1ca76283efc431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349424202343bb8359c434f5f6a9d6b46f7573258fbfbb561bb5212cbf5850a82a9a02f7e0246e83221664427aca6d13c10809a2cb4b54dae9a7b2f5ab764213dd479a6a942431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a3494242039dee4258b8dfe34460086ff1703209e478437c6ab0f598a2e6e809fd30a9ff3a03e06b4e04ec4de4f757c84d51acdaf6cb1ef4bccbfd8103703bc01a845dcf3365431c02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a3494220109ad32155722014ddca21ae3b8d3c3a93a6d0ab5c7e19d0c693d565c47c1626431c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349422035d5eecc404fa2a63644f30cf8af43fdbd829e5cd9c74707ca9b33a9134c756e431c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9032967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a3494220b9c855defd44676ff3fc5342adbc90c2dec15624eab55b1ff29765315603db6e0000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAVgYqc1kSzacMGx/sZHsAU/2JeY8KD8A+dF6lZ/vo+j2AAAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIBE0Auiae9+QhcZDjRXd8ahncqZSIiRCdukwL/3Z+pOxwgrlimsRpr6YsVHYWC2qhMEAF8mU2SNbE+xRipR4LGfEDiIRYLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1AUAJoDdbiEWNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQAFAFgLCIchFk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsBQDDJJqCIRb5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QUAfdZVkgEXIAtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5QxsCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUJCA8wXSFygHC67DrocgLPq2vXunMFGKfpPEHHRmCDi0H/MAq38rUWmjPtndZyYSc3VeWOeTRhnJyuZGgNj0cp2KD78QxsCT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwDKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUJCAjQ7uDWcQ09fap1rRvdXMlj7+7Vhu1ISy/WFCoKpoC9+AkboMiFmRCesptE8EICaLLS1Ta6aey9at2QhPdR5pqlCQxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUJCA53uQli43+NEYAhv8XAyCeR4Q3xqsPWYouboCf0wqf86A+BrTgTsTeT3V8hNUaza9sse9LzL/YEDcDvAGoRdzzNlQxwCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIgEJrTIVVyIBTdyiGuO408OpOm0KtcfhnQxpPVZcR8FiZDHAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMpZ9LQIKl5XacrUb5PP8oluw5X6RxbPnqBq/pyMqNJQiA11e7MQE+ipjZE8wz4r0P9vYKeXNnHRwfKmzOpE0x1bkMcAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5Ayln0tAgqXldpytRvk8/yiW7DlfpHFs+eoGr+nIyo0lCILnIVd79RGdv8/xTQq28kMLewVYk6rVbH/KXZTFWA9tuAAA=</pre>\n* Case: Spend of a Taproot output where a key in a script is a MuSig2 Aggregate Pubkey\n** With participant pubkeys only\n*** Bytes in Hex: <pre>70736274ff01005202000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f5050000000022512056bdb481b4d67103f6d5dea8a9aafd3684a6a79b4a2e247799db8d4b1a86e1f82215c050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac023200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4acc021160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c2680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd002501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c2501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2cc3249a82211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f92501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c7dd6559201172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f90000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgVr20gbTWcQP21d6oqar9NoSmp5tKLiR3mduNSxqG4fgiFcBQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wCMgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SswCEWC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QlAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosJoDdbiEWNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQAlAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwlAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPoswySagiEWUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsAFAHxGHl0hFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5JQGxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LH3WVZIBFyBQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAEYILEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5AAA=</pre>\n** With all pubnonces\n*** Bytes in Hex: <pre>70736274ff01005202000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f5050000000022512056bdb481b4d67103f6d5dea8a9aafd3684a6a79b4a2e247799db8d4b1a86e1f82215c050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac023200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4acc021160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c2680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd002501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c2501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2cc3249a82211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f92501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c7dd6559201172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9631b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202d99e7c8719b3ad08566b0cb9c7d5eda3127c9e8119185b7d584d939b173915f50240df22aab78332cf0f25329d103dc0d2060a03742e9448026e736bcf3db98f3c631b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202e702a7075226a0d9313a77e6db10b8e742d4cffdc948a0edc9b856c13b412e5403386a0298f308fb3099155772e45b2aa8e770f435bedfe2041d1cc4d3d37538c6631b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202b1d912d45d753ceed0954417ba982656d2aec53f8638bd6f297dae3b743d71b0032f424537d599d28f14d59fe0a11b82fea2aa226a2980ffdacad5fdab20f806830000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgVr20gbTWcQP21d6oqar9NoSmp5tKLiR3mduNSxqG4fgiFcBQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wCMgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SswCEWC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QlAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosJoDdbiEWNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQAlAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwlAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPoswySagiEWUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsAFAHxGHl0hFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5JQGxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LH3WVZIBFyBQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAEYILEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5YxsCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LEIC2Z58hxmzrQhWawy5x9XtoxJ8noEZGFt9WE2Tmxc5FfUCQN8iqreDMs8PJTKdED3A0gYKA3QulEgCbnNrzz25jzxjGwJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosQgLnAqcHUiag2TE6d+bbELjnQtTP/clIoO3JuFbBO0EuVAM4agKY8wj7MJkVV3LkWyqo53D0Nb7f4gQdHMTT03U4xmMbAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5AwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixCArHZEtRddTzu0JVEF7qYJlbSrsU/hji9byl9rjt0PXGwAy9CRTfVmdKPFNWf4KEbgv6iqiJqKYD/2srV/asg+AaDAAA=</pre>\n** With all partial signatures\n*** Bytes in Hex: <pre>70736274ff01005202000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f5050000000022512056bdb481b4d67103f6d5dea8a9aafd3684a6a79b4a2e247799db8d4b1a86e1f841140b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c402667d52f6cc07fe06db31b1a5f7efe81903f9cbeef40fa64dafca01d2cb1d56403bc7504898e55872557d16d2ca79bc55fef10973841a33ec032d884758c9fe62215c050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac023200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4acc021160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c2680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd002501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c2501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2cc3249a82211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f92501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c7dd6559201172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9631b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202d99e7c8719b3ad08566b0cb9c7d5eda3127c9e8119185b7d584d939b173915f50240df22aab78332cf0f25329d103dc0d2060a03742e9448026e736bcf3db98f3c631b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202e702a7075226a0d9313a77e6db10b8e742d4cffdc948a0edc9b856c13b412e5403386a0298f308fb3099155772e45b2aa8e770f435bedfe2041d1cc4d3d37538c6631b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202b1d912d45d753ceed0954417ba982656d2aec53f8638bd6f297dae3b743d71b0032f424537d599d28f14d59fe0a11b82fea2aa226a2980ffdacad5fdab20f80683631c02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20ada78b70af8cffa4c50863aef515ac58a327cd58c55bad29a162e67d9c413322631c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c201fa8b7e6741c21eb8d9b0f65269df9e423369fc390ad2e918420c57feb2a1b61631c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20366c31ad65e533f6d2b45e5910f3f587543f8061918167bf5a818b13be5792a40000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgVr20gbTWcQP21d6oqar9NoSmp5tKLiR3mduNSxqG4fhBFAtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixAJmfVL2zAf+BtsxsaX37+gZA/nL7vQPpk2vygHSyx1WQDvHUEiY5VhyVX0W0sp5vFX+8QlzhBoz7AMtiEdYyf5iIVwFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAIyALWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1KzAIRYLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1CUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNACUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixYCwiHIRZPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLCUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+izDJJqCIRZQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAUAfEYeXSEW+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvklAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosfdZVkgEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARggsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwiGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvljGwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosQgLZnnyHGbOtCFZrDLnH1e2jEnyegRkYW31YTZObFzkV9QJA3yKqt4Myzw8lMp0QPcDSBgoDdC6USAJuc2vPPbmPPGMbAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixCAucCpwdSJqDZMTp35tsQuOdC1M/9yUig7cm4VsE7QS5UAzhqApjzCPswmRVXcuRbKqjncPQ1vt/iBB0cxNPTdTjGYxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LEICsdkS1F11PO7QlUQXupgmVtKuxT+GOL1vKX2uO3Q9cbADL0JFN9WZ0o8U1Z/goRuC/qKqImopgP/aytX9qyD4BoNjHAI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosIK2ni3CvjP+kxQhjrvUVrFijJ81YxVutKaFi5n2cQTMiYxwCT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LCAfqLfmdBwh642bD2UmnfnkIzafw5CtLpGEIMV/6yobYWMcAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5AwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwgNmwxrWXlM/bStF5ZEPP1h1Q/gGGRgWe/WoGLE75XkqQAAA==</pre>\n* Case: Spend of a Taproot output where the internal key is derived from a MuSig2 Aggregate Pubkey\n** With participant pubkeys only\n*** Bytes in Hex: <pre>70736274ff01005202000000012589e7767958ba154f9018cccf0dedea6147bb60cd1a194b6e3590a9965690d60100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f50500000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa42116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a8221168dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f0d002680dd6e01000000020000002116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655920117208dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f90000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAASWJ53Z5WLoVT5AYzM8N7ephR7tgzRoZS241kKmWVpDWAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEg0LImxlmfJzh034/mhKtsMCgIG+6KLL7TGhNvWGX2z6QhFjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0ABQBYCwiHIRZPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAUAwySagiEWjdlquFiyWcUYIYwBSkbrTmrImeUcZ173dPu2ioeZzi8NACaA3W4BAAAAAgAAACEW+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkFAH3WVZIBFyCN2Wq4WLJZxRghjAFKRutOasiZ5RxnXvd0+7aKh5nOLyIaAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUYwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QAA</pre>\n** With all pubnonces\n*** Bytes in Hex: <pre>70736274ff01005202000000012589e7767958ba154f9018cccf0dedea6147bb60cd1a194b6e3590a9965690d60100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f50500000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa42116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a8221168dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f0d002680dd6e01000000020000002116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655920117208dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd0002d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa442024eefc9fdd12be74746485c678b8268949cc9236e9fce82241395523af04262bf038c276e832aad4bfb9e90485162f574c8b2619df5bd19db8ffa2eb0059493bf1b431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa44203a324a3f4221bfab2b6fa0786a7048f3345ce344f1458e151ba187b59aab498cb02a3638259ba4ccc46fe79d8d79a4d9e704ec0f7701b5e664d4d8733838af49196431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f902d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa44202c12eb4ef8760321c072a51d8fb65c34ee8b452a14818557f61df061285a5809103a08e41b262942c6e5932fd1fb5d99236897989f6e912dc21476d2771874114930000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAASWJ53Z5WLoVT5AYzM8N7ephR7tgzRoZS241kKmWVpDWAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEg0LImxlmfJzh034/mhKtsMCgIG+6KLL7TGhNvWGX2z6QhFjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0ABQBYCwiHIRZPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAUAwySagiEWjdlquFiyWcUYIYwBSkbrTmrImeUcZ173dPu2ioeZzi8NACaA3W4BAAAAAgAAACEW+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkFAH3WVZIBFyCN2Wq4WLJZxRghjAFKRutOasiZ5RxnXvd0+7aKh5nOLyIaAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUYwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+UMbAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAtCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+kQgJO78n90SvnR0ZIXGeLgmiUnMkjbp/OgiQTlVI68EJivwOMJ26DKq1L+56QSFFi9XTIsmGd9b0Z24/6LrAFlJO/G0MbAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAtCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+kQgOjJKP0Ihv6srb6B4anBI8zRc40TxRY4VG6GHtZqrSYywKjY4JZukzMRv552NeaTZ5wTsD3cBteZk1NhzODivSRlkMbAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5AtCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+kQgLBLrTvh2AyHAcqUdj7ZcNO6LRSoUgYVX9h3wYShaWAkQOgjkGyYpQsblky/R+12ZI2iXmJ9ukS3CFHbSdxh0EUkwAA</pre>\n** With all partial signatures\n*** Bytes in Hex: <pre>70736274ff01005202000000012589e7767958ba154f9018cccf0dedea6147bb60cd1a194b6e3590a9965690d60100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f50500000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa40113409e39897ac2ffe27525dc460f8584fddd11fe9a97ce2e50c1489b8c1a4e92fcc07e48db63a1a4ccb9d297537d0c038838378bbf278de7aa1a128995d1625cc5cd2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a8221168dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f0d002680dd6e01000000020000002116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655920117208dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd0002d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa442024eefc9fdd12be74746485c678b8268949cc9236e9fce82241395523af04262bf038c276e832aad4bfb9e90485162f574c8b2619df5bd19db8ffa2eb0059493bf1b431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa44203a324a3f4221bfab2b6fa0786a7048f3345ce344f1458e151ba187b59aab498cb02a3638259ba4ccc46fe79d8d79a4d9e704ec0f7701b5e664d4d8733838af49196431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f902d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa44202c12eb4ef8760321c072a51d8fb65c34ee8b452a14818557f61df061285a5809103a08e41b262942c6e5932fd1fb5d99236897989f6e912dc21476d277187411493431c02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd0002d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa420657db286be14e80ece0dd84b4d17c4dc414c3e56bc8cef0827b061b4dd2c8f43431c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa420e78552fb4ce9b2d00e1ed0e2cb98e087199127477e8f1a1c681a00b9c4ce7098431c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f902d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa420cbcc95786a1c674d48d8ac52e322dd7c6eabac3bfc4be79b750de28df82e2f730000</pre>\n*** Base64 String: <pre>cHNidP8BAFICAAAAASWJ53Z5WLoVT5AYzM8N7ephR7tgzRoZS241kKmWVpDWAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEg0LImxlmfJzh034/mhKtsMCgIG+6KLL7TGhNvWGX2z6QBE0CeOYl6wv/idSXcRg+FhP3dEf6al84uUMFIm4waTpL8wH5I22OhpMy50pdTfQwDiDg3i78njeeqGhKJldFiXMXNIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFo3ZarhYslnFGCGMAUpG605qyJnlHGde93T7toqHmc4vDQAmgN1uAQAAAAIAAAAhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSARcgjdlquFiyWcUYIYwBSkbrTmrImeUcZ173dPu2ioeZzi8iGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvlDGwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAALQsibGWZ8nOHTfj+aEq2wwKAgb7oosvtMaE29YZfbPpEICTu/J/dEr50dGSFxni4JolJzJI26fzoIkE5VSOvBCYr8DjCdugyqtS/uekEhRYvV0yLJhnfW9GduP+i6wBZSTvxtDGwJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLALQsibGWZ8nOHTfj+aEq2wwKAgb7oosvtMaE29YZfbPpEIDoySj9CIb+rK2+geGpwSPM0XONE8UWOFRuhh7Waq0mMsCo2OCWbpMzEb+edjXmk2ecE7A93AbXmZNTYczg4r0kZZDGwL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QLQsibGWZ8nOHTfj+aEq2wwKAgb7oosvtMaE29YZfbPpEICwS6074dgMhwHKlHY+2XDTui0UqFIGFV/Yd8GEoWlgJEDoI5BsmKULG5ZMv0ftdmSNol5ifbpEtwhR20ncYdBFJNDHAI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAALQsibGWZ8nOHTfj+aEq2wwKAgb7oosvtMaE29YZfbPpCBlfbKGvhToDs4N2EtNF8TcQUw+VryM7wgnsGG03SyPQ0McAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAtCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+kIOeFUvtM6bLQDh7Q4suY4IcZkSdHfo8aHGgaALnEznCYQxwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkC0LImxlmfJzh034/mhKtsMCgIG+6KLL7TGhNvWGX2z6Qgy8yVeGocZ01I2KxS4yLdfG6rrDv8S+ebdQ3ijfguL3MAAA==</pre>\n* Case: Receiving a Taproot output where the internal key is a MuSig2 Aggregate Pubkey\n** Bytes in Hex: <pre>70736274ff01007d02000000012589e7767958ba154f9018cccf0dedea6147bb60cd1a194b6e3590a9965690d60000000000fdffffff0280969800000000002251202967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349420fc0927c00000000160014349c5d330278c3002a64f597d2b01aa3dc1bd903000000000001007d02000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370000000000fdffffff02895c2b7d00000000160014cfd98ba1027ea4ed4bd2ae1b348b6156a015037500e1f50500000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa4e100000001011f895c2b7d00000000160014cfd98ba1027ea4ed4bd2ae1b348b6156a0150375220602a66650f08bffa4f089eb22edcdbe7616645ff6cd180a36484d4bc81054595b7b18bfff44a3540000800100008000000080010000008a020000000105200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421070b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2107346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721074fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822107f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655922208030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f900220203be4ae53d37cc075f40b30d6da4729d40adeeb983533af1616192bc76d5b2612a18bfff44a3540000800100008000000080010000008d02000000</pre>\n** Base64 String: <pre>cHNidP8BAH0CAAAAASWJ53Z5WLoVT5AYzM8N7ephR7tgzRoZS241kKmWVpDWAAAAAAD9////AoCWmAAAAAAAIlEgKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIPwJJ8AAAAABYAFDScXTMCeMMAKmT1l9KwGqPcG9kDAAAAAAABAH0CAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AAAAAAD9////AolcK30AAAAAFgAUz9mLoQJ+pO1L0q4bNIthVqAVA3UA4fUFAAAAACJRINCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+k4QAAAAEBH4lcK30AAAAAFgAUz9mLoQJ+pO1L0q4bNIthVqAVA3UiBgKmZlDwi/+k8InrIu3NvnYWZF/2zRgKNkhNS8gQVFlbexi//0SjVAAAgAEAAIAAAACAAQAAAIoCAAAAAQUgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhBwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIQc0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEHT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhB/kwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIggDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5ACICA75K5T03zAdfQLMNbaRynUCt7rmDUzrxYWGSvHbVsmEqGL//RKNUAACAAQAAgAAAAIABAAAAjQIAAAA=</pre>\n* Case: Receiving a Taproot output where the internal key is derived from a MuSig2 Aggregate Pubkey\n** Bytes in Hex: <pre>70736274ff01007d0200000001f835a5ec8e4008f96f17407e13f0c34912c39d27620800fae02baf86b8a78e760000000000fdffffff028096980000000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa49e405d05000000001600149f94ac2db46420b95dc0db1cc8f4bec0bb9234d8000000000001005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd0000000001011f18ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd220603293c8d8dc47b712d7c13a5d0536b7f2e3193267e60f7e66e563939dbe507479c18bfff44a35400008001000080000000800000000097010000000105208dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f2107346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721074fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a8221078dd96ab858b259c518218c014a46eb4e6ac899e51c675ef774fbb68a8799ce2f0d002680dd6e01000000020000002107f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd655922208030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f900220202ce69de967622b1c82eb0a0f80ceb0573a0f768b02fdb047b13c171e79174fcce18bfff44a3540000800100008000000080010000008e02000000</pre>\n** Base64 String: <pre>cHNidP8BAH0CAAAAAfg1peyOQAj5bxdAfhPww0kSw50nYggA+uArr4a4p452AAAAAAD9////AoCWmAAAAAAAIlEg0LImxlmfJzh034/mhKtsMCgIG+6KLL7TGhNvWGX2z6SeQF0FAAAAABYAFJ+UrC20ZCC5XcDbHMj0vsC7kjTYAAAAAAABAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAQEfGN31BQAAAAAWABTJEj4G6NfwlmxdHND5MwAtTrdXzSIGAyk8jY3Ee3EtfBOl0FNrfy4xkyZ+YPfmblY5OdvlB0ecGL//RKNUAACAAQAAgAAAAIAAAAAAlwEAAAABBSCN2Wq4WLJZxRghjAFKRutOasiZ5RxnXvd0+7aKh5nOLyEHNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQAFAFgLCIchB0+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsBQDDJJqCIQeN2Wq4WLJZxRghjAFKRutOasiZ5RxnXvd0+7aKh5nOLw0AJoDdbgEAAAACAAAAIQf5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QUAfdZVkiIIAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUYwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QAiAgLOad6WdiKxyC6woPgM6wVzoPdosC/bBHsTwXHnkXT8zhi//0SjVAAAgAEAAIAAAACAAQAAAI4CAAAA</pre>\n\nThe following are invalid PSBTs\n\n* Case: PSBT with x-only aggregate pubkey in input participant pubkeys keydata\n** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592211a0b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f90000\n</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIRoLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkAAA==</pre>\n* Case: PSBT with an x-only input participant pubkey\n** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d462346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f90000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RiNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkAAA==</pre>\n* Case: PSBT with x-only aggregate pubkey in output participant pubkeys keydata\n** Bytes in Hex: <pre>70736274ff01007d02000000012589e7767958ba154f9018cccf0dedea6147bb60cd1a194b6e3590a9965690d60000000000fdffffff0280969800000000002251202967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349420fc0927c00000000160014349c5d330278c3002a64f597d2b01aa3dc1bd903000000000001007d02000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370000000000fdffffff02895c2b7d00000000160014cfd98ba1027ea4ed4bd2ae1b348b6156a015037500e1f50500000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa4e100000001011f895c2b7d00000000160014cfd98ba1027ea4ed4bd2ae1b348b6156a0150375220602a66650f08bffa4f089eb22edcdbe7616645ff6cd180a36484d4bc81054595b7b18bfff44a3540000800100008000000080010000008a020000000105200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421070b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2107346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721074fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822107f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd6559221080b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f900220203be4ae53d37cc075f40b30d6da4729d40adeeb983533af1616192bc76d5b2612a18bfff44a3540000800100008000000080010000008d02000000\n</pre>\n** Base64 String: <pre>cHNidP8BAH0CAAAAASWJ53Z5WLoVT5AYzM8N7ephR7tgzRoZS241kKmWVpDWAAAAAAD9////AoCWmAAAAAAAIlEgKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIPwJJ8AAAAABYAFDScXTMCeMMAKmT1l9KwGqPcG9kDAAAAAAABAH0CAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AAAAAAD9////AolcK30AAAAAFgAUz9mLoQJ+pO1L0q4bNIthVqAVA3UA4fUFAAAAACJRINCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+k4QAAAAEBH4lcK30AAAAAFgAUz9mLoQJ+pO1L0q4bNIthVqAVA3UiBgKmZlDwi/+k8InrIu3NvnYWZF/2zRgKNkhNS8gQVFlbexi//0SjVAAAgAEAAIAAAACAAQAAAIoCAAAAAQUgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhBwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIQc0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEHT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhB/kwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIQgLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkAIgIDvkrlPTfMB19Asw1tpHKdQK3uuYNTOvFhYZK8dtWyYSoYv/9Eo1QAAIABAACAAAAAgAEAAACNAgAAAA==</pre>\n* Case: PSBT with an x-only output participant pubkey\n** Bytes in Hex: <pre>70736274ff01007d02000000012589e7767958ba154f9018cccf0dedea6147bb60cd1a194b6e3590a9965690d60000000000fdffffff0280969800000000002251202967d2d020a9795da72b51be4f3fca25bb0e57e91c5b3e7a81abfa7232a349420fc0927c00000000160014349c5d330278c3002a64f597d2b01aa3dc1bd903000000000001007d02000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370000000000fdffffff02895c2b7d00000000160014cfd98ba1027ea4ed4bd2ae1b348b6156a015037500e1f50500000000225120d0b226c6599f273874df8fe684ab6c3028081bee8a2cbed31a136f5865f6cfa4e100000001011f895c2b7d00000000160014cfd98ba1027ea4ed4bd2ae1b348b6156a0150375220602a66650f08bffa4f089eb22edcdbe7616645ff6cd180a36484d4bc81054595b7b18bfff44a3540000800100008000000080010000008a020000000105200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421070b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2107346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721074fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822107f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd6559221080b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f900220203be4ae53d37cc075f40b30d6da4729d40adeeb983533af1616192bc76d5b2612a18bfff44a3540000800100008000000080010000008d02000000</pre>\n** Base64 String: <pre>cHNidP8BAH0CAAAAASWJ53Z5WLoVT5AYzM8N7ephR7tgzRoZS241kKmWVpDWAAAAAAD9////AoCWmAAAAAAAIlEgKWfS0CCpeV2nK1G+Tz/KJbsOV+kcWz56gav6cjKjSUIPwJJ8AAAAABYAFDScXTMCeMMAKmT1l9KwGqPcG9kDAAAAAAABAH0CAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AAAAAAD9////AolcK30AAAAAFgAUz9mLoQJ+pO1L0q4bNIthVqAVA3UA4fUFAAAAACJRINCyJsZZnyc4dN+P5oSrbDAoCBvuiiy+0xoTb1hl9s+k4QAAAAEBH4lcK30AAAAAFgAUz9mLoQJ+pO1L0q4bNIthVqAVA3UiBgKmZlDwi/+k8InrIu3NvnYWZF/2zRgKNkhNS8gQVFlbexi//0SjVAAAgAEAAIAAAACAAQAAAIoCAAAAAQUgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhBwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIQc0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEHT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhB/kwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIQgLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkAIgIDvkrlPTfMB19Asw1tpHKdQK3uuYNTOvFhYZK8dtWyYSoYv/9Eo1QAAIABAACAAAAAgAEAAACNAgAAAA==</pre>\n* Case: PSBT with x-only aggregate pubkey in public nonce keydata\n** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9421b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44202529b19d7879ccc04c915487f5f1341bc6858b0bc74e5036c643d37b53a4371b503b7f8afe3263fcb3ef2454fe16f3a6759c5600c78e637b8dfa0d83e8552882056431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44203a81d973499e74f82d2b5ab13f1e69e9e11a5fdb40f5466ef672e6e4ceba0be7903499593767150394eece384d051c45b615c52dbe1c8eb3610d7b344b43b7dad6d431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d442033949dbff31b9d50251d8821e66cc5c97b7e3afd7d95bfdc77500fda8947f3ae0023f20e4f0bf0b76f0d40cd3abfe7ce373d6685bbd77b5fa28e7f49fb429d189b00000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5QhsCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQALWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EICUpsZ14eczATJFUh/XxNBvGhYsLx05QNsZD03tTpDcbUDt/iv4yY/yz7yRU/hbzpnWcVgDHjmN7jfoNg+hVKIIFZDGwJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EIDqB2XNJnnT4LStasT8eaenhGl/bQPVGbvZy5uTOugvnkDSZWTdnFQOU7s44TQUcRbYVxS2+HI6zYQ17NEtDt9rW1DGwL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EIDOUnb/zG51QJR2IIeZsxcl7fjr9fZW/3HdQD9qJR/OuACPyDk8L8LdvDUDNOr/nzjc9ZoW713tfoo5/SftCnRibAAAA==</pre>\n* Case: PSBT with an x-only participant pubkey in public nonce keydata\n** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9421b346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44202529b19d7879ccc04c915487f5f1341bc6858b0bc74e5036c643d37b53a4371b503b7f8afe3263fcb3ef2454fe16f3a6759c5600c78e637b8dfa0d83e8552882056431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44203a81d973499e74f82d2b5ab13f1e69e9e11a5fdb40f5466ef672e6e4ceba0be7903499593767150394eece384d051c45b615c52dbe1c8eb3610d7b344b43b7dad6d431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d442033949dbff31b9d50251d8821e66cc5c97b7e3afd7d95bfdc77500fda8947f3ae0023f20e4f0bf0b76f0d40cd3abfe7ce373d6685bbd77b5fa28e7f49fb429d189b00000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5Qhs0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EICUpsZ14eczATJFUh/XxNBvGhYsLx05QNsZD03tTpDcbUDt/iv4yY/yz7yRU/hbzpnWcVgDHjmN7jfoNg+hVKIIFZDGwJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EIDqB2XNJnnT4LStasT8eaenhGl/bQPVGbvZy5uTOugvnkDSZWTdnFQOU7s44TQUcRbYVxS2+HI6zYQ17NEtDt9rW1DGwL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EIDOUnb/zG51QJR2IIeZsxcl7fjr9fZW/3HdQD9qJR/OuACPyDk8L8LdvDUDNOr/nzjc9ZoW713tfoo5/SftCnRibAAAA==</pre>\n* Case: PSBT with invalid public nonce valuedata length\n** Bytes in Hex: <pre>70736274ff01005202000000015686dff400165f4e040a5855f658093472c9bcf8108b272a5d31f181f7b4ffb10100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f505000000002251200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d421160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d405002680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000500580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c0500c3249a822116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f905007dd65592221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9431b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44102529b19d7879ccc04c915487f5f1341bc6858b0bc74e5036c643d37b53a4371b503b7f8afe3263fcb3ef2454fe16f3a6759c5600c78e637b8dfa0d83e85528820431b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d44203a81d973499e74f82d2b5ab13f1e69e9e11a5fdb40f5466ef672e6e4ceba0be7903499593767150394eece384d051c45b615c52dbe1c8eb3610d7b344b43b7dad6d431b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d442033949dbff31b9d50251d8821e66cc5c97b7e3afd7d95bfdc77500fda8947f3ae0023f20e4f0bf0b76f0d40cd3abfe7ce373d6685bbd77b5fa28e7f49fb429d189b00000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAVaG3/QAFl9OBApYVfZYCTRyybz4EIsnKl0x8YH3tP+xAQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9QhFgtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUBQAmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAUAWAsIhyEWT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwFAMMkmoIhFvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5BQB91lWSIhoDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RjAjRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAvkwigGSWMMQSTRPhfidUim1MchFg2+ZsIYB8RO84Db5QxsCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQADC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9RBAlKbGdeHnMwEyRVIf18TQbxoWLC8dOUDbGQ9N7U6Q3G1A7f4r+MmP8s+8kVP4W86Z1nFYAx45je436DYPoVSiCBDGwJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EIDqB2XNJnnT4LStasT8eaenhGl/bQPVGbvZy5uTOugvnkDSZWTdnFQOU7s44TQUcRbYVxS2+HI6zYQ17NEtDt9rW1DGwL5MIoBkljDEEk0T4X4nVIptTHIRYNvmbCGAfETvOA2+QMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1EIDOUnb/zG51QJR2IIeZsxcl7fjr9fZW/3HdQD9qJR/OuACPyDk8L8LdvDUDNOr/nzjc9ZoW713tfoo5/SftCnRibAAAA==</pre>\n* Case: PSBT with x-only aggregate pubkey in partial sig keydata\n** Bytes in Hex: <pre>70736274ff01005202000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f5050000000022512056bdb481b4d67103f6d5dea8a9aafd3684a6a79b4a2e247799db8d4b1a86e1f841140b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c402667d52f6cc07fe06db31b1a5f7efe81903f9cbeef40fa64dafca01d2cb1d56403bc7504898e55872557d16d2ca79bc55fef10973841a33ec032d884758c9fe62215c050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac023200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4acc021160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c2680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd002501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c2501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2cc3249a82211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f92501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c7dd6559201172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9631b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202d99e7c8719b3ad08566b0cb9c7d5eda3127c9e8119185b7d584d939b173915f50240df22aab78332cf0f25329d103dc0d2060a03742e9448026e736bcf3db98f3c631b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202e702a7075226a0d9313a77e6db10b8e742d4cffdc948a0edc9b856c13b412e5403386a0298f308fb3099155772e45b2aa8e770f435bedfe2041d1cc4d3d37538c6631b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202b1d912d45d753ceed0954417ba982656d2aec53f8638bd6f297dae3b743d71b0032f424537d599d28f14d59fe0a11b82fea2aa226a2980ffdacad5fdab20f80683621c02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd000b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20ada78b70af8cffa4c50863aef515ac58a327cd58c55bad29a162e67d9c413322631c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c201fa8b7e6741c21eb8d9b0f65269df9e423369fc390ad2e918420c57feb2a1b61631c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20366c31ad65e533f6d2b45e5910f3f587543f8061918167bf5a818b13be5792a40000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgVr20gbTWcQP21d6oqar9NoSmp5tKLiR3mduNSxqG4fhBFAtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixAJmfVL2zAf+BtsxsaX37+gZA/nL7vQPpk2vygHSyx1WQDvHUEiY5VhyVX0W0sp5vFX+8QlzhBoz7AMtiEdYyf5iIVwFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAIyALWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1KzAIRYLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1CUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNACUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixYCwiHIRZPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLCUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+izDJJqCIRZQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAUAfEYeXSEW+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvklAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosfdZVkgEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARggsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwiGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvljGwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosQgLZnnyHGbOtCFZrDLnH1e2jEnyegRkYW31YTZObFzkV9QJA3yKqt4Myzw8lMp0QPcDSBgoDdC6USAJuc2vPPbmPPGMbAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixCAucCpwdSJqDZMTp35tsQuOdC1M/9yUig7cm4VsE7QS5UAzhqApjzCPswmRVXcuRbKqjncPQ1vt/iBB0cxNPTdTjGYxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LEICsdkS1F11PO7QlUQXupgmVtKuxT+GOL1vKX2uO3Q9cbADL0JFN9WZ0o8U1Z/goRuC/qKqImopgP/aytX9qyD4BoNiHAI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwgraeLcK+M/6TFCGOu9RWsWKMnzVjFW60poWLmfZxBMyJjHAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosIB+ot+Z0HCHrjZsPZSad+eQjNp/DkK0ukYQgxX/rKhthYxwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LCA2bDGtZeUz9tK0XlkQ8/WHVD+AYZGBZ79agYsTvleSpAAA</pre>\n* Case: PSBT with an x-only participant pubkey in partial sig keydata\n** Bytes in Hex: <pre>70736274ff01005202000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f5050000000022512056bdb481b4d67103f6d5dea8a9aafd3684a6a79b4a2e247799db8d4b1a86e1f841140b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c402667d52f6cc07fe06db31b1a5f7efe81903f9cbeef40fa64dafca01d2cb1d56403bc7504898e55872557d16d2ca79bc55fef10973841a33ec032d884758c9fe62215c050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac023200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4acc021160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c2680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd002501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c2501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2cc3249a82211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f92501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c7dd6559201172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9631b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202d99e7c8719b3ad08566b0cb9c7d5eda3127c9e8119185b7d584d939b173915f50240df22aab78332cf0f25329d103dc0d2060a03742e9448026e736bcf3db98f3c631b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202e702a7075226a0d9313a77e6db10b8e742d4cffdc948a0edc9b856c13b412e5403386a0298f308fb3099155772e45b2aa8e770f435bedfe2041d1cc4d3d37538c6631b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202b1d912d45d753ceed0954417ba982656d2aec53f8638bd6f297dae3b743d71b0032f424537d599d28f14d59fe0a11b82fea2aa226a2980ffdacad5fdab20f80683621c346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20ada78b70af8cffa4c50863aef515ac58a327cd58c55bad29a162e67d9c413322631c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c201fa8b7e6741c21eb8d9b0f65269df9e423369fc390ad2e918420c57feb2a1b61631c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20366c31ad65e533f6d2b45e5910f3f587543f8061918167bf5a818b13be5792a40000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgVr20gbTWcQP21d6oqar9NoSmp5tKLiR3mduNSxqG4fhBFAtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixAJmfVL2zAf+BtsxsaX37+gZA/nL7vQPpk2vygHSyx1WQDvHUEiY5VhyVX0W0sp5vFX+8QlzhBoz7AMtiEdYyf5iIVwFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAIyALWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1KzAIRYLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1CUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNACUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixYCwiHIRZPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLCUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+izDJJqCIRZQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAUAfEYeXSEW+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvklAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosfdZVkgEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARggsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwiGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvljGwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosQgLZnnyHGbOtCFZrDLnH1e2jEnyegRkYW31YTZObFzkV9QJA3yKqt4Myzw8lMp0QPcDSBgoDdC6USAJuc2vPPbmPPGMbAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixCAucCpwdSJqDZMTp35tsQuOdC1M/9yUig7cm4VsE7QS5UAzhqApjzCPswmRVXcuRbKqjncPQ1vt/iBB0cxNPTdTjGYxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LEICsdkS1F11PO7QlUQXupgmVtKuxT+GOL1vKX2uO3Q9cbADL0JFN9WZ0o8U1Z/goRuC/qKqImopgP/aytX9qyD4BoNiHDRrmVkzVxB8nTRZ6d66jT6vROZjbIXH+FPrkLpS6M0AAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwgraeLcK+M/6TFCGOu9RWsWKMnzVjFW60poWLmfZxBMyJjHAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosIB+ot+Z0HCHrjZsPZSad+eQjNp/DkK0ukYQgxX/rKhthYxwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LCA2bDGtZeUz9tK0XlkQ8/WHVD+AYZGBZ79agYsTvleSpAAA</pre>\n* Case: PSBT with invalid partial sig valuedata length\n** Bytes in Hex: <pre>70736274ff01005202000000019a8b4a50796b9600990f7fe11dfa00bc70efd296048afc86719af0fb1fa919370100000000fdffffff0118ddf50500000000160014c9123e06e8d7f0966c5d1cd0f933002d4eb757cd000000000001012b00e1f5050000000022512056bdb481b4d67103f6d5dea8a9aafd3684a6a79b4a2e247799db8d4b1a86e1f841140b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c402667d52f6cc07fe06db31b1a5f7efe81903f9cbeef40fa64dafca01d2cb1d56403bc7504898e55872557d16d2ca79bc55fef10973841a33ec032d884758c9fe62215c050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac023200b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4acc021160b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d42501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c2680dd6e2116346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd002501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c580b088721164fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c2501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2cc3249a82211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f92501b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c7dd6559201172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c221a030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d46302346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9631b02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202d99e7c8719b3ad08566b0cb9c7d5eda3127c9e8119185b7d584d939b173915f50240df22aab78332cf0f25329d103dc0d2060a03742e9448026e736bcf3db98f3c631b024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202e702a7075226a0d9313a77e6db10b8e742d4cffdc948a0edc9b856c13b412e5403386a0298f308fb3099155772e45b2aa8e770f435bedfe2041d1cc4d3d37538c6631b02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c4202b1d912d45d753ceed0954417ba982656d2aec53f8638bd6f297dae3b743d71b0032f424537d599d28f14d59fe0a11b82fea2aa226a2980ffdacad5fdab20f80683631c02346b99593357107c9d3459e9deba8d3eaf44e6636c85c7f853eb90ba52e8cd00030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c1fa78b70af8cffa4c50863aef515ac58a327cd58c55bad29a162e67d9c413322631c024fafd65f8169186fc2bfdb2233c77e630d10be280a24c7165c09a27611775c2c030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c201fa8b7e6741c21eb8d9b0f65269df9e423369fc390ad2e918420c57feb2a1b61631c02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9030b58e337aa4d3852a8c29387c42408d8cfbe3a613a5e397e0a9f01a5fb7107d4b11fedaa63a0956501a7308c93b5637371e7613d9b8ade1783d49e26c06cfa2c20366c31ad65e533f6d2b45e5910f3f587543f8061918167bf5a818b13be5792a40000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAZqLSlB5a5YAmQ9/4R36ALxw79KWBIr8hnGa8PsfqRk3AQAAAAD9////ARjd9QUAAAAAFgAUyRI+BujX8JZsXRzQ+TMALU63V80AAAAAAAEBKwDh9QUAAAAAIlEgVr20gbTWcQP21d6oqar9NoSmp5tKLiR3mduNSxqG4fhBFAtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixAJmfVL2zAf+BtsxsaX37+gZA/nL7vQPpk2vygHSyx1WQDvHUEiY5VhyVX0W0sp5vFX+8QlzhBoz7AMtiEdYyf5iIVwFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAIyALWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1KzAIRYLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1CUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwmgN1uIRY0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNACUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixYCwiHIRZPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLCUBsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+izDJJqCIRZQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAUAfEYeXSEW+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvklAbEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosfdZVkgEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARggsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+iwiGgMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1GMCNGuZWTNXEHydNFnp3rqNPq9E5mNshcf4U+uQulLozQACT6/WX4FpGG/Cv9siM8d+Yw0QvigKJMcWXAmidhF3XCwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvljGwI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosQgLZnnyHGbOtCFZrDLnH1e2jEnyegRkYW31YTZObFzkV9QJA3yKqt4Myzw8lMp0QPcDSBgoDdC6USAJuc2vPPbmPPGMbAk+v1l+BaRhvwr/bIjPHfmMNEL4oCiTHFlwJonYRd1wsAwtY4zeqTThSqMKTh8QkCNjPvjphOl45fgqfAaX7cQfUsR/tqmOglWUBpzCMk7Vjc3HnYT2bit4Xg9SeJsBs+ixCAucCpwdSJqDZMTp35tsQuOdC1M/9yUig7cm4VsE7QS5UAzhqApjzCPswmRVXcuRbKqjncPQ1vt/iBB0cxNPTdTjGYxsC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LEICsdkS1F11PO7QlUQXupgmVtKuxT+GOL1vKX2uO3Q9cbADL0JFN9WZ0o8U1Z/goRuC/qKqImopgP/aytX9qyD4BoNjHAI0a5lZM1cQfJ00Weneuo0+r0TmY2yFx/hT65C6UujNAAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosH6eLcK+M/6TFCGOu9RWsWKMnzVjFW60poWLmfZxBMyJjHAJPr9ZfgWkYb8K/2yIzx35jDRC+KAokxxZcCaJ2EXdcLAMLWOM3qk04UqjCk4fEJAjYz746YTpeOX4KnwGl+3EH1LEf7apjoJVlAacwjJO1Y3Nx52E9m4reF4PUnibAbPosIB+ot+Z0HCHrjZsPZSad+eQjNp/DkK0ukYQgxX/rKhthYxwC+TCKAZJYwxBJNE+F+J1SKbUxyEWDb5mwhgHxE7zgNvkDC1jjN6pNOFKowpOHxCQI2M++OmE6Xjl+Cp8BpftxB9SxH+2qY6CVZQGnMIyTtWNzcedhPZuK3heD1J4mwGz6LCA2bDGtZeUz9tK0XlkQ8/WHVD+AYZGBZ79agYsTvleSpAAA</pre>\n\n==Rationale==\n\n<references/>\n\n==Reference implementation==\n\nThe reference implementation of the PSBT format is available at Bitcoin Core [[https://github.com/bitcoin/bitcoin/pull/31247|PR #31247]].\n\n==Acknowledgements==\n\nThanks to Sanket Kanjalkar whose notes on this topic formed the initial basis of this BIP. Also\nthanks to Pieter Wuille, Jonas Nick, Tim Ruffing, Marko Bencun, Salvatore Ingala, and all others who\nhave participated in discussions about these fields.\n", "content_length": 91651}
{"bip_number": 372, "filename": "bip-0372.mediawiki", "content": "<pre>\n  BIP: 372\n  Layer: Applications\n  Title: Pay-to-contract tweak fields for PSBT\n  Author: Maxim Orlovsky <orlovsky@lnp-bp.org>\n  Discussions-To: <bitcoin-dev@lists.linuxfoundation.org>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0372\n  Status: Draft\n  Type: Standards Track\n  Created: 2022-01-16\n  License: BSD-2-Clause\n  Requires: BIP-174\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes additional fields for BIP 174 PSBTv0 and BIP 370 PSBTv2\nthat allow for pay-to-contract (P2C) key tweaking data to be included in a PSBT\nof any version. These will represent extra-transaction information required\nfor the signer to produce valid signatures spending previous outputs.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Background===\n\nKey tweaking is a procedure for creating a cryptographic commitment to a\nmessage using elliptic curve properties. The procedure uses the discrete log\nproblem (DLP) to commit to an extra-transaction message. This is done by adding\nto a public key (for which the output owner knows the corresponding private key)\na hash of the message multiplied by the generator point G of the elliptic curve.\nThis produces a tweaked public key containing the commitment. Later, in order\nto spend an output containing the P2C commitment, the same commitment should be\nadded to the corresponding private key.\n\nThis type of commitment was originally proposed as a part of the pay to contract\nconcept by Ilja Gerhardt and Timo Hanke in [1] and later used by Eternity Wall\n[2] for the same purpose. Since that time, multiple different protocols for P2C\nhave been developed, including OpenTimeStamps [3], Elements sidechain P2C tweaks\n[4] and LNPBP-1 [5], used for constructing Peter Todd's single-use-seals [6]\nin client-side-validation protocols like RGB.\n\n===Motivation===\n\nP2C outputs can be detected onchain and spent only if the output owner\nnot only knows the corresponding original private key, but also is aware of\na P2C tweak applied to the public key. In order to produce a valid signature, the\nsame tweak value must be added (modulo group order) to the original private key\nby a signer device. This represents a challenge for external signers, which may\nnot have any information about such commitment. This proposal addresses this\nissue by adding relevant fields to the PSBT input information.\n\nThe proposal abstracts details of specific P2C protocols and provides a universal\nmethod for spending previous outputs containing P2C tweaks, applied to the public\nkey contained within any standard form of the <tt>scriptPubkey</tt>, including\nbare scripts and P2PK, P2PKH, P2SH, witness v0 P2WPKH, P2WSH, nested witness v0\nP2WPKH-P2SH, P2WSH-P2SH and witness v1 P2TR outputs.\n\n\n==Design==\n\nP2C-tweaked public keys are already exposed in the\n<tt>PSBT_IN_REDEEM_SCRIPT</tt>, <tt>PSBT_IN_WITNESS_SCRIPT</tt>,\n<tt>PSBT_IN_TAP_INTERNAL_KEY</tt> and <tt>PSBT_IN_TAP_LEAF_SCRIPT</tt> fields;\nthe only information signer is needed to recognize which keys it should sign\nwith is from which of the original keys they were generated. This is achieved by\nintroducing a new `PSBT_IN_P2C_TWEAK` field, which has the original key as a field\nkey and the tweak as a field value. The signer will recognize the keys which are\navailable to it, apply the tweak to them and see in which scripts it was used --\nand use this information to apply tweaks for the corresponding private keys and\nproduce valid signatures.\n\n\n==Specification==\n\nThe new per-input type is defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| P2C Key Tweak\n| <tt>PSBT_IN_P2C_TWEAK = 0x19</tt>\n| <tt><pubkey></tt>\n| 33 bytes of compact public key serialization specifying to which keys the\nP2C tweak may be applied (i.e. this MUST be a value of a public key before the\ntweak is applied). BIP-340 keys are serialized by appending `0x02`\nbyte.<ref>'''Why compressed public keys are not distinguished from BIP-340\npublic keys''' We follow the logic of BIP32 key derivation, which does not\ndistinguish them. The type of the key is defined by the input type,\nand adding additional PSBT field types will just create the need for handling\nerrors when the input type does not match the provided key type.</ref>\n| <tt><tweak></tt>\n| The 32 byte value which MUST be added to a private key to produce a correct\nECDSA and/or Schnorr signature (\"key tweak\"). Signers SHOULD remove this field\nafter <tt>PSBT_IN_PARTIAL_SIG</tt> is constructed.\n|\n|\n| 0, 2\n| BIP-P2C\n|}\n\n\n==Security considerations==\n\nThe scope of this proposal is deliberately kept narrow; it addresses\nonly spending of transaction outputs containing P2C tweaks - and does not\naddress construction of new P2C commitments or transactions containing them\nin their outputs.<ref>'''Why only spending of P2C tweaked outputs is covered'''\nP2C tweaks commit to external data, some of which may represent certain values\n(like in some sidechains, single-use-seal applications like RGB, etc). Creation\nof such outputs may allow hardware devices to understand the structure of such\nextra-transaction data, which may be in different formats and constantly\nevolve. Thus, this should be addressed with separate standards (or be\nvendor-based). The current proposal only touches the question of spending an\noutput that contained a previously created P2C commitment, which does not create\na new commitment and does not provide that kind of risk of extra-blockchain\nvalue losses.</ref>\n\n\n==Rationale==\n\n<references/>\n\n\n==Compatibility==\n\nThe proposal is compatible with the existing consensus rules and does not\nrequire any modification to them.\n\nThe proposed P2C PSBT fields provide sufficient information for creating\nvalid signatures for spending the following output types containing tweaked\npublic keys:\n- bare scripts,\n- P2PK,\n- P2PKH,\n- P2SH,\n- witness v0 P2WPKH and P2WSH,\n- nested witness v0 P2WPKH-P2SH and P2WSH-P2SH\n\nPost-0 witness versions, including taproot outputs and future witness versions,\nmay not be supported or covered by this BIP and may require the addition of new\nfields to the PSBT inputs.\n\n\n==Reference implementation==\n\nWIP\n\n\n==Acknowledgements==\n\nThe author is grateful to Andrew Poelstra, who provided an initial set of ideas\nand information with his previous work on the topic, on which this standard\nwas designed.\n\n\n==Test vectors==\n\nTBD\n\n\n==References==\n\n[1] Ilja Gerhardt, Timo Hanke. ''Homomorphic Payment Addresses and the Pay-to-Contract Protocol.'' arXiv:1212.3257 [cs.CR]. [https://arxiv.org/pdf/1212.3257.pdf arxiv.org/pdf/1212.3257.pdf]\n\n[2] Eternity Wall. ''Sign-to-contract.'' [https://blog.eternitywall.com/2018/04/13/sign-to-contract/ blog.eternitywall.com]\n\n[3] Peter Todd. ''OpenTimestamps: Scalable, Trust-Minimized, Distributed Timestamping with Bitcoin.'' [https://petertodd.org/2016/opentimestamps-announcement petertodd.org]\n\n[4] Adam Back, Matt Corallo, Luke Dashjr, et al. ''Enabling Blockchain Innovations with Pegged Sidechains (commit5620e43). Appendix A.'' [https://blockstream.com/sidechains.pdf blockstream.com/sidechains.pdf]\n\n[5] Maxim Orlovsky, Rene Pickhardt, Federico Tenga, et al. ''Key tweaking: collision-resistant elliptic curve-based commitments. LNPBP-1 Standard.'' [https://github.com/LNP-BP/LNPBPs/blob/master/lnpbp-0001.md LNPBP-1 on GitHub]\n\n[6] Peter Todd. ''Single-use-seals. LNPBP-8 Standard.'' [https://github.com/LNP-BP/LNPBPs/blob/master/lnpbp-0008.md LNPBP-8 on GitHub]\n\n\n", "content_length": 7634}
{"bip_number": 371, "filename": "bip-0371.mediawiki", "content": "<pre>\n  BIP: 371\n  Layer: Applications\n  Title: Taproot Fields for PSBT\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0371\n  Status: Final\n  Type: Standards Track\n  Created: 2021-06-21\n  License: BSD-2-Clause\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes additional fields for BIP 174 PSBTv0 and BIP 370 PSBTv2 that allow for\nBIP 340/341/342 Taproot data to be included in a PSBT of any version. These will be fields for\nsignatures and scripts that are relevant to the creation of Taproot inputs.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nBIPs 340, 341, and 342 specify Taproot which provides a wholly new way to create and spend Bitcoin outputs.\nThe existing PSBT fields are unable to support Taproot due to the new signature algorithm and the method\nby which scripts are embedded inside of a Taproot output. Therefore new fields must be defined to allow\nPSBTs to carry the information necessary for signing Taproot inputs.\n\n==Specification==\n\nThe new per-input types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Taproot Key Spend Signature\n| <tt>PSBT_IN_TAP_KEY_SIG = 0x13</tt>\n| None\n| No key data <ref>'''Why is there no key data for <tt>PSBT_IN_TAP_KEY_SIG</tt>'''The signature in a key path spend corresponds directly with the pubkey provided in the output script. Thus it is not necessary to provide any metadata that attaches the key path spend signature to a particular pubkey.</ref>\n| <tt><64 or 65 byte signature></tt>\n| The 64 or 65 byte Schnorr signature for key path spending a Taproot output. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|-\n| Taproot Script Spend Signature\n| <tt>PSBT_IN_TAP_SCRIPT_SIG = 0x14</tt>\n| <tt><xonlypubkey> <leafhash></tt>\n| A 32 byte X-only public key involved in a leaf script concatenated with the 32 byte hash of the leaf it is part of.\n| <tt><64 or 65 byte signature></tt>\n| The 64 or 65 byte Schnorr signature for this pubkey and leaf combination. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|-\n| Taproot Leaf Script\n| <tt>PSBT_IN_TAP_LEAF_SCRIPT = 0x15</tt>\n| <tt><bytes control block></tt>\n| The control block for this leaf as specified in BIP 341. The control block contains the merkle tree path to this leaf.\n| <tt><bytes script> <8-bit uint leaf version></tt>\n| The script for this leaf as would be provided in the witness stack followed by the single byte leaf version. Note that the leaves included in this field should be those that the signers of this input are expected to be able to sign for. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|-\n| Taproot Key BIP 32 Derivation Path\n| <tt>PSBT_IN_TAP_BIP32_DERIVATION = 0x16</tt>\n| <tt><32 byte xonlypubkey></tt>\n| A 32 byte X-only public key involved in this input. It may be the output key, the internal key, or a key present in a leaf script.\n| <tt><compact size uint number of hashes> <32 byte leaf hash>* <4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| A compact size unsigned integer representing the number of leaf hashes, followed by a list of leaf hashes, followed by the 4 byte master key fingerprint concatenated with the derivation path of the public key. The derivation path is represented as 32-bit little endian unsigned integer indexes concatenated with each other. Public keys are those needed to spend this output. The leaf hashes are of the leaves which involve this public key. The internal key does not have leaf hashes, so can be indicated with a <tt>hashes len</tt> of 0. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|-\n| Taproot Internal Key\n| <tt>PSBT_IN_TAP_INTERNAL_KEY = 0x17</tt>\n| None\n| No key data\n| <tt><32 byte xonlypubkey></tt>\n| The X-only pubkey used as the internal key in this output.<ref>'''Why is the internal key provided?'''The internal key is not necessarily the same key as in the Taproot output script. BIP 341 recommends tweaking the key with the hash of itself. It may be necessary for signers to know what the internal key actually is so that they are able to determine whether an input can be signed by it.</ref> Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|-\n| Taproot Merkle Root\n| <tt>PSBT_IN_TAP_MERKLE_ROOT = 0x18</tt>\n| None\n| No key data\n| <tt><32-byte hash></tt>\n| The 32 byte Merkle root hash. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|}\n\nThe new per-output types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Taproot Internal Key\n| <tt>PSBT_OUT_TAP_INTERNAL_KEY = 0x05</tt>\n| None\n| No key data\n| <tt><32 byte xonlypubkey></tt>\n| The X-only pubkey used as the internal key in this output.\n|\n|\n| 0, 2\n|-\n| Taproot Tree\n| <tt>PSBT_OUT_TAP_TREE = 0x06</tt>\n| None\n| No key data\n| <tt>{<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*</tt>\n| One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree, allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that the tree is correctly reconstructed. Each tuple is an 8-bit unsigned integer representing the depth in the Taproot tree for this script, an 8-bit unsigned integer representing the leaf version, the length of the script as a compact size unsigned integer, and the script itself.\n|\n|\n| 0, 2\n|-\n| Taproot Key BIP 32 Derivation Path\n| <tt>PSBT_OUT_TAP_BIP32_DERIVATION = 0x07</tt>\n| <tt><32 byte xonlypubkey></tt>\n| A 32 byte X-only public key involved in this output. It may be the output key, the internal key, or a key present in a leaf script.\n| <tt><compact size uint number of hashes> <32 byte leaf hash>* <4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| A compact size unsigned integer representing the number of leaf hashes, followed by a list of leaf hashes, followed by the 4 byte master key fingerprint concatenated with the derivation path of the public key. The derivation path is represented as 32-bit little endian unsigned integer indexes concatenated with each other. Public keys are those needed to spend this output. The leaf hashes are of the leaves which involve this public key. The internal key does not have leaf hashes, so can be indicated with a <tt>hashes len</tt> of 0. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n|}\n\n===UTXO Types===\n\nBIP 174 recommends using <tt>PSBT_IN_NON_WITNESS_UTXO</tt> for all inputs because of potential attacks involving\nan updater lying about the amounts in an output. Because a Taproot signature will commit to all of the amounts\nand output scripts spent by the inputs of the transaction, such attacks are prevented as any such lying would\nresult in an invalid signature. Thus Taproot inputs can use just <tt>PSBT_IN_WITNESS_UTXO</tt>.\n\n==Compatibility==\n\nThese are simply new fields added to the existing PSBT format. Because PSBT is designed to be extensible, old\nsoftware will ignore the new fields.\n\n==Test Vectors==\n\nThe following are invalid PSBTs:\n\n* Case: PSBT With <tt>PSBT_IN_TAP_INTERNAL_KEY</tt> key that is too long (incorrectly serialized as compressed DER)\n** Bytes in Hex: <pre>70736274ff010071020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff02787c01000000000016001483a7e34bd99ff03a4962ef8a1a101bb295461ece606b042a010000001600147ac369df1b20e033d6116623957b0ac49f3c52e8000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a075701172102fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa232000000\n</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXARchAv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyAAAA</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_KEY_SIG</tt> signature that is too short\n** Bytes in Hex: <pre><70736274ff010071020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff02787c01000000000016001483a7e34bd99ff03a4962ef8a1a101bb295461ece606b042a010000001600147ac369df1b20e033d6116623957b0ac49f3c52e8000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a075701133f173bb3d36c074afb716fec6307a069a2e450b995f3c82785945ab8df0e24260dcd703b0cbf34de399184a9481ac2b3586db6601f026a77f7e4938481bc3475000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXARM/Fzuz02wHSvtxb+xjB6BpouRQuZXzyCeFlFq43w4kJg3NcDsMvzTeOZGEqUgawrNYbbZgHwJqd/fkk4SBvDR1AAAA</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_KEY_SIG</tt> signature that is too long\n** Bytes in Hex: <pre><70736274ff010071020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff02787c01000000000016001483a7e34bd99ff03a4962ef8a1a101bb295461ece606b042a010000001600147ac369df1b20e033d6116623957b0ac49f3c52e8000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a0757011342173bb3d36c074afb716fec6307a069a2e450b995f3c82785945ab8df0e24260dcd703b0cbf34de399184a9481ac2b3586db6601f026a77f7e4938481bc34751701aa000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXARNCFzuz02wHSvtxb+xjB6BpouRQuZXzyCeFlFq43w4kJg3NcDsMvzTeOZGEqUgawrNYbbZgHwJqd/fkk4SBvDR1FwGqAAAA</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_BIP32_DERIVATION</tt> key that is too long (incorrectly serialized as compressed DER)\n** Bytes in Hex: <pre><70736274ff010071020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff02787c01000000000016001483a7e34bd99ff03a4962ef8a1a101bb295461ece606b042a010000001600147ac369df1b20e033d6116623957b0ac49f3c52e8000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a0757221602fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2321900772b2da75600008001000080000000800100000000000000000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Anh8AQAAAAAAFgAUg6fjS9mf8DpJYu+KGhAbspVGHs5gawQqAQAAABYAFHrDad8bIOAz1hFmI5V7CsSfPFLoAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXIhYC/jSQZMmNbiqFP6PJsSvYswShnBlcYO+n7iOTBG0/ojIZAHcrLadWAACAAQAAgAAAAIABAAAAAAAAAAAAAA==</pre>\n\n* Case: PSBT With <tt>PSBT_OUT_TAP_INTERNAL_KEY</tt> key that is too long (incorrectly serialized as compressed DER)\n** Bytes in Hex: <pre>70736274ff01007d020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff02887b0100000000001600142382871c7e8421a00093f754d91281e675874b9f606b042a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a0757000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a0757000001052102fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa23200</pre>\n** Base64 String: <pre>cHNidP8BAH0CAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Aoh7AQAAAAAAFgAUI4KHHH6EIaAAk/dU2RKB5nWHS59gawQqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXAAABBSEC/jSQZMmNbiqFP6PJsSvYswShnBlcYO+n7iOTBG0/ojIA</pre>\n\n* Case: PSBT With <tt>PSBT_OUT_TAP_BIP32_DERIVATION</tt> key that is too long (incorrectly serialized as compressed DER)\n** Bytes in Hex: <pre>70736274ff01007d020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff02887b0100000000001600142382871c7e8421a00093f754d91281e675874b9f606b042a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a0757000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a07570000220702fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2321900772b2da7560000800100008000000080010000000000000000</pre>\n** Base64 String: <pre>cHNidP8BAH0CAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////Aoh7AQAAAAAAFgAUI4KHHH6EIaAAk/dU2RKB5nWHS59gawQqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXAAAAAAABASsA8gUqAQAAACJRIFosLPW1LPMfg60ujaY/8DGD7Nj2CcdRCuikjgORCgdXAAAiBwL+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMhkAdystp1YAAIABAACAAAAAgAEAAAAAAAAAAA==</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_SCRIPT_SIG</tt> key that is too long (incorrectly serialized as compressed DER)\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a01000000225120030da4fce4f7db28c2cb2951631e003713856597fe963882cb500e68112cca63000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b6924214022cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b094089756aa3739ccc689ec0fcf3a360be32cc0b59b16e93a1e8bb4605726b2ca7a3ff706c4176649632b2cc68e1f912b8a578e3719ce7710885c7a966f49bcd43cb0000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgAw2k/OT32yjCyylRYx4ANxOFZZf+ljiCy1AOaBEsymMAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJCFAIssTrGgkjegGqmo2Wc88A+toIdCcgRSk6Gj+vehlu20s2XDhX1P8DIL5UP1WD/qRm3YXK+AXNoqJkTrwdPQAsJQIl1aqNznMxonsD886NgvjLMC1mxbpOh6LtGBXJrLKej/3BsQXZkljKyzGjh+RK4pXjjcZzncQiFx6lm9JvNQ8sAAA==</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_SCRIPT_SIG</tt> signature that is too long\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a01000000225120030da4fce4f7db28c2cb2951631e003713856597fe963882cb500e68112cca63000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b69241142cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b094289756aa3739ccc689ec0fcf3a360be32cc0b59b16e93a1e8bb4605726b2ca7a3ff706c4176649632b2cc68e1f912b8a578e3719ce7710885c7a966f49bcd43cb01010000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgAw2k/OT32yjCyylRYx4ANxOFZZf+ljiCy1AOaBEsymMAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJBFCyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwlCiXVqo3OczGiewPzzo2C+MswLWbFuk6Hou0YFcmssp6P/cGxBdmSWMrLMaOH5ErileONxnOdxCIXHqWb0m81DywEBAAA=</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_SCRIPT_SIG</tt> signature that is too short\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a01000000225120030da4fce4f7db28c2cb2951631e003713856597fe963882cb500e68112cca63000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b69241142cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b093f89756aa3739ccc689ec0fcf3a360be32cc0b59b16e93a1e8bb4605726b2ca7a3ff706c4176649632b2cc68e1f912b8a578e3719ce7710885c7a966f49bcd430000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgAw2k/OT32yjCyylRYx4ANxOFZZf+ljiCy1AOaBEsymMAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJBFCyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwk/iXVqo3OczGiewPzzo2C+MswLWbFuk6Hou0YFcmssp6P/cGxBdmSWMrLMaOH5ErileONxnOdxCIXHqWb0m81DAAA=</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_LEAF_SCRIPT</tt> Control block that is too long\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a01000000225120030da4fce4f7db28c2cb2951631e003713856597fe963882cb500e68112cca63000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b6926315c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac06f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae970115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f80023202cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2acc00000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgAw2k/OT32yjCyylRYx4ANxOFZZf+ljiCy1AOaBEsymMAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJjFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wG99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwEV8uSQr3zEXE94UR82BXzlxaXFYyWin7RN/CA/NW4fgAIyAssTrGgkjegGqmo2Wc88A+toIdCcgRSk6Gj+vehlu20qzAAAA=</pre>\n\n* Case: PSBT With <tt>PSBT_IN_TAP_LEAF_SCRIPT</tt> Control block that is too short\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a01000000225120030da4fce4f7db28c2cb2951631e003713856597fe963882cb500e68112cca63000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b6926115c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac06f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae970115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e123202cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2acc00000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgAw2k/OT32yjCyylRYx4ANxOFZZf+ljiCy1AOaBEsymMAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJhFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wG99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwEV8uSQr3zEXE94UR82BXzlxaXFYyWin7RN/CA/NW4SMgLLE6xoJI3oBqpqNlnPPAPraCHQnIEUpOho/r3oZbttKswAAA</pre>\n\nThe following are valid PSBTs:\n\n* Case: PSBT with one P2TR key only input with internal key and its derivation path\n** Bytes in Hex: <pre>70736274ff010052020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff0148e6052a01000000160014768e1eeb4cf420866033f80aceff0f9720744969000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a07572116fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2321900772b2da75600008001000080000000800100000000000000011720fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa232002202036b772a6db74d8753c98a827958de6c78ab3312109f37d3e0304484242ece73d818772b2da7540000800100008000000080000000000000000000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAFgAUdo4e60z0IIZgM/gKzv8PlyB0SWkAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1chFv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyGQB3Ky2nVgAAgAEAAIAAAACAAQAAAAAAAAABFyD+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMgAiAgNrdyptt02HU8mKgnlY3mx4qzMSEJ830+AwRIQkLs5z2Bh3Ky2nVAAAgAEAAIAAAACAAAAAAAAAAAAA</pre>\n\n* Case: PSBT with one P2TR key only input with internal key, its derivation path, and signature\n** Bytes in Hex: <pre>70736274ff010052020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff0148e6052a01000000160014768e1eeb4cf420866033f80aceff0f9720744969000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a0757011340bb53ec917bad9d906af1ba87181c48b86ace5aae2b53605a725ca74625631476fc6f5baedaf4f2ee0f477f36f58f3970d5b8273b7e497b97af2e3f125c97af342116fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2321900772b2da75600008001000080000000800100000000000000011720fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa232002202036b772a6db74d8753c98a827958de6c78ab3312109f37d3e0304484242ece73d818772b2da7540000800100008000000080000000000000000000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAFgAUdo4e60z0IIZgM/gKzv8PlyB0SWkAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1cBE0C7U+yRe62dkGrxuocYHEi4as5aritTYFpyXKdGJWMUdvxvW67a9PLuD0d/NvWPOXDVuCc7fkl7l68uPxJcl680IRb+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMhkAdystp1YAAIABAACAAAAAgAEAAAAAAAAAARcg/jSQZMmNbiqFP6PJsSvYswShnBlcYO+n7iOTBG0/ojIAIgIDa3cqbbdNh1PJioJ5WN5seKszEhCfN9PgMESEJC7Oc9gYdystp1QAAIABAACAAAAAgAAAAAAAAAAAAA==</pre>\n\n* Case: PSBT with one P2TR key only output with internal key and its derivation path\n** Bytes in Hex: <pre>70736274ff01005e020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff0148e6052a0100000022512083698e458c6664e1595d75da2597de1e22ee97d798e706c4c0a4b5a9823cd743000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a07572116fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2321900772b2da75600008001000080000000800100000000000000011720fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa232000105201124da7aec92ccd06c954562647f437b138b95721a84be2bf2276bbddab3e67121071124da7aec92ccd06c954562647f437b138b95721a84be2bf2276bbddab3e6711900772b2da7560000800100008000000080000000000500000000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAIlEgg2mORYxmZOFZXXXaJZfeHiLul9eY5wbEwKS1qYI810MAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1chFv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyGQB3Ky2nVgAAgAEAAIAAAACAAQAAAAAAAAABFyD+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMgABBSARJNp67JLM0GyVRWJkf0N7E4uVchqEvivyJ2u92rPmcSEHESTaeuySzNBslUViZH9DexOLlXIahL4r8idrvdqz5nEZAHcrLadWAACAAQAAgAAAAIAAAAAABQAAAAA=</pre>\n\n* Case: PSBT with one P2TR script path only input with dummy internal key, scripts, derivation paths for keys in the scripts, and merkle root\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a0100000022512083698e458c6664e1595d75da2597de1e22ee97d798e706c4c0a4b5a9823cd743000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b6926215c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac06f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae970115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f823202cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2acc04215c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac097c6e6fea5ff714ff5724499990810e406e98aa10f5bf7e5f6784bc1d0a9a6ce23204320b0bf16f011b53ea7be615924aa7f27e5d29ad20ea1155d848676c3bad1b2acc06215c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b09115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f82320fa0f7a3cef3b1d0c0a6ce7d26e17ada0b2e5c92d19efad48b41859cb8a451ca9acc021162cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d23901cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b09772b2da7560000800100008002000080000000000000000021164320b0bf16f011b53ea7be615924aa7f27e5d29ad20ea1155d848676c3bad1b23901115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f8772b2da75600008001000080010000800000000000000000211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116fa0f7a3cef3b1d0c0a6ce7d26e17ada0b2e5c92d19efad48b41859cb8a451ca939016f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae970772b2da7560000800100008003000080000000000000000001172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820f0362e2f75a6f420a5bde3eb221d96ae6720cf25f81890c95b1d775acb515e65000105201124da7aec92ccd06c954562647f437b138b95721a84be2bf2276bbddab3e67121071124da7aec92ccd06c954562647f437b138b95721a84be2bf2276bbddab3e6711900772b2da7560000800100008000000080000000000500000000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgg2mORYxmZOFZXXXaJZfeHiLul9eY5wbEwKS1qYI810MAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJiFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wG99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwEV8uSQr3zEXE94UR82BXzlxaXFYyWin7RN/CA/NW4fgjICyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSrMBCFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wJfG5v6l/3FP9XJEmZkIEOQG6YqhD1v35fZ4S8HQqabOIyBDILC/FvARtT6nvmFZJKp/J+XSmtIOoRVdhIZ2w7rRsqzAYhXBUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsDNlw4V9T/AyC+VD9Vg/6kZt2FyvgFzaKiZE68HT0ALCRFfLkkK98xFxPeFEfNgV85cWlxWMlop+0TfwgPzVuH4IyD6D3o87zsdDAps59JuF62gsuXJLRnvrUi0GFnLikUcqazAIRYssTrGgkjegGqmo2Wc88A+toIdCcgRSk6Gj+vehlu20jkBzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwl3Ky2nVgAAgAEAAIACAACAAAAAAAAAAAAhFkMgsL8W8BG1Pqe+YVkkqn8n5dKa0g6hFV2EhnbDutGyOQERXy5JCvfMRcT3hRHzYFfOXFpcVjJaKftE38ID81bh+HcrLadWAACAAQAAgAEAAIAAAAAAAAAAACEWUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsAFAHxGHl0hFvoPejzvOx0MCmzn0m4XraCy5cktGe+tSLQYWcuKRRypOQFvfWIFnpSXoaSiZ1admHbaYBAa/zjjUpubk5zn+RrpcHcrLadWAACAAQAAgAMAAIAAAAAAAAAAAAEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARgg8DYuL3Wm9CClvePrIh2WrmcgzyX4GJDJWx13WstRXmUAAQUgESTaeuySzNBslUViZH9DexOLlXIahL4r8idrvdqz5nEhBxEk2nrskszQbJVFYmR/Q3sTi5VyGoS+K/Ina73as+ZxGQB3Ky2nVgAAgAEAAIAAAACAAAAAAAUAAAAA</pre>\n\n* Case: PSBT with one P2TR script path only output with dummy internal key, taproot tree, and script key derivation paths\n** Bytes in Hex: <pre>70736274ff01005e020000000127744ababf3027fe0d6cf23a96eee2efb188ef52301954585883e69b6624b2420000000000ffffffff0148e6052a010000002251200a8cbdc86de1ce1c0f9caeb22d6df7ced3683fe423e05d1e402a879341d6f6f5000000000001012b00f2052a010000002251205a2c2cf5b52cf31f83ad2e8da63ff03183ecd8f609c7510ae8a48e03910a07572116fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2321900772b2da75600008001000080000000800100000000000000011720fe349064c98d6e2a853fa3c9b12bd8b304a19c195c60efa7ee2393046d3fa2320001052050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac001066f02c02220736e572900fe1252589a2143c8f3c79f71a0412d2353af755e9701c782694a02ac02c02220631c5f3b5832b8fbdebfb19704ceeb323c21f40f7a24f43d68ef0cc26b125969ac01c0222044faa49a0338de488c8dfffecdfb6f329f380bd566ef20c8df6d813eab1c4273ac210744faa49a0338de488c8dfffecdfb6f329f380bd566ef20c8df6d813eab1c42733901f06b798b92a10ed9a9d0bbfd3af173a53b1617da3a4159ca008216cd856b2e0e772b2da75600008001000080010000800000000003000000210750929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2107631c5f3b5832b8fbdebfb19704ceeb323c21f40f7a24f43d68ef0cc26b125969390118ace409889785e0ea70ceebb8e1ca892a7a78eaede0f2e296cf435961a8f4ca772b2da756000080010000800200008000000000030000002107736e572900fe1252589a2143c8f3c79f71a0412d2353af755e9701c782694a02390129a5b4915090162d759afd3fe0f93fa3326056d0b4088cb933cae7826cb8d82c772b2da7560000800100008003000080000000000300000000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAASd0Srq/MCf+DWzyOpbu4u+xiO9SMBlUWFiD5ptmJLJCAAAAAAD/////AUjmBSoBAAAAIlEgCoy9yG3hzhwPnK6yLW33ztNoP+Qj4F0eQCqHk0HW9vUAAAAAAAEBKwDyBSoBAAAAIlEgWiws9bUs8x+DrS6Npj/wMYPs2PYJx1EK6KSOA5EKB1chFv40kGTJjW4qhT+jybEr2LMEoZwZXGDvp+4jkwRtP6IyGQB3Ky2nVgAAgAEAAIAAAACAAQAAAAAAAAABFyD+NJBkyY1uKoU/o8mxK9izBKGcGVxg76fuI5MEbT+iMgABBSBQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAEGbwLAIiBzblcpAP4SUliaIUPI88efcaBBLSNTr3VelwHHgmlKAqwCwCIgYxxfO1gyuPvev7GXBM7rMjwh9A96JPQ9aO8MwmsSWWmsAcAiIET6pJoDON5IjI3//s37bzKfOAvVZu8gyN9tgT6rHEJzrCEHRPqkmgM43kiMjf/+zftvMp84C9Vm7yDI322BPqscQnM5AfBreYuSoQ7ZqdC7/Trxc6U7FhfaOkFZygCCFs2Fay4Odystp1YAAIABAACAAQAAgAAAAAADAAAAIQdQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wAUAfEYeXSEHYxxfO1gyuPvev7GXBM7rMjwh9A96JPQ9aO8MwmsSWWk5ARis5AmIl4Xg6nDO67jhyokqenjq7eDy4pbPQ1lhqPTKdystp1YAAIABAACAAgAAgAAAAAADAAAAIQdzblcpAP4SUliaIUPI88efcaBBLSNTr3VelwHHgmlKAjkBKaW0kVCQFi11mv0/4Pk/ozJgVtC0CIy5M8rngmy42Cx3Ky2nVgAAgAEAAIADAACAAAAAAAMAAAAA</pre>\n\n* Case: PSBT with one P2TR script path only input with dummy internal key, scripts, script key derivation paths, merkle root, and script path signatures\n** Bytes in Hex: <pre>70736274ff01005e02000000019bd48765230bf9a72e662001f972556e54f0c6f97feb56bcb5600d817f6995260100000000ffffffff0148e6052a0100000022512083698e458c6664e1595d75da2597de1e22ee97d798e706c4c0a4b5a9823cd743000000000001012b00f2052a01000000225120c2247efbfd92ac47f6f40b8d42d169175a19fa9fa10e4a25d7f35eb4dd85b69241142cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b0940bf818d9757d6ffeb538ba057fb4c1fc4e0f5ef186e765beb564791e02af5fd3d5e2551d4e34e33d86f276b82c99c79aed3f0395a081efcd2cc2c65dd7e693d7941144320b0bf16f011b53ea7be615924aa7f27e5d29ad20ea1155d848676c3bad1b2115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f840e1f1ab6fabfa26b236f21833719dc1d428ab768d80f91f9988d8abef47bfb863bb1f2a529f768c15f00ce34ec283cdc07e88f8428be28f6ef64043c32911811a4114fa0f7a3cef3b1d0c0a6ce7d26e17ada0b2e5c92d19efad48b41859cb8a451ca96f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae97040ec1f0379206461c83342285423326708ab031f0da4a253ee45aafa5b8c92034d8b605490f8cd13e00f989989b97e215faa36f12dee3693d2daccf3781c1757f66215c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac06f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae970115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f823202cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d2acc04215c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac097c6e6fea5ff714ff5724499990810e406e98aa10f5bf7e5f6784bc1d0a9a6ce23204320b0bf16f011b53ea7be615924aa7f27e5d29ad20ea1155d848676c3bad1b2acc06215c150929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b09115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f82320fa0f7a3cef3b1d0c0a6ce7d26e17ada0b2e5c92d19efad48b41859cb8a451ca9acc021162cb13ac68248de806aa6a3659cf3c03eb6821d09c8114a4e868febde865bb6d23901cd970e15f53fc0c82f950fd560ffa919b76172be017368a89913af074f400b09772b2da7560000800100008002000080000000000000000021164320b0bf16f011b53ea7be615924aa7f27e5d29ad20ea1155d848676c3bad1b23901115f2e490af7cc45c4f78511f36057ce5c5a5c56325a29fb44dfc203f356e1f8772b2da75600008001000080010000800000000000000000211650929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac005007c461e5d2116fa0f7a3cef3b1d0c0a6ce7d26e17ada0b2e5c92d19efad48b41859cb8a451ca939016f7d62059e9497a1a4a267569d9876da60101aff38e3529b9b939ce7f91ae970772b2da7560000800100008003000080000000000000000001172050929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0011820f0362e2f75a6f420a5bde3eb221d96ae6720cf25f81890c95b1d775acb515e65000105201124da7aec92ccd06c954562647f437b138b95721a84be2bf2276bbddab3e67121071124da7aec92ccd06c954562647f437b138b95721a84be2bf2276bbddab3e6711900772b2da7560000800100008000000080000000000500000000</pre>\n** Base64 String: <pre>cHNidP8BAF4CAAAAAZvUh2UjC/mnLmYgAflyVW5U8Mb5f+tWvLVgDYF/aZUmAQAAAAD/////AUjmBSoBAAAAIlEgg2mORYxmZOFZXXXaJZfeHiLul9eY5wbEwKS1qYI810MAAAAAAAEBKwDyBSoBAAAAIlEgwiR++/2SrEf29AuNQtFpF1oZ+p+hDkol1/NetN2FtpJBFCyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwlAv4GNl1fW/+tTi6BX+0wfxOD17xhudlvrVkeR4Cr1/T1eJVHU404z2G8na4LJnHmu0/A5Wgge/NLMLGXdfmk9eUEUQyCwvxbwEbU+p75hWSSqfyfl0prSDqEVXYSGdsO60bIRXy5JCvfMRcT3hRHzYFfOXFpcVjJaKftE38ID81bh+EDh8atvq/omsjbyGDNxncHUKKt2jYD5H5mI2KvvR7+4Y7sfKlKfdowV8AzjTsKDzcB+iPhCi+KPbvZAQ8MpEYEaQRT6D3o87zsdDAps59JuF62gsuXJLRnvrUi0GFnLikUcqW99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwQOwfA3kgZGHIM0IoVCMyZwirAx8NpKJT7kWq+luMkgNNi2BUkPjNE+APmJmJuX4hX6o28S3uNpPS2szzeBwXV/ZiFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wG99YgWelJehpKJnVp2YdtpgEBr/OONSm5uTnOf5GulwEV8uSQr3zEXE94UR82BXzlxaXFYyWin7RN/CA/NW4fgjICyxOsaCSN6AaqajZZzzwD62gh0JyBFKToaP696GW7bSrMBCFcFQkpt0waBJVLeLS2A16XpeB4paDyjsltVHv+6azoA6wJfG5v6l/3FP9XJEmZkIEOQG6YqhD1v35fZ4S8HQqabOIyBDILC/FvARtT6nvmFZJKp/J+XSmtIOoRVdhIZ2w7rRsqzAYhXBUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsDNlw4V9T/AyC+VD9Vg/6kZt2FyvgFzaKiZE68HT0ALCRFfLkkK98xFxPeFEfNgV85cWlxWMlop+0TfwgPzVuH4IyD6D3o87zsdDAps59JuF62gsuXJLRnvrUi0GFnLikUcqazAIRYssTrGgkjegGqmo2Wc88A+toIdCcgRSk6Gj+vehlu20jkBzZcOFfU/wMgvlQ/VYP+pGbdhcr4Bc2iomROvB09ACwl3Ky2nVgAAgAEAAIACAACAAAAAAAAAAAAhFkMgsL8W8BG1Pqe+YVkkqn8n5dKa0g6hFV2EhnbDutGyOQERXy5JCvfMRcT3hRHzYFfOXFpcVjJaKftE38ID81bh+HcrLadWAACAAQAAgAEAAIAAAAAAAAAAACEWUJKbdMGgSVS3i0tgNel6XgeKWg8o7JbVR7/ums6AOsAFAHxGHl0hFvoPejzvOx0MCmzn0m4XraCy5cktGe+tSLQYWcuKRRypOQFvfWIFnpSXoaSiZ1admHbaYBAa/zjjUpubk5zn+RrpcHcrLadWAACAAQAAgAMAAIAAAAAAAAAAAAEXIFCSm3TBoElUt4tLYDXpel4HiloPKOyW1Ue/7prOgDrAARgg8DYuL3Wm9CClvePrIh2WrmcgzyX4GJDJWx13WstRXmUAAQUgESTaeuySzNBslUViZH9DexOLlXIahL4r8idrvdqz5nEhBxEk2nrskszQbJVFYmR/Q3sTi5VyGoS+K/Ina73as+ZxGQB3Ky2nVgAAgAEAAIAAAACAAAAAAAUAAAAA</pre>\n\n==Rationale==\n\n<references/>\n\n==Reference implementation==\n\nThe reference implementation of the PSBT format is available at https://github.com/achow101/bitcoin/tree/taproot-psbt.\n\n==Acknowledgements==\n\nTBD\n", "content_length": 33881}
{"bip_number": 370, "filename": "bip-0370.mediawiki", "content": "<pre>\n  BIP: 370\n  Layer: Applications\n  Title: PSBT Version 2\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0370\n  Status: Final\n  Type: Standards Track\n  Created: 2021-01-14\n  License: BSD-2-Clause\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a second version of the Partially Signed Bitcoin Transaction format\ndescribed in BIP 174 which allows for inputs and outputs to be added to the PSBT after creation.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nPartially Signed Bitcoin Transaction Version 0 as described in BIP 174 is unable to have new\ninputs and outputs be added to the transaction. The fixed global unsigned transaction\ncannot be changed which prevents any additional inputs or outputs to be added.\nPSBT Version 2 is intended to rectify this problem.\n\nAn additional beneficial side effect is that all information for a given input or output will be\nprovided by its <tt><input-map></tt> or <tt><output-map></tt>. With Version 0, to retrieve\nall of the information for an input or output, data would need to be found in two locations:\nthe <tt><input-map></tt>/<tt><output-map></tt> and the global unsigned transaction. PSBT\nVersion 2 now moves all related information to one place.\n\n==Specification==\n\nPSBT Version 2 (PSBTv2) only specifies new fields and field inclusion/exclusion requirements.\n\n<tt>PSBT_GLOBAL_UNSIGNED_TX</tt> must be excluded in PSBTv2.\n<tt>PSBT_GLOBAL_VERSION</tt> must be included in PSBTv2 and set to version number 2<ref>'''What happened to version number 1?'''\nVersion number 1 is skipped because PSBT Version 0 has been colloquially referred to as version 1. Originally this BIP was to be\nversion 1, but because it has been colloquially referred to as version 2 during its design phase, it was decided to change the\nversion number to 2 so that there would not be any confusion</ref>.\n\nThe new global types for PSBT Version 2 are as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Transaction Version\n| <tt>PSBT_GLOBAL_TX_VERSION = 0x02</tt>\n| None\n| No key data\n| <tt><32-bit little endian int version></tt>\n| The 32-bit little endian signed integer representing the version number of the transaction being created. Note that this is not the same as the PSBT version number specified by the PSBT_GLOBAL_VERSION field.\n| 2\n| 0\n| 2\n|-\n| Fallback Locktime\n| <tt>PSBT_GLOBAL_FALLBACK_LOCKTIME = 0x03</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint locktime></tt>\n| The 32-bit little endian unsigned integer representing the transaction locktime to use if no inputs specify a required locktime.\n|\n| 0\n| 2\n|-\n| Input Count\n| <tt>PSBT_GLOBAL_INPUT_COUNT = 0x04</tt>\n| None\n| No key data\n| <tt><compact size uint input count></tt>\n| Compact size unsigned integer representing the number of inputs in this PSBT.\n| 2\n| 0\n| 2\n|-\n| Output Count\n| <tt>PSBT_GLOBAL_OUTPUT_COUNT = 0x05</tt>\n| None\n| No key data\n| <tt><compact size uint output count></tt>\n| Compact size unsigned integer representing the number of outputs in this PSBT.\n| 2\n| 0\n| 2\n|-\n| Transaction Modifiable Flags\n| <tt>PSBT_GLOBAL_TX_MODIFIABLE = 0x06</tt>\n| None\n| No key data\n| <tt><8-bit uint flags></tt>\n| An 8 bit unsigned integer as a bitfield for various transaction modification flags. Bit 0 is the Inputs Modifiable Flag, set to 1 to indicate whether inputs can be added or removed. Bit 1 is the Outputs Modifiable Flag, set to 1 to indicate whether outputs can be added or removed. Bit 2 is the Has SIGHASH_SINGLE flag, set to 1 to indicate whether the transaction has a SIGHASH_SINGLE signature who's input and output pairing must be preserved. Bit 2 essentially indicates that the Constructor must iterate the inputs to determine whether and how to add or remove an input.\n|\n| 0\n| 2\n|}\n\nThe new per-input types for PSBT Version 2 are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Previous TXID\n| <tt>PSBT_IN_PREVIOUS_TXID = 0x0e</tt>\n| None\n| No key data\n| <tt><32 byte txid></tt>\n| 32 byte txid of the previous transaction whose output at PSBT_IN_OUTPUT_INDEX is being spent.\n| 2\n| 0\n| 2\n|-\n| Spent Output Index\n| <tt>PSBT_IN_OUTPUT_INDEX = 0x0f</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint index></tt>\n| 32 bit little endian integer representing the index of the output being spent in the transaction with the txid of PSBT_IN_PREVIOUS_TXID.\n| 2\n| 0\n| 2\n|-\n| Sequence Number\n| <tt>PSBT_IN_SEQUENCE = 0x10</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint sequence></tt>\n| The 32 bit unsigned little endian integer for the sequence number of this input. If omitted, the sequence number is assumed to be the final sequence number (0xffffffff).\n|\n| 0\n| 2\n|-\n| Required Time-based Locktime\n| <tt>PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x11</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint locktime></tt>\n| 32 bit unsigned little endian integer greater than or equal to 500000000 representing the minimum Unix timestamp that this input requires to be set as the transaction's lock time.\n|\n| 0\n| 2\n|-\n| Required Height-based Locktime\n| <tt>PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x12</tt>\n| None\n| No key data\n| <tt><32-bit uint locktime></tt>\n| 32 bit unsigned little endian integer greater than 0 and less than 500000000 representing the minimum block height that this input requires to be set as the transaction's lock time.\n|\n| 0\n| 2\n|}\n\nThe new per-output types for PSBT Version 2 are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| Output Amount\n| <tt>PSBT_OUT_AMOUNT = 0x03</tt>\n| None\n| No key data\n| <tt><64-bit little endian int amount></tt>\n| 64 bit signed little endian integer representing the output's amount in satoshis.\n| 2\n| 0\n| 2\n|-\n| Output Script\n| <tt>PSBT_OUT_SCRIPT = 0x04</tt>\n| None\n| No key data\n| <tt><bytes script></tt>\n| The script for this output, also known as the scriptPubKey. Must be omitted in PSBTv0. Must be provided in PSBTv2.\n| 2\n| 0\n| 2\n|}\n\n===Determining Lock Time===\n\nThe nLockTime field of a transaction is determined by inspecting the PSBT_GLOBAL_FALLBACK_LOCKTIME and each input's PSBT_IN_REQUIRED_TIME_LOCKTIME and PSBT_IN_REQUIRED_HEIGHT_LOCKTIME fields.\nIf none of the inputs have a PSBT_IN_REQUIRED_TIME_LOCKTIME and PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then PSBT_GLOBAL_FALLBACK_LOCKTIME must be used.\nIf PSBT_GLOBAL_FALLBACK_LOCKTIME is not provided, then it is assumed to be 0.\n\nIf one or more inputs have a PSBT_IN_REQUIRED_TIME_LOCKTIME or PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then the field chosen is the one which is supported by all of the inputs.\nThis can be determined by looking at all of the inputs which specify a locktime in either of those fields, and choosing the field which is present in all of those inputs.\nInputs not specifying a lock time field can take both types of lock times, as can those that specify both.\nThe lock time chosen is then the maximum value of the chosen type of lock time.\n\nIf a PSBT has both types of locktimes possible because one or more inputs specify both PSBT_IN_REQUIRED_TIME_LOCKTIME and PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then locktime determined by looking at the PSBT_IN_REQUIRED_HEIGHT_LOCKTIME fields of the inputs must be chosen.<ref>'''Why choose the height based locktime?'''\nIn the event of a tie for the locktime type, signers need to be able to know which locktime to use as their signatures will commit to the locktime in the transaction, so choosing the wrong one will result in an invalid transaction.\nHeight based locktime is preferred over time based as Bitcoin's unit of time is the block height, so a height makes more sense in the context of Bitcoin.</ref>\n\n===Unique Identification===\n\nPSBTv2s can be uniquely identified by constructing an unsigned transaction given the information provided in the PSBT, and computing the transaction ID of that transaction.\nSince PSBT_IN_SEQUENCE can be changed by Updaters and Combiners, the sequence number in this unsigned transaction must be set to 0 (not final, nor the sequence in PSBT_IN_SEQUENCE).\nThe lock time in this unsigned transaction must be computed as described previously.\n\n==Roles==\n\nPSBTv2 introduces new roles and modifies some existing roles.\n\n===Creator===\n\nIn PSBTv2, the Creator initializes the PSBT with 0 inputs and 0 outputs.\nThe PSBT version number is set to 2.\nThe Creator should also set PSBT_GLOBAL_FALLBACK_LOCKTIME.\nIf the Creator is not also a Constructor and will be giving the PSBT to others to add inputs and outputs, the PSBT_GLOBAL_TX_MODIFIABLE field must be present and the Inputs Modifiable and Outputs Modifiable flags set appropriately; moreover, the transaction version number must be set to at least 2. <ref>'''Why does the transaction version number need to be at least 2?''' The transaction version number is part of the validation rules for some features such as OP_CHECKSEQUENCEVERIFY. Since it is backwards compatible, and there are other ways to disable those features (e.g. through sequence numbers), it is easier to require transactions be able to support these features than to try to negotiate the transaction version number.</ref>\nIf the Creator is a Constructor and no inputs and outputs will be added by other entities, PSBT_GLOBAL_TX_MODIFIABLE may be omitted.\n\n===Constructor===\n\nThis Constructor is only present for PSBTv2.\nOnce a Creator initializes the PSBT, a constructor will add inputs and outputs.\nBefore any input or output may be added, the constructor must check the PSBT_GLOBAL_TX_MODIFIABLE field.\nInputs may only be added if the Inputs Modifiable flag is True.\nOutputs may only be added if the Outputs Modifiable flag is True.\n\nWhen an input or output is added, the corresponding PSBT_GLOBAL_INPUT_COUNT or PSBT_GLOBAL_OUTPUT_COUNT must be incremented to reflect the number of inputs and outputs in the PSBT.\nWhen an input is added, it must have PSBT_IN_PREVIOUS_TXID and PSBT_IN_OUTPUT_INDEX set.\nWhen an output is added, it must have PSBT_OUT_VALUE and PSBT_OUT_OUTPUT_SCRIPT set.\nIf the input has a required timelock, Constructors must set the requisite timelock field.\nIf the input has a required time based timelock, then PSBT_IN_REQUIRED_TIME_TIMELOCK must be set.\nIf the input has a required height based timelock, then PSBT_IN_REQUIRED_HEIGHT_TIMELOCK must be set.\nIf an input has both types of timelocks, then both may be set.\nIn some cases, an input that can allow both types, but a particular branch supporting only one type of timelock will be taken, then the type of timelock that will be used can be the only one set.\n\nIf an input being added specifies a required time lock, then the Constructor must iterate through all of the existing inputs and ensure that the time lock types are compatible.\nAdditionally, if during this iteration, it finds that any inputs have signatures, it must ensure that the newly added input does not change the transaction's locktime.\nIf the newly added input has an incompatible time lock, then it must not be added.\nIf it changes the transaction's locktime when there are existing signatures, it must not be added.\n\nIf the Has SIGHASH_SINGLE flag is True, then the Constructor must iterate through the inputs and find the inputs which have signatures that use SIGHASH_SINGLE.\nThe same number of inputs and outputs must be added before those inputs and their corresponding outputs.\n\nA Constructor may choose to declare that no further inputs and outputs can be added to the transaction by setting the appropriate bits in PSBT_GLOBAL_TX_MODIFIABLE to 0 or by removing the field entirely.\n\nA single entity is likely to be both a Creator and Constructor.\n\n===Updater===\n\nFor PSBTv2, an Updater can set the sequence number.\n\n===Signer===\n\nFor PSBTv2s, a signer must update the PSBT_GLOBAL_TX_MODIFIABLE field after signing inputs so that it accurately reflects the state of the PSBT.\nIf the Signer added a signature that does not use SIGHASH_ANYONECANPAY, the Input Modifiable flag must be set to False.\nIf the Signer added a signature that does not use SIGHASH_NONE, the Outputs Modifiable flag must be set to False.\nIf the Signer added a signature that uses SIGHASH_SINGLE, the Has SIGHASH_SINGLE flag must be set to True.\n\n===Transaction Extractor===\n\nFor PSBTv2s, the transaction is constructed using the PSBTv2 fields.\nThe lock time for this transaction is determined as described in the Determining Lock Time section.\nThe Extractor should produce a fully valid, network serialized transaction if all inputs are complete.\n\n==Backwards Compatibility==\n\nPSBTv2 shares the same generic format as PSBTv0 as defined in BIP 174. Parsers for PSBTv0 should\nbe able to deserialize PSBTv2 with only changes to support the new fields.\n\nHowever PSBTv2 is incompatible with PSBTv0, and vice versa due to the use of the PSBT_GLOBAL_VERSION.\nThis incompatibility is intentional so that PSBT_GLOBAL_UNSIGNED_TX could be removed in PSBTv2.\nHowever it is possible to convert a PSBTv2 to a PSBTv0 by creating an unsigned\ntransaction from the PSBTv2 fields.\n\n==Test Vectors==\n\nThe following are invalid PSBTs:\n\n* Case: PSBTv0 but with PSBT_GLOBAL_VERSION set to 2.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc68850000000001fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAH7BAIAAAAAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BCGsCRzBEAiAFJ1pIVzTgrh87lxI3WG8OctyFgz0njA5HTNIxEsD6XgIgawSMg868PEHQuTzH2nYYXO29Aw0AWwgBi+K5i7rL33sBIQN2DcygXzmX3GWykwYPfynxUUyMUnBI4SgCsEHU/DQKJwAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_GLOBAL_TX_VERSION.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc68850000000001020402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAECBAIAAAAAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BCGsCRzBEAiAFJ1pIVzTgrh87lxI3WG8OctyFgz0njA5HTNIxEsD6XgIgawSMg868PEHQuTzH2nYYXO29Aw0AWwgBi+K5i7rL33sBIQN2DcygXzmX3GWykwYPfynxUUyMUnBI4SgCsEHU/DQKJwAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_GLOBAL_FALLBACK_LOCKTIME.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc68850000000001030402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAEDBAIAAAAAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BCGsCRzBEAiAFJ1pIVzTgrh87lxI3WG8OctyFgz0njA5HTNIxEsD6XgIgawSMg868PEHQuTzH2nYYXO29Aw0AWwgBi+K5i7rL33sBIQN2DcygXzmX3GWykwYPfynxUUyMUnBI4SgCsEHU/DQKJwAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_GLOBAL_INPUT_COUNT.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc68850000000001040102000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAEEAQIAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BCGsCRzBEAiAFJ1pIVzTgrh87lxI3WG8OctyFgz0njA5HTNIxEsD6XgIgawSMg868PEHQuTzH2nYYXO29Aw0AWwgBi+K5i7rL33sBIQN2DcygXzmX3GWykwYPfynxUUyMUnBI4SgCsEHU/DQKJwAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_GLOBAL_OUTPUT_COUNT.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc68850000000001050102000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAEFAQIAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BCGsCRzBEAiAFJ1pIVzTgrh87lxI3WG8OctyFgz0njA5HTNIxEsD6XgIgawSMg868PEHQuTzH2nYYXO29Aw0AWwgBi+K5i7rL33sBIQN2DcygXzmX3GWykwYPfynxUUyMUnBI4SgCsEHU/DQKJwAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_GLOBAL_TX_MODIFIABLE.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc68850000000001060100000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAEGAQAAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BCGsCRzBEAiAFJ1pIVzTgrh87lxI3WG8OctyFgz0njA5HTNIxEsD6XgIgawSMg868PEHQuTzH2nYYXO29Aw0AWwgBi+K5i7rL33sBIQN2DcygXzmX3GWykwYPfynxUUyMUnBI4SgCsEHU/DQKJwAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_IN_PREVIOUS_TXID.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a27010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc800220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gAIgIC1gH4SEamdV93a+AOPZ3o+xCsyTX7g8RfsBYtTK1at5IY9p2HPlQAAIABAACAAAAAgAAAAAAqAAAAACICA27+LCVWIZhlU7qdZcPdxkFlyhQ24FqjWkxusCRRz3ltGPadhz5UAACAAQAAgAAAAIABAAAAYgAAAAA=</pre>\n\n* Case: PSBTv0 but with PSBT_IN_OUTPUT_INDEX.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a27010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_IN_SEQUENCE.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a27011004ffffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonARAE/////wAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_IN_REQUIRED_TIME_LOCKTIME.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a270111048c8dc46200220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonAREEjI3EYgAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_IN_REQUIRED_HEIGHT_LOCKTIME.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a270112041027000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonARIEECcAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAAAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv0 but with PSBT_OUT_AMOUNT.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f00000000002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonACICAtYB+EhGpnVfd2vgDj2d6PsQrMk1+4PEX7AWLUytWreSGPadhz5UAACAAQAAgAAAAIAAAAAAKgAAAAEDCAAIry8AAAAAACICA27+LCVWIZhlU7qdZcPdxkFlyhQ24FqjWkxusCRRz3ltGPadhz5UAACAAQAAgAAAAIABAAAAYgAAAAA=</pre>\n\n* Case: PSBTv0 but with PSBT_OUT_SCRIPT.\n** Bytes in Hex: <pre>70736274ff01007102000000010b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc80000000000feffffff020008af2f00000000160014c430f64c4756da310dbd1a085572ef299926272c8bbdeb0b00000000160014a07dac8ab6ca942d379ed795f835ba71c9cc688500000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e01086b02473044022005275a485734e0ae1f3b971237586f0e72dc85833d278c0e474cd23112c0fa5e02206b048c83cebc3c41d0b93cc7da76185cedbd030d005b08018be2b98bbacbdf7b012103760dcca05f3997dc65b293060f7f29f1514c8c527048e12802b041d4fc340a2700220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000104160014a07dac8ab6ca942d379ed795f835ba71c9cc6885002202036efe2c255621986553ba9d65c3ddc64165ca1436e05aa35a4c6eb02451cf796d18f69d873e540000800100008000000080010000006200000000</pre>\n** Base64 String: <pre>cHNidP8BAHECAAAAAQsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAAAAAAD+////AgAIry8AAAAAFgAUxDD2TEdW2jENvRoIVXLvKZkmJyyLvesLAAAAABYAFKB9rIq2ypQtN57Xlfg1unHJzGiFAAAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEIawJHMEQCIAUnWkhXNOCuHzuXEjdYbw5y3IWDPSeMDkdM0jESwPpeAiBrBIyDzrw8QdC5PMfadhhc7b0DDQBbCAGL4rmLusvfewEhA3YNzKBfOZfcZbKTBg9/KfFRTIxScEjhKAKwQdT8NAonACICAtYB+EhGpnVfd2vgDj2d6PsQrMk1+4PEX7AWLUytWreSGPadhz5UAACAAQAAgAAAAIAAAAAAKgAAAAEEFgAUoH2sirbKlC03nteV+DW6ccnMaIUAIgIDbv4sJVYhmGVTup1lw93GQWXKFDbgWqNaTG6wJFHPeW0Y9p2HPlQAAIABAACAAAAAgAEAAABiAAAAAA==</pre>\n\n* Case: PSBTv2 missing PSBT_GLOBAL_INPUT_COUNT.\n** Bytes in Hex: <pre>70736274ff01020402000000010304000000000105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEFAQIB+wQCAAAAAAEAUgIAAAABwaolbiFLlqGCL5PeQr/ztfP/jQUZMG41FddRWl6AWxIAAAAAAP////8BGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgAAAAABAR8Yxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gBDwQAAAAAARAE/v///wAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: PSBTv2 missing PSBT_GLOBAL_OUTPUT_COUNT.\n** Bytes in Hex: <pre>70736274ff01020402000000010304000000000104010101fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEB+wQCAAAAAAEAUgIAAAABwaolbiFLlqGCL5PeQr/ztfP/jQUZMG41FddRWl6AWxIAAAAAAP////8BGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgAAAAABAR8Yxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gBDwQAAAAAARAE/v///wAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: PSBTv2 missing PSBT_IN_PREVIOUS_TXID.\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010f0400000000011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEBBQECAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEPBAAAAAABEAT+////ACICAtYB+EhGpnVfd2vgDj2d6PsQrMk1+4PEX7AWLUytWreSGPadhz5UAACAAQAAgAAAAIAAAAAAKgAAAAEDCAAIry8AAAAAAQQWABTEMPZMR1baMQ29GghVcu8pmSYnLAAiAgLjb7/1PdU0Bwz4/TlmFGgPNXqbhdtzQL8c+nRdKtezQBj2nYc+VAAAgAEAAIAAAACAAQAAAGQAAAABAwiLvesLAAAAAAEEFgAUTdGTrJZKVqwbnhzKhFT+L0dPhRMA</pre>\n\n* Case: PSBTv2 missing PSBT_IN_OUTPUT_INDEX.\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEBBQECAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IARAE/v///wAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: PSBTv2 missing PSBT_OUT_AMOUNT.\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEBBQECAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAEQBP7///8AIgIC1gH4SEamdV93a+AOPZ3o+xCsyTX7g8RfsBYtTK1at5IY9p2HPlQAAIABAACAAAAAgAAAAAAqAAAAAQQWABTEMPZMR1baMQ29GghVcu8pmSYnLAAiAgLjb7/1PdU0Bwz4/TlmFGgPNXqbhdtzQL8c+nRdKtezQBj2nYc+VAAAgAEAAIAAAACAAQAAAGQAAAABAwiLvesLAAAAAAEEFgAUTdGTrJZKVqwbnhzKhFT+L0dPhRMA</pre>\n\n* Case: PSBTv2 missing PSBT_OUT_SCRIPT.\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f0000000000220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEBBQECAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAEQBP7///8AIgIC1gH4SEamdV93a+AOPZ3o+xCsyTX7g8RfsBYtTK1at5IY9p2HPlQAAIABAACAAAAAgAAAAAAqAAAAAQMIAAivLwAAAAAAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: PSBTv2 with PSBT_IN_REQUIRED_TIME_LOCKTIME less than 500000000.\n** Bytes in Hex: <pre>70736274ff01020402000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011104ff64cd1d00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIB+wQCAAAAAAEAUgIAAAABwaolbiFLlqGCL5PeQr/ztfP/jQUZMG41FddRWl6AWxIAAAAAAP////8BGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgAAAAABAR8Yxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gBDwQAAAAAAREE/2TNHQAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: PSBTv2 with PSBT_IN_REQUIRED_HEIGHT_LOCKTIME greater than or equal to 500000000.\n** Bytes in Hex: <pre>70736274ff01020402000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f04000000000112040065cd1d00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIB+wQCAAAAAAEAUgIAAAABwaolbiFLlqGCL5PeQr/ztfP/jQUZMG41FddRWl6AWxIAAAAAAP////8BGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgAAAAABAR8Yxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gBDwQAAAAAARIEAGXNHQAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\nThe following are valid PSBTs\n\n* Case: 1 input, 2 output PSBTv2, required fields only.\n** Bytes in Hex: <pre>70736274ff01020402000000010401010105010201fb040200000000010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIB+wQCAAAAAAEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2.\n** Bytes in HEx: <pre>70736274ff01020402000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIB+wQCAAAAAAEAUgIAAAABwaolbiFLlqGCL5PeQr/ztfP/jQUZMG41FddRWl6AWxIAAAAAAP////8BGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgAAAAABAR8Yxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gBDwQAAAAAACICAtYB+EhGpnVfd2vgDj2d6PsQrMk1+4PEX7AWLUytWreSGPadhz5UAACAAQAAgAAAAIAAAAAAKgAAAAEDCAAIry8AAAAAAQQWABTEMPZMR1baMQ29GghVcu8pmSYnLAAiAgLjb7/1PdU0Bwz4/TlmFGgPNXqbhdtzQL8c+nRdKtezQBj2nYc+VAAAgAEAAIAAAACAAQAAAGQAAAABAwiLvesLAAAAAAEEFgAUTdGTrJZKVqwbnhzKhFT+L0dPhRMA</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with PSBT_IN_SEQUENCE.\n** Bytes in Hex: <pre>70736274ff01020402000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff00220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIB+wQCAAAAAAEAUgIAAAABwaolbiFLlqGCL5PeQr/ztfP/jQUZMG41FddRWl6AWxIAAAAAAP////8BGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgAAAAABAR8Yxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAQ4gCwrZIUGcHIcZc11y3HOfnqngY40f5MHu8PmUQISBX8gBDwQAAAAAARAE/v///wAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with PSBT_IN_SEQUENCE, and all locktime fields\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401010105010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff0111048c8dc4620112041027000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEBBQECAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAEQBP7///8BEQSMjcRiARIEECcAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with Inputs Modifiable Flag (bit 0) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010101fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEBAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with Outputs Modifiable Flag (bit 1) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010201fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgECAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with Has SIGHASH_SINGLE Flag (bit 2) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010401fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEEAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with an undefined flag (bit 3) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010801fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEIAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with both Inputs Modifiable Flag (bit 0) and Outputs Modifiable Flag (bit 1) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010301fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEDAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with both Inputs Modifiable Flag (bit 0) and Has SIGHASH_SINGLE Flag (bit 2) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010501fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEFAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with both Outputs Modifiable Flag (bit 1) and Has SIGHASH_SINGLE FLag (bit 2) of PSBT_GLOBAL_TX_MODIFIABLE set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010601fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEGAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with all defined PSBT_GLOBAL_TX_MODIFIABLE flags set\n** Bytes in Hex: <pre>70736274ff0102040200000001040101010501020106010701fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgEHAfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with all possible PSBT_GLOBAL_TX_MODIFIABLE flags set\n** Bytes in Hex: <pre>70736274ff010204020000000104010101050102010601ff01fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f040000000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIBBgH/AfsEAgAAAAABAFICAAAAAcGqJW4hS5ahgi+T3kK/87Xz/40FGTBuNRXXUVpegFsSAAAAAAD/////ARjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4AAAAAAQEfGMaaOwAAAAAWABSwo68UQghBJpPKfRZoUrUtsK7wbgEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAAiAgLWAfhIRqZ1X3dr4A49nej7EKzJNfuDxF+wFi1MrVq3khj2nYc+VAAAgAEAAIAAAACAAAAAACoAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAIgIC42+/9T3VNAcM+P05ZhRoDzV6m4Xbc0C/HPp0XSrXs0AY9p2HPlQAAIABAACAAAAAgAEAAABkAAAAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: 1 input, 2 output updated PSBTv2, with all PSBTv2 fields\n** Bytes in Hex: <pre>70736274ff010204020000000103040000000001040101010501020106010701fb0402000000000100520200000001c1aa256e214b96a1822f93de42bff3b5f3ff8d0519306e3515d7515a5e805b120000000000ffffffff0118c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e0000000001011f18c69a3b00000000160014b0a3af144208412693ca7d166852b52db0aef06e010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000011004feffffff0111048c8dc4620112041027000000220202d601f84846a6755f776be00e3d9de8fb10acc935fb83c45fb0162d4cad5ab79218f69d873e540000800100008000000080000000002a0000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c00220202e36fbff53dd534070cf8fd396614680f357a9b85db7340bf1cfa745d2ad7b34018f69d873e54000080010000800000008001000000640000000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQEBBQECAQYBBwH7BAIAAAAAAQBSAgAAAAHBqiVuIUuWoYIvk95Cv/O18/+NBRkwbjUV11FaXoBbEgAAAAAA/////wEYxpo7AAAAABYAFLCjrxRCCEEmk8p9FmhStS2wrvBuAAAAAAEBHxjGmjsAAAAAFgAUsKOvFEIIQSaTyn0WaFK1LbCu8G4BDiALCtkhQZwchxlzXXLcc5+eqeBjjR/kwe7w+ZRAhIFfyAEPBAAAAAABEAT+////AREEjI3EYgESBBAnAAAAIgIC1gH4SEamdV93a+AOPZ3o+xCsyTX7g8RfsBYtTK1at5IY9p2HPlQAAIABAACAAAAAgAAAAAAqAAAAAQMIAAivLwAAAAABBBYAFMQw9kxHVtoxDb0aCFVy7ymZJicsACICAuNvv/U91TQHDPj9OWYUaA81epuF23NAvxz6dF0q17NAGPadhz5UAACAAQAAgAAAAIABAAAAZAAAAAEDCIu96wsAAAAAAQQWABRN0ZOslkpWrBueHMqEVP4vR0+FEwA=</pre>\n\nThe following tests are the timelock determination algorithm.\n\nThe timelock for the following PSBTs should be computed to be 0:\n\n* Case: No locktimes specified\n** Bytes in Hex: <pre>70736274ff01020402000000010401010105010201fb040200000000010e200b0ad921419c1c8719735d72dc739f9ea9e0638d1fe4c1eef0f9944084815fc8010f0400000000000103080008af2f000000000104160014c430f64c4756da310dbd1a085572ef299926272c000103088bbdeb0b0000000001041600144dd193ac964a56ac1b9e1cca8454fe2f474f851300</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQQBAQEFAQIB+wQCAAAAAAEOIAsK2SFBnByHGXNdctxzn56p4GONH+TB7vD5lECEgV/IAQ8EAAAAAAABAwgACK8vAAAAAAEEFgAUxDD2TEdW2jENvRoIVXLvKZkmJywAAQMIi73rCwAAAAABBBYAFE3Rk6yWSlasG54cyoRU/i9HT4UTAA==</pre>\n\n* Case: Fallback locktime of 0\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f040100000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f0400000000000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAAAAQ4gOhs7PIN9ZInqejHY5sfdUDwAG+8+BpWOdXSAjWjKeKUBDwQAAAAAAAEDCE+TNXcAAAAAAQQWABQLE1LKzQPPaqG388jWOIZxs0peEQA=</pre>\n\nThe timelock for the following PSBTs should be computed to be 10000:\n\n* Case: Input 1 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 10000, Input 2 has no locktime fields\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000112041027000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f0400000000000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEgQQJwAAAAEOIDobOzyDfWSJ6nox2ObH3VA8ABvvPgaVjnV0gI1oynilAQ8EAAAAAAABAwhPkzV3AAAAAAEEFgAUCxNSys0Dz2qht/PI1jiGcbNKXhEA</pre>\n\n* Case: Input 1 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 10000, Input 2 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 9000\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000112041027000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f040000000001120428230000000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEgQQJwAAAAEOIDobOzyDfWSJ6nox2ObH3VA8ABvvPgaVjnV0gI1oynilAQ8EAAAAAAESBCgjAAAAAQMIT5M1dwAAAAABBBYAFAsTUsrNA89qobfzyNY4hnGzSl4RAA==</pre>\n\n* Case: Input 1 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 10000, Input 2 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 9000 and PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048460\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000112041027000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f04000000000111048c8dc46201120428230000000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEgQQJwAAAAEOIDobOzyDfWSJ6nox2ObH3VA8ABvvPgaVjnV0gI1oynilAQ8EAAAAAAERBIyNxGIBEgQoIwAAAAEDCE+TNXcAAAAAAQQWABQLE1LKzQPPaqG388jWOIZxs0peEQA=</pre>\n\n* Case: Input 1 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 10000 and PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048459, Input 2 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 9000 and PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048460\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000111048b8dc4620112041027000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f04000000000111048c8dc46201120428230000000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEQSLjcRiARIEECcAAAABDiA6Gzs8g31kiep6Mdjmx91QPAAb7z4GlY51dICNaMp4pQEPBAAAAAABEQSMjcRiARIEKCMAAAABAwhPkzV3AAAAAAEEFgAUCxNSys0Dz2qht/PI1jiGcbNKXhEA</pre>\n\nThe timelock for the following PSBTs should be computed to be 1657048460:\n\n* Case: Input 1 has PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048459, Input 2 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 9000 and PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048460\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000111048b8dc46200010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f04000000000111048c8dc46201120428230000000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEQSLjcRiAAEOIDobOzyDfWSJ6nox2ObH3VA8ABvvPgaVjnV0gI1oynilAQ8EAAAAAAERBIyNxGIBEgQoIwAAAAEDCE+TNXcAAAAAAQQWABQLE1LKzQPPaqG388jWOIZxs0peEQA=</pre>\n\n* Case: Input 1 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 10000 and PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048459, Input 2 has PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048460\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000111048b8dc4620112041027000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f04000000000111048c8dc462000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEQSLjcRiARIEECcAAAABDiA6Gzs8g31kiep6Mdjmx91QPAAb7z4GlY51dICNaMp4pQEPBAAAAAABEQSMjcRiAAEDCE+TNXcAAAAAAQQWABQLE1LKzQPPaqG388jWOIZxs0peEQA=</pre>\n\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f040100000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f04000000000111048c8dc462000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAAAAQ4gOhs7PIN9ZInqejHY5sfdUDwAG+8+BpWOdXSAjWjKeKUBDwQAAAAAAREEjI3EYgABAwhPkzV3AAAAAAEEFgAUCxNSys0Dz2qht/PI1jiGcbNKXhEA</pre>\n\nThe timelock for the following PSBTs cannot be computed:\n\n* Case: Input 1 has PSBT_IN_REQUIRED_HEIGHT_LOCKTIME of 10000, Input 2 has PSBT_IN_REQUIRED_TIME_LOCKTIME of 1657048460\n** Bytes in Hex: <pre>70736274ff0102040200000001030400000000010401020105010101fb040200000000010e200f758dbfbd4da7c16c8a3309c3c81e1100f561ea646db5b01752c485e1bdde9f010f04010000000112041027000000010e203a1b3b3c837d6489ea7a31d8e6c7dd503c001bef3e06958e7574808d68ca78a5010f04000000000111048c8dc462000103084f9335770000000001041600140b1352cacd03cf6aa1b7f3c8d6388671b34a5e1100</pre>\n** Base64 String: <pre>cHNidP8BAgQCAAAAAQMEAAAAAAEEAQIBBQEBAfsEAgAAAAABDiAPdY2/vU2nwWyKMwnDyB4RAPVh6mRttbAXUsSF4b3enwEPBAEAAAABEgQQJwAAAAEOIDobOzyDfWSJ6nox2ObH3VA8ABvvPgaVjnV0gI1oynilAQ8EAAAAAAERBIyNxGIAAQMIT5M1dwAAAAABBBYAFAsTUsrNA89qobfzyNY4hnGzSl4RAA==</pre>\n\n==Rationale==\n\n<references/>\n\n==Reference implementation==\n\nThe reference implementation of the PSBT format is available in [https://github.com/bitcoin/bitcoin/pull/21283 Bitcoin Core PR 21283].\n", "content_length": 75008}
{"bip_number": 353, "filename": "bip-0353.mediawiki", "content": "<pre>\n  BIP: 353\n  Layer: Applications\n  Title: DNS Payment Instructions\n  Author: Matt Corallo <bip353@bluematt.me>\n          Bastien Teinturier <bastien@acinq.fr>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0353\n  Status: Proposed\n  Type: Standards Track\n  Created: 2024-02-10\n  License: CC0-1.0\n  Post-History: 2024-02-13: https://groups.google.com/g/bitcoindev/c/uATaflkYglQ [bitcoin-dev] Mapping Human-Readable Names to Payment Instructions\n</pre>\n\n\n==Copyright==\n\nThis BIP is licensed under the CC0-1.0 license.\n\n==Abstract==\nThis BIP proposes a standard format for encoding [[bip-0021.mediawiki|BIP 21]] URI schemes in DNS TXT records.\n\n==Motivation==\nVarious Bitcoin and other cryptocurrency applications have developed human-readable names for payment instructions over time, with marketplace adoption signaling strong demand for it from users.\n\nThe DNS provides a standard, global, hierarchical namespace mapping human-readable labels to records of various forms. Using DNSSEC, the DNS provides cryptographic guarantees using a straightforward PKI which follows the hierarchical nature of the DNS, allowing for stateless and even offline validation of DNS records from a single trusted root.\n\nFurther, because DNS queries are generally proxied through ISP-provided or other resolvers, DNS queries usually do not directly expose the queryer's IP address. Further, because of the prevalence of open resolvers, the simplicity of the protocol, and broad availability of DNS recursive resolver implementations, finding a proxy for DNS records is trivial.\n\nThus, using TXT records to store Bitcoin payment instructions allows for human-readable Bitcoin payment destinations which can be trivially verified on hardware wallets and which can be resolved relatively privately.\n\n==Specification==\n\n=== General rules for handling ===\nBitcoin wallets MUST NOT prefer to use DNS-based resolving when methods with explicit public keys or addresses are available. In other words, if a standard Bitcoin address or direct BIP 21 URI is available or would suffice, Bitcoin wallets MUST prefer to use that instead.\n\n=== Records ===\nPayment instructions are indexed by both a user and a domain. Instructions for a given <code>user</code> and <code>domain</code> are stored at <code>user</code>.user._bitcoin-payment.<code>domain</code> in a single TXT RR.\n\nThe TXT RR\u2019s RDATA <b>MUST</b> consist of one or more DNS <code><character-string></code>s (see [[https://www.rfc-editor.org/rfc/rfc1035#section-3.3.14|RFC&nbsp;1035&nbsp;\u00a73.3.14]]), each \u2264255 bytes.\n\nAll payment instructions MUST be DNSSEC-signed.\n\nPayment instructions MAY resolve through CNAME or DNAME records as long as all such records and the ultimate records pointed to by them are DNSSEC signed.\n\nUser and domain names which are not expressible using standard printable ASCII MUST be encoded using the punycode IDN encoding defined in [[https://datatracker.ietf.org/doc/html/rfc3492|RFC 3492]] and [[https://datatracker.ietf.org/doc/html/rfc5891|RFC 5891]].\n\nNote that because resolvers are not required to support resolving non-ASCII identifiers, wallets SHOULD avoid using non-ASCII identifiers.\n\nFor payment instructions that have a built-in expiry time (e.g. Lightning BOLT 12 offers), care must be taken to ensure that the DNS records expire prior to the expiry of the payment instructions. Otherwise, senders may have payment instructions cached locally which have expired, preventing payment.\n\n=== Resolution ===\n\nClients resolving Bitcoin payment instructions MUST ignore any TXT records at the same label which do not begin with (ignoring case) \"bitcoin:\". Resolvers encountering multiple \"bitcoin:\"-matching TXT records at the same label MUST treat the records as invalid and refuse to use any payment instructions therein.\n\nClients resolving Bitcoin payment instructions <b>MUST</b> reconstruct the <code>bitcoin:</code> URI by concatenating the TXT RR\u2019s <code><character-string></code> fields in <b>RDATA order</b>, without inserting separators, before parsing.<ref>DNS TXT RDATA consists of one or more length-prefixed strings with a maximum of 255 bytes of content; see RFC&nbsp;1035&nbsp;\u00a73.3.14.</ref>\n\nClients <b>MUST NOT</b> concatenate across multiple TXT RRs at the same owner name.\n\nClients resolving Bitcoin payment instructions MUST fully validate DNSSEC signatures leading to the DNS root (including any relevant CNAME or DNAME records) and MUST NOT accept DNSSEC signatures which use SHA-1 or RSA with keys shorter than 1024 bits. Resolvers MAY accept SHA-1 DS records.\n\nClients resolving Bitcoin payment instructions MUST NOT trust a remote resolver to validate DNSSEC records on their behalf.\n\nClients resolving Bitcoin payment instructions MUST support resolving through CNAME or DNAME records.\n\nResolvers MAY support resolving non-ASCII user and domain identifiers. Resolvers which do support non-ASCII user and domain identifiers MUST take precautions to prevent homograph attacks and SHOULD consider denying paste functionality when entering non-ASCII identifiers. Wallets which do not take any such precautions MUST instead display non-ASCII user and domain identifiers using their raw punycode. As such, wallets SHOULD NOT create identifiers which are not entirely printable ASCII.\n\nWhile clients MAY cache the payment instructions they receive from the DNS, clients MUST NOT cache the payment instructions received from the DNS for longer than the TTL provided by their DNS resolver, and further MUST NOT cache the payment instructions for longer than the lowest initial TTL (which is signed as a part of DNSSEC signatures) received in the full DNSSEC chain leading from the DNS root to the resolved TXT record.\n\n=== Address Reuse ===\n\nPayment instructions with on-chain addresses which will be re-used SHOULD be rotated as regularly as possible to reduce address reuse. Such payment instructions SHOULD also use a relatively short DNS TTL to ensure regular rotation takes effect quickly. In cases where this is not practical, payment instructions SHOULD NOT contain on-chain addresses (i.e. the URI path SHOULD be empty).\n\nPayment instructions which do contain on-chain addresses which will be re-used SHOULD be rotated after any transaction to such an address is confirmed on-chain.\n\n=== Display ===\n\nWhen displaying a verified human-readable name, wallets SHOULD prefix it with \u20bf, i.e. \u20bf<code>user</code>@<code>domain</code>. They SHOULD parse recipient information in both <code>user</code>@<code>domain</code> and \u20bf<code>user</code>@<code>domain</code> forms and resolve such an entry into recipient information using the above record. For the avoidance of doubt, the \u20bf is *not* included in the DNS label which is resolved.\n\nWallets providing the ability for users to \"copy\" their address information SHOULD copy the underlying URI directly, rather than the human-readable name. This avoids an additional DNS lookup by the application in which it is pasted. Wallets that nevertheless provide users the ability to copy their human-readable name, MUST include the \u20bf prefix (i.e. copy it in the form \u20bf<code>user</code>@<code>domain</code>).\n\nWallets accepting payment information from external devices (e.g. hardware wallets) SHOULD accept RFC 9102-formatted proofs (as a series of unsorted <code>AuthenticationChain</code> records) and, if verification succeeds, SHOULD display the recipient in the form \u20bf<code>user</code>@<code>domain</code>.\n\n=== PSBT types ===\n\nWallets accepting payment information from external devices (e.g. hardware wallets) MAY examine the following per-output PSBT fields to fetch RFC 9102-formatted proofs. Wallets creating PSBTs with recipient information derived from human-readable names SHOULD include the following fields.\n\nWhen validating the contained proof, clients MUST enforce the inception on all contained RRSigs is no later than the current time and that the expiry of all RRSigs is no earlier than an hour in the past. Clients MAY allow for an expiry up to an hour in the past to allow for delays between PSBT construction and signing only if such a delay is likely to occur in their intended usecase.\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n|-\n| BIP 353 DNSSEC proof\n| <tt>PSBT_OUT_DNSSEC_PROOF = 0x35</tt>\n| None\n| <tt><1-byte-length-prefixed BIP 353 human-readable name without the \u20bf prefix><RFC 9102-formatted DNSSEC Proof></tt>\n| A BIP 353 human-readable name (without the \u20bf prefix), prefixed by a 1-byte length.\nFollowed by an [[https://www.rfc-editor.org/rfc/rfc9102.html#name-dnssec-authentication-chain|RFC 9102 DNSSEC <tt>AuthenticationChain</tt>]] (i.e. a series of DNS Resource Records in no particular order) providing a DNSSEC proof to a BIP 353 DNS TXT record.\n|\n|\n| 0, 2\n|}\n\n== Rationale ==\n\n=== Display ===\n\nThere are several ways in which human-readable payment instructions could be displayed in wallets. In order to ensure compatibility with existing human-readable names schemes, @ is used as the separator between the <code>user</code> and <code>domain</code> parts. However, simply using the @ separator can lead to confusion between email addresses on a given domain and payment instructions on a domain. In order to somewhat reduce the incidence of such confusion, a \u20bf prefix is used.\n\n=== Rotation ===\n\nOn-chain addresses which are re-used (i.e. not including schemes like [[bip-0352.mediawiki|Silent Payments]]) need to be rotated to avoid contributing substantially to address reuse. However, rotating them on a timer or any time a transaction enters the mempool could lead to substantial overhead from excess address generation. Instead, rotating addresses any time a transaction is confirmed on-chain ensures address rotation happens often while bounding the maximum number of addresses needed to one per block, which grows very slowly and will not generate an address set too large to handle while scanning the chain going forward.\n\n=== Alternatives ===\nThere are many existing schemes to resolve human-readable names to cryptocurrency payment instructions. Sadly, these current schemes suffer from a myriad of drawbacks, including (a) lacking succinct proofs of namespace to public key mappings, (b) revealing sender IP addresses to recipients or other intermediaries as a side-effect of payment, (c) relying on the bloated TLS Certificate Authority infrastructure, or (d) lacking open access, not allowing anyone to create a namespace mapping.\n\n==== DNS Rather than blockchain-based solutions ====\nThere are many blockchain-based alternatives to the DNS which feature better censorship-resistance and, in many cases, security. However, here we chose to use the standard ICANN-managed DNS namespace as many blockchain-based schemes suffer from (a), above (though in some cases this could be addressed with cryptographic SNARK schemes). Further, because they do not have simple client-side querying ability, many of these schemes use trusted intermediaries which resolve names on behalf of clients. This reintroduces drawbacks (b) and often (c) as well.\n\nFinally, it is worth noting that none of the blockchain-based alternatives to the DNS have had material adoption outside of their specific silos, and committing Bitcoin wallets to rely on a separate system which doesn't see broad adoption may not be sustainable.\n\n==== DNS Rather than HTTP-based solutions ====\nHTTP(s)-based payment instruction resolution protocols suffer from drawbacks (a), (b), and (c), above, and generally shouldn't be considered a serious alternative for payment instruction resolution.\n\n==== Private DNS Querying ====\nWhile public recursive DNS resolvers are very common (e.g. 1.1.1.1, 8.8.8.8, and 9.9.9.9), using such resolvers directly (even after validating DNSSEC signatures) introduces drawback (b), at least in regard to a centralized intermediary. Resolving payment instructions recursively locally using a resolver on the same local network or in the paying application would instead introduce drawback (b) directly to the recipient, which may well be worse.\n\nFor payers not using VPN or other proxying technologies, they generally trust their ISP to not snoop on their DNS requests anyway, so using ISP-provided recursive DNS resolvers is likely the best option.\n\nHowever, for the best privacy, payers are encouraged to perform DNS resolution over Tor or another VPN technology.\n\nLightning payers should consider utilizing DNS resolution over native onion messages, using the protocol described in [[https://github.com/lightning/blips/blob/master/blip-0032.md|BLIP 32]]\n\n=== DNS Enumeration ===\n\nIn most cases where payments are accepted from any third-party, user enumeration is practical by simply attempting to send small value payments to a list of possible user names. However, storing all valid users in the DNS directly may make such enumeration marginally more practical. Thus, those wishing to avoid such enumeration should carefully ensure all DNS names return valid payment instructions. Note when doing so that wildcard records are identified as such by the DNSSEC RRSIG labels counter and are differentiable from non-wildcard records.\n\n== Backwards Compatibility ==\n\nThis work is intended to extend and subsume the existing \"Lightning Address\" scheme, which maps similar names (without the \u20bf prefix) using HTTPS servers to Lightning BOLT 11 payment instructions. Wallets implementing this scheme MAY fall back to existing \"Lightning Address\" logic if DNS resolution fails but SHOULD NOT do so after this scheme is sufficiently broadly deployed to avoid leaking sender IP address information.\n\n== Examples ==\n\n<code>matt@mattcorallo.com</code> resolves to\n\n<pre>matt.user._bitcoin-payment.mattcorallo.com. 1800 IN TXT  \"bitcoin:?lno=lno1qsgr30k45jhvkfqxjqheaetac\nu4guyxvqttftvqu0f5sneckep3lkwdut7mmhhpcyjmlmnjn4hze8ed7pq88xqkxt2dcw5mlxhz644fms82f7k4ymfxs2ehhpjtxw\nxly0w5k8xdtlvpqyd8xzdq4tq8lgupnueshgydr330lc3j5kdcqh54gt7jdg9n68j4eqqeu7ts8uh0qxamee6ndj37tc6mzgejth\nvvjqj96p8dz2h\" \"rsh5z5n27qfk6svjz5pmkh0smq26k0j2j4q36xgq3r5qzet9kuhq4lydpen5mskxgjdvs5faqgv8pmj7cfd7\nny84djksqpqk9ky6juc7fpezecxvg7sjx05dckyypnv9tmvfp6tkpehmtaqmvuupetxuzqf4t0azddjdcpasgw6hxuz9g\"\n</pre>\n\n* Note that <code>lno</code> indicates a value containing a lightning BOLT12 offer.\n* Note that the complete URI is broken into two strings with maximum 255 characters each\n\n=== Example proofs ===\n\nThe following are valid DNSSEC proofs to be included in the <code>PSBT_OUT_DNSSEC_PROOF</code> record in a PSBT.\n\nThis encodes address <tt>bc1qztwy6xen3zdtt7z0vrgapmjtfz8acjkfp5fp7l</tt> to <tt>simple@dnssec_proof_tests.bitcoin.ninja</tt> valid on August 7, 2025. Note that the second TXT record (which does not start with, case insensitively, \"bitcoin:\") is ignored.\n<tt>2773696d706c6540646e737365635f70726f6f665f74657374732e626974636f696e2e6e696e6a610673696d706c650475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100001000010000001e001110626974636f696e20697320636f6f6c210673696d706c650475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100001000010000001e003736626974636f696e3a3f62633d626331717a7477793678656e337a647474377a3076726761706d6a74667a3861636a6b6670356670376c0673696d706c650475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100002e00010000001e006100100d060000001e68a70b7e68948166d0e207626974636f696e056e696e6a61007e51ba5c43c4d18dc62a54d4647d1fcf2cfa594cd6bfddfe834c7b9bc6f1849490972441ea34283c6c7dbab3ed783deabebb3f1081ade02e57795a85220051bc07626974636f696e056e696e6a6100003000010001614500440100030dff753a27b08c3e48a642b210d6fcc444ff9ed4faf9c1241103db4ed3c19a95c3afbb52c0c02eb392ee048cc9e28ac2d272b1053bdc052bc18d5de05d7710196c07626974636f696e056e696e6a6100003000010001614500440101030df65551925ce6321888e685981823d617fbc10f329bffe4081bf18c2372632a5548010bf62e6556a92722629275e0bd001e3d7837d325a353f6a851c5b965259607626974636f696e056e696e6a6100002e000100016145006100300d0200093a806898c73468863d1c716c07626974636f696e056e696e6a610002fd1bf18c2ebb5ece5e28ca76bf30650695636c55633bccae8179c2d1ee7b97e78d188e08ffc869a8f67847bf557516ac12465ebea1acc281d6d636fdab612007626974636f696e056e696e6a6100002b000100000cfc0024716c0d023f7ad5a303e9c1cd1474b8df2ae56f3f82da8637ca55db4d9a2bb85960ca698e07626974636f696e056e696e6a6100002b000100000cfc0024768a0d02ce46a9aff9a06e789c1bdfe250b0ef6ba8d39a53b2a3427c551f5ad375e059b607626974636f696e056e696e6a6100002e000100000cfc0099002b080200000e1068a89268688cd4d892dc056e696e6a61004d88897d7d5f5d920ca436e81ee67b1bb22f1a96309693454ab9d0b06434794162cc42846a4b51a40475a5b44e940c04dd1ac2c902a190ca2251ae89184520b0f3f22c12c51403d0a6e1cd95792e8f6f5036cd2d50dbdfa5eba3b2ee70ff78d40dc2eba2cc899af26954a55e5b5d344d478cabd9423418495caee45c550b1144056e696e6a61000030000100000cfc0088010003080301000197edb59d4f181e2761dd8d0465854339afc71fd89e47155981ddd175cdce79477552aeaf7b5a08fc4ac6025555f60582f2060e630edfb35b9c7cc30990fb9c3dc9f2fd036c962f67b94c9670d4ceaacd77973bca82ab7c9615f7e4320dda5b6d74dec673017c6fa448b5542a804e08ac873c509c1945ff734c320491e4b18e6d056e696e6a61000030000100000cfc01080101030803010001c71e4c9dc49249a27b3ef42fcb8d56b4c3ac76715c7ad01c41d0d432590d15c3c62cee4b2d29ac35f2d72c9b32a70a0243cbd08aeebc9f6f1e0e63d9e1cdfe133c455a82435c0780b750012c942f7ed5b662eec8d9ae885a58993fa78d7561fedcd11d9e1c171acb02d0025837ba61a3c0a6756427414470c9ca0906b298168b5f4d9640e62e1b75dd06be664104ed32cfe447fa21f37401712c720a0dca4bb1bc20f3fa3103cad336bde20b16f73948e6b80dda0a528db536a958868c3870ecddcfb02dfb3cb4d22e2ad49a4b9f78c90ff6c7e10e301b3fb36fe859a94c30084660665741c14ff60d0535013fcf439840ecad82fc9278e4ace68ba95e708249056e696e6a61000030000100000cfc00880100030803010001d28cb7e2bb163d5815838bedeca1006dde8551b379cb963c8a2cb42bc360127e3a5cf88ffc851a67414815b875f65d78c39b58d2fb29a1d4e76d50cb6b4a58a11fe2fb7c1b6db7bf7d72f5a1401e381c57fcc76f599cc73f05095d2bd14d9895e4fa1cff21bd760598a734b640102d11bc159c6b2ae73dbfd2741518142584d1056e696e6a6100002e000100000cfc01190030080100000e1068a89268688cd4d8b402056e696e6a6100646e04cf5f76daa775ff98905ded3d2caad68d3198fc161340d558262c7ba7da28e7538a7f32d5a6485e4448037e8edf55759b7059fdc084f1017f790aa7c0d8f0e4af6c9af04e4afd16ce6052c30da59314c9c98075fd32bb77a81f34bea6190631b9d0a4351a764c14152ea217e6271647bf95b0df4c3d7cc00937bec01b65ad1b5209c976a4843e399f173f196a012c0876bc9afa3457d940d6ad7b9d50b3d496836d7342cf3aec75ac4785563e20574ddd2dab1cfb6b5da32508edf7186aa516b0451b221251652ee44353710cbe35928b79fff4293c5e8eff7ab371ce43595e2300305bda0108b911c3ef7d4d15c70d68686fddf28422d5fcbcdb967e84056e696e6a6100002b0001000151800024b4020802c8f816a7a575bdb2f997f682aab2653ba2cb5eddb69b036a30742a33befaf141056e696e6a6100002e0001000151800113002b08010001518068a55650689424c0b569007f4d7bbce2d77380e115f8469a3c6d1d4bd9be1145eeee843332f1d54da134a25f7d259ccfa36a2e833106139ba37bc28651b7717dabfc8c450e889c5d5d6d39d12f1004252fa08692794af4a7f29a94f6611f9b000ba899d90d6a32e91c54e63720811546b251fb265b7f62615391ab330f83a96841f0367347e67522112f63f3efda891ae0f7265ed5b89673f184027cdb9b5e94b16a9b1f99877cc8e078abf246cad1f76a48a34474977dbd89dd3b41f381df89a82e2939aeb06830f656253e4e347cd04ee6dba0c8377e818f919f80a7e6aefa0f8196d04845bc26b498b0115022ff75e363711e55337de505e50df69b840699160467516d15e8235aa4cf00003000010002a30001080100030803010001b11b182a464c3adc6535aa59613bda7a61cac86945c20b773095941194f4b9f516e8bd924b1e50e3fe83918b51e54529d4e5a1e45303df8462241d5e05979979ae5bf9c6c598c08a496e17f3bd3732d5aebe62667b61db1bbe178f27ac99408165a230d6aee78348e6c67789541f845b2ada96667f8dd16ae44f9e260c4a138b3bb1015965ebe609434a06464bd7d29bac47c3017e83c0f89bca1a9e3bdd0813715f3484292df589bc632e27d37efc02837cb85d770d5bd53a36edc99a8294771aa93cf22406f5506c8cf850ed85c1a475dee5c2d3700b3f5631d903524b849995c20cb407ed411f70b428ae3d642716fe239335aa961a752e67fb6dca0bf72900003000010002a30001080101030803010001af7a8deba49d995a792aefc80263e991efdbc86138a931deb2c65d5682eab5d3b03738e3dfdc89d96da64c86c0224d9ce02514d285da3068b19054e5e787b2969058e98e12566c8c808c40c0b769e1db1a24a1bd9b31e303184a31fc7bb56b85bbba8abc02cd5040a444a36d47695969849e16ad856bb58e8fac8855224400319bdab224d83fc0e66aab32ff74bfeaf0f91c454e6850a1295207bbd4cdde8f6ffb08faa9755c2e3284efa01f99393e18786cb132f1e66ebc6517318e1ce8a3b7337ebb54d035ab57d9706ecd9350d4afacd825e43c8668eece89819caf6817af62dc4fbd82f0e33f6647b2b6bda175f14607f59f4635451e6b27df282ef73d8700003000010002a30001080101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b500003000010002a30001080100030803010001b6aec4b48567e2925a2d9c4fa4c96e6dddf86215a9bd8dd579c38ccb1199ed1be89946a7f72fc2633909a2792d0eed1b5afb2ee4c78d865a76d6cd9369d999c96af6be0a2274b8f2e9e0a0065bd20257570f08bc14c16f5616426881a83dbce6926e391c138a2ec317efa7349264de2e791c9b7d4a6048ee6eedf27bf1ece398ff0d229f18377cb1f6b98d1228ef217b8146c0c73851b89a6fc37c621ca187e16428a743ffea0072e185ef93e39525cee3ad01e0c94d2e511c8c313322c29ab91631e1856049a36898684c3056e5997473816fb547acb0be6e660bdfa89a5cb28b3669d8625f3f018c7b3b8a4860e774ee8261811ce7f96c461bc162c1a374f300002e00010002a3000113003008000002a30068a66180688ab2004f66007d114bf33e6d20e7588fdfde9a9e2a8ebd5593ce8bc06419e1d1a4afa8766abc1626504ea6243ca5fc9bce55a3f03c0e7eb488409690d84c3beb30f299da007ab69299d0e203c5b44b94328248768089a9b68982650e9ca2d37526307cbd9f06690e58c3c4a1703b1d1193ea0501417944b937b593294e339571eec42a3c700ce075d9c446e5d32bf979396c1c7935f69bd7df2826567fe582a3615d6095368be991b1e5dc39c0af3b0c39e0e353bbcb928e52e886193ac88da0cd8665ea992b642975aa5486f2e6514d0b5086c66ddd58fe8f7a27ecb128211e3ca1bdc4cad91f3cc9b63c526ebaea86075318e33bfc5a53c919e6f01262b24d178eb2cd04b1</tt>\n\nThis encodes address <tt>BC1QYYQ734DCNHHCWYW8YJXSWXG4P7K9NXU0QT84QZ</tt> to <tt>override.x_domain_cname_wild@dnssec_proof_tests.bitcoin.ninja</tt> valid on August 6, 2025.\n<tt>3d6f766572726964652e785f646f6d61696e5f636e616d655f77696c6440646e737365635f70726f6f665f74657374732e626974636f696e2e6e696e6a61086f7665727269646513785f646f6d61696e5f636e616d655f77696c640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100001000010000001e003736424954434f494e3a3f42433d4243315159595137333444434e48484357595738594a58535758473450374b394e58553051543834515a086f7665727269646513785f646f6d61696e5f636e616d655f77696c640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100002e00010000001e006100100d070000001e68a5c51b68933b03d0e207626974636f696e056e696e6a61002076be9a243f968dad8a1fff2bce554e231998ca4e943a525a4ceb1d9cda053f7e95c4ca9e3fd5e9bd3af44b2d049c42a4f2f8fd273c9fb068267d6b9d69a2dc07626974636f696e056e696e6a6100003000010002a62900440100030dff753a27b08c3e48a642b210d6fcc444ff9ed4faf9c1241103db4ed3c19a95c3afbb52c0c02eb392ee048cc9e28ac2d272b1053bdc052bc18d5de05d7710196c07626974636f696e056e696e6a6100003000010002a62900440101030df65551925ce6321888e685981823d617fbc10f329bffe4081bf18c2372632a5548010bf62e6556a92722629275e0bd001e3d7837d325a353f6a851c5b965259607626974636f696e056e696e6a6100002e00010002a629006100300d0200093a806898c73468863d1c716c07626974636f696e056e696e6a610002fd1bf18c2ebb5ece5e28ca76bf30650695636c55633bccae8179c2d1ee7b97e78d188e08ffc869a8f67847bf557516ac12465ebea1acc281d6d636fdab612007626974636f696e056e696e6a6100002b000100000cda0024716c0d023f7ad5a303e9c1cd1474b8df2ae56f3f82da8637ca55db4d9a2bb85960ca698e07626974636f696e056e696e6a6100002b000100000cda0024768a0d02ce46a9aff9a06e789c1bdfe250b0ef6ba8d39a53b2a3427c551f5ad375e059b607626974636f696e056e696e6a6100002e000100000cda0099002b080200000e1068a89268688cd4d892dc056e696e6a61004d88897d7d5f5d920ca436e81ee67b1bb22f1a96309693454ab9d0b06434794162cc42846a4b51a40475a5b44e940c04dd1ac2c902a190ca2251ae89184520b0f3f22c12c51403d0a6e1cd95792e8f6f5036cd2d50dbdfa5eba3b2ee70ff78d40dc2eba2cc899af26954a55e5b5d344d478cabd9423418495caee45c550b1144056e696e6a61000030000100000e1000880100030803010001d28cb7e2bb163d5815838bedeca1006dde8551b379cb963c8a2cb42bc360127e3a5cf88ffc851a67414815b875f65d78c39b58d2fb29a1d4e76d50cb6b4a58a11fe2fb7c1b6db7bf7d72f5a1401e381c57fcc76f599cc73f05095d2bd14d9895e4fa1cff21bd760598a734b640102d11bc159c6b2ae73dbfd2741518142584d1056e696e6a61000030000100000e100088010003080301000197edb59d4f181e2761dd8d0465854339afc71fd89e47155981ddd175cdce79477552aeaf7b5a08fc4ac6025555f60582f2060e630edfb35b9c7cc30990fb9c3dc9f2fd036c962f67b94c9670d4ceaacd77973bca82ab7c9615f7e4320dda5b6d74dec673017c6fa448b5542a804e08ac873c509c1945ff734c320491e4b18e6d056e696e6a61000030000100000e1001080101030803010001c71e4c9dc49249a27b3ef42fcb8d56b4c3ac76715c7ad01c41d0d432590d15c3c62cee4b2d29ac35f2d72c9b32a70a0243cbd08aeebc9f6f1e0e63d9e1cdfe133c455a82435c0780b750012c942f7ed5b662eec8d9ae885a58993fa78d7561fedcd11d9e1c171acb02d0025837ba61a3c0a6756427414470c9ca0906b298168b5f4d9640e62e1b75dd06be664104ed32cfe447fa21f37401712c720a0dca4bb1bc20f3fa3103cad336bde20b16f73948e6b80dda0a528db536a958868c3870ecddcfb02dfb3cb4d22e2ad49a4b9f78c90ff6c7e10e301b3fb36fe859a94c30084660665741c14ff60d0535013fcf439840ecad82fc9278e4ace68ba95e708249056e696e6a6100002e000100000e1001190030080100000e1068a89268688cd4d8b402056e696e6a6100646e04cf5f76daa775ff98905ded3d2caad68d3198fc161340d558262c7ba7da28e7538a7f32d5a6485e4448037e8edf55759b7059fdc084f1017f790aa7c0d8f0e4af6c9af04e4afd16ce6052c30da59314c9c98075fd32bb77a81f34bea6190631b9d0a4351a764c14152ea217e6271647bf95b0df4c3d7cc00937bec01b65ad1b5209c976a4843e399f173f196a012c0876bc9afa3457d940d6ad7b9d50b3d496836d7342cf3aec75ac4785563e20574ddd2dab1cfb6b5da32508edf7186aa516b0451b221251652ee44353710cbe35928b79fff4293c5e8eff7ab371ce43595e2300305bda0108b911c3ef7d4d15c70d68686fddf28422d5fcbcdb967e84056e696e6a6100002b0001000151800024b4020802c8f816a7a575bdb2f997f682aab2653ba2cb5eddb69b036a30742a33befaf141056e696e6a6100002e0001000151800113002b08010001518068a404d06892d340b5690081d888ee9bd744185f24bfbaaae70172bb03b6c0a899dcd6801c44b2e3e6acd5fe2192f4f06e5690ace176cb08557f2d5ceef5e9d9eb72f4f639dcf34650eebdef5cb91cd546fbdbd8a529d7ef9bb2168160ae800790d7a7266b531174d8d9be06cad2f1d0f062d9431f7de4beceb02f30ddc97bba44535a703e2d3cc01d2341bb48eb7b25d938f0ed2a7d4c53818e7cb883dc14ffce5899504265869fd3133953c96f48b99ff2055acd53b9f69d2eb8a911bb1f05e2fb8d1d0cc391e1b9ae19fc32b00727a9d8551e1a09319ba94da44cc317bb66e8f372385560cdf8455f858d4afd602307d982d996f729a16c263efa9b8cebe7862b7f9a88ac9fbaf445a600003000010002a30001080100030803010001b6aec4b48567e2925a2d9c4fa4c96e6dddf86215a9bd8dd579c38ccb1199ed1be89946a7f72fc2633909a2792d0eed1b5afb2ee4c78d865a76d6cd9369d999c96af6be0a2274b8f2e9e0a0065bd20257570f08bc14c16f5616426881a83dbce6926e391c138a2ec317efa7349264de2e791c9b7d4a6048ee6eedf27bf1ece398ff0d229f18377cb1f6b98d1228ef217b8146c0c73851b89a6fc37c621ca187e16428a743ffea0072e185ef93e39525cee3ad01e0c94d2e511c8c313322c29ab91631e1856049a36898684c3056e5997473816fb547acb0be6e660bdfa89a5cb28b3669d8625f3f018c7b3b8a4860e774ee8261811ce7f96c461bc162c1a374f300003000010002a30001080101030803010001af7a8deba49d995a792aefc80263e991efdbc86138a931deb2c65d5682eab5d3b03738e3dfdc89d96da64c86c0224d9ce02514d285da3068b19054e5e787b2969058e98e12566c8c808c40c0b769e1db1a24a1bd9b31e303184a31fc7bb56b85bbba8abc02cd5040a444a36d47695969849e16ad856bb58e8fac8855224400319bdab224d83fc0e66aab32ff74bfeaf0f91c454e6850a1295207bbd4cdde8f6ffb08faa9755c2e3284efa01f99393e18786cb132f1e66ebc6517318e1ce8a3b7337ebb54d035ab57d9706ecd9350d4afacd825e43c8668eece89819caf6817af62dc4fbd82f0e33f6647b2b6bda175f14607f59f4635451e6b27df282ef73d8700003000010002a30001080100030803010001b11b182a464c3adc6535aa59613bda7a61cac86945c20b773095941194f4b9f516e8bd924b1e50e3fe83918b51e54529d4e5a1e45303df8462241d5e05979979ae5bf9c6c598c08a496e17f3bd3732d5aebe62667b61db1bbe178f27ac99408165a230d6aee78348e6c67789541f845b2ada96667f8dd16ae44f9e260c4a138b3bb1015965ebe609434a06464bd7d29bac47c3017e83c0f89bca1a9e3bdd0813715f3484292df589bc632e27d37efc02837cb85d770d5bd53a36edc99a8294771aa93cf22406f5506c8cf850ed85c1a475dee5c2d3700b3f5631d903524b849995c20cb407ed411f70b428ae3d642716fe239335aa961a752e67fb6dca0bf72900003000010002a30001080101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b500002e00010002a3000113003008000002a30068a66180688ab2004f66007d114bf33e6d20e7588fdfde9a9e2a8ebd5593ce8bc06419e1d1a4afa8766abc1626504ea6243ca5fc9bce55a3f03c0e7eb488409690d84c3beb30f299da007ab69299d0e203c5b44b94328248768089a9b68982650e9ca2d37526307cbd9f06690e58c3c4a1703b1d1193ea0501417944b937b593294e339571eec42a3c700ce075d9c446e5d32bf979396c1c7935f69bd7df2826567fe582a3615d6095368be991b1e5dc39c0af3b0c39e0e353bbcb928e52e886193ac88da0cd8665ea992b642975aa5486f2e6514d0b5086c66ddd58fe8f7a27ecb128211e3ca1bdc4cad91f3cc9b63c526ebaea86075318e33bfc5a53c919e6f01262b24d178eb2cd04b1</tt>\n\nThe following encodes both the on-chain address <tt>bc1qztwy6xen3zdtt7z0vrgapmjtfz8acjkfp5fp7l</tt> and the BOLT 12 offer <tt>lno1zr5qyugqgskrk70kqmuq7v3dnr2fnmhukps9n8hut48vkqpqnskt2svsqwjakp7k6pyhtkuxw7y2kqmsxlwruhzqv0zsnhh9q3t9xhx39suc6qsr07ekm5esdyum0w66mnx8vdquwvp7dp5jp7j3v5cp6aj0w329fnkqqv60q96sz5nkrc5r95qffx002q53tqdk8x9m2tmt85jtpmcycvfnrpx3lr45h2g7na3sec7xguctfzzcm8jjqtj5ya27te60j03vpt0vq9tm2n9yxl2hngfnmygesa25s4u4zlxewqpvp94xt7rur4rhxunwkthk9vly3lm5hh0pqv4aymcqejlgssnlpzwlggykkajp7yjs5jvr2agkyypcdlj280cy46jpynsezrcj2kwa2lyr8xvd6lfkph4xrxtk2xc3lpq</tt> to <tt>a.x_domain_cname_wild@dnssec_proof_tests.bitcoin.ninja</tt> valid on August 6, 2025. Note that it requires following a CNAME to a different domain.\n<tt>36612e785f646f6d61696e5f636e616d655f77696c6440646e737365635f70726f6f665f74657374732e626974636f696e2e6e696e6a61056e696e6a6100002b0001000151800024b4020802c8f816a7a575bdb2f997f682aab2653ba2cb5eddb69b036a30742a33befaf14107626974636f696e056e696e6a6100003000010002a54400440100030dff753a27b08c3e48a642b210d6fcc444ff9ed4faf9c1241103db4ed3c19a95c3afbb52c0c02eb392ee048cc9e28ac2d272b1053bdc052bc18d5de05d7710196c056e696e6a6100002e000100000d2b01190030080100000e1068a89268688cd4d8b402056e696e6a6100646e04cf5f76daa775ff98905ded3d2caad68d3198fc161340d558262c7ba7da28e7538a7f32d5a6485e4448037e8edf55759b7059fdc084f1017f790aa7c0d8f0e4af6c9af04e4afd16ce6052c30da59314c9c98075fd32bb77a81f34bea6190631b9d0a4351a764c14152ea217e6271647bf95b0df4c3d7cc00937bec01b65ad1b5209c976a4843e399f173f196a012c0876bc9afa3457d940d6ad7b9d50b3d496836d7342cf3aec75ac4785563e20574ddd2dab1cfb6b5da32508edf7186aa516b0451b221251652ee44353710cbe35928b79fff4293c5e8eff7ab371ce43595e2300305bda0108b911c3ef7d4d15c70d68686fddf28422d5fcbcdb967e84056e696e6a6100002e0001000151800113002b08010001518068a404d06892d340b5690081d888ee9bd744185f24bfbaaae70172bb03b6c0a899dcd6801c44b2e3e6acd5fe2192f4f06e5690ace176cb08557f2d5ceef5e9d9eb72f4f639dcf34650eebdef5cb91cd546fbdbd8a529d7ef9bb2168160ae800790d7a7266b531174d8d9be06cad2f1d0f062d9431f7de4beceb02f30ddc97bba44535a703e2d3cc01d2341bb48eb7b25d938f0ed2a7d4c53818e7cb883dc14ffce5899504265869fd3133953c96f48b99ff2055acd53b9f69d2eb8a911bb1f05e2fb8d1d0cc391e1b9ae19fc32b00727a9d8551e1a09319ba94da44cc317bb66e8f372385560cdf8455f858d4afd602307d982d996f729a16c263efa9b8cebe7862b7f9a88ac9fbaf445a6056e696e6a61000030000100000d2b00880100030803010001d28cb7e2bb163d5815838bedeca1006dde8551b379cb963c8a2cb42bc360127e3a5cf88ffc851a67414815b875f65d78c39b58d2fb29a1d4e76d50cb6b4a58a11fe2fb7c1b6db7bf7d72f5a1401e381c57fcc76f599cc73f05095d2bd14d9895e4fa1cff21bd760598a734b640102d11bc159c6b2ae73dbfd2741518142584d107626974636f696e056e696e6a6100002b000100000bf50024716c0d023f7ad5a303e9c1cd1474b8df2ae56f3f82da8637ca55db4d9a2bb85960ca698e00003000010002a30001080100030803010001b11b182a464c3adc6535aa59613bda7a61cac86945c20b773095941194f4b9f516e8bd924b1e50e3fe83918b51e54529d4e5a1e45303df8462241d5e05979979ae5bf9c6c598c08a496e17f3bd3732d5aebe62667b61db1bbe178f27ac99408165a230d6aee78348e6c67789541f845b2ada96667f8dd16ae44f9e260c4a138b3bb1015965ebe609434a06464bd7d29bac47c3017e83c0f89bca1a9e3bdd0813715f3484292df589bc632e27d37efc02837cb85d770d5bd53a36edc99a8294771aa93cf22406f5506c8cf850ed85c1a475dee5c2d3700b3f5631d903524b849995c20cb407ed411f70b428ae3d642716fe239335aa961a752e67fb6dca0bf7290b6d617474636f72616c6c6f03636f6d00003000010003d52200440101030dec7c1fa1752495c42d2224eace96ed74144e9cb811608dd91594974bdc723fdc5b38a37c3340f1deca68a7ec82248822954b2994de5ac99ff6e9db95fd42c94b00003000010002a30001080101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b507626974636f696e056e696e6a6100002e000100000bf50099002b080200000e1068a89268688cd4d892dc056e696e6a61004d88897d7d5f5d920ca436e81ee67b1bb22f1a96309693454ab9d0b06434794162cc42846a4b51a40475a5b44e940c04dd1ac2c902a190ca2251ae89184520b0f3f22c12c51403d0a6e1cd95792e8f6f5036cd2d50dbdfa5eba3b2ee70ff78d40dc2eba2cc899af26954a55e5b5d344d478cabd9423418495caee45c550b114403636f6d00002e000100000266005700300d0100015180689f3dfb688b764f4d0603636f6d00d87373f3d5d404f7cdc3aace633c96357bc606ced620792597e1308b1d6c5902668c4d3c1a37bab8486ba24485d57a9d98157fe706424b2043bfb40306d01484046d6174740475736572105f626974636f696e2d7061796d656e740b6d617474636f72616c6c6f03636f6d00002e000100000e10006300100d0500000e1068a57e5a6892f44226480b6d617474636f72616c6c6f03636f6d004515e7d3cdf4137c316d4d36972fab9273df457789a9fabb16c4689e1644ae9080c7505e06daebc136d3c43054d0c69d185ac5616afca8998edf828e63a68286206f3266653035326d646a61336638746c3563353667706668646661696661687007626974636f696e056e696e6a6100003200010000001e002201000000083c92990db9cddbc614c8e4a40e1317cc888750fad000dab671a24e1a3a056e696e6a61000030000100000d2b01080101030803010001c71e4c9dc49249a27b3ef42fcb8d56b4c3ac76715c7ad01c41d0d432590d15c3c62cee4b2d29ac35f2d72c9b32a70a0243cbd08aeebc9f6f1e0e63d9e1cdfe133c455a82435c0780b750012c942f7ed5b662eec8d9ae885a58993fa78d7561fedcd11d9e1c171acb02d0025837ba61a3c0a6756427414470c9ca0906b298168b5f4d9640e62e1b75dd06be664104ed32cfe447fa21f37401712c720a0dca4bb1bc20f3fa3103cad336bde20b16f73948e6b80dda0a528db536a958868c3870ecddcfb02dfb3cb4d22e2ad49a4b9f78c90ff6c7e10e301b3fb36fe859a94c30084660665741c14ff60d0535013fcf439840ecad82fc9278e4ace68ba95e7082490b6d617474636f72616c6c6f03636f6d00002b0001000151800024e2f50d02f0e161567d468087ff27b051abc94476178a7cb635da1aa705e05c77ca81de520b6d617474636f72616c6c6f03636f6d00002e0001000151800057002b0d0200015180689a991368914e2b504103636f6d0070ac13ac37043e66f191553c554ee9307a91a4cf27bd724949e52032a2b464cadb776cd362918159344d9685b84650436449914f25fc62cc6dd6b761f565828303636f6d00002b00010001518000244d060d028acbb0cd28f41250a80a491389424d341522d946b0da0c0291f2d3d771d7805a0b6d617474636f72616c6c6f03636f6d00002e00010003d522006300300d0200093a80689c35ca6889abb2e2f50b6d617474636f72616c6c6f03636f6d0016857529219dd561091a51c72a27e25d963094f8dcd93b11f0917d45466251acb1402bb6fa4529bd20b7db697df429c4ba830685fc290ee5a8a937c2d34530c007626974636f696e056e696e6a6100003000010002a54400440101030df65551925ce6321888e685981823d617fbc10f329bffe4081bf18c2372632a5548010bf62e6556a92722629275e0bd001e3d7837d325a353f6a851c5b9652596016113785f646f6d61696e5f636e616d655f77696c640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100002e00010000001e006100050d060000001e68a4c58868923b70d0e207626974636f696e056e696e6a6100849202c2306be651b9a5901331d9bf363e74ba758c16e993c4f93fe4c1a08e7bc46baa64b22e9540435b4b6b83fc4800c58d27bd9b2fe82d02ed6d6f9059cfa50b6d617474636f72616c6c6f03636f6d00003000010003d52200440100030dfd9dbc34cb5053a2c4a6b3d0dc60fc65d8a992dc1e080f6deeddba7fe6b25217730de64c9a1ce986b3f81f556881fe0e7b5b20c8ae381c4fefdbc311aa7d22ee206f3266653035326d646a61336638746c3563353667706668646661696661687007626974636f696e056e696e6a6100002e00010000001e006100320d030000003c68a5076a68927d52d0e207626974636f696e056e696e6a6100620532890060f3f82a90a05ab32afe628ef58a58fbed98df2fbb1d3d00064b05111503f67cbd0f485f6196f007ddb3e6ec087e31f94221bf2b388179d31373b203636f6d00003000010000026600440101030db71f0465101ddbe2bf0c9455d12fa16c1cda44f4bf1ba2553418ad1f3aa9b06973f21b84eb532cf4035ee8d4832ca26d89306a7d32560c0cb0129d450ac10835016113785f646f6d61696e5f636e616d655f77696c640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100000500010000001e002c046d6174740475736572105f626974636f696e2d7061796d656e740b6d617474636f72616c6c6f03636f6d0007626974636f696e056e696e6a6100002b000100000bf50024768a0d02ce46a9aff9a06e789c1bdfe250b0ef6ba8d39a53b2a3427c551f5ad375e059b60b6d617474636f72616c6c6f03636f6d00003000010003d52200440100030d8b1cf07c86f18c19c8c3146db093893648dcc1ab5fb79e99ccbab4aa06f98d52ac27b92e215d9da98d7535f3c2ce038fbb9d41b9c63d3845d444feffc1f71ed703636f6d00002e0001000151800113002b08010001518068a404d06892d340b5690024fbea2f86eb0e472114b9da41f1da69e4ef2d02ffcd6bdd987239f288795603d5f54308b238ef19f2747d6a1bc0e775782025561b0f14d1dd19be6bf36b495a3e2d538d5532c5c6e1056c06aa4e81de07f637313955a7761d313db0c6cd0b5c17b4ee22d530d6cdc0c4e195df85b354bbe32027537f1ca21f2815b2d0dbd154582124b3c4c27f1c3aea16f6bfe7e6f5c80aaccd61601bdd8f947ef5c30f004482617cf97629b8b89d8e7320719c979c6a9defdf79b743ecef08bdf2f90796da018fdc6be1e0629fe706044e0f8ad1b25927eca09074a502eb9136eefe5903ad3f97866ab014f1ec96e1f38e3aba66520a25ace386f4897e1ecfd774ce0a0f8a03636f6d00003000010000026600440100030df17b60fb56d522f8634153e785c0a978532ea76de39d34bb356d3d042e07f29f7b992176cc83acef7b78ea750425203b18f2b8228b3cdd2bc7eb13c3e3035a7e0b6d617474636f72616c6c6f03636f6d00002b00010001518000249f000d02594d2813e04a1d2660ff3c0afc5579b9ec0fe72cc206dc6f248bbe6dd652e19500002e00010002a3000113003008000002a30068a66180688ab2004f66007d114bf33e6d20e7588fdfde9a9e2a8ebd5593ce8bc06419e1d1a4afa8766abc1626504ea6243ca5fc9bce55a3f03c0e7eb488409690d84c3beb30f299da007ab69299d0e203c5b44b94328248768089a9b68982650e9ca2d37526307cbd9f06690e58c3c4a1703b1d1193ea0501417944b937b593294e339571eec42a3c700ce075d9c446e5d32bf979396c1c7935f69bd7df2826567fe582a3615d6095368be991b1e5dc39c0af3b0c39e0e353bbcb928e52e886193ac88da0cd8665ea992b642975aa5486f2e6514d0b5086c66ddd58fe8f7a27ecb128211e3ca1bdc4cad91f3cc9b63c526ebaea86075318e33bfc5a53c919e6f01262b24d178eb2cd04b100003000010002a30001080100030803010001b6aec4b48567e2925a2d9c4fa4c96e6dddf86215a9bd8dd579c38ccb1199ed1be89946a7f72fc2633909a2792d0eed1b5afb2ee4c78d865a76d6cd9369d999c96af6be0a2274b8f2e9e0a0065bd20257570f08bc14c16f5616426881a83dbce6926e391c138a2ec317efa7349264de2e791c9b7d4a6048ee6eedf27bf1ece398ff0d229f18377cb1f6b98d1228ef217b8146c0c73851b89a6fc37c621ca187e16428a743ffea0072e185ef93e39525cee3ad01e0c94d2e511c8c313322c29ab91631e1856049a36898684c3056e5997473816fb547acb0be6e660bdfa89a5cb28b3669d8625f3f018c7b3b8a4860e774ee8261811ce7f96c461bc162c1a374f3046d6174740475736572105f626974636f696e2d7061796d656e740b6d617474636f72616c6c6f03636f6d000010000100000e1001ecff626974636f696e3a626331717a7477793678656e337a647474377a3076726761706d6a74667a3861636a6b6670356670376c3f6c6e6f3d6c6e6f317a7235717975677167736b726b37306b716d7571377633646e7232666e6d68756b7073396e386875743438766b7170716e736b743273767371776a616b70376b36707968746b7578773779326b716d73786c777275687a7176307a736e686839713374397868783339737563367173723037656b6d3565736479756d307736366d6e783876647175777670376470356a70376a337635637036616a3077333239666e6b7171763630713936737a356e6b726335723935716666783030327135337471646beb3878396d32746d7438356a74706d63796376666e727078336c723435683267376e6133736563377867756374667a7a636d386a6a71746a3579613237746536306a303376707430767139746d326e3979786c32686e67666e6d79676573613235733475347a6c78657771707670393478743772757234726878756e776b74686b39766c79336c6d356868307071763461796d6371656a6c6773736e6c707a776c6767796b6b616a7037796a73356a76723261676b79797063646c6a323830637934366a70796e73657a72636a326b7761326c797238787664366c666b706834787278746b327863336c707100003000010002a30001080101030803010001af7a8deba49d995a792aefc80263e991efdbc86138a931deb2c65d5682eab5d3b03738e3dfdc89d96da64c86c0224d9ce02514d285da3068b19054e5e787b2969058e98e12566c8c808c40c0b769e1db1a24a1bd9b31e303184a31fc7bb56b85bbba8abc02cd5040a444a36d47695969849e16ad856bb58e8fac8855224400319bdab224d83fc0e66aab32ff74bfeaf0f91c454e6850a1295207bbd4cdde8f6ffb08faa9755c2e3284efa01f99393e18786cb132f1e66ebc6517318e1ce8a3b7337ebb54d035ab57d9706ecd9350d4afacd825e43c8668eece89819caf6817af62dc4fbd82f0e33f6647b2b6bda175f14607f59f4635451e6b27df282ef73d8707626974636f696e056e696e6a6100002e00010002a544006100300d0200093a806898c73468863d1c716c07626974636f696e056e696e6a610002fd1bf18c2ebb5ece5e28ca76bf30650695636c55633bccae8179c2d1ee7b97e78d188e08ffc869a8f67847bf557516ac12465ebea1acc281d6d636fdab6120056e696e6a61000030000100000d2b0088010003080301000197edb59d4f181e2761dd8d0465854339afc71fd89e47155981ddd175cdce79477552aeaf7b5a08fc4ac6025555f60582f2060e630edfb35b9c7cc30990fb9c3dc9f2fd036c962f67b94c9670d4ceaacd77973bca82ab7c9615f7e4320dda5b6d74dec673017c6fa448b5542a804e08ac873c509c1945ff734c320491e4b18e6d</tt>\n\nThe following is an *invalid* DNSSEC proof when included in the <code>PSBT_OUT_DNSSEC_PROOF</code> record of a PSBT.\n\nThe following encodes the on-chain address <tt>bc1qztwy6xen3zdtt7z0vrgapmjtfz8acjkfp5fp7l</tt> to <tt>invalid@dnssec_proof_tests.bitcoin.ninja</tt> but is '''invalid'''.\nThis proof contains two TXT records which start with, case insensitively, \"bitcoin:\". It is a valid DNSSEC proof but should fail BIP 353-specific validation.\n<tt>28696e76616c696440646e737365635f70726f6f665f74657374732e626974636f696e2e6e696e6a6107696e76616c69640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100001000010000001e003736426954634f694e3a3f42433d626331717a7477793678656e337a647474377a3076726761706d6a74667a3861636a6b6670356670376c07696e76616c69640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100001000010000001e003736626974636f696e3a3f62633d626331717a7477793678656e337a647474377a3076726761706d6a74667a3861636a6b6670356670376c07696e76616c69640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100002e00010000001e006100100d060000001e68a70b256894810dd0e207626974636f696e056e696e6a6100a7ed29b28f64a885e6496f080befc724da98afe8879a985c1f82b15dc6f97cf595b8a3b62edc58870291448a7f4017fba8c3e8380ab32a0883439fba965773ac07626974636f696e056e696e6a610000300001000161f300440100030dff753a27b08c3e48a642b210d6fcc444ff9ed4faf9c1241103db4ed3c19a95c3afbb52c0c02eb392ee048cc9e28ac2d272b1053bdc052bc18d5de05d7710196c07626974636f696e056e696e6a610000300001000161f300440101030df65551925ce6321888e685981823d617fbc10f329bffe4081bf18c2372632a5548010bf62e6556a92722629275e0bd001e3d7837d325a353f6a851c5b965259607626974636f696e056e696e6a6100002e0001000161f3006100300d0200093a806898c73468863d1c716c07626974636f696e056e696e6a610002fd1bf18c2ebb5ece5e28ca76bf30650695636c55633bccae8179c2d1ee7b97e78d188e08ffc869a8f67847bf557516ac12465ebea1acc281d6d636fdab612007626974636f696e056e696e6a6100002b000100000daa0024716c0d023f7ad5a303e9c1cd1474b8df2ae56f3f82da8637ca55db4d9a2bb85960ca698e07626974636f696e056e696e6a6100002b000100000daa0024768a0d02ce46a9aff9a06e789c1bdfe250b0ef6ba8d39a53b2a3427c551f5ad375e059b607626974636f696e056e696e6a6100002e000100000daa0099002b080200000e1068a89268688cd4d892dc056e696e6a61004d88897d7d5f5d920ca436e81ee67b1bb22f1a96309693454ab9d0b06434794162cc42846a4b51a40475a5b44e940c04dd1ac2c902a190ca2251ae89184520b0f3f22c12c51403d0a6e1cd95792e8f6f5036cd2d50dbdfa5eba3b2ee70ff78d40dc2eba2cc899af26954a55e5b5d344d478cabd9423418495caee45c550b1144056e696e6a61000030000100000daa01080101030803010001c71e4c9dc49249a27b3ef42fcb8d56b4c3ac76715c7ad01c41d0d432590d15c3c62cee4b2d29ac35f2d72c9b32a70a0243cbd08aeebc9f6f1e0e63d9e1cdfe133c455a82435c0780b750012c942f7ed5b662eec8d9ae885a58993fa78d7561fedcd11d9e1c171acb02d0025837ba61a3c0a6756427414470c9ca0906b298168b5f4d9640e62e1b75dd06be664104ed32cfe447fa21f37401712c720a0dca4bb1bc20f3fa3103cad336bde20b16f73948e6b80dda0a528db536a958868c3870ecddcfb02dfb3cb4d22e2ad49a4b9f78c90ff6c7e10e301b3fb36fe859a94c30084660665741c14ff60d0535013fcf439840ecad82fc9278e4ace68ba95e708249056e696e6a61000030000100000daa0088010003080301000197edb59d4f181e2761dd8d0465854339afc71fd89e47155981ddd175cdce79477552aeaf7b5a08fc4ac6025555f60582f2060e630edfb35b9c7cc30990fb9c3dc9f2fd036c962f67b94c9670d4ceaacd77973bca82ab7c9615f7e4320dda5b6d74dec673017c6fa448b5542a804e08ac873c509c1945ff734c320491e4b18e6d056e696e6a61000030000100000daa00880100030803010001d28cb7e2bb163d5815838bedeca1006dde8551b379cb963c8a2cb42bc360127e3a5cf88ffc851a67414815b875f65d78c39b58d2fb29a1d4e76d50cb6b4a58a11fe2fb7c1b6db7bf7d72f5a1401e381c57fcc76f599cc73f05095d2bd14d9895e4fa1cff21bd760598a734b640102d11bc159c6b2ae73dbfd2741518142584d1056e696e6a6100002e000100000daa01190030080100000e1068a89268688cd4d8b402056e696e6a6100646e04cf5f76daa775ff98905ded3d2caad68d3198fc161340d558262c7ba7da28e7538a7f32d5a6485e4448037e8edf55759b7059fdc084f1017f790aa7c0d8f0e4af6c9af04e4afd16ce6052c30da59314c9c98075fd32bb77a81f34bea6190631b9d0a4351a764c14152ea217e6271647bf95b0df4c3d7cc00937bec01b65ad1b5209c976a4843e399f173f196a012c0876bc9afa3457d940d6ad7b9d50b3d496836d7342cf3aec75ac4785563e20574ddd2dab1cfb6b5da32508edf7186aa516b0451b221251652ee44353710cbe35928b79fff4293c5e8eff7ab371ce43595e2300305bda0108b911c3ef7d4d15c70d68686fddf28422d5fcbcdb967e84056e696e6a6100002b0001000151800024b4020802c8f816a7a575bdb2f997f682aab2653ba2cb5eddb69b036a30742a33befaf141056e696e6a6100002e0001000151800113002b08010001518068a55650689424c0b569007f4d7bbce2d77380e115f8469a3c6d1d4bd9be1145eeee843332f1d54da134a25f7d259ccfa36a2e833106139ba37bc28651b7717dabfc8c450e889c5d5d6d39d12f1004252fa08692794af4a7f29a94f6611f9b000ba899d90d6a32e91c54e63720811546b251fb265b7f62615391ab330f83a96841f0367347e67522112f63f3efda891ae0f7265ed5b89673f184027cdb9b5e94b16a9b1f99877cc8e078abf246cad1f76a48a34474977dbd89dd3b41f381df89a82e2939aeb06830f656253e4e347cd04ee6dba0c8377e818f919f80a7e6aefa0f8196d04845bc26b498b0115022ff75e363711e55337de505e50df69b840699160467516d15e8235aa4cf00003000010002a30001080101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b500003000010002a30001080100030803010001b6aec4b48567e2925a2d9c4fa4c96e6dddf86215a9bd8dd579c38ccb1199ed1be89946a7f72fc2633909a2792d0eed1b5afb2ee4c78d865a76d6cd9369d999c96af6be0a2274b8f2e9e0a0065bd20257570f08bc14c16f5616426881a83dbce6926e391c138a2ec317efa7349264de2e791c9b7d4a6048ee6eedf27bf1ece398ff0d229f18377cb1f6b98d1228ef217b8146c0c73851b89a6fc37c621ca187e16428a743ffea0072e185ef93e39525cee3ad01e0c94d2e511c8c313322c29ab91631e1856049a36898684c3056e5997473816fb547acb0be6e660bdfa89a5cb28b3669d8625f3f018c7b3b8a4860e774ee8261811ce7f96c461bc162c1a374f300003000010002a30001080100030803010001b11b182a464c3adc6535aa59613bda7a61cac86945c20b773095941194f4b9f516e8bd924b1e50e3fe83918b51e54529d4e5a1e45303df8462241d5e05979979ae5bf9c6c598c08a496e17f3bd3732d5aebe62667b61db1bbe178f27ac99408165a230d6aee78348e6c67789541f845b2ada96667f8dd16ae44f9e260c4a138b3bb1015965ebe609434a06464bd7d29bac47c3017e83c0f89bca1a9e3bdd0813715f3484292df589bc632e27d37efc02837cb85d770d5bd53a36edc99a8294771aa93cf22406f5506c8cf850ed85c1a475dee5c2d3700b3f5631d903524b849995c20cb407ed411f70b428ae3d642716fe239335aa961a752e67fb6dca0bf72900003000010002a30001080101030803010001af7a8deba49d995a792aefc80263e991efdbc86138a931deb2c65d5682eab5d3b03738e3dfdc89d96da64c86c0224d9ce02514d285da3068b19054e5e787b2969058e98e12566c8c808c40c0b769e1db1a24a1bd9b31e303184a31fc7bb56b85bbba8abc02cd5040a444a36d47695969849e16ad856bb58e8fac8855224400319bdab224d83fc0e66aab32ff74bfeaf0f91c454e6850a1295207bbd4cdde8f6ffb08faa9755c2e3284efa01f99393e18786cb132f1e66ebc6517318e1ce8a3b7337ebb54d035ab57d9706ecd9350d4afacd825e43c8668eece89819caf6817af62dc4fbd82f0e33f6647b2b6bda175f14607f59f4635451e6b27df282ef73d8700002e00010002a3000113003008000002a30068a66180688ab2004f66007d114bf33e6d20e7588fdfde9a9e2a8ebd5593ce8bc06419e1d1a4afa8766abc1626504ea6243ca5fc9bce55a3f03c0e7eb488409690d84c3beb30f299da007ab69299d0e203c5b44b94328248768089a9b68982650e9ca2d37526307cbd9f06690e58c3c4a1703b1d1193ea0501417944b937b593294e339571eec42a3c700ce075d9c446e5d32bf979396c1c7935f69bd7df2826567fe582a3615d6095368be991b1e5dc39c0af3b0c39e0e353bbcb928e52e886193ac88da0cd8665ea992b642975aa5486f2e6514d0b5086c66ddd58fe8f7a27ecb128211e3ca1bdc4cad91f3cc9b63c526ebaea86075318e33bfc5a53c919e6f01262b24d178eb2cd04b1</tt>\n\nThe following encodes both the on-chain address <tt>bc1qztwy6xen3zdtt7z0vrgapmjtfz8acjkfp5fp7l</tt> and the BOLT 12 offer <tt>lno1zr5qyugqgskrk70kqmuq7v3dnr2fnmhukps9n8hut48vkqpqnskt2svsqwjakp7k6pyhtkuxw7y2kqmsxlwruhzqv0zsnhh9q3t9xhx39suc6qsr07ekm5esdyum0w66mnx8vdquwvp7dp5jp7j3v5cp6aj0w329fnkqqv60q96sz5nkrc5r95qffx002q53tqdk8x9m2tmt85jtpmcycvfnrpx3lr45h2g7na3sec7xguctfzzcm8jjqtj5ya27te60j03vpt0vq9tm2n9yxl2hngfnmygesa25s4u4zlxewqpvp94xt7rur4rhxunwkthk9vly3lm5hh0pqv4aymcqejlgssnlpzwlggykkajp7yjs5jvr2agkyypcdlj280cy46jpynsezrcj2kwa2lyr8xvd6lfkph4xrxtk2xc3lpq</tt> to <tt>a.x_domain_cname_wild@dnssec_proof_tests.bitcoin.ninja</tt> but is '''invalid'''.\nThis proof is missing the required NSEC3 record to prove the lack of an override to the wildcard CNAME entry.\n<tt>36612e785f646f6d61696e5f636e616d655f77696c6440646e737365635f70726f6f665f74657374732e626974636f696e2e6e696e6a61016113785f646f6d61696e5f636e616d655f77696c640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100000500010000001e002c046d6174740475736572105f626974636f696e2d7061796d656e740b6d617474636f72616c6c6f03636f6d00016113785f646f6d61696e5f636e616d655f77696c640475736572105f626974636f696e2d7061796d656e7412646e737365635f70726f6f665f746573747307626974636f696e056e696e6a6100002e00010000001e006100050d060000001e68a4c58868923b70d0e207626974636f696e056e696e6a6100849202c2306be651b9a5901331d9bf363e74ba758c16e993c4f93fe4c1a08e7bc46baa64b22e9540435b4b6b83fc4800c58d27bd9b2fe82d02ed6d6f9059cfa5046d6174740475736572105f626974636f696e2d7061796d656e740b6d617474636f72616c6c6f03636f6d000010000100000e1001ecff626974636f696e3a626331717a7477793678656e337a647474377a3076726761706d6a74667a3861636a6b6670356670376c3f6c6e6f3d6c6e6f317a7235717975677167736b726b37306b716d7571377633646e7232666e6d68756b7073396e386875743438766b7170716e736b743273767371776a616b70376b36707968746b7578773779326b716d73786c777275687a7176307a736e686839713374397868783339737563367173723037656b6d3565736479756d307736366d6e783876647175777670376470356a70376a337635637036616a3077333239666e6b7171763630713936737a356e6b726335723935716666783030327135337471646beb3878396d32746d7438356a74706d63796376666e727078336c723435683267376e6133736563377867756374667a7a636d386a6a71746a3579613237746536306a303376707430767139746d326e3979786c32686e67666e6d79676573613235733475347a6c78657771707670393478743772757234726878756e776b74686b39766c79336c6d356868307071763461796d6371656a6c6773736e6c707a776c6767796b6b616a7037796a73356a76723261676b79797063646c6a323830637934366a70796e73657a72636a326b7761326c797238787664366c666b706834787278746b327863336c7071046d6174740475736572105f626974636f696e2d7061796d656e740b6d617474636f72616c6c6f03636f6d00002e000100000e10006300100d0500000e1068a57e5a6892f44226480b6d617474636f72616c6c6f03636f6d004515e7d3cdf4137c316d4d36972fab9273df457789a9fabb16c4689e1644ae9080c7505e06daebc136d3c43054d0c69d185ac5616afca8998edf828e63a68286206f3266653035326d646a61336638746c3563353667706668646661696661687007626974636f696e056e696e6a6100002e00010000001e006100320d030000003c68a5076a68927d52d0e207626974636f696e056e696e6a6100620532890060f3f82a90a05ab32afe628ef58a58fbed98df2fbb1d3d00064b05111503f67cbd0f485f6196f007ddb3e6ec087e31f94221bf2b388179d31373b207626974636f696e056e696e6a6100003000010002a54400440100030dff753a27b08c3e48a642b210d6fcc444ff9ed4faf9c1241103db4ed3c19a95c3afbb52c0c02eb392ee048cc9e28ac2d272b1053bdc052bc18d5de05d7710196c07626974636f696e056e696e6a6100003000010002a54400440101030df65551925ce6321888e685981823d617fbc10f329bffe4081bf18c2372632a5548010bf62e6556a92722629275e0bd001e3d7837d325a353f6a851c5b965259607626974636f696e056e696e6a6100002e00010002a544006100300d0200093a806898c73468863d1c716c07626974636f696e056e696e6a610002fd1bf18c2ebb5ece5e28ca76bf30650695636c55633bccae8179c2d1ee7b97e78d188e08ffc869a8f67847bf557516ac12465ebea1acc281d6d636fdab612007626974636f696e056e696e6a6100002b000100000bf50024768a0d02ce46a9aff9a06e789c1bdfe250b0ef6ba8d39a53b2a3427c551f5ad375e059b607626974636f696e056e696e6a6100002b000100000bf50024716c0d023f7ad5a303e9c1cd1474b8df2ae56f3f82da8637ca55db4d9a2bb85960ca698e07626974636f696e056e696e6a6100002e000100000bf50099002b080200000e1068a89268688cd4d892dc056e696e6a61004d88897d7d5f5d920ca436e81ee67b1bb22f1a96309693454ab9d0b06434794162cc42846a4b51a40475a5b44e940c04dd1ac2c902a190ca2251ae89184520b0f3f22c12c51403d0a6e1cd95792e8f6f5036cd2d50dbdfa5eba3b2ee70ff78d40dc2eba2cc899af26954a55e5b5d344d478cabd9423418495caee45c550b11440b6d617474636f72616c6c6f03636f6d00003000010003d52200440100030d8b1cf07c86f18c19c8c3146db093893648dcc1ab5fb79e99ccbab4aa06f98d52ac27b92e215d9da98d7535f3c2ce038fbb9d41b9c63d3845d444feffc1f71ed70b6d617474636f72616c6c6f03636f6d00003000010003d52200440101030dec7c1fa1752495c42d2224eace96ed74144e9cb811608dd91594974bdc723fdc5b38a37c3340f1deca68a7ec82248822954b2994de5ac99ff6e9db95fd42c94b0b6d617474636f72616c6c6f03636f6d00003000010003d52200440100030dfd9dbc34cb5053a2c4a6b3d0dc60fc65d8a992dc1e080f6deeddba7fe6b25217730de64c9a1ce986b3f81f556881fe0e7b5b20c8ae381c4fefdbc311aa7d22ee0b6d617474636f72616c6c6f03636f6d00002e00010003d522006300300d0200093a80689c35ca6889abb2e2f50b6d617474636f72616c6c6f03636f6d0016857529219dd561091a51c72a27e25d963094f8dcd93b11f0917d45466251acb1402bb6fa4529bd20b7db697df429c4ba830685fc290ee5a8a937c2d34530c00b6d617474636f72616c6c6f03636f6d00002b00010001518000249f000d02594d2813e04a1d2660ff3c0afc5579b9ec0fe72cc206dc6f248bbe6dd652e1950b6d617474636f72616c6c6f03636f6d00002b0001000151800024e2f50d02f0e161567d468087ff27b051abc94476178a7cb635da1aa705e05c77ca81de520b6d617474636f72616c6c6f03636f6d00002e0001000151800057002b0d0200015180689a991368914e2b504103636f6d0070ac13ac37043e66f191553c554ee9307a91a4cf27bd724949e52032a2b464cadb776cd362918159344d9685b84650436449914f25fc62cc6dd6b761f5658283056e696e6a61000030000100000d2b00880100030803010001d28cb7e2bb163d5815838bedeca1006dde8551b379cb963c8a2cb42bc360127e3a5cf88ffc851a67414815b875f65d78c39b58d2fb29a1d4e76d50cb6b4a58a11fe2fb7c1b6db7bf7d72f5a1401e381c57fcc76f599cc73f05095d2bd14d9895e4fa1cff21bd760598a734b640102d11bc159c6b2ae73dbfd2741518142584d1056e696e6a61000030000100000d2b01080101030803010001c71e4c9dc49249a27b3ef42fcb8d56b4c3ac76715c7ad01c41d0d432590d15c3c62cee4b2d29ac35f2d72c9b32a70a0243cbd08aeebc9f6f1e0e63d9e1cdfe133c455a82435c0780b750012c942f7ed5b662eec8d9ae885a58993fa78d7561fedcd11d9e1c171acb02d0025837ba61a3c0a6756427414470c9ca0906b298168b5f4d9640e62e1b75dd06be664104ed32cfe447fa21f37401712c720a0dca4bb1bc20f3fa3103cad336bde20b16f73948e6b80dda0a528db536a958868c3870ecddcfb02dfb3cb4d22e2ad49a4b9f78c90ff6c7e10e301b3fb36fe859a94c30084660665741c14ff60d0535013fcf439840ecad82fc9278e4ace68ba95e708249056e696e6a61000030000100000d2b0088010003080301000197edb59d4f181e2761dd8d0465854339afc71fd89e47155981ddd175cdce79477552aeaf7b5a08fc4ac6025555f60582f2060e630edfb35b9c7cc30990fb9c3dc9f2fd036c962f67b94c9670d4ceaacd77973bca82ab7c9615f7e4320dda5b6d74dec673017c6fa448b5542a804e08ac873c509c1945ff734c320491e4b18e6d056e696e6a6100002e000100000d2b01190030080100000e1068a89268688cd4d8b402056e696e6a6100646e04cf5f76daa775ff98905ded3d2caad68d3198fc161340d558262c7ba7da28e7538a7f32d5a6485e4448037e8edf55759b7059fdc084f1017f790aa7c0d8f0e4af6c9af04e4afd16ce6052c30da59314c9c98075fd32bb77a81f34bea6190631b9d0a4351a764c14152ea217e6271647bf95b0df4c3d7cc00937bec01b65ad1b5209c976a4843e399f173f196a012c0876bc9afa3457d940d6ad7b9d50b3d496836d7342cf3aec75ac4785563e20574ddd2dab1cfb6b5da32508edf7186aa516b0451b221251652ee44353710cbe35928b79fff4293c5e8eff7ab371ce43595e2300305bda0108b911c3ef7d4d15c70d68686fddf28422d5fcbcdb967e84056e696e6a6100002b0001000151800024b4020802c8f816a7a575bdb2f997f682aab2653ba2cb5eddb69b036a30742a33befaf141056e696e6a6100002e0001000151800113002b08010001518068a404d06892d340b5690081d888ee9bd744185f24bfbaaae70172bb03b6c0a899dcd6801c44b2e3e6acd5fe2192f4f06e5690ace176cb08557f2d5ceef5e9d9eb72f4f639dcf34650eebdef5cb91cd546fbdbd8a529d7ef9bb2168160ae800790d7a7266b531174d8d9be06cad2f1d0f062d9431f7de4beceb02f30ddc97bba44535a703e2d3cc01d2341bb48eb7b25d938f0ed2a7d4c53818e7cb883dc14ffce5899504265869fd3133953c96f48b99ff2055acd53b9f69d2eb8a911bb1f05e2fb8d1d0cc391e1b9ae19fc32b00727a9d8551e1a09319ba94da44cc317bb66e8f372385560cdf8455f858d4afd602307d982d996f729a16c263efa9b8cebe7862b7f9a88ac9fbaf445a603636f6d00003000010000026600440100030df17b60fb56d522f8634153e785c0a978532ea76de39d34bb356d3d042e07f29f7b992176cc83acef7b78ea750425203b18f2b8228b3cdd2bc7eb13c3e3035a7e03636f6d00003000010000026600440101030db71f0465101ddbe2bf0c9455d12fa16c1cda44f4bf1ba2553418ad1f3aa9b06973f21b84eb532cf4035ee8d4832ca26d89306a7d32560c0cb0129d450ac1083503636f6d00002e000100000266005700300d0100015180689f3dfb688b764f4d0603636f6d00d87373f3d5d404f7cdc3aace633c96357bc606ced620792597e1308b1d6c5902668c4d3c1a37bab8486ba24485d57a9d98157fe706424b2043bfb40306d0148403636f6d00002b00010001518000244d060d028acbb0cd28f41250a80a491389424d341522d946b0da0c0291f2d3d771d7805a03636f6d00002e0001000151800113002b08010001518068a404d06892d340b5690024fbea2f86eb0e472114b9da41f1da69e4ef2d02ffcd6bdd987239f288795603d5f54308b238ef19f2747d6a1bc0e775782025561b0f14d1dd19be6bf36b495a3e2d538d5532c5c6e1056c06aa4e81de07f637313955a7761d313db0c6cd0b5c17b4ee22d530d6cdc0c4e195df85b354bbe32027537f1ca21f2815b2d0dbd154582124b3c4c27f1c3aea16f6bfe7e6f5c80aaccd61601bdd8f947ef5c30f004482617cf97629b8b89d8e7320719c979c6a9defdf79b743ecef08bdf2f90796da018fdc6be1e0629fe706044e0f8ad1b25927eca09074a502eb9136eefe5903ad3f97866ab014f1ec96e1f38e3aba66520a25ace386f4897e1ecfd774ce0a0f8a00003000010002a30001080101030803010001acffb409bcc939f831f7a1e5ec88f7a59255ec53040be432027390a4ce896d6f9086f3c5e177fbfe118163aaec7af1462c47945944c4e2c026be5e98bbcded25978272e1e3e079c5094d573f0e83c92f02b32d3513b1550b826929c80dd0f92cac966d17769fd5867b647c3f38029abdc48152eb8f207159ecc5d232c7c1537c79f4b7ac28ff11682f21681bf6d6aba555032bf6f9f036beb2aaa5b3778d6eebfba6bf9ea191be4ab0caea759e2f773a1f9029c73ecb8d5735b9321db085f1b8e2d8038fe2941992548cee0d67dd4547e11dd63af9c9fc1c5466fb684cf009d7197c2cf79e792ab501e6a8a1ca519af2cb9b5f6367e94c0d47502451357be1b500003000010002a30001080101030803010001af7a8deba49d995a792aefc80263e991efdbc86138a931deb2c65d5682eab5d3b03738e3dfdc89d96da64c86c0224d9ce02514d285da3068b19054e5e787b2969058e98e12566c8c808c40c0b769e1db1a24a1bd9b31e303184a31fc7bb56b85bbba8abc02cd5040a444a36d47695969849e16ad856bb58e8fac8855224400319bdab224d83fc0e66aab32ff74bfeaf0f91c454e6850a1295207bbd4cdde8f6ffb08faa9755c2e3284efa01f99393e18786cb132f1e66ebc6517318e1ce8a3b7337ebb54d035ab57d9706ecd9350d4afacd825e43c8668eece89819caf6817af62dc4fbd82f0e33f6647b2b6bda175f14607f59f4635451e6b27df282ef73d8700003000010002a30001080100030803010001b11b182a464c3adc6535aa59613bda7a61cac86945c20b773095941194f4b9f516e8bd924b1e50e3fe83918b51e54529d4e5a1e45303df8462241d5e05979979ae5bf9c6c598c08a496e17f3bd3732d5aebe62667b61db1bbe178f27ac99408165a230d6aee78348e6c67789541f845b2ada96667f8dd16ae44f9e260c4a138b3bb1015965ebe609434a06464bd7d29bac47c3017e83c0f89bca1a9e3bdd0813715f3484292df589bc632e27d37efc02837cb85d770d5bd53a36edc99a8294771aa93cf22406f5506c8cf850ed85c1a475dee5c2d3700b3f5631d903524b849995c20cb407ed411f70b428ae3d642716fe239335aa961a752e67fb6dca0bf72900003000010002a30001080100030803010001b6aec4b48567e2925a2d9c4fa4c96e6dddf86215a9bd8dd579c38ccb1199ed1be89946a7f72fc2633909a2792d0eed1b5afb2ee4c78d865a76d6cd9369d999c96af6be0a2274b8f2e9e0a0065bd20257570f08bc14c16f5616426881a83dbce6926e391c138a2ec317efa7349264de2e791c9b7d4a6048ee6eedf27bf1ece398ff0d229f18377cb1f6b98d1228ef217b8146c0c73851b89a6fc37c621ca187e16428a743ffea0072e185ef93e39525cee3ad01e0c94d2e511c8c313322c29ab91631e1856049a36898684c3056e5997473816fb547acb0be6e660bdfa89a5cb28b3669d8625f3f018c7b3b8a4860e774ee8261811ce7f96c461bc162c1a374f300002e00010002a3000113003008000002a30068a66180688ab2004f66007d114bf33e6d20e7588fdfde9a9e2a8ebd5593ce8bc06419e1d1a4afa8766abc1626504ea6243ca5fc9bce55a3f03c0e7eb488409690d84c3beb30f299da007ab69299d0e203c5b44b94328248768089a9b68982650e9ca2d37526307cbd9f06690e58c3c4a1703b1d1193ea0501417944b937b593294e339571eec42a3c700ce075d9c446e5d32bf979396c1c7935f69bd7df2826567fe582a3615d6095368be991b1e5dc39c0af3b0c39e0e353bbcb928e52e886193ac88da0cd8665ea992b642975aa5486f2e6514d0b5086c66ddd58fe8f7a27ecb128211e3ca1bdc4cad91f3cc9b63c526ebaea86075318e33bfc5a53c919e6f01262b24d178eb2cd04b1</tt>\n\nFurther valid test cases can be generated by using https://satsto.me and selecting the \"Look up using satsto.me's native proof server\" option. This will cause lookups to be a single request to a server that returns a full DNSSEC proof (without the HRN prefix), which can be exracted using your browser's console.\n\nGenerated proofs can be tested against the below <code>dnssec-prover</code> implementation at https://satsto.me/prooftest.html\n\n\n== Reference Implementations ==\n* A DNSSEC proof generation and validation implementation can be found at https://git.bitcoin.ninja/index.cgi?p=dnssec-prover;a=summary\n* A lightning-specific name to payment instruction resolver can be found at https://git.bitcoin.ninja/index.cgi?p=lightning-resolver;a=summary\n* Reference implementations for parsing the URI contents can be found in [[bip-0321.mediawiki|BIP 321]].\n\n\n== Footnotes ==\n\n<references />\n\n== Acknowledgements ==\n\nThanks to Rusty Russell for the concrete address rotation suggestion.\n\nThanks to the Bitcoin Design Community, and especially Christoph Ono for lots of discussion, analysis, and UX mockups in how human-readable payment instructions should be displayed.\n\nThanks to Andrew Kaizer for the suggestion to explicitly restrict cache lifetime to the relevant DNS TTLs.\n", "content_length": 63335}
{"bip_number": 352, "filename": "bip-0352.mediawiki", "content": "<pre>\n  BIP: 352\n  Layer: Applications\n  Title: Silent Payments\n  Author: josibake <josibake@protonmail.com>\n          Ruben Somsen <rsomsen@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n  Status: Proposed\n  Type: Standards Track\n  Created: 2023-03-09\n  License: BSD-2-Clause\n  Post-History: 2022-03-13: https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8 [gist] Original proposal\n                2022-03-28: https://gnusha.org/pi/bitcoindev/CAPv7TjbXm953U2h+-12MfJ24YqOM5Kcq77_xFTjVK+R2nf-nYg@mail.gmail.com/ [bitcoin-dev] Silent Payments \u2013 Non-interactive private payments with no on-chain overhead\n                2022-10-11: https://gnusha.org/pi/bitcoindev/P_21MLHGJicZ-hkbC4DGu86c5BtNKiH8spY4TOw5FJsfimdi_6VyHzU_y-s1mZsOcC2FA3EW_6w6W5qfV9dRK_7AvTAxDlwVfU-yhWZPEuo=@protonmail.com/ [bitcoin-dev] Silent Payment v4 (coinjoin support added)\n                2023-08-04: https://gnusha.org/pi/bitcoindev/ZM03twumu88V2NFH@petertodd.org/ [bitcoin-dev] BIP-352 Silent Payments addresses should have an expiration time\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\n\nThis document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n\n=== Copyright ===\n\nThis BIP is licensed under the BSD 2-clause license.\n\n=== Motivation ===\n\nUsing a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver, so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n\nHowever, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out-of-band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n\nThis proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n\nThe design keeps collaborative transactions such as CoinJoins and inputs with MuSig and FROST keys in mind, but it is recommended that the keys of all inputs of a transaction belong to the same entity as there is no formal proof that the protocol is secure in a collaborative setting.\n\n== Goals ==\n\nWe aim to present a protocol which satisfies the following properties:\n\n* No increase in the size or cost of transactions\n* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n* Transactions can't be linked to a silent payment address by an outside observer\n* No sender-receiver interaction required\n* No linking of multiple payments to the same sender\n* Each silent payment goes to a unique address, avoiding accidental address reuse\n* Supports payment labeling\n* Uses existing seed phrase or descriptor methods for backup and recovery\n* Separates scanning and spending responsibilities\n* Compatible with other spending protocols, such as CoinJoin\n* Light client/SPV wallet support\n* Protocol is upgradeable\n\n== Overview ==\n\nWe first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, ''\u00b7'' refers to elliptic curve scalar multiplication, ''G'' represents the generator point for secp256k1, and ''n'' represents the curve order for secp256k1. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n\n''' Simple case '''\n\nBob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n\n* Let ''P = B + hash(a\u00b7B)\u00b7G''\n* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n\nSince ''a\u00b7B == b\u00b7A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie\u2013Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b\u00b7A)\u00b7G'' and seeing that ''P'' is present in the transaction outputs).\n\n''' Creating more than one output '''\n\nIn order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n\n* Let ''k = 0''\n* Let ''P<sub>0</sub> = B + hash(a\u00b7B || k)\u00b7G''\n* For additional outputs:\n** Increment ''k'' by one (''k++'')\n** Let ''P<sub>i</sub> = B + hash(a\u00b7B || k)\u00b7G''\n\nBob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b\u00b7A || 0)\u00b7G''. Once he detects the first output, he must:\n\n* Check for ''P<sub>1</sub> = B + hash(b\u00b7A || 1)\u00b7G''\n* If ''P<sub>1</sub>'' is not found, stop\n* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n\nSince Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible. It should also be noted that the order in which these outputs appear in the transaction does not affect the outcome.\n\n''' Preventing address reuse '''\n\nIf Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destinations ''P<sub>i</sub>''. To prevent this, Alice should include an input hash in the following manner:\n\n* Let ''input_hash = hash(outpoint || A)''<ref name=\"why_include_A\">'''Why include A in the input hash calculation?''' By committing to A in input hash, this ensures that the sender cannot maliciously choose a private key ''a&prime;'' in a subsequent transaction where ''a&prime; = input_hash\u00b7a / input_hash&prime;'', which would force address reuse in the protocol.</ref>\n* Let ''P<sub>0</sub> = B + hash(input_hash\u00b7a\u00b7B || 0)\u00b7G''\n\nBob must calculate the same ''input_hash'' when scanning.\n\n''' Using all inputs '''\n\nIn our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the silent payments protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 33 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie\u2013Hellman] to prevent the other participants from learning who Alice is paying. Note it is currently not recommended to use this protocol for CoinJoins due to a lack of a formal security proof.</ref>.\n\nAlice performs the tweak with the sum of her input private keys in the following manner:\n\n* Let ''a = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>n</sub>''\n* Let ''input_hash = hash(outpoint<sub>L</sub> || (a\u00b7G))'', where ''outpoint<sub>L</sub>'' is the smallest outpoint lexicographically<ref name=\"why_smallest_outpoint\">'''Why use the lexicographically smallest outpoint for the hash?''' Recall that the purpose of including the input hash is so that the sender and receiver can both come up with a deterministic nonce that ensures that a unique address is generated each time, even when reusing the same scriptPubKey as an input. Choosing the smallest outpoint lexicographically satisfies this requirement, while also ensuring that the generated output is not dependent on the final ordering of inputs in the transaction. Using a single outpoint also works well with memory constrained devices (such as hardware signing devices) as it does not require the device to have the entire transaction in memory in order to generate the silent payment output.</ref>\n* Let ''P<sub>0</sub> = B + hash(input_hash\u00b7a\u00b7B || 0)\u00b7G''\n\n''' Spend and Scan Key '''\n\nSince Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n\n* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(input_hash\u00b7a\u00b7B<sub>scan</sub> || 0)\u00b7G''\n\nBob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(input_hash\u00b7b<sub>scan</sub>\u00b7A || 0)\u00b7G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(input_hash\u00b7b<sub>scan</sub>\u00b7A || 0)) mod n'' as the private key.\n\n''' Labels '''\n\nFor a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n\n* Let ''B<sub>m</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub> || m)\u00b7G'' where m is an incrementable integer starting from 1\n* Publish ''(B<sub>scan</sub>, B<sub>1</sub>)'', ''(B<sub>scan</sub>, B<sub>2</sub>)'' etc.\n\nAlice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n\n* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(input_hash\u00b7b<sub>scan</sub>\u00b7A || 0)\u00b7G''\n* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''hash(b<sub>scan</sub> || 1)\u00b7G'', ''hash(b<sub>scan</sub> || 2)\u00b7G'' etc.) that the wallet has previously used\n\nIt is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n\n''' Labels for change '''\n\nBob can also use labels for managing his own change outputs. We reserve ''m = 0'' for this use case. This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. It is important that the wallet never hands out the label with ''m = 0'' in order to ensure nobody else can create payments that are wrongly labeled as change.\n\nWhile the use of labels is optional, every receiving silent payments wallet should at least scan for the change label when recovering from backup in order to ensure maximum cross-compatibility.\n\n== Specification ==\n\nWe use the following functions and conventions:\n\n* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the input hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted Y coordinate.\n\nFor everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340]. This includes the ''hash<sub>tag</sub>(x)'' notation to refer to ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n\n=== Versions ===\n\nThis document defines version 0 (''sp1q''). Version is communicated through the address in the same way as bech32 addresses (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32 BIP173]. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n\nFuture silent payments versions will use the following scheme:\n\n{| class=\"wikitable\"\n|-\n!\n!0\n!1\n!2\n!3\n!4\n!5\n!6\n!7\n!Compatibility\n|-\n!+0\n|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n|-\n!+8\n|g||f||2||t||v||d||w||0\n|-\n!+16\n|s||3||j||n||5||4||k||h\n|-\n!+24\n|c||e||6||m||u||a||7|| -\n|}\n\n''v31'' (l) is reserved for a backwards incompatible change, if needed. For silent payments v0:\n\n* If the receiver's silent payment address version is:\n** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes\n** ''v31'': fail\n* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n\n=== Scanning silent payment eligible transactions ===\n\nFor silent payments v0 a transaction MUST be scanned if and only if all of the following are true:\n\n* The transaction contains at least one BIP341 taproot output (note: spent transactions optionally can be skipped by only considering transactions with at least one unspent taproot output)\n* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n* The transaction does not spend an output with SegWit version > 1<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend SegWit version > 1?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for silent payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a new SegWit version is added in the future and silent payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n\n=== Address encoding ===\n\nA silent payment address is constructed in the following manner:\n\n* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n* Let ''B<sub>m</sub> = B<sub>spend</sub> + hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))\u00b7G'', where ''hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))\u00b7G'' is an optional integer tweak for labeling\n** If no label is applied then ''B<sub>m</sub> = B<sub>spend</sub>''\n* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n** The data-part values:\n*** The character \"q\", to represent a silent payment address of version 0\n*** The 66-byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n\nNote: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 segwit addresses and limits versions to 0 through 16, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n\n\n* HRP [2-3 characters]\n* separator [1 character]\n* version [1-2 characters]\n* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n* checksum [6 characters]\n\n\nFor a silent payments v0 address, this results in a 117-character address when using a 3-character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023-character limit is suggested.</ref> and allows versions up to 31. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n\n=== Inputs For Shared Secret Derivation ===\n\nWhile any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n\n* ''P2TR''\n* ''P2WPKH''\n* ''P2SH-P2WPKH''\n* ''P2PKH''\n\nInputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are excluded from shared secret derivation as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this by using only the output public key.\n\nFor all of the output types listed, only X-only and compressed public keys are permitted<ref name=\"why_only_compressed_public_keys\">''' Why only compressed public keys ''' Uncompressed and hybrid public keys are less common than compressed keys and generally considered to be a bad idea due to their blockspace inefficiency. Additionally, [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#restrictions-on-public-key-type BIP143] recommends restricting P2WPKH inputs to compressed keys as a default policy.</ref>.\n\n''' P2TR '''\n\n'' Keypath spend ''\n\n    witness:      <signature>\n    scriptSig:    (empty)\n    scriptPubKey: 1 <32-byte-x-only-key>\n                  (0x5120{32-byte-x-only-key})\n\nThe sender uses the private key corresponding to the taproot output key (i.e. the tweaked private key). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig supported?''' While we do not recommend it due to lack of a security proof (except if all participants are trusted or are the same entity), any taproot output able to do a key path theoretically is supported. Any offline key aggregation technique can be used, such as FROST or MuSig. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>1</sub>\u00b7B<sub>scan</sub> + a<sub>2</sub>\u00b7B<sub>scan</sub> + ... + a<sub>t</sub>\u00b7B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(input_hash\u00b7ECDH || 0)\u00b7G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. The receiver obtains the public key from the ''scriptPubKey'' (i.e. the taproot output key).\n\n'' Script path spend ''\n\n    witness:      <optional witness items> <leaf script> <control block>\n    scriptSig:    (empty)\n    scriptPubKey: 1 <32-byte-x-only-key>\n                  (0x5120{32-byte-x-only-key})\n\nSame as a keypath spend, the sender MUST use the private key corresponding to the taproot output key. If this key is not available, the output cannot be included as an input to the transaction. Same as a keypath spend, the receiver obtains the public key from the ''scriptPubKey'' (i.e. the taproot output key)<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where the sender can perform ECDH with the key path private key but spends the output using the script path.</ref>.\n\nThe one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H'' is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the input will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>. The receiver determines whether or not to skip the input by checking in the control block if the taproot internal key is equal to ''H''.\n\n''' P2WPKH '''\n\n    witness:      <signature> <33-byte-compressed-key>\n    scriptSig:    (empty)\n    scriptPubKey: 0 <20-byte-key-hash>\n                  (0x0014{20-byte-key-hash})\n\nThe sender performs the tweak using the private key for the output and the receiver obtains the public key as the last witness item.\n\n''' P2SH-P2WPKH '''\n\n    witness:      <signature> <33-byte-compressed-key>\n    scriptSig:    <0 <20-byte-key-hash>>\n                  (0x160014{20-byte-key-hash})\n    scriptPubKey: HASH160 <20-byte-script-hash> EQUAL\n                  (0xA914{20-byte-script-hash}87)\n\nThe sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key as the last witness item.\n\n''' P2PKH '''\n\n    scriptSig:    <signature> <33-byte-compressed-key>\n    scriptPubKey: OP_DUP HASH160 <20-byte-key-hash> OP_EQUALVERIFY OP_CHECKSIG\n                  (0x76A914{20-byte-key-hash}88AC)\n\nThe receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' does not match the template specified (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n\n=== Sender ===\n\n==== Selecting inputs ====\n\nThe sending wallet performs coin selection as usual with the following restrictions:\n\n* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n* Exclude inputs with SegWit version > 1 (see ''[[#scanning-silent-payment-eligible-transactions|Scanning silent payment eligible transactions]]'')\n* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n\n==== Creating outputs ====\n\nAfter the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n\n* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even Y coordinate and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each X-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even Y coordinate when performing the ECDH step since the receiver will assume the even Y coordinate when summing the taproot X-only public keys.</ref>\n* Let ''a = a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n** If ''a = 0'', fail\n* Let ''input_hash = hash<sub>BIP0352/Inputs</sub>(outpoint<sub>L</sub> || A)'', where ''outpoint<sub>L</sub>'' is the smallest ''outpoint'' lexicographically used in the transaction<ref name=\"why_smallest_outpoint\"></ref> and ''A = a\u00b7G''\n** If ''input_hash'' is not a valid scalar, i.e., if ''input_hash = 0'' or ''input_hash'' is larger or equal to the secp256k1 group order, fail\n* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n* For each group:\n** Let ''ecdh_shared_secret = input_hash\u00b7a\u00b7B<sub>scan</sub>''\n** Let ''k = 0''\n** For each ''B<sub>m</sub>'' in the group:\n*** Let ''t<sub>k</sub> = hash<sub>BIP0352/SharedSecret</sub>(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(k))''\n**** If ''t<sub>k</sub>'' is not a valid scalar, i.e., if ''t<sub>k</sub> = 0'' or ''t<sub>k</sub>'' is larger or equal to the secp256k1 group order, fail\n*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>k</sub>\u00b7G''\n*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n*** Optionally, repeat with k++ to create additional outputs for the current ''B<sub>m</sub>''\n*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''k++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>k</sub>'' when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''k'', an outside observer could subtract the two output values and observe that this value is the same as the difference between two published silent payment addresses and learn who the recipient is.</ref>\n** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs by sending to its own silent payment address using label ''m = 0'', following the steps above\n\nAll generated outputs MUST be present in the final transaction. If an output ''P<sub>i</sub>'' with ''i < k'' is omitted, the receiver will not be able to find outputs ''P<sub>j</sub>'' where ''i < j <= k''.\n\n=== Receiver ===\n\n==== Key Derivation ====\n\nTwo keys are needed to create a silent payments address: the spend key and the scan key. To ensure compatibility, wallets MAY use BIP32 derivation with the following derivation paths for the spend and scan key. When using BIP32 derivation, wallet software MUST use hardened derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any BIP32/BIP43 compatible wallet. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> for both the spend and scan key.\n\nA scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n\n     scan_private_key: m / purpose' / coin_type' / account' / 1' / 0\n    spend_private_key: m / purpose' / coin_type' / account' / 0' / 0\n\n<code>purpose</code> is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n\n==== Scanning ====\n\nIf each of the checks in ''[[#scanning-silent-payment-eligible-transactions|Scanning silent payment eligible transactions]]'' passes, the receiving wallet must:\n\n* Let ''A = A<sub>1</sub> + A<sub>2</sub> + ... + A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n** If ''A'' is the point at infinity, skip the transaction\n* Let ''input_hash = hash<sub>BIP0352/Inputs</sub>(outpoint<sub>L</sub> || A)'', where ''outpoint<sub>L</sub>'' is the smallest ''outpoint'' lexicographically used in the transaction<ref name=\"why_smallest_outpoint\"></ref>\n** If ''input_hash'' is not a valid scalar, i.e., if ''input_hash = 0'' or ''input_hash'' is larger or equal to the secp256k1 group order, fail\n* Let ''ecdh_shared_secret = input_hash\u00b7b<sub>scan</sub>\u00b7A''\n* Check for outputs:\n** Let ''outputs_to_check'' be the taproot output keys from all taproot outputs in the transaction (spent and unspent).\n** Starting with ''k = 0'':\n*** Let ''t<sub>k</sub> = hash<sub>BIP0352/SharedSecret</sub>(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(k))''\n**** If ''t<sub>k</sub>'' is not a valid scalar, i.e., if ''t<sub>k</sub> = 0'' or ''t<sub>k</sub>'' is larger or equal to the secp256k1 group order, fail\n*** Compute ''P<sub>k</sub> = B<sub>spend</sub> + t<sub>k</sub>\u00b7G''\n*** For each ''output'' in ''outputs_to_check'':\n**** If ''P<sub>k</sub>'' equals ''output'':\n***** Add ''P<sub>k</sub>'' to the wallet\n***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''k++''\n**** Else, check for labels (always check for the change label, i.e. ''hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))'' where ''m = 0'')<ref name=\"precompute_labels\">''' Why precompute labels?''' Precomputing the labels is not strictly necessary: a wallet could track the max number of labels it has used (call it ''M'') and scan for labels by adding ''hash(b<sub>scan</sub> || m)\u00b7G'' to ''P<sub>0</sub>'' for each label ''m'' up to ''M'' and comparing to the transaction outputs. This is more performant than precomputing the labels and checking via subtraction in cases where the number of eligible outputs exceeds the number of labels in use. In practice this will mainly apply to users that choose never to use labels, or users that use a single label for generating silent payment change outputs. If using a large number of labels, the wallet would need to add all possible labels to each output. This ends up being ''n\u00b7M'' additions, where ''n'' is the number of outputs in the transaction and ''M'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''hash(b<sub>scan</sub> || m)\u00b7G'' once when creating the labeled address and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:\n***** Compute ''label = output - P<sub>k</sub>''\n***** Check if ''label'' exists in the list of labels used by the wallet\n***** If a match is found:\n****** Add ''P<sub>k</sub> + label'' to the wallet\n****** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''k++''\n***** If a label is not found, negate ''output'' and check a second time<ref name=\"negate_output\">''' Why negate the output?''' Unfortunately taproot outputs are X-only, meaning we don't know what the correct Y coordinate is. This causes this specific calculation to fail 50% of the time, so we need to repeat it with the other Y coordinate by negating the output.</ref>\n*** If no matches are found, stop\n\n==== Spending ====\n\nRecall that a silent payment output is of the form ''B<sub>spend</sub> + t<sub>k</sub>\u00b7G + hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))\u00b7G'', where ''hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))\u00b7G'' is an optional label. To spend a silent payment output:\n\n* Let ''d = (b<sub>spend</sub> + t<sub>k</sub> + hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))) mod n'', where ''hash<sub>BIP0352/Label</sub>(ser<sub>256</sub>(b<sub>scan</sub>) || ser<sub>32</sub>(m))'' is the optional label\n* Spend the [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] output with the private key ''d''\n\n==== Backup and Recovery ====\n\nSince each silent payment output address is derived independently, regular backups are recommended. When recovering from a backup, the wallet will need to scan since the last backup to detect new payments.\n\nIf using a seed/seed phrase only style backup, the user can recover the wallet's unspent outputs from the UTXO set (i.e. only scanning transactions with at least one unspent taproot output) and can recover the full wallet history by scanning the blockchain starting from the wallet birthday. If a wallet uses labels, this information SHOULD be included in the backup. If the user does not know whether labels were used, it is strongly recommended they always precompute and check a large number of labels (e.g. 100k labels) to use when re-scanning. This ensures that the wallet can recover all funds from only a seed/seed phrase backup. The change label should simply always be scanned for, even when no other labels were used. This ensures the use of a change label is not critical for backups and maximizes cross-compatibility.\n\n== Backward Compatibility ==\n\nSilent payments introduces a new address format and protocol for sending and as such is not compatible with older wallet software or wallets which have not implemented the silent payments protocol.\n\n== Test Vectors ==\n\nA [[bip-0352/send_and_receive_test_vectors.json|collection of test vectors in JSON format]] are provided, along with a [[bip-0352/reference.py|python reference implementation]]. Each test vector consists of a sending test case and corresponding receiving test case. This is to allow sending and receiving to be implemented separately. To ensure determinism while testing, sort the array of ''B<sub>m</sub>'' by amount (see the [[bip-0352/reference.py|reference implementation]]). Test cases use the following schema:\n\n''' test_case '''\n\n    {\n        \"comment\": \"Comment describing the behavior being tested\",\n        \"sending\": [<array of sender test objects>],\n        \"receiving\": [<array of recipient test objects>],\n    }\n\n''' sender '''\n\n    {\n        \"given\": {\n            \"vin\": [<array of vin objects with an added field for the private key. These objects are structured to match the `vin` output field from `getrawtransaction verbosity=2`>],\n            \"recipients\": [<array of strings, where each string is a bech32m encoding representing a silent payment address>]\n        },\n        \"expected\": {\n            \"outputs\": [<array of strings, where each string is a hex encoding of 32-byte X-only public key; contains all possible output sets, test must match a subset of size `n_outputs`>],\n            \"n_outputs\": <integer for the exact number of expected outputs>,\n        },\n    }\n\n''' recipient '''\n\n    {\n        \"given\": {\n            \"vin\": [<array of vin objects. These objects are structured to match the `vin` output field from `getrawtransaction verbosity=2`>],\n            \"key_material\": {\n                \"scan_priv_key\": <hex encoded scan private key>,\n                \"spend_priv_key\": <hex encoded spend private key>,\n            }\n            \"labels\": [<array of ints, representing labels the receiver has used>],\n         },\n         \"expected\": {\n             \"addresses\": [<array of bech32m strings, one for the silent payment address and each labeled address (if used)>],\n             \"outputs\": [<array of outputs with tweak and signature; contains all possible output sets, tester must match a subset of size `n_outputs`>\n                 {\n                     \"priv_key_tweak\": <hex encoded private key tweak data>,\n                     \"pub_key\": <hex encoded X-only public key>,\n                     \"signature\": <hex encoded signature for the output (produced with spend_priv_key + priv_key_tweak)>\n                 },\n                 ...\n             ],\n             \"n_outputs\": <integer for the exact number of expected outputs>\n         }\n     }\n\nWallets should include inputs not in the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list when testing to ensure that only inputs from the list are being used for shared secret derivation. Additionally, receiving wallets should include non-silent payment outputs for themselves in testing to ensure silent payments scanning does not interfere with regular outputs detection.\n\n=== Functional tests ===\n\nBelow is a list of functional tests which should be included in sending and receiving implementations.\n\n==== Sending ====\n\n* Ensure taproot outputs are excluded during coin selection if the sender does not have access to the key path private key (unless using ''H'' as the taproot internal key)\n* Ensure the silent payment address is re-derived if inputs are added or removed during RBF\n\n==== Receiving ====\n\n* Ensure the public key can be extracted from non-standard ''P2PKH'' scriptSigs\n* Ensure taproot script path spends are included, using the taproot output key (unless ''H'' is used as the taproot internal key)\n* Ensure the scanner can extract the public key from each of the input types supported (e.g. ''P2WPKH'', ''P2SH-P2WPKH'', etc.)\n\n== Appendix A: Light Client Support ==\n\nThis section proposes a few ideas for how light clients could support scanning for incoming silent payments (sending is fairly straightforward) in ways that preserve bandwidth and privacy. While this is out of scope for the current BIP, it is included to motivate further research into this topic. In this context, a light client refers to any bitcoin wallet client which does not process blocks and does not have a direct connection to a node which does process blocks (e.g. a full node). Based on this definition, clients that directly connect to a personal electrum server or a bitcoin node are not light clients.\n\nThis distinction makes the problem for light clients more clear: light clients need a way to source the necessary data for performing the tweaks and a way of determining if any of the generated outputs exist in a block.\n\n=== Tweak Data ===\n\nRecall that a silent payment eligible transaction follows [[#scanning-silent-payment-eligible-transactions|certain conditions]] and should have at least one unspent taproot output. Full nodes (or any index server backed by a full node, such as electrum server) can build an index which collects all of the eligible public keys for a silent payments eligible transaction, sums them up, multiplies the sum by the ''input_hash'', and serves them to clients. This would be 33 bytes per silent payment eligible transaction.\n\nFor a typical bitcoin block of ~3500 txs, lets assume every transaction is a silent payments eligible transaction. This means a client would need to request ''33 bytes * 3500'' of data per block (roughly 100 kB per block). If a client were to request data for every block, this would amount to ~450 MB per month, assuming 100% taproot usage and all non-dust outputs remain unspent for > 1 month. As of today, these numbers are closer to 7\u201312 kB per block (30\u201350 MB per month)<ref name=\"appendix_data\">''' Data for Appendix A ''' These numbers are based on data from January 2023 until July 2024. See [https://github.com/josibake/bitcoin-data-analysis/blob/main/notebooks/silent-payments-light-client-data.ipynb Silent payments light client data] for the full analysis.</ref>.\n\n=== Transaction cut-through ===\n\nIt is unlikely a light client would need to scan every block and as such can take advantage of transaction cut-through, depending on how often they choose to scan for new blocks. Empirically, ~75% of transactions with at least one non-dust unspent taproot output will have spent all non-dust taproot UTXOs in 150 blocks or less<ref name=\"appendix_data\"></ref>. This means a client that only scans once per day could ''significantly'' cut down on the number of blocks and the number of transactions per block that they need to request by only asking for data on transactions that were created since their last scan and that still have at least one non-dust unspent taproot output as of the current block height. Based on taproot adoption as of July 2024, a light client scanning once every 3 days would use roughly 30 MB per month<ref name=\"appendix_data\">.\n\n[[File:bip-0352/scan_data_downloader_per_month.png]]\n\n=== BIP158 ===\n\nOnce a light client has the tweak data for a block, they can determine whether or not an output to them exists in the block using BIP158 block filters. Per BIP158, they would then request the entire block and add the transaction to their wallet, though it maybe be possible to only request the prevout txids and vouts for all transactions with at least one taproot output, along with the scriptPubKeys and amounts. This would allow the client to download the necessary data for constructing a spending transaction, without downloading the entire block. How this affects the security assumptions of BIP158 is an open question.\n\n=== Out-of-band notifications ===\n\nAssuming a secure messaging protocol exists, the sender can send an encrypted (using the scan public key of the silent payment address) notification to the receiver with the following information:\n* The spend public key (communicates the label)\n* The shared secret portion of the private key (i.e ''hash(ecdh_shared_secret || k)'')\n* The outpoint and amount (so it's immediately spendable)\n\nIt is important to note that these notifications are not required. At any point, the receiver can fall back to scanning for silent payment transactions if they don't trust the notifications they are receiving, are being spammed with fake notifications, or if they are concerned that they are not receiving notifications.\n\nA malicious notification could potentially cause the following issues:\n\n* You did not actually receive money to the stated key\n** This can be probabilistically resolved by matching the key against the BIP158 block filters and assuming it's not a false positive, or fully resolved by downloading the block\n* You received money but the outpoint or amount is incorrect, so attempts to spend it will fail or cause you to overpay fees\n** There doesn't seem to be much motivation for malicious senders to ever do this, but light clients need to take into account that this can occur and should ideally check for it by downloading the block\n* The private key is correct but it wasn't actually derived using the silent payment protocol, causing recovery from back-up to fail (unsafe - no implementation should ever allow this)\n** This can be detected by downloading the tweak data of the corresponding block and should be resolved by immediately spending the output\n\nWallet designers can choose which tradeoffs they find appropriate. For example, a wallet could check the block filter to at least probabilistically confirm the likely existence of the UTXO, thus efficiently cutting down on spam. The payment could then be marked as unconfirmed until a scan is performed and the existence of the UTXO in accordance to the silent payment specification is verified.\n\n== Change Log ==\n\nTo help implementers understand updates to this document, we attach a version number that resembles ''semantic versioning'' (<code>MAJOR.MINOR.PATCH</code>).\nThe <code>MAJOR</code> version is incremented if changes to the BIP are introduced that are incompatible with prior versions.\nThe <code>MINOR</code> version is incremented whenever the inputs or the output of an algorithm changes in a backward-compatible way or new backward-compatible functionality is added.\nThe <code>PATCH</code> version is incremented for other changes that are noteworthy (bug fixes, test vectors, important clarifications, etc.).\n\n* '''1.0.2''' (2025-07-25):\n** Clarify how to handle the improbable corner case where the output of SHA256 is equal to 0 or greater than or equal to the secp256k1 curve order.\n* '''1.0.1''' (2024-06-22):\n** Add steps to fail if private key sum is zero (for sender) or public key sum is point at infinity (for receiver), add corresponding test vectors.\n* '''1.0.0''' (2024-05-08):\n** Initial version, merged as BIP-352.\n\n== Acknowledgements ==\n\nThis document is the result of many discussions and contains contributions by a number of people. The authors wish to thank all those who provided valuable feedback and reviews, including the participants of the [https://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae BIP47 Prague discussion], the [https://github.com/josibake/silent-payments-workshop Advancing Bitcoin silent payments Workshop], and [https://btctranscripts.com/bitcoin-core-dev-tech/2023-04/2023-04-26-silent-payments/ coredev]. The authors would like to also thank [https://github.com/w0xlt w0xlt] for writing the initial implementation of silent payments.\n\n== Rationale and References ==\n<references/>\n\n", "content_length": 51268}
{"bip_number": 351, "filename": "bip-0351.mediawiki", "content": "<pre>\n  BIP: 351\n  Layer: Applications\n  Title: Private Payments\n  Author: Alfred Hodler <alfred_hodler@protonmail.com>\n          Clark Moody <clark@clarkmoody.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0351\n  Status: Draft\n  Type: Informational\n  Created: 2022-07-10\n  License: MIT\n</pre>\n\n==Abstract==\n\nThis BIP makes it possible for two parties to transact using addresses that only they can calculate. This is done using exclusively on-chain methods and in a manner that minimizes blockchain footprint. Receiving parties can share their payment codes publicly without a loss of privacy, as every sender will calculate a unique set of addresses for each payment code.\n\n==Motivation==\n\nA recipient that wishes to receive funds privately has several options. Each has tradeoffs in terms of chain analysis potential, recoverability, and wallet complexity.\n\n'''Sharing a static address''' works well enough for one-time payments between two parties as long as the address is shared through a private channel. It does not work well for recurring payments because address reuse leads to a loss of privacy. Using this method for donations exacerbates the problem since the address will serve as a focal point for data collection and analysis. Wallets must not reissue the same address to multiple recipients.\n\n'''Sharing a BIP32 extended public key''' works for recurring payments between two parties only. The same key cannot be shared to any other party without leaking the chain of payments. Furthermore, an extended public key does not say anything about address types and makes it possible for a sender to send to a script that a recipient cannot spend from. Alternate [https://github.com/satoshilabs/slips/blob/master/slip-0132.md version bytes] have been proposed to specify address types, but wallet adoption is limited.\n\n'''Sharing a BIP380 descriptor containing an extended public key''' solves the address type issue from sharing a raw BIP32 extended key. The drawback is that descriptor support is not widespread, especially in mobile wallets.\n\n'''Using a payment server''' works in the case of recipients that have the resources to set up and maintain a payment server that will generate a fresh address for each payment. These are usually businesses and the method is usually out of reach for the average user. The centralized server is vulnerable to takedown remotely and physically.\n\n'''Sharing a BIP47 payment code''' addresses most of the above shortcomings. However, it introduces the following problems:\n\n* The BIP uses a notification mechanism that relies on publicly known per-recipient notification addresses. If Alice wants to send funds to Bob, she has to use the same notification address that everyone else uses to notify Bob. If Alice is not careful with coin selection, i.e. ensuring that her notification UTXO is not linked to her, she will publicly expose herself as someone who is trying to send funds to Bob and their relationship becomes permanently visible on the blockchain.\n\n* The BIP does not say anything about address types. Receiving wallets therefore have to watch all address types that can be created from a single public key. Even then, a sender could send to a script that a recipient cannot spend from.\n\n==Method==\n\nWhen Alice wants to start paying Bob in private, she imports his payment code into a compatible wallet. Her wallet extracts Bob's public key from the payment code and sends a notification transaction. If Bob finds a notification transaction addressed to himself, he imports Alice's public key contained therein and stores it. Bob then performs ECDH using Alice's public key and his own private key in order to calculate a common set of addresses to watch. Alice calculates the same set of addresses on her end and uses them to send coins to Bob. If Alice engages in coin control, both the initial notification transaction and subsequent payment transactions cannot be attributed to either party. Even if Alice uses coins that are already associated with her, chain analysis will identify her as a sender but Bob's privacy will remain entirely preserved.\n\n==Specification==\n\n===Definitions===\n\n* Alice: sender\n* Bob: recipient\n* Payment code: static string that Bob generates and shares with others so that he can receive payments\n* ''P'': public key contained in Bob's payment code\n* ''p'': private key associated with Bob's public key ''P''\n* ''N'': extended public key used by Alice to derive child keys for each Bob she wants to transact with\n* ''n'': private key associated with Alice's public key ''N''\n* ''x'': Alice's secret recipient index, unique for each Bob\n* ''N<sub>x</sub>'': child public key derived from ''N'' at index ''x'' (non-hardened)\n* ''n<sub>x</sub>'': private key associated with ''N<sub>x</sub>''\n* ''c'': Alice's transaction count toward Bob\n* ''P<sub>c</sub>'': Bob's public key at index ''c''\n* ''p<sub>c</sub>'': Bob's private key at index ''c''\n* ''A<sub>c</sub>'': Bob's receive address at index ''c''\n* ''H'': SHA256 hash function\n* ''*'': EC multiplication\n* ''+'': EC addition\n* ''|'': string concatenation\n* ''[a..b]'': string slicing (inclusive of ''a'', exclusive of ''b'')\n\n===Public Key Derivation Path===\n\nThe derivation path for this BIP follows BIP44. The following BIP32 path levels are defined:\n\n<code>\nm / purpose' / coin_type' / account'\n</code>\n\n<code>purpose</code> is set to 351.\n\n''(p, P)'' and ''(n, N)'' are keys associated with the above path, depending on which side is performing the calculation.\n\n''N<sub>x</sub>'' keys are the direct non-hardened children of ''N''. For instance, the path of ''N<sub>0</sub>'' from ''N'' is ''m / 0''.\n\n===Payment Code Structure and Encoding===\n\n* bytes <code>[0..2]</code>: address type flags (2 bytes)\n* bytes <code>[2..35]</code>: compressed public key P (33 bytes)\n\nPayment codes are encoded in bech32m and the human readable part is \"pay\" for mainnet and \"payt\" for testnet (all types), resulting in payment codes that look like \"pay1cqqq8d29g0a7m8ghmycqk5yv24mfh3xg8ptzqcn8xz6d2tjl8ccdnfkpjl7p84\".\n\n===Address Types===\n\nAddress type flags determine which address types a payment code accepts. This is represented by big-endian ordered 16 bits. For instance, a hypothetical payment code that handles all address types will have all defined bits set to 1 (<code>0xffff</code>).\n\nCurrently defined flags:\n\n{| class=\"wikitable\"\n! Address Type !! Flag !! Flag Value !! Ordinal Value\n|-\n| P2PKH || <code>1 << 0</code> || <code>0x0001</code> || 0\n|-\n| P2WPKH || <code>1 << 1</code> || <code>0x0002</code> || 1\n|-\n| P2TR || <code>1 << 2</code> || <code>0x0004</code> || 2\n|}\n\nThe remaining flags are reserved for future address types.\n\nWhile payment codes use 2-byte bitflag arrays, notifications use ordinal values in the form of a single byte.\n\nAll keys are compressed. Using uncompressed keys at any point is illegal.\n\n===Notifications===\n\nNotifications are performed by publishing transactions that contain a 40-byte <code>OP_RETURN</code> output. The value of the <code>OP_RETURN</code> is constructed using the following formula:\n\n''search_key | notification_code | N<sub>x</sub> | address_type''\n\n* ''search_key'' equals \"PP\" and is a static ASCII-encoded string (2 bytes)\n* ''notification_code'' is ''H(n<sub>x</sub> * P)[0..4]'' (4 bytes)\n* ''N<sub>x</sub>'' is the unique public key a sender is using for a particular recipient (33 bytes)\n* ''address_type'' is the '''ordinal''' value of a single address type that a sender wants to send to (1 byte). This must be selected from the recipient's accepted address types.\n\nWhen Alice wants to notify Bob that he will receive future payments from her, she performs the following procedure:\n\n# Assigns an unused, unique index ''x'' to Bob (''0'' if Bob is the first party she is notifying).\n# Calculates a 4-byte notification code: ''notification_code = H(n<sub>x</sub> * P)[0..4]''\n# Commits to one of Bob's accepted address types by choosing its ordinal value. Going forward Alice must not send to address types other than the one she committed to in the notification.\n# Constructs a notification payload by concatenating the above values according to the formula.\n# Selects any UTXO in her wallet, preferably not associated with her.\n# Sends a transaction including an <code>OP_RETURN</code> output whose value is set to the constructed payload.\n\nWhen Bob notices a 40-byte <code>OP_RETURN</code> starting with ''search key'', he performs the following procedure:\n\n# Breaks down the payload into its four constituent parts.\n# Discards the ''search_key'' (item #0).\n# Selects ''N<sub>x</sub>'' (item #2) and performs ''H(N<sub>x</sub> * p)'' (Bob does not know the value of ''x''). Bob takes the first four bytes of the calculated value.\n# If the four bytes match the notification value (item #1), Bob found a notification addressed to himself and stores ''N<sub>x</sub>'' together with ''address_type''.\n# If this process fails for any reason, Bob assumes a spurious notification or one not addressed to himself and gives up.\n\nSince changing ''x'' yields a completely different sender identity, Alice can always re-notify Bob from a different index when she does not want to be associated with her previous identity. Alice can also re-notify Bob when she wants to start sending to a different address type. Bob must be able to update his watchlist in that case and he can stop watching addresses associated with the old address type.\n\nOut-of-band notifications between Alice and Bob are legal (in fact, they may not be prevented), but in that case Bob loses the ability to restore his wallet from <code>OP_RETURN</code> outputs embedded in the blockchain. In that case, Bob has the burden of keeping a valid backup of any out-of-band notifications.\n\n===Allowing Notification Collisions===\n\nSince ''notification_code'' is a 4-byte truncation of the full value, Bob has a 1 in ~4.3 billion chance of detecting a spurious notification. This is considered acceptable because the cost of doing so is adding a few more addresses to Bob's watchlist. The benefit of this approach is that is saves 28 bytes per notification.\n\n===Scanning Requirement===\n\nThere is a scanning requirement on the recipient side in that the recipient must have access to full blocks in order to be able to search them for OP_RETURN outputs containing notifications. For more information on how light clients can get around this limitation and still use the standard, see Appendix B.\n\nRecipients that do not want to decode raw block data can quickly search for notifications in a block by looking for the following byte array: <code>[106, 40, 80, 80]</code>. The first two bytes represent ''OP_RETURN'' and ''OP_PUSHBYTES_40'', followed by the ASCII value of ''search_key''.\n\n===Transacting===\n\nAlice initializes counter ''c'' which is unique to Bob and increments with each transaction. ''c'' is a 64-bit integer and must be inputted into a hasher as a big-endian encoded array of 8 bytes.\n\n1. Alice calculates a secret point (constant between Alice and Bob):\n\n''S = n<sub>x</sub> * P''\n\n2. Alice calculates a shared secret:\n\n''s = H(S | c)''\n\n3. Alice calculates Bob's ephemeral public key and its associated address where the funds will be sent:\n\n''P<sub>c</sub> = P + s*G''\n\n4. Alice constructs an address using the key ''P<sub>c</sub>'', using one of the address types she committed to in the notification transaction.\n\nBob constructs his watchlist by mirroring this process on his end, except that his method of calculating ''S'' is:\n\n''S = N<sub>x</sub> * p''\n\nWhen Bob wants to spend from such addresses, he calculates his private keys in the following manner:\n\n''p<sub>c</sub> = p + s''\n\n==Backward Compatibility==\n\nPrivate Payments is a new standard which is not compatible with any previous standard based on static payment codes, such as BIP47.\n\nWhile the standard does not support versioning, it reserves unused bits in the address type bitflag array which can be allocated to new address types once they are deemed ubiquitous. Older payment codes (i.e. those generated when fewer address types were available) are readable by software supporting new address types. The reverse is also supported since older software will ignore newer address type flags that are not understood.\n\n==Appendix A: Test Vectors==\n\n===Alice's Wallet===\n\n'''BIP32 seed:''' 0xfe\n\n'''Master xprv:''' xprv9s21ZrQH143K2qVytoy3eZSSuc1gfzFrkV4bgoHzYTkgge4UoNP62eV8jkHYNqddaaefpnjwkz71P5m4EW6RuQBJeP9pdfa9WBnjP6XUivG\n\n'''n:''' xprv9zNFGn56Wm1s89ycTCg4hB615ehu6ZvNL4mxUEAL28pNhBAb6SZgLdsgmQd1ECgAiCjy6XxTTRyBdPAhH1oMfLhv2bSwfiCYhL9s9ahEehf\n\n'''N:''' xpub6DMbgHbzM8aALe45ZED54K2jdgYPW2eDhHhZGcZwaUMMZyVjdysvtSCAcfPYiqB5Zw41EyLWPxCXko6iEckwRdF5CD2ZKdTxUKigPXsnpaE\n\n'''x:''' 0\n\n'''n<sub>x</sub>:''' be9518016ec15762877de7d2ce7367a2087cf5682e72bbffa89535d73bb42f40\n\n'''N<sub>x</sub>:''' 02e3217349724307eed5514b53b1f53f0802672a9913d9bbb76afecc86be23f464\n\n\n===Bob's Wallet===\n'''BIP32 seed:''' 0xff\n\n'''Master xprv:''' xprv9s21ZrQH143K47bRNtc26e8Gb3wkUiJ4fH3ewYgJeiGABp7vQtTKsLBzHM2fsfiK7Er6uMrWbdDwwrdcVn5TDC1T1npTFFkdEVoMgTwfVuR\n\n'''p:''' 0x26c610e7d0ed4395be3f0664073d66b0a3442b49e1ec13faf2dd9b7d3c335441\n\n'''P:''' 0x0302be8bff520f35fae3439f245c52afb9085a7bf62d099c1f5e9e1b15a7e2121a\n\n'''Accepted scripts:''' 0x03 (legacy + segwit) (0x01 | 0x02)\n\n'''Payment code:''' pay1qqpsxq4730l4yre4lt3588eyt3f2lwggtfalvtgfns04a8smzkn7yys6xv2gs8\n\n\n===Alice notifying Bob===\n'''S:''' 0x02c0892d6ba30b5b1eafebd47172e46d358721f294698f9f59b4d96b781da09a62\n\n'''Notification code:''' 0x49cb55bb\n\n'''Address type commitment:''' 1 (segwit)\n\n'''Notification output script:''' OP_RETURN OP_PUSHBYTES_40 505049cb55bb02e3217349724307eed5514b53b1f53f0802672a9913d9bbb76afecc86be23f46401\n\n\n===Alice sending to Bob===\n'''c:''' 0\n\n'''s:''' 0x5dbe5efee4a5b9df73708241858f2bf7ec65f141dbd229ea8e2f9f51804a18f2\n\n'''s*G:''' 0x039362033c1bc3f05e081d4d7f76d5ffebde349b0f6a4d2e8ffc5c065c17233247\n\n'''P<sub>c</sub>:''' 0x03e669bd1705691a080840b07d76713d040934a37f2e8dde2fe02f5d3286a49219\n\n'''A<sub>c</sub>:''' bc1qw7ld5h9tj2ruwxqvetznjfq9g5jyp0gjhrs30w\n\n\n===Bob spending===\n'''c:''' 0\n\n'''p<sub>c</sub>:''' 0x84846fe6b592fd7531af88a58ccc92a88faa1c8bbdbe3de5810d3acebc7d6d33\n\n==Appendix B: Potential OP_RETURN Services==\n\nCompact Block Filters, as formulated in BIP-0158, do not cover <code>OP_RETURN</code> data payloads. In support of light wallets, an external service could publish transaction proofs for all transactions that include the tagged notification payload. Light wallets would download all such transactions, filter for matches against their payment code, then verify the transaction proofs against the block headers obtained over the P2P network.\n\n==Appendix C: Potential Notification Transaction Services==\n\nNo specific instruction is given as to the details of the notification transaction beyond simply including the single <code>OP_RETURN</code> payload. Since no restriction exists for other inputs or outputs of this transaction, there is an opportunity for an external service to include this payload in a transaction completely unrelated to Alice's wallet. Such a service could charge a fee out-of-band to help cover fees.\n\nAnother opportunity exists for an existing business to attach notification payloads to transactions sent during the normal course of operations. Large withdrawal transactions from mining pools or exchanges could include a marginal notification payload without affecting overall fees.\n\n==Reference Implementation==\n\nReference implementation is available at https://github.com/private-payments/rust-private-payments\n\n==Reference==\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[bip-0047.mediawiki|BIP47 - Reusable Payment Codes for Hierarchical Deterministic Wallets]]\n* [[bip-0157.mediawiki|BIP157 - Client Side Block Filtering]]\n* [[bip-0158.mediawiki|BIP158 - Compact Block Filters for Light Clients]]\n* [https://gist.github.com/RubenSomsen/21c477c90c942acf45f8e8f5c1ad4fae BIP47 Prague Discussion (acknowledgements: @rubensomsen, @afilini, @kixunil])\n\n", "content_length": 16227}
{"bip_number": 350, "filename": "bip-0350.mediawiki", "content": "<pre>\n  BIP: 350\n  Layer: Applications\n  Title: Bech32m format for v1+ witness addresses\n  Author: Pieter Wuille <pieter@wuille.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0350\n  Status: Final\n  Type: Standards Track\n  Created: 2020-12-16\n  License: BSD-2-Clause\n  Post-History: 2021-01-05: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-January/018338.html [bitcoin-dev] Bech32m BIP: new checksum, and usage for segwit address\n  Replaces: 173\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document defines an improved variant of Bech32 called '''Bech32m''', and amends BIP173 to use Bech32m for native segregated witness outputs of version 1 and later. Bech32 remains in use for segregated witness outputs of version 0.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\n[[bip-0173.mediawiki|BIP173]] defined a generic checksummed base 32 encoded format called Bech32. It is in use for segregated witness outputs of version 0 (P2WPKH and P2WSH, see [[bip-0141.mediawiki|BIP141]]), and other applications.\n\nBech32 has an unexpected [https://github.com/sipa/bech32/issues/51 weakness]: whenever the final character is a 'p', inserting or deleting any number of 'q' characters immediately preceding it does not invalidate the checksum. This does not affect existing uses of witness version 0 BIP173 addresses due to their restriction to two specific lengths, but may affect future uses and/or other applications using the Bech32 encoding.\n\nThis document addresses that by specifying Bech32m, a variant of Bech32 that mitigates this insertion weakness and related issues.\n\n==Specification==\n\nWe first specify the new checksum algorithm, and then document how it should be used for future Bitcoin addresses.\n\n===Bech32m===\n\nBech32m modifies the checksum of the Bech32 specification, replacing the constant ''1'' that is xored into the checksum at the end with ''0x2bc830a3''. The resulting checksum verification and creation algorithm (in Python, cf. the code in [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#Bech32|BIP173 Bech32 section]):\n\n<pre>\nBECH32M_CONST = 0x2bc830a3\n\ndef bech32m_polymod(values):\n  GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]\n  chk = 1\n  for v in values:\n    b = (chk >> 25)\n    chk = (chk & 0x1ffffff) << 5 ^ v\n    for i in range(5):\n      chk ^= GEN[i] if ((b >> i) & 1) else 0\n  return chk\n\ndef bech32m_hrp_expand(s):\n  return [ord(x) >> 5 for x in s] + [0] + [ord(x) & 31 for x in s]\n\ndef bech32m_verify_checksum(hrp, data):\n  return bech32m_polymod(bech32m_hrp_expand(hrp) + data) == BECH32M_CONST\n\ndef bech32m_create_checksum(hrp, data):\n  values = bech32m_hrp_expand(hrp) + data\n  polymod = bech32m_polymod(values + [0,0,0,0,0,0]) ^ BECH32M_CONST\n  return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]\n</pre>\n\nAll other aspects of Bech32 remain unchanged, including its human-readable parts (HRPs).\n\nA combined function to decode both Bech32 and Bech32m simultaneously could be written using:\n\n<pre>\nclass Encoding(Enum):\n    BECH32 = 1\n    BECH32M = 2\n\ndef bech32_bech32m_verify_checksum(hrp, data):\n    check = bech32_polymod(bech32_hrp_expand(hrp) + data)\n    if check == 1:\n        return Encoding.BECH32\n    elif check == BECH32M_CONST:\n        return Encoding.BECH32M\n    else:\n        return None\n</pre>\n\nwhich returns either None for failure, or one of the BECH32 / BECH32M enumeration values to indicate successful decoding according to the respective standard.\n\n===Addresses for segregated witness outputs===\n\nVersion 0 outputs (specifically, P2WPKH and P2WSH addresses) continue to use Bech32<ref>'''Why not permit both Bech32 and Bech32m for v0 addresses?''' Permitting both encodings reduces the error detection capabilities (it makes it equivalent to only have 29 bits of checksum).</ref> as specified in BIP173. Addresses for segregated witness outputs version 1 through 16 use Bech32m. Again, all other aspects of the encoding remain the same, including the 'bc' HRP.\n\nTo generate an address for a segregated witness output:\n\n* If its witness version is 0, encode it using Bech32.\n* If its witness version is 1 or higher, encode it using Bech32m.\n\nTo decode an address, client software should either decode with both a Bech32 and a Bech32m decoder<ref>'''Can a single string simultaneously be valid as Bech32 and Bech32m?''' No, a valid Bech32 and Bech32m string will always differ by at least 3 characters if they are the same length.</ref>, or use a decoder that supports both simultaneously. In both cases, the address decoder has to verify that the encoding matches what is expected for the decoded witness version (Bech32 for version 0, Bech32m for others).\n\nThe following code demonstrates the checks that need to be performed. Refer to the Python code linked in the reference implementation section below for full details of the called functions.\n\n<pre>\ndef decode(hrp, addr):\n    hrpgot, data, spec = bech32_decode(addr)\n    if hrpgot != hrp:\n        return (None, None)\n    decoded = convertbits(data[1:], 5, 8, False)\n    # Witness programs are between 2 and 40 bytes in length.\n    if decoded is None or len(decoded) < 2 or len(decoded) > 40:\n        return (None, None)\n    # Witness versions are in range 0..16.\n    if data[0] > 16:\n        return (None, None)\n    # Witness v0 programs must be exactly length 20 or 32.\n    if data[0] == 0 and len(decoded) != 20 and len(decoded) != 32:\n        return (None, None)\n    # Witness v0 uses Bech32; v1 through v16 use Bech32m.\n    if data[0] == 0 and spec != Encoding.BECH32 or data[0] != 0 and spec != Encoding.BECH32M:\n        return (None, None)\n    # Success.\n    return (data[0], decoded)\n</pre>\n\n'''Error locating'''\n\nBech32m, like Bech32, does support locating<ref>'''What about error correction?''' As explained in BIP173, introducing error correction reduces the ability to detect errors. While it is technically possible to correct a small number of errors due to Bech32(m)'s nature as a BCH code, implementations should refrain from using this for more than indicating where an error may be present.</ref> the positions of a few substitution errors. To combine this functionality with\nthe segregated witness addresses proposed by this document, simply try locating errors for both Bech32 and Bech32m. If only one finds error locations, report that one. If both do (which should be very rare),\nthere are a number of options:\n* Report the one that needs fewer corrections (if they differ).\n* Eliminate the response(s) that are inconsistent. Any symbol that isn't on an error location can be checked. For example, if the witness version symbol is not an error location, and it doesn't correspond to the specification used (0 for Bech32, 1+ for Bech32m), that response can be eliminated.\n\nSee the fancy Javascript decoder below for example of the above.\n\n==Compatibility==\n\nThis document introduces a new encoding for v1 segregated witness outputs and higher versions. There should not be any compatibility issues on the receiver side; no wallets are creating v1 segregated witness addresses yet, as the output type is not usable on mainnet.\n\nOn the other hand, the Bech32m proposal breaks forward-compatibility for sending to v1 and higher version segregated witness addresses. This incompatibility is [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-October/018236.html intentional]. An alternative design was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-November/017460.html considered] where Bech32 remained in use for certain subsets of future addresses, but ultimately [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018293.html discarded]. By introducing a clean break, we protect not only new software but also existing senders from the mutation issue, as new addresses will be incompatible with the existing Bech32 address validation. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-November/018268.html Experiments] by Taproot proponents had shown that hardly any wallets and services supported sending to higher segregated witness output versions, so little is lost by [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018298.html breaking] forward-compatibility. Furthermore, those experiments identified cases in which segregated witness implementations would have caused wallets to burn funds when sending to version 1 addresses. In case it is still in use, the chosen approach will prevent such software from destroying funds when attempting to send to a Bech32m address.\n\n==Reference implementations==\n\n* Reference encoder and decoder:\n** [https://github.com/sipa/bech32/blob/master/ref/python Reference Python implementation]\n** [https://github.com/sipa/bech32/blob/master/ref/c Reference C implementation]\n** [https://github.com/sipa/bech32/blob/master/ref/c++ Reference C++ implementation]\n** [https://github.com/bitcoin/bitcoin/pull/20861 Bitcoin Core C++ implementation]\n** [https://github.com/sipa/bech32/blob/master/ref/javascript Reference Javascript implementation]\n\n* Fancy decoder that localizes errors:\n** [https://github.com/sipa/bech32/blob/master/ecc/javascript For JavaScript] ([http://bitcoin.sipa.be/bech32/demo/demo.html demo website])\n\n==Test vectors==\n\n'''Implementation advice''' Experiments testing BIP173 implementations found that many wallets and services did not support sending to higher version segregated witness outputs. In anticipation of the proposed [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki Taproot] soft fork introducing v1 segregated witness outputs on the network, we emphatically recommend employing the complete set of test vectors provided below as well as ensuring that your implementation supports sending to v1 '''and higher versions'''. All higher versions of native segregated witness outputs should be recognized as valid recipients. As higher versions are not defined on the network, no wallet should ever create them and no recipient should ever provide them to a sender. Nor should a recipient ever want to falsely provide them as the recipient would simply see a payment intended to themselves burned instead. However, by defining higher versions as valid recipients now, future soft forks introducing higher versions of native segwit outputs will be forward-compatible to all wallets correctly implementing the Bech32m specification.\n\n===Test vectors for Bech32m===\n\nThe following strings are valid Bech32m:\n* <tt>A1LQFN3A</tt>\n* <tt>a1lqfn3a</tt>\n* <tt>an83characterlonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11sg7hg6</tt>\n* <tt>abcdef1l7aum6echk45nj3s0wdvt2fg8x9yrzpqzd3ryx</tt>\n* <tt>11llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllludsr8</tt>\n* <tt>split1checkupstagehandshakeupstreamerranterredcaperredlc445v</tt>\n* <tt>?1v759aa</tt>\n\nNo string can be simultaneously valid Bech32 and Bech32m, so the above examples also serve as invalid test vectors for Bech32.\n\nThe following string are not valid Bech32m (with reason for invalidity):\n* 0x20 + <tt>1xj0phk</tt>: HRP character out of range\n* 0x7F + <tt>1g6xzxy</tt>: HRP character out of range\n* 0x80 + <tt>1vctc34</tt>: HRP character out of range\n* <tt>an84characterslonghumanreadablepartthatcontainsthetheexcludedcharactersbioandnumber11d6pts4</tt>: overall max length exceeded\n* <tt>qyrz8wqd2c9m</tt>: No separator character\n* <tt>1qyrz8wqd2c9m</tt>: Empty HRP\n* <tt>y1b0jsk6g</tt>: Invalid data character\n* <tt>lt1igcx5c0</tt>: Invalid data character\n* <tt>in1muywd</tt>: Too short checksum\n* <tt>mm1crxm3i</tt>: Invalid character in checksum\n* <tt>au1s5cgom</tt>: Invalid character in checksum\n* <tt>M1VUXWEZ</tt>: checksum calculated with uppercase form of HRP\n* <tt>16plkw9</tt>: empty HRP\n* <tt>1p2gdwpf</tt>: empty HRP\n\n===Test vectors for v0-v16 native segregated witness addresses===\n\nThe following list gives valid segwit addresses and the scriptPubKey that they\ntranslate to in hex.\n* <tt>BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4</tt>: <tt>0014751e76e8199196d454941c45d1b3a323f1433bd6</tt>\n* <tt>tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7</tt>: <tt>00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262</tt>\n* <tt>bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kt5nd6y</tt>: <tt>5128751e76e8199196d454941c45d1b3a323f1433bd6751e76e8199196d454941c45d1b3a323f1433bd6</tt>\n* <tt>BC1SW50QGDZ25J</tt>: <tt>6002751e</tt>\n* <tt>bc1zw508d6qejxtdg4y5r3zarvaryvaxxpcs</tt>: <tt>5210751e76e8199196d454941c45d1b3a323</tt>\n* <tt>tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy</tt>: <tt>0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433</tt>\n* <tt>tb1pqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesf3hn0c</tt>: <tt>5120000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433</tt>\n* <tt>bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqzk5jj0</tt>: <tt>512079be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798</tt>\n\nThe following list gives invalid segwit addresses and the reason for\ntheir invalidity.\n* <tt>tc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vq5zuyut</tt>: Invalid human-readable part\n* <tt>bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqh2y7hd</tt>: Invalid checksum (Bech32 instead of Bech32m)\n* <tt>tb1z0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vqglt7rf</tt>: Invalid checksum (Bech32 instead of Bech32m)\n* <tt>BC1S0XLXVLHEMJA6C4DQV22UAPCTQUPFHLXM9H8Z3K2E72Q4K9HCZ7VQ54WELL</tt>: Invalid checksum (Bech32 instead of Bech32m)\n* <tt>bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kemeawh</tt>: Invalid checksum (Bech32m instead of Bech32)\n* <tt>tb1q0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vq24jc47</tt>: Invalid checksum (Bech32m instead of Bech32)\n* <tt>bc1p38j9r5y49hruaue7wxjce0updqjuyyx0kh56v8s25huc6995vvpql3jow4</tt>: Invalid character in checksum\n* <tt>BC130XLXVLHEMJA6C4DQV22UAPCTQUPFHLXM9H8Z3K2E72Q4K9HCZ7VQ7ZWS8R</tt>: Invalid witness version\n* <tt>bc1pw5dgrnzv</tt>: Invalid program length (1 byte)\n* <tt>bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7v8n0nx0muaewav253zgeav</tt>: Invalid program length (41 bytes)\n* <tt>BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P</tt>: Invalid program length for witness version 0 (per BIP141)\n* <tt>tb1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vq47Zagq</tt>: Mixed case\n* <tt>bc1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7v07qwwzcrf</tt>: zero padding of more than 4 bits\n* <tt>tb1p0xlxvlhemja6c4dqv22uapctqupfhlxm9h8z3k2e72q4k9hcz7vpggkg4j</tt>: Non-zero padding in 8-to-5 conversion\n* <tt>bc1gmk9yu</tt>: Empty data section\n\n\n==Appendix: checksum design & properties==\n\nChecksums are used to detect errors introduced into data during transfer. A hash function-based checksum such as Base58Check detects any type of error uniformly, but not all classes of errors are equally likely to occur in practice. Bech32 prioritizes detection of substitution errors, but improving detection of one error class inevitably worsens detection of other error classes. During the design of Bech32, it was assumed that other simple error patterns beside substitutions would have a similar detection rate as in a hash function-based design, and detection would only be worse for complex, impractical errors. The discovered insertion weakness shows that this is not the case.\n\nFor Bech32m, we aim to retain Bech32's guarantees for substitution errors, but make sure that other common errors don't perform worse than a hash function-based checksum would. To make sure the new standard is easy to implement, we restrict the design space to only amending the final constant that is xored in, as it was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-December/017521.html observed] that is sufficient to mitigate the 'q' insertion issue while retaining the intended substitution error detection. In what follows, we explain how the new constant ''0x2bc830a3'' was chosen.\n\n===Error patterns & detection probability===\n\nWe define an error pattern as a sequence of first one or more deletions, then swaps of adjacent characters, followed by substitutions, insertions, and duplications, in that order, all in specific positions, applied to a string with valid checksum that is otherwise randomly chosen. For insertions and substitutions we assume a uniformly random new character. For example, \"delete the 17th character, swap the 11th character with the 12th character, and insert a random character in the 24th position\" is an error pattern. \"Replace the 43rd through 48th character with 'aardvark'\" is not a valid error pattern, because the new characters are not random and there is no reason why this particular string is more likely than any other to be substituted.\n\nA hash function-based checksum design with a 30-bit hash would have a probability of incorrectly accepting equal to ''2<sup>-30</sup>'', for every error pattern. Bech32 has a probability of 0 to incorrectly accept error patterns consisting of up to 4 substitutions\u2014they are always detected. The 'q'-insertion issue shows that for Bech32 a simple error pattern (\"insert a random character in the penultimate position\") with probability ''2<sup>-10</sup>'' exists: it requires the final character to be 'p' (leaving only  1 in 32 strings), and requires the inserted character to be 'q' (permitting only 1 of 32 possible inserted characters).\n\nNote that the choice of ''what'' the error pattern is (which types of errors, and where) isn't part of our probabilities: we try to make sure that ''every'' pattern behaves well, not just randomly chosen ones, because presumably humans\nmake some kinds of errors more than others, and we cannot easily model which ones.\n\n===Detection properties of Bech32m===\n\nThe table below shows the error detection properties of Bech32m, and a comparison with Bech32. The code used for this analysis can be found [https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e#file-const_analysis-cpp here]. Every row specifies one error pattern via the constraints in the left four columns. The remaining columns report what percentage of those patterns have certain probabilities of not being detected. The columns are:\n\n* '''errors''' The maximum number of individual errors considered\n* '''of type''' What type of errors are considered (either \"subst. only\" for just substitutions, or \"any\" to also include deletions, swaps, insertions, and duplications)\n* '''window''' The maximum size of the window in which the errors have to occur<ref>'''What is an error pattern\u2019s window size?''' The window size of an error pattern is the length of the smallest consecutive range of characters that contains all modified characters (on input or output; whichever is larger). For example, an error pattern that turns \"abcdef\" into \"accdbef\" has a window size of 4, as it is replacing \"bcd\" with \"ccdb\", a 4 character string. Window size is only meaningful when the pattern consists of two or more errors.</ref>\n* '''code/verifier''' Whether this line is about Bech32 or Bech32m encoded strings, and whether those are evaluated regarding their probability of being accepted by either a Bech32 or a Bech32m verifier.<ref>'''Why do we care about probability of accepting Bech32m strings in Bech32 verifiers?''' For applications where Bech32m replaces an existing use of Bech32 (such as segregated witness addresses), we want to make sure that a Bech32m string created by new software won\u2019t be erroneously accepted by old software that assumes Bech32 - even when a small number of errors were introduced as well.</ref><ref>'''Should we also take into account failures that occur due to taking a valid Bech32m string, and after errors it becoming acceptable to a Bech32 verifier?''' This situation may in theory occur for segregated witness addresses when errors occur that change the version number in a v1+ address to v0. Due to the specificity of this type of error, plus the additional constraints that apply for v0 addresses, this is both unlikely and hard to analyze.</ref>\n* '''error patterns with failure probability''' For each probability (''0'', ''2<sup>-30</sup>'', ''2<sup>-25</sup>'', ''2<sup>-20</sup>'', ''2<sup>-15</sup>'', and ''2<sup>-10</sup>'') this reports what percentage of error patterns restricted by the constraints in the previous columns have those probabilities of being incorrectly accepted.\n\nThe properties are divided into two classes: those that hold over all strings when averaged over all possible HRPs (human readable parts), and those specific to the \"bc1\" HRP with the length restrictions imposed by segregated witness addresses<ref>'''What restrictions were taken into account for the \"bc1\"-specific analysis?''' The minimum length (due to witness programs being at least 2 bytes), the maximum length (due to witness programs being at most 40 bytes), and the fact that the witness programs are a multiple of 8 bits. The fact that the first data symbol cannot be over 16, or that the padding has to be 0, is not taken into account.</ref>.\n\n{| class=\"wikitable\"\n! rowspan=\"2\" | errors\n! rowspan=\"2\" | of type\n! rowspan=\"2\" | window\n! rowspan=\"2\" | code/verifier\n! colspan=\"6\" | error patterns with failure probability\n|-\n! ''0'' !! ''2<sup>-30</sup>'' !! ''2<sup>-25</sup>'' !! ''2<sup>-20</sup>'' !! ''2<sup>-15</sup>'' !! ''2<sup>-10</sup>''\n|-\n! colspan=\"10\" | Properties averaged over all HRPs\n|-\n| &leq; 4 || only subst. || any      || rowspan=\"6\" | Bech32m/Bech32m || 100.00%|| colspan=\"5\" | none<sup>(a)</sup>\n|-\n| any     || any         || &leq; 4  || 56.16%|| 43.84%|| colspan=\"4\" | none<sup>(b)</sup>\n|-\n| &leq; 2 || any         || &leq; 68 || 7.71%|| 92.28%|| colspan=\"4\" | none<sup>(b)</sup>\n|-\n| &leq; 2 || any         || any      || 7.79%|| 92.20%|| 0.004%|| colspan=\"3\" | none<sup>(b)</sup>\n|-\n| &leq; 3 || any         || &leq; 69 || 7.73%|| 92.23%|| 0.033%<sup>(d)</sup> || colspan=\"3\" | none<sup>(b)</sup>\n|-\n| &leq; 3 || any         || any      || 7.77%|| 92.19%|| 0.034%|| 0.000065% || colspan=\"2\" | none<sup>(b)</sup>\n|-\n| &leq; 4 || only subst. || any      || rowspan=\"6\" | Bech32/Bech32 || 100.00%|| colspan=\"5\" | none\n|-\n| any     || any         || &leq; 4  || 54.00%|| 43.84%|| 1.08%|| 0.90%|| 0.17%|| 0.0091%\n|-\n| &leq; 2 || any         || &leq; 68 || 4.59%|| 92.29%|| 1.09%|| 1.01%|| 0.99%|| 0.039%\n|-\n| &leq; 2 || any         || any      || 4.58%|| 92.21%|| 1.11%|| 1.04%|| 1.02%|| 0.038%\n|-\n| &leq; 3 || any         || &leq; 69 || 6.69%|| 92.23%|| 0.56%|| 0.48%|| 0.041%|| 0.00055%\n|-\n| &leq; 3 || any         || any      || 6.66%|| 92.19%|| 0.59%|| 0.52%|| 0.041%|| 0.00053%\n|-\n|       0 || -           || -        || rowspan=\"3\" | Bech32m/Bech32 ||  100.00%|| colspan=\"5\" | none<sup>(a)</sup>\n|-\n|       1 || any         || -        || 46.53%|| 53.46%|| colspan=\"4\" | none<sup>(b)</sup>\n|-\n| &leq; 2 || any         || any      || 22.18%|| 77.77%|| 0.048%|| colspan=\"3\" | none<sup>(b)</sup>\n|-\n! colspan=\"10\" | Properties for segregated witness addresses with HRP \"bc\"\n|-\n| &leq; 4 || only subst. || any      || rowspan=\"6\" | Bech32m/Bech32m || 100.00%|| colspan=\"5\" | none<sup>(a)</sup>\n|-\n|       1 || any         || -        ||  24.34%|| 75.66%|| colspan=\"4\" | none<sup>(c)</sup>\n|-\n| &leq; 2 || any         || &leq; 28 ||  16.85%|| 83.15%|| colspan=\"4\" | none<sup>(c)</sup>\n|-\n| any     || any         || &leq; 4  ||  74.74%|| 25.25%|| 0.0016%|| colspan=\"3\" | none<sup>(c)</sup>\n|-\n| &leq; 2 || any         || any      ||  15.72%|| 84.23%|| 0.039%|| 0.0053%|| colspan=\"2\" | none<sup>(c)</sup>\n|-\n| &leq; 3 || any         || any      ||  13.98%|| 85.94%|| 0.078%|| 0.00063%|| colspan=\"2\" | none<sup>(c)</sup>\n|-\n| &leq; 4 || only subst. || any      || rowspan=\"6\" | Bech32/Bech32 || 100.00%|| colspan=\"5\" | none\n|-\n|       1 || any         || -        ||  14.63%|| 75.71%|| 2.43%|| 2.43%|| 2.43%|| 2.38%\n|-\n| &leq; 2 || any         || &leq; 28 ||  14.22%|| 83.15%|| 0.94%|| 0.84%|| 0.79%|| 0.054%\n|-\n| any     || any         || &leq; 4  ||  73.23%|| 25.26%|| 0.76%|| 0.63%|| 0.12%|| 0.0064%\n|-\n| &leq; 2 || any         || any      ||  12.79%|| 84.24%|| 1.06%|| 0.95%|| 0.92%|| 0.041%\n|-\n| &leq; 3 || any         || any      ||  13.00%|| 85.94%|| 0.57%|| 0.45%|| 0.044%|| 0.00067%\n|-\n| &leq; 3 || only subst. || any      || rowspan=\"3\" | Bech32m/Bech32 || 100.00%|| colspan=\"5\" | none<sup>(c)</sup>\n|-\n|       1 || any         || -        ||  70.89%|| 29.11%|| colspan=\"4\" | none<sup>(c)</sup>\n|-\n| &leq; 2 || any         || any      ||  36.12%|| 63.79%|| 0.092%|| 0.00049%|| colspan=\"2\" | none<sup>(c)</sup>\n|}\n\nThe numbers in this table, as well as a comparison with the numbers for the \u2018\u20191\u2019\u2019 constant and earlier proposed improved constants, can be found [https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e#file-results_final-txt here].\n\n\n===Selection process===\n\nThe details of the selection process can be found [https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e here], but in short:\n* Start with the set of all ''2<sup>30</sup>-1'' constants different from Bech32's ''1''. All of these satisfy the properties marked <sup>(a)</sup> in the table above.\n* Through exhaustive analysis, reject all constants that do not exhibit the properties<ref>'''How were the properties to select for chosen?''' All these properties are as strong as they can be without rejecting every constant: rejecting constants with lower probabilities, or more errors, or wider windows all result in nothing left.</ref> marked <sup>(b)</sup> in the table above (e.g. all constants that permit any error pattern of 2 errors or less in a window of 68 characters or less with a detection probability ''&geq; 2<sup>-20</sup>''). This selection leaves us with 12054 candidates.\n* Reject all constants that do not exhibit the <sup>(c)</sup> properties in the table above<ref>'''Why optimize for segregated witness addresses (with HRP \"bc1\") specifically?''' Our analysis for generic HRP has limitations (see the detailed description [https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e#file-bech32m_mail-txt here], under \"Technical details\"). We optimize for generic usage first, but optimize for segregated witness addresses as a tiebreaker.</ref>. This leaves us with 79 candidates.\n* Finally, select the candidate that minimizes the number of error classes matching <sup>(d)</sup> in the table above as a final tiebreaker. The result is the single constant ''0x2bc830a3''.\n\n==Footnotes==\n\n<references />\n\n==Acknowledgements==\n\nThanks to Greg Maxwell for doing most of the computation for code selection and analysis, and comments.\nThanks to Mark Erhardt for help with writing and editing this document.\nThanks to Rusty Russell and others on the bitcoin-dev list for the discussion around intentionally breaking compatibility with existing senders, which is used in this specification.\n", "content_length": 26929}
{"bip_number": 347, "filename": "bip-0347.mediawiki", "content": "<pre>\n  BIP: 347\n  Layer: Consensus (soft fork)\n  Title: OP_CAT in Tapscript\n  Author: Ethan Heilman <ethan.r.heilman@gmail.com>\n          Armin Sabouri <arminsdev@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0347\n  Status: Draft\n  Type: Standards Track\n  Created: 2023-12-11\n  License: BSD-3-Clause\n  Post-History: 2023-10-21: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-October/022049.html [bitcoin-dev] Proposed BIP for OP_CAT\n</pre>\n\n==Abstract==\n\nThis BIP introduces OP_CAT as a tapscript opcode which allows the concatenation of two values on the stack. OP_CAT would be activated via a soft fork by redefining the opcode OP_SUCCESS126 (126 in decimal and 0x7e in hexadecimal). This is the same opcode value used by the original OP_CAT.\n\n== Copyright ==\n\nThis document is licensed under the 3-clause BSD license.\n\n==Specification==\n\nWhen evaluated, the OP_CAT instruction:\n# Pops the top two values off the stack,\n# concatenates the popped values together in stack order,\n# and then pushes the concatenated value on the top of the stack.\n\nGiven the stack ''<nowiki>[x1, x2]</nowiki>'', where ''x2'' is at the top of the stack, OP_CAT will push ''x1 || x2'' onto the stack. By ''||'' we denote concatenation. OP_CAT fails if there are fewer than two values on the stack or if a concatenated value would have a combined size greater than the maximum script element size of 520 bytes.\n\nThis opcode would be activated via a soft fork by redefining the tapscript opcode OP_SUCCESS126 (126 in decimal and 0x7e in hexadecimal) to OP_CAT.\n\n==Motivation==\n\nBitcoin Tapscript lacks a general purpose way of combining objects on the stack, restricting the expressiveness and power of Tapscript. This prevents, among many other things, the ability to construct and evaluate merkle trees and other hashed data structures in Tapscript. OP_CAT, by adding a general purpose way to concatenate stack values, would overcome this limitation and greatly increase the functionality of Tapscript.\n\nOP_CAT aims to expand the toolbox of the tapscript developer with a simple, modular, and useful opcode in the spirit of Unix <ref>R. Pike and B. Kernighan, \"Program design in the UNIX environment\", 1983, https://harmful.cat-v.org/cat-v/unix_prog_design.pdf</ref>. To demonstrate the usefulness of OP_CAT below we provide a non-exhaustive list of some usecases that OP_CAT would enable:\n\n* Bitstream, a protocol for the atomic swap (fair exchange) of bitcoins for decryption keys, that enables decentralized file hosting systems paid in Bitcoin. While such swaps are currently possible on Bitcoin without OP_CAT, they require the use of complex and computationally expensive Verifiable Computation cryptographic techniques. OP_CAT would remove this requirement on Verifiable Computation, making such protocols far more practical to build in Bitcoin. <ref>R. Linus, \"BitStream: Decentralized File Hosting Incentivised via Bitcoin Payments\", 2023, https://robinlinus.com/bitstream.pdf</ref>\n* Tree signatures provide a multisignature script whose size can be logarithmic in the number of public keys and can encode spend conditions beyond n-of-m. For instance a transaction less than 1KB in size could support tree signatures with up to 4,294,967,296 public keys. This also enables generalized logical spend conditions. <ref> P. Wuille, \"Multisig on steroids using tree signatures\", 2015, https://blog.blockstream.com/en-treesignatures/</ref>\n* Post-Quantum Lamport signatures in Bitcoin transactions. Lamport signatures merely require the ability to hash and concatenate values on the stack. <ref>J. Rubin, \"[bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was CheckSigFromStack for Arithmetic Values]\", 2021, https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019233.html</ref> It has been proposed that if ECDSA is broken or a powerful computer was on the horizon, there might be an effort to protect ownership of bitcoins by allowing people to mark their taproot outputs as \"script-path only\" and then move their coins into such outputs with a leaf in the script tree requiring a Lamport signature. It is an open question if a tapscript commitment would preserve the quantum resistance of Lamport signatures. Beyond this question, the use of Lamport Signatures in taproot outputs is unlikely to be quantum resistant even if the script spend-path is made quantum resistant. This is because taproot outputs can also be spent with a key. An attacker with a sufficiently powerful quantum computer could bypass the taproot script spend-path by finding the discrete log of the taproot output and thus spending the output using the key spend-path. The use of \"Nothing Up My Sleeve\" (NUMS) points as described in [[bip-0341.mediawiki|BIP341]] to disable the key spend-path does not disable the key spend-path against a quantum attacker as NUMS relies on the hardness of finding discrete logs. We are not aware of any mechanism which could disable the key spend-path in a taproot output without a softfork change to taproot.\n* Non-equivocation contracts <ref>T. Ruffing, A. Kate, D. Schr\u00f6der, \"Liar, Liar, Coins on Fire: Penalizing Equivocation by Loss of Bitcoins\", 2015, https://web.archive.org/web/20221023121048/https://publications.cispa.saarland/565/1/penalizing.pdf</ref> in tapscript provide a mechanism to punish equivocation/double spending in Bitcoin payment channels. OP_CAT enables this by enforcing rules on the spending transaction's nonce. The capability is a useful building block for payment channels and other Bitcoin protocols.\n* Vaults <ref>M. Moser, I. Eyal, and E. G. Sirer, Bitcoin Covenants, https://web.archive.org/web/20220203124718/https://fc16.ifca.ai/bitcoin/papers/MES16.pdf</ref> which are a specialized covenant that allows a user to block a malicious party who has compromised the user's secret key from stealing the funds in that output. As shown in <ref>A. Poelstra, \"CAT and Schnorr Tricks II\", 2021, https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-ii.html</ref> OP_CAT is sufficient to build vaults in Bitcoin.\n* Replicating CheckSigFromStack <ref>A. Poelstra, \"CAT and Schnorr Tricks I\", 2021, https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html</ref> which would allow the creation of simple covenants and other advanced contracts without having to presign spending transactions, possibly reducing complexity and the amount of data that needs to be stored. Originally shown to work with Schnorr signatures, this result has been extended to ECDSA signatures <ref>R. Linus, \"Covenants with CAT and ECDSA\", 2023, https://gist.github.com/RobinLinus/9a69f5552be94d13170ec79bf34d5e85#file-covenants_cat_ecdsa-md</ref>.\n\nOP_CAT was available in early versions of Bitcoin.\nIn 2010, a single commit disabled OP_CAT, along with another 15 opcodes.\nFolklore states that OP_CAT was removed in this commit because it enabled the construction of a script whose evaluation could have memory usage exponential in the size of the script.\nFor example, a script that pushed a 1-byte value on the stack and then repeated the opcodes OP_DUP, OP_CAT 40 times would result in a stack element whose size was greater than 1 terabyte assuming no maximum stack element size. As Bitcoin at that time had a maximum stack element size of 5000 bytes, the effect of this expansion was limited to 5000 bytes.\nThis is no longer an issue because tapscript enforces a maximum stack element size of 520 bytes.\n\n\n==Rationale==\n\nOur decision to reenable OP_CAT by redefining a tapscript OP_SUCCESSx opcode to OP_CAT was motivated to leverage the tapscript softfork opcode upgrade path introduced in [[bip-0342.mediawiki|BIP342]].\n\nWe specifically choose to use OP_SUCCESS126 rather than another OP_SUCCESSx as OP_SUCCESS126 uses the same opcode value (126 in decimal and 0x7e in hexadecimal) that was used for OP_CAT prior to it being disabled in Bitcoin. This removes a potential source of confusion that would exist if we had a opcode value different from the one used in the original OP_CAT opcode.\n\nWhile the OP_SUCCESSx opcode upgrade path could enable us to increase the stack element size while reenabling OP_CAT, we wanted to separate the decision to change the stack element size limit from the decision to reenable OP_CAT. This BIP takes no position in favor or against increasing the stack element size limit.\n\n==Backwards Compatibility==\n\nOP_CAT usage in a non-tapscript script will continue to trigger the SCRIPT_ERR_DISABLED_OPCODE. The only change would be to OP_CAT usage in tapscript. This change to tapscript would be activated as a soft fork that redefines an OP_SUCCESSx opcode (OP_SUCCESS126) to OP_CAT.\n\n==Reference implementation==\n\n<pre>\ncase OP_CAT:\n{\n  if (stack.size() < 2)\n    return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n  valtype& vch1 = stacktop(-2);\n  valtype& vch2 = stacktop(-1);\n  if (vch1.size() + vch2.size() > MAX_SCRIPT_ELEMENT_SIZE)\n    return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n  vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n  stack.pop_back();\n}\nbreak;\n</pre>\n\n\nThe value of <code>MAX_SCRIPT_ELEMENT_SIZE</code> is 520.\n\nThis implementation is inspired by the original implementation of [https://github.com/bitcoin/bitcoin/blob/01cd2fdaf3ac6071304ceb80fb7436ac02b1059e/script.cpp#L381-L393 OP_CAT as it existed in the Bitcoin codebase] prior to the commit \"misc changes\" 4bd188c<ref>S. Nakamoto, \"misc changes\", Aug 25 2010, https://github.com/bitcoin/bitcoin/commit/4bd188c4383d6e614e18f79dc337fbabe8464c82#diff-27496895958ca30c47bbb873299a2ad7a7ea1003a9faa96b317250e3b7aa1fefR94</ref> which disabled it:\n\n<pre>\ncase OP_CAT:\n{\n    // (x1 x2 -- out)\n    if (stack.size() < 2)\n        return false;\n    valtype& vch1 = stacktop(-2);\n    valtype& vch2 = stacktop(-1);\n    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n    stack.pop_back();\n    if (stacktop(-1).size() > 5000)\n        return false;\n}\nbreak;\n</pre>\n\nAn alternative implementation of OP_CAT can be found in Elements <ref>Roose S., Elements Project, \"Re-enable several disabled opcodes\", 2019, https://github.com/ElementsProject/elements/commit/13e1103abe3e328c5a4e2039b51a546f8be6c60a#diff-a0337ffd7259e8c7c9a7786d6dbd420c80abfa1afdb34ebae3261109d9ae3c19R740-R759</ref>.\n\n==References==\n\n<references/>\n\n==Acknowledgements==\n\nWe wish to acknowledge Dan Gould for encouraging and helping review this effort. We also want to thank Madars Virza, Jeremy Rubin, Andrew Poelstra, Bob Summerwill,\nTim Ruffing and Johan T. Halseth for their feedback, review and helpful comments.\n", "content_length": 10580}
{"bip_number": 345, "filename": "bip-0345.mediawiki", "content": "<pre>\n  BIP: 345\n  Layer: Consensus (soft fork)\n  Title: OP_VAULT\n  Author: James O'Beirne <vaults@au92.org>\n          Greg Sanders <gsanders87@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2023-02-03\n  License: BSD-3-Clause\n  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcement\n                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n  Superseded-By: 443\n</pre>\n\n\n== Introduction ==\n\nThis BIP proposes two new tapscript opcodes that add consensus support for a specialized\ncovenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n<code>OP_CHECKTEMPLATEVERIFY</code>\n([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\nallow users to enforce a delay period before designated coins may be spent to\nan arbitrary destination, with the exception of a prespecified \"recovery\" path.\nAt any time prior to final withdrawal, the coins can be spent to the\nrecovery path.\n\n=== Copyright ===\n\nThis document is licensed under the 3-clause BSD license.\n\n\n=== Motivation ===\n\nThe hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\nsignificant effort to secure their private keys, and hope that once provisioned\ntheir custody system does not yield to any number of evolving and\npersistent threats. Users have little means to intervene once a compromise is\ndetected. This proposal introduces a mechanism that significantly\nmitigates the worst-case outcome of key compromise: coin loss.\n\nIntroducing a way to intervene during unexpected spends allows users to\nincorporate highly secure key storage methods or unusual fallback strategies\nthat are only exercised in the worst case, and which may otherwise be\noperationally prohibitive. The goal of this proposal is to make this strategy\nusable for custodians of any size with minimal complication.\n\n==== Example uses ====\n\nA common configuration for an individual custodying Bitcoin is \"single\nsignature and passphrase\" using a hardware wallet. A user with such a\nconfiguration might be concerned about the risk associated with relying on a\nsingle manufacturer for key management, as well as physical access to the\nhardware.\n\nThis individual can use <code>OP_VAULT</code> to make use of a highly secure\nkey as the unlikely recovery path, while using their existing signing procedure\nas the withdrawal trigger key with a configured spend delay of e.g. 1 day.\n\nThe recovery path key can be of a highly secure nature that might otherwise\nmake it impractical for daily use. For example, the key could be generated in\nsome analog fashion, or on an old computer that is then destroyed, with the\nprivate key replicated only in paper form. Or the key could be a 2-of-3\nmultisig using devices from different manufacturers. Perhaps the key is\ngeographically or socially distributed.\n\nSince it can be any Bitcoin script policy, the recovery key can include a\nnumber of spending conditions, e.g. a time-delayed fallback to an \"easier\"\nrecovery method, in case the highly secure key winds up being ''too'' highly\nsecure.\n\nThe user can run software on their mobile device that monitors the blockchain\nfor spends of the vault outpoints. If the vaulted coins move in an unexpected\nway, the user can immediately sweep them to the recovery path, but spending the\ncoins on a daily basis works in the same way it did prior to vaulting (aside\nfrom the spend delay).\n\nInstitutional custodians of Bitcoin may use vaults in similar fashion.\n\n===== Provable timelocks =====\n\nThis proposal provides a mitigation to the\n[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\nsetting the spend delay to, say, a week, and using as the recovery path a\nscript that enforces a longer relative timelock, the owner of the vault can\nprove that he is unable to access its value immediately. To the author's\nknowledge, this is the only way to configure this defense without rolling\ntimelocked coins for perpetuity or relying on a trusted third party.\n\n== Goals ==\n\n[[File:bip-0345/vaults-Basic.png|frame|center]]\n\nVaults in Bitcoin have been discussed formally since 2016\n([https://crypto.news/app/uploads/2016/08/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\nhaving a configurable delay period with recovery capability in light of an\nunexpected spend has been widely recognized.\n\nThe only way to implement vaults given the existing consensus rules, aside from\n[https://github.com/revault emulating vaults with large multisig\nconfigurations], is to use presigned transactions created with a one-time-use\nkey. This approach was first demonstrated\n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n\nUnfortunately, this approach has a number of practical shortcomings:\n* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n* amounts and withdrawal patterns must be precommitted to,\n* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n* the particular fee management technique or wallet must be decided upon vault creation,\n* coin loss follows if a vault address is reused,\n* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n* the vault creation ceremony must be performed each time a new balance is to be deposited.\n\nThe deployment of a \"precomputed\" covenant mechanism like\n[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT]\nwould both remove the necessity to use an ephemeral key, since the\ncovenant is enforced on-chain, and lessen the burden of sensitive data storage,\nsince the necessary transactions can be generated from a set of compact\nparameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n2022].\n\nHowever, the limitations of precomputation still apply: amounts,\ndestinations, and fee management are all fixed. Funds must flow through a fixed\nintermediary to their final destination. Batch operations, which may be vital\nfor successful recovery during fee spikes or short spend delay, are not possible.\n\n[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n\nHaving a \"general\" covenant mechanism that can encode arbitrary transactional\nstate machines would allow us to solve these issues, but at the cost of complex\nand large scripts that would probably be duplicated many times over in the\nblockchain. The particular design and deployment timeline of such a general\nframework is also uncertain. This approach was demonstrated\n[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n\nThis proposal intends to address the problems outlined above by\nproviding a delay period/recovery path use with minimal transactional and\noperational overhead using a specialized covenant.\n\nThe design goals of the proposal are:\n\n* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to \u201creceive\u201d multiple deposits.\n\n* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n\n* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n\n* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n\n* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n\nThese goals are accompanied by basic safety considerations (e.g. not being\nvulnerable to mempool pinning) and a desire for concision, both in terms of the number\nof outputs created as well as script sizes.\n\nThis proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/527b007dbf5b9a89895017030183370e05468ae6/bip-ephemeralanchors.mediawiki ephemeral anchors].\n\n== Design ==\n\nIn typical usage, a vault is created by encumbering coins under a\ntaptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\ncontaining at least two leaves: one with an <code>OP_VAULT</code>-containing script that\nfacilitates the expected withdrawal process, and another leaf with\n<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered\nat any time prior to withdrawal finalization.\n\nThe rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\nwithdrawal by allowing a spending transaction to replace the\n<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\nsome parameters to be set at spend (trigger) time. All other leaves in the\ntaptree must be unchanged in the destination output, which preserves the recovery path as well as any\nother spending conditions originally included in the vault. This is similar to\nthe <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed\n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n\nThese tapleaf replacement rules, described more precisely below, ensure a\ntimelocked withdrawal, where the timelock is fixed by the original\n<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\nprocess is triggered.\n\nWhile <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\npreferred method to bind the proposed withdrawal to a particular set of final\noutputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\nfacilitate other kinds of withdrawal processes.\n\n[[File:bip-0345/opvault.drawio.png|frame|center]]\n\n\n=== Transaction types ===\n\nThe vault has a number of stages, some of them optional:\n\n* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n\n* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n\n* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n\n* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n\n\n=== Fee management ===\n\nA primary consideration of this proposal is how fee management is handled.\nProviding dynamic fee management is critical to the operation of a vault, since\n\n* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n* a fee wallet that is prespecified might be compromised or lost before use.\n\nBut dynamic fee management can introduce\n[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\nhas been taken to avoid unnecessarily introducing these vectors when using the new\ndestination-based spending policies that this proposal introduces.\n\nOriginally, this proposal had a hard dependency on reformed transaction\nnVersion=3 policies, including ephemeral anchors, but it has since been revised\nto simply benefit from these changes in policy as well as other potential fee\nmanagement mechanisms.\n\n\n== Specification ==\n\nThe tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\nto implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\nrespectively.\n\n=== <code>OP_VAULT</code> evaluation ===\n\nWhen evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n\n<source>\n<leaf-update-script-body>\n<push-count>\n[ <push-count> leaf-update script data items ... ]\n<trigger-vout-idx>\n<revault-vout-idx>\n<revault-amount>\n</source>\n\nwhere\n\n* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n** Otherwise, script execution MUST fail and terminate immediately.\n\n* <code><push-count></code> is an up to 4-byte minimally encoded <code>CScriptNum</code> indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prefix with data pushes?''' Prefixing the <code>leaf-update-script-body</code> with opcodes opens up the door to prefix OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n** If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.\n** If this value is less than 0, script execution MUST fail and terminate immediately.\n** If there are fewer than 3 items following the <code><push-count></code> items on the stack, script execution MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <push-count></code> items remaining on the stack.\n\n* The following <code><push-count></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n\n* <code><trigger-vout-idx></code> is an up to 4-byte minimally encoded <code>CScriptNum</code> indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n** If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.\n** If this value is less than 0 or is greater than or equal to the number of outputs, script execution MUST fail and terminate immediately.\n\n* <code><revault-vout-idx></code> is an up to 4-byte minimally encoded <code>CScriptNum</code> optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n** If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.\n** If this value is greater than or equal to the number of outputs, script execution MUST fail and terminate immediately.\n** If this value is negative and not equal to -1, script execution MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n\n* <code><revault-amount></code> is an up to 7-byte minimally encoded CScriptNum indicating the number of satoshis being revaulted.\n** If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.\n** If this value is not greater than or equal to 0, script execution MUST fail and terminate immediately.\n** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution MUST fail and terminate immediately.\n** If this value is zero but <code><revault-vout-idx></code> is not -1, script execution MUST fail and terminate immediately.\n\nAfter the stack is parsed, the following validation checks are performed:\n\n* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><push-count></code> leaf-update script data items be called the ''leaf-update-script''.\n* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution MUST fail and terminate immediately.\n** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution MUST fail and terminate immediately.\n* Implementation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution SHOULD fail and terminate immediately. This ensures that (at a minimum) the vaulted value for this input is carried through.\n** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n\nIf none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n\n=== <code>OP_VAULT_RECOVER</code> evaluation ===\n\nWhen evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n<code>0xbc</code>), the expected format of the stack, shown top to bottom, is:\n\n<source>\n<recovery-sPK-hash>\n<recovery-vout-idx>\n</source>\n\nwhere\n\n* <code><recovery-sPK-hash></code> is a 32-byte data push.\n** If this is not 32 bytes in length, script execution MUST fail and terminate immediately.\n* <code><recovery-vout-idx></code> is an up to 4-byte minimally encoded <code>CScriptNum</code> indicating the index of the recovery output.\n** If this value does not decode to a valid CScriptNum, script execution MUST fail and terminate immediately.\n** If this value is less than 0 or is greater than or equal to the number of outputs, script execution MUST fail and terminate immediately.\n\nAfter the stack is parsed, the following validation checks are performed:\n\n* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n* Compute the scriptPubKey tagged hash for ''recoveryOut'' as <code>output-sPK-hash = tagged_hash(\"VaultRecoverySPK\", CompactSize(len(recoveryOut.scriptPubKey)) || recoveryOut.scriptPubKey)</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n* If the ''recoveryOut'' <code>output-sPK-hash</code> is not equal to <code><recovery-sPK-hash></code>, script execution MUST fail and terminate immediately.\n** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n\nIf none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n\n=== Deferred check evaluation ===\n\nOnce all inputs for a transaction are validated per the rules above, any\ndeferred checks queued MUST be evaluated.\n\nThe Python pseudocode for this is as follows:\n\n<source lang=\"python\">\nclass TriggerCheck:\n    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n    input_amount: int\n    revault_amount: int\n    trigger_vout_idx: int\n    revault_vout_idx: int\n\n\nclass RecoveryCheck:\n    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n    input_amount: int\n    vout_idx: int\n\n\ndef validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n    \"\"\"\n    Ensure that all value from vault inputs being triggered or recovered is preserved\n    in suitable output nValues.\n    \"\"\"\n    # Map to hold expected output values.\n    out_map: Dict[int, int] = defaultdict(lambda: 0)\n\n    for c in checks:\n        if isinstance(c, TriggerCheck):\n            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n\n            if c.revault_amount > 0:\n                out_map[c.revault_vout_idx] += c.revault_amount\n\n        elif isinstance(c, RecoveryCheck):\n            out_map[c.vout_idx] += c.input_amount\n\n    for (vout_idx, amount_sats) in out_map.items():\n        # Trigger/recovery value can be greater than the constituent vault input\n        # amounts.\n        if tx.vout[vout_idx].nValue < amount_sats:\n            return False\n\n    return True\n</source>\n\nIf the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\nimmediately.\n\nThis ensures that all compatible vault inputs can be batched into shared\ncorresponding trigger or recovery outputs while preserving their entire input value.\n\n\n== Policy changes ==\n\nIn order to prevent possible pinning attacks, recovery transactions must be replaceable.\n\n* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n*# the version of the recovery transaction has an nVersion other than 3.\n\nIf the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\nit be called \"unauthorized,\" because there is no script guarding the recovery\nprocess. In order to prevent pinning attacks in the case of unauthorized\nrecovery - since the spend of the input (and the structure of the\ntransaction) is not authorized by a signed signature message - the output structure of\nunauthorized recovery transaction is limited.\n\n* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/527b007dbf5b9a89895017030183370e05468ae6/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n\n== Implementation ==\n\nA sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-02-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n\n\n== Applications ==\n\nThe specification above, perhaps surprisingly, does not specifically cover how a relative timelocked withdrawal process with a fixed target is implemented. The tapleaf update semantics specified in <code>OP_VAULT</code> as well as the output-based authorization enabled by <code>OP_VAULT_RECOVER</code> can be used to implement a vault, but they are incomplete without two other pieces:\n\n* a way to enforce relative timelocks, like <code>OP_CHECKSEQUENCEVERIFY</code>, and\n* a way to enforce that proposed withdrawals are ultimately being spent to a precise set of outputs, like <code>OP_CHECKTEMPLATEVERIFY</code>.\n\nThese two pieces are combined with the tapleaf update capabilities of\n<code>OP_VAULT</code> to create a vault, described below.\n\n=== Creating a vault ===\n\nIn order to vault coins, they can be spent into a witness v1 <code>scriptPubKey</code>\nthat contains a taptree of the form\n\n<source>\ntr(<internal-pubkey>,\n  leaves = {\n    recover:\n      <recovery-sPK-hash> OP_VAULT_RECOVER,\n\n    trigger:\n      <trigger-auth-pubkey> OP_CHECKSIGVERIFY                     (i)\n      <spend-delay> 2 $leaf-update-script-body OP_VAULT,          (ii)\n\n    ... [ possibly other leaves ]\n  }\n)\n</source>\nwhere\n* <code>$leaf-update-script-body</code> is, for example, <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY</code>.\n** This is one example of a trigger script, but ''any'' script fragment can be used, allowing the creation of different types of vaults. For example, you could use <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG</code> to do a time-delayed transfer of the coins to another key. This also future-proofs <code>OP_VAULT</code> for future scripting capabilities.\n* The script fragment in <code>(i)</code> is called the \"trigger authorization,\" because it gates triggering the withdrawal. This can be done in whatever manner the wallet designer would like.\n* The script fragment in <code>(ii)</code> is the incomplete <code>OP_VAULT</code> invocation - it will be completed once the rest of the parameters (the CTV target hash, trigger vout index, and revault vout index) are provided by the trigger transaction witness.\n\nTypically, the internal key for the vault taproot output will be specified so\nthat it is controlled by the same descriptor as the recovery path, which\nfacilitates another (though probably unused) means of recovering the vault\noutput to the recovery path. This has the potential advantage of recovering the\ncoin without ever revealing it was a vault.\n\nOtherwise, the internal key can be chosen to be an unspendable NUMS point to\nforce execution of the taptree contents.\n\n=== Triggering a withdrawal ===\n\nTo make use of the vault, and spend it towards some output, we construct a spend\nof the above <code>tr()</code> output that simply replaces the \"trigger\" leaf with the\nfull leaf-update script (in this case, a timelocked CTV script):\n\n<source>\nWitness stack:\n\n- <revault-amount>\n- <revault-vout-idx> (-1 if none)\n- <trigger-vout-idx>\n- <target-CTV-hash>\n- <trigger-auth-pubkey-signature>\n- [ \"trigger\" leaf script contents ]\n- [ taproot control block prompting a script-path spend to \"trigger\" leaf ]\n\nOutput scripts:\n\n[\n  tr(<internal-pubkey>,\n    leaves = {\n      recover:\n        <recovery-sPK-hash> OP_VAULT_RECOVER,               <--  unchanged\n\n      trigger:\n        <target-CTV-hash> <spend-delay>\n        OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY  <--  changed per the\n                                                                    leaf-update\n                                                                    rules of OP_VAULT\n       ... [ possibly other leaves ]\n     }\n   ),\n\n   [ optional revault output with the\n     same sPK as the original vault output ],\n]\n</source>\n\n<code>OP_VAULT</code> has allowed the taptree to be transformed so that the trigger leaf\nbecomes a timelocked CTV script, which is what actually facilitates the announced\nwithdrawal. The withdrawal is interruptible by the recovery path because the\n\"recover\" leaf is preserved exactly from the original taptree.\n\nNote that the CTV hash is specified at spend time using the witness stack, and\n\"locked in\" via the <code>OP_VAULT</code> spend rules which assert its existence in the output.\n\nThe vault funds can be recovered at any time prior to the spend of the\ntimelocked CTV script by way of a script-path spend using the \"recover\" leaf.\n\n\n=== Recovery authorization ===\n\nWhen configuring a vault, the user must decide if they want to have the\nrecovery process gated by a script fragment prefixing the\n<code>OP_VAULT_RECOVER</code> instruction in the \"recover\" leaf. Its use\nentails trade-offs.\n\n==== Unauthorized recovery ====\n\nUnauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path, i.e. the preimage of <code><recovery-sPK-hash></code>.\n\nBut because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n\nAdditionally, unauthorized recovery across multiple distinct recovery paths\ncannot be done in the same transaction, and fee control is more constrained:\nbecause the output structure is limited for unauthorized recovery, fee\nmanagement relies either on inputs which are completely spent to fees or the\nuse of the optional ephemeral anchor and package relay.\n\nThese limitations are to avoid pinning attacks.\n\n==== Authorized recovery ====\n\nWith authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization script fragment when recovery is required.\n\nIf this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n\nHowever, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n\n==== Recommendation: use a simple, offline recovery authorization key seed ====\n\nThe benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated.\n\nNote that the recovery authorization key '''is not''' the recovery path key, and\nthis is '''much different''' than any recommendation on how to generate the\nrecovery path key itself.\n\n=== Address reuse and recovery ===\n\nWhen creating a vault, four factors affect the resulting P2TR address:\n# The internal pubkey (likely belonging to the recovery wallet)\n# The recovery leaf\n# The trigger leaf\n# Any other leaves that exist in the taptree\n\nThe end user has the option of varying certain contents along descriptors in\norder to avoid reusing vault addresses without affecting key management, e.g.\nthe trigger authorization pubkeys.\n\nNote that when using unauthorized recovery, the reveal of the\nrecovery scriptPubKey will allow any observer to initiate the recovery process\nfor any vault with matching recovery params, provided they are able to locate\nthe vault outpoints. As a result, it is recommended to expect that\n'''all outputs sharing an identical unauthorized <code><recovery-sPK-hash></code> should be recovered together'''.\n\nThis situation can be avoided with a comparable key management model by varying\nthe generation of each vault's recovery scriptPubKey along a single descriptor,\nbut note that this will prevent recovering multiple separate vaults into a single\nrecovery output.\n\nVarying the internal pubkey will prevent batching the trigger of multiple vault\ninputs into a single trigger output; consequently it is recommended that users\ninstead vary some component of the trigger leaf script if address reuse is\nundesirable. Users could vary the trigger pubkey along a descriptor, keeping\nthe recovery path and internal-pubkey the same, which both avoids reusing\naddresses and allows batched trigger and recovery operations.\n\n==== Recommendation: generate new recovery addresses for new trigger keys ====\n\nIf using unauthorized recovery, it is recommended that you do not share recovery scriptPubKeys\nacross separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\nrecovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\nmeans that an observer might be able to initiate recovery for vaults controlled by an uncompromised\ntrigger key.\n\n==== Fee management ====\n\nFees can be managed in a variety of ways, but it's worth noting that both\ntrigger and recovery transactions must preserve the total value of vault\ninputs, so vaulted values cannot be repurposed to pay for fees. This does not\napply to the withdrawal transaction, which can allocate value arbitrarily.\n\nIn the case of vaults that use recovery authorization, all transactions can\n\"bring their own fees\" in the form of unrelated inputs and outputs. These\ntransactions are also free to specify ephemeral anchors, once the related relay\npolicies are deployed. This means that vaults using recovery authorization have\nno dependence on the deploy of v3 relay policy.\n\nFor vaults using unauthorized recovery, the recovery\ntransaction relies on the use of either fully-spent fee inputs or an ephemeral\nanchor output. This means that vaults which do not use recovery authorization\nare essentially dependent on v3 transaction relay policy being deployed.\n\n=== Batching ===\n\n==== During trigger ====\n\n<code>OP_VAULT</code> outputs with the same taptree, aside from slightly\ndifferent trigger leaves, can be batched together in the same withdrawal\nprocess. Two \"trigger\" leaves are compatible if they have the same\n<code>OP_VAULT</code> arguments.\n\nNote that this allows the trigger authorization -- the script prefixing the\n<code>OP_VAULT</code> invocation -- to differ while still allowing batching.\n\nTrigger transactions can act on multiple incompatible <code>OP_VAULT</code>\ninput sets, provided each set has a suitable associated ''triggerOut''\noutput.\n\nSince <code>SIGHASH_DEFAULT</code> can be used to sign the trigger\nauthorization, unrelated inputs and outputs can be included, possibly to\nfacilitate fee management or the batch withdrawal of incompatible vaults.\n\n==== During withdrawal ====\n\nDuring final withdrawal, multiple trigger outputs can be used towards the same\nwithdrawal transaction provided that they share identical\n<code><target-CTV-hash></code> parameters. This facilitates batched\nwithdrawals.\n\n==== During recovery ====\n\n<code>OP_VAULT_RECOVER</code> outputs with the same <code><recovery-sPK-hash></code>\ncan be recovered into the same output.\n\nRecovery-incompatible vaults which have authorized recovery can be recovered in\nthe same transaction, so long as each set (grouped by\n<code><recovery-sPK-hash></code>) has an associated ''recoveryOut''. This allows\nunrelated recoveries to share common fee management.\n\n=== Watchtowers ===\n\nThe value of vaults is contingent upon having monitoring in place that will\nalert the owner when unexpected spends are taking place. This can be done in a\nvariety of ways, with varying degrees of automation and trust in the\nwatchtower.\n\nIn the maximum-trust case, the watchtower can be fully aware of all vaulted\ncoins and has the means to initiate the recovery process if spends are not\npre-reported to the watchtower.\n\nIn the minimum-trust case, the user can supply a probabilistic filter of which\ncoins they wish to monitor; the watchtower would then alert the user if any\ncoins matching the filter move, and the user would be responsible for ignoring\nfalse positives and handling recovery initiation.\n\n=== Output descriptors ===\n\nOutput descriptors for vault-related outputs will be covered in a subsequent BIP.\n\n== Deployment ==\n\nActivation mechanism is to be determined.\n\nThis BIP should be deployed concurrently with BIP-0119 to enable full use of vaults.\n\n== Backwards compatibility ==\n\n<code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code> replace, respectively,\nthe witness v1-only opcodes OP_SUCCESS187 and OP_SUCCESS188 with stricter\nverification semantics. Consequently, scripts using those opcodes which\npreviously were valid will cease to be valid with this change.\n\nStricter verification semantics for an OP_SUCCESSx opcode are a soft fork, so\nexisting software will be fully functional without upgrade except for mining\nand block validation.\n\nBackwards compatibility considerations are very comparable to previous\ndeployments for OP_CHECKSEQUENCEVERIFY and OP_CHECKLOCKTIMEVERIFY (see\n[https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP-0065] and\n[https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112]).\n\n\n== Rationale ==\n\n<references />\n\n== References ==\n\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012470.html [bitcoin-dev] Bitcoin Vaults (2016)]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html [bitcoin-dev] Simple lock/unlock mechanism (2018)]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html [bitcoin-dev] On-chain vaults prototype (2020)]\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html [bitcoin-dev] TAPLEAF_UPDATE_VERIFY covenant opcode (2021)]\n* [https://arxiv.org/abs/2005.11776 Custody Protocols Using Bitcoin Vaults (2020)]\n* [https://jameso.be/vaults.pdf Vaults and Covenants (2023)]\n\n== Acknowledgements ==\n\nThe author would like to thank\n\n* AJ Towns and Greg Sanders for discussion, numerous suggestions that improved the proposal, and advice.\n* Jeremy Rubin for inspiration, advice, and mentorship.\n* BL for discussion and insight.\n* John Moffett for early feedback and a test case demonstrating a recursive script evaluation attack.\n* Johan Halseth for providing conceptual review and pointing out a pinning attack.\n* Pieter Wuille for implementation advice.\n", "content_length": 44153}
{"bip_number": 343, "filename": "bip-0343.mediawiki", "content": "<pre>\n  BIP: 343\n  Layer: Consensus (soft fork)\n  Title: Mandatory activation of taproot deployment\n  Author: Shinobius <quantumedusa@gmail.com>\n          Michael Folkson <michaelfolkson@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0343\n  Status: Final\n  Type: Standards Track\n  Created: 2021-04-25\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies a BIP8 (LOT=true) deployment to activate taproot.\n\n==Motivation==\n\nThe Taproot soft fork upgrade has been assessed to have overwhelming community consensus and hence should attempt to be activated. Lessons have been learned from the BIP148 and BIP91 deployments in 2017 with regards to giving many months of advance warning before the mandatory signaling is attempted. The mandatory signaling is only required if miners have failed to meet the signaling threshold during the BIP8 deployment. It is important that mandatory signaling is included as without it miners would effectively have the ability to indefinitely block the activation of a soft fork with overwhelming consensus.\n\n==Specification==\n\nThis BIP will begin an activation signaling period using bit 2 at blockheight 681408 with a minimum activation height of 709632 and an activation threshold of 90%. The signaling period will timeout at blockheight 760032 with a latest activation height of 762048. Lockinontimeout (LOT) is set to true so mandatory signaling will be enforced in the last signaling period before the timeout height. Blocks without the signaling bit 2 set run the risk of being rejected during this period if taproot is not locked in prior. This BIP will cease to be active when taproot is locked in.\n\n==Reference implementation==\n\n*[[https://github.com/BitcoinActivation/bitcoin]]\n\n==Backward Compatibility==\n\nAs a soft fork, older software will continue to operate without modification. Non-upgraded nodes, however, will consider all SegWit version 1 witness programs as anyone-can-spend scripts. They are strongly encouraged to upgrade in order to fully validate the new programs.\n\n==Compatibility with later alternative activations==\n\nThe activation mechanism \u201cSpeedy Trial\u201d as proposed by Russell O\u2019Connor and outlined in this bitcoin-dev mailing list [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-March/018583.html post] by David Harding was released in Bitcoin Core. It is effectively a BIP8 activation mechanism with one exception: start height and timeout height were defined using median time past (MTP) rather than block heights. It uses signaling bit 2, was deployed between midnight April 24th 2021 and midnight August 11th 2021, has a minimum activation height of 709632 and intends to activate BIPs 340, 341, and 342. The BIP8(LOT=true) deployment is compatible with the \u201cSpeedy Trial\u201d deployment in Bitcoin Core as there was not a discrepancy between MTP and block height for the defined start heights.\n\nThe BIP8 (LOT=true) deployment has also been deliberately designed to be compatible with a future BIP8(LOT=false) or BIP8(LOT=true) deployment in Bitcoin Core assuming Bitcoin Core releases one of these activation mechanisms in the event of the Speedy Trial deployment failing to activate.\n\n==Rationale==\n\nThe deployment of BIP148 demonstrated that multiple implementations with different activation mechanisms can incentivize the necessary actors to act so that the different deployments activate in sync. A BIP8 LOT=true deployment can run in parallel with other BIP8 activation mechanisms that have eventual mandatory signaling or no mandatory signaling. Eventual mandatory signaling ensures that miners cannot prevent the activation of a desired feature with community consensus indefinitely.\n\n==Acknowledgements==\n\nThanks to Shaolin Fry and Luke Dashjr for their work on BIP148 and BIP8 which were important prerequisites for this proposal.\n\n==References==\n\n*[[bip-0008.mediawiki|BIP8 Version bits with lock-in by height]]\n*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n*[[bip-0340.mediawiki|BIP340 Schnorr Signatures for secp256k1]]\n*[[bip-0341.mediawiki|BIP341 Taproot: SegWit version 1 spending rules]]\n*[[bip-0342.mediawiki|BIP342 Validation of Taproot Scripts]]\n*[https://taproot.works/taproot-faq/ Taproot benefits]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n\n", "content_length": 4432}
{"bip_number": 342, "filename": "bip-0342.mediawiki", "content": "<pre>\n  BIP: 342\n  Layer: Consensus (soft fork)\n  Title: Validation of Taproot Scripts\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Jonas Nick <jonasd.nick@gmail.com>\n          Anthony Towns <aj@erisian.com.au>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0342\n  Status: Final\n  Type: Standards Track\n  Created: 2020-01-19\n  License: BSD-3-Clause\n  Post-History: 2019-05-06: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016914.html [bitcoin-dev] Taproot proposal\n  Requires: 340, 341\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document specifies the semantics of the initial scripting system under [[bip-0341.mediawiki|BIP341]].\n\n===Copyright===\n\nThis document is licensed under the 3-clause BSD license.\n\n===Motivation===\n\n[[bip-0341.mediawiki|BIP341]] proposes improvements to just the script structure, but some of its goals are incompatible with the semantics of certain opcodes within the scripting language itself.\nWhile it is possible to deal with these in separate optional improvements, their impact is not guaranteed unless they are addressed simultaneously with [[bip-0341.mediawiki|BIP341]] itself.\n\nSpecifically, the goal is making '''Schnorr signatures''', '''batch validation''', and '''signature hash''' improvements available to spends that use the script system as well.\n\n==Design==\n\nIn order to achieve these goals, signature opcodes <code>OP_CHECKSIG</code> and <code>OP_CHECKSIGVERIFY</code> are modified to verify Schnorr signatures as specified in [[bip-0340.mediawiki|BIP340]] and to use a signature message algorithm based on the common message calculation in [[bip-0341.mediawiki|BIP341]].\nThe tapscript signature message also simplifies <code>OP_CODESEPARATOR</code> handling and makes it more efficient.\n\nThe inefficient <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> opcodes are disabled.\nInstead, a new opcode <code>OP_CHECKSIGADD</code> is introduced to allow creating the same multisignature policies in a batch-verifiable way.\nTapscript uses a new, simpler signature opcode limit fixing complicated interactions with transaction weight.\nFurthermore, a potential malleability vector is eliminated by requiring MINIMALIF.\n\nTapscript can be upgraded through soft forks by defining unknown key types, for example to add new <code>hash_types</code> or signature algorithms.\nAdditionally, the new tapscript <code>OP_SUCCESS</code> opcodes allow introducing new opcodes more cleanly than through <code>OP_NOP</code>.\n\n==Specification==\n\nThe rules below only apply when validating a transaction input for which all of the conditions below are true:\n* The transaction input is a '''segregated witness spend''' (i.e., the scriptPubKey contains a witness program as defined in [[bip-0141.mediawiki|BIP141]]).\n* It is a '''taproot spend''' as defined in [[bip-0341.mediawiki#design|BIP341]] (i.e., the witness version is 1, the witness program is 32 bytes, and it is not P2SH wrapped).\n* It is a '''script path spend''' as defined in [[bip-0341.mediawiki#design|BIP341]] (i.e., after removing the optional annex from the witness stack, two or more stack elements remain).\n* The leaf version is ''0xc0'' (i.e. the first byte of the last witness element after removing the optional annex is ''0xc0'' or ''0xc1''), marking it as a '''tapscript spend'''.\n\nValidation of such inputs must be equivalent to performing the following steps in the specified order.\n# If the input is invalid due to BIP141 or BIP341, fail.\n# The script as defined in BIP341 (i.e., the penultimate witness stack element after removing the optional annex) is called the '''tapscript''' and is decoded into opcodes, one by one:\n## If any opcode numbered ''80, 98, 126-129, 131-134, 137-138, 141-142, 149-153, 187-254'' is encountered, validation succeeds (none of the rules below apply). This is true even if later bytes in the tapscript would fail to decode otherwise. These opcodes are renamed to <code>OP_SUCCESS80</code>, ..., <code>OP_SUCCESS254</code>, and collectively known as <code>OP_SUCCESSx</code><ref>'''<code>OP_SUCCESSx</code>''' <code>OP_SUCCESSx</code> is a mechanism to upgrade the Script system. Using an <code>OP_SUCCESSx</code> before its meaning is defined by a softfork is insecure and leads to fund loss. The inclusion of <code>OP_SUCCESSx</code> in a script will pass it unconditionally. It precedes any script execution rules to avoid the difficulties in specifying various edge cases, for example: <code>OP_SUCCESSx</code> in a script with an input stack larger than 1000 elements, <code>OP_SUCCESSx</code> after too many signature opcodes, or even scripts with conditionals lacking <code>OP_ENDIF</code>. The mere existence of an <code>OP_SUCCESSx</code> anywhere in the script will guarantee a pass for all such cases. <code>OP_SUCCESSx</code> are similar to the <code>OP_RETURN</code> in very early bitcoin versions (v0.1 up to and including v0.3.5). The original <code>OP_RETURN</code> terminates script execution immediately, and return pass or fail based on the top stack element at the moment of termination. This was one of a major design flaws in the original bitcoin protocol as it permitted unconditional third party theft by placing an <code>OP_RETURN</code> in <code>scriptSig</code>. This is not a concern in the present proposal since it is not possible for a third party to inject an <code>OP_SUCCESSx</code> to the validation process, as the <code>OP_SUCCESSx</code> is part of the script (and thus committed to by the taproot output), implying the consent of the coin owner. <code>OP_SUCCESSx</code> can be used for a variety of upgrade possibilities:\n* An <code>OP_SUCCESSx</code> could be turned into a functional opcode through a softfork. Unlike <code>OP_NOPx</code>-derived opcodes which only have read-only access to the stack, <code>OP_SUCCESSx</code> may also write to the stack. Any rule changes to an <code>OP_SUCCESSx</code>-containing script may only turn a valid script into an invalid one, and this is always achievable with softforks.\n* Since <code>OP_SUCCESSx</code> precedes size check of initial stack and push opcodes, an <code>OP_SUCCESSx</code>-derived opcode requiring stack elements bigger than 520 bytes may uplift the limit in a softfork.\n* <code>OP_SUCCESSx</code> may also redefine the behavior of existing opcodes so they could work together with the new opcode. For example, if an <code>OP_SUCCESSx</code>-derived opcode works with 64-bit integers, it may also allow the existing arithmetic opcodes in the ''same script'' to do the same.\n* Given that <code>OP_SUCCESSx</code> even causes potentially unparseable scripts to pass, it can be used to introduce multi-byte opcodes, or even a completely new scripting language when prefixed with a specific <code>OP_SUCCESSx</code> opcode.</ref>.\n## If any push opcode fails to decode because it would extend past the end of the tapscript, fail.\n# If the '''initial stack''' as defined in BIP341 (i.e., the witness stack after removing both the optional annex and the two last stack elements after that) violates any resource limits (stack size, and size of the elements in the stack; see \"Resource Limits\" below), fail. Note that this check can be bypassed using <code>OP_SUCCESSx</code>.\n# The tapscript is executed according to the rules in the following section, with the initial stack as input.\n## If execution fails for any reason, fail.\n## If the execution results in anything but exactly one element on the stack which evaluates to true with <code>CastToBool()</code>, fail.\n# If this step is reached without encountering a failure, validation succeeds.\n\n===Script execution===\n\nThe execution rules for tapscript are based on those for P2WSH according to BIP141, including the <code>OP_CHECKLOCKTIMEVERIFY</code> and <code>OP_CHECKSEQUENCEVERIFY</code> opcodes defined in [[bip-0065.mediawiki|BIP65]] and [[bip-0112.mediawiki|BIP112]], but with the following modifications:\n* '''Disabled script opcodes''' The following script opcodes are disabled in tapscript: <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code><ref>'''Why are <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> disabled, and not turned into OP_SUCCESSx?''' This is a precaution to make sure people who accidentally keep using <code>OP_CHECKMULTISIG</code> in Tapscript notice a problem immediately. It also avoids the complication of script disassemblers needing to become context-dependent.</ref>. The disabled opcodes behave in the same way as <code>OP_RETURN</code>, by failing and terminating the script immediately when executed, and being ignored when found in unexecuted branch of the script.\n* '''Consensus-enforced MINIMALIF''' The MINIMALIF rules, which are only a standardness rule in P2WSH, are consensus enforced in tapscript. This means that the input argument to the <code>OP_IF</code> and <code>OP_NOTIF</code> opcodes must be either exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1)<ref>'''Why make MINIMALIF consensus?''' This makes it considerably easier to write non-malleable scripts that take branch information from the stack.</ref>.\n* '''OP_SUCCESSx opcodes''' As listed above, some opcodes are renamed to <code>OP_SUCCESSx</code>, and make the script unconditionally valid.\n* '''Signature opcodes'''. The <code>OP_CHECKSIG</code> and <code>OP_CHECKSIGVERIFY</code> are modified to operate on Schnorr public keys and signatures (see [[bip-0340.mediawiki|BIP340]]) instead of ECDSA, and a new opcode <code>OP_CHECKSIGADD</code> is added.\n** The opcode 186 (<code>0xba</code>) is named as <code>OP_CHECKSIGADD</code>. <ref>'''<code>OP_CHECKSIGADD</code>''' This opcode is added to compensate for the loss of <code>OP_CHECKMULTISIG</code>-like opcodes, which are incompatible with batch verification. <code>OP_CHECKSIGADD</code> is functionally equivalent to <code>OP_ROT OP_SWAP OP_CHECKSIG OP_ADD</code>, but only takes 1 byte. All <code>CScriptNum</code>-related behaviours of <code>OP_ADD</code> are also applicable to <code>OP_CHECKSIGADD</code>.</ref><ref>'''Alternatives to <code>CHECKMULTISIG</code>''' There are multiple ways of implementing a threshold ''k''-of-''n'' policy using Taproot and Tapscript:\n* '''Using a single <code>OP_CHECKSIGADD</code>-based script''' A <code>CHECKMULTISIG</code> script <code>m <pubkey_1> ... <pubkey_n> n CHECKMULTISIG</code> with witness <code>0 <signature_1> ... <signature_m></code> can be rewritten as script <code><pubkey_1> CHECKSIG <pubkey_2> CHECKSIGADD ... <pubkey_n> CHECKSIGADD m NUMEQUAL</code> with witness <code><w_n> ... <w_1></code>. Every witness element <code>w_i</code> is either a signature corresponding to <code>pubkey_i</code> or an empty vector. A similar <code>CHECKMULTISIGVERIFY</code> script can be translated to BIP342 by replacing <code>NUMEQUAL</code> with <code>NUMEQUALVERIFY</code>. This approach has very similar characteristics to the existing <code>OP_CHECKMULTISIG</code>-based scripts.\n* '''Using a ''k''-of-''k'' script for every combination''' A ''k''-of-''n'' policy can be implemented by splitting the script into several leaves of the Merkle tree, each implementing a ''k''-of-''k'' policy using <code><pubkey_1> CHECKSIGVERIFY ... <pubkey_(n-1)> CHECKSIGVERIFY <pubkey_n> CHECKSIG</code>. This may be preferable for privacy reasons over the previous approach, as it only exposes the participating public keys, but it is only more cost effective for small values of ''k'' (1-of-''n'' for any ''n'', 2-of-''n'' for ''n &ge; 6'', 3-of-''n'' for ''n &ge; 9'', ...). Furthermore, the signatures here commit to the branch used, which means signers need to be aware of which other signers will be participating, or produce signatures for each of the tree leaves.\n* '''Using an aggregated public key for every combination''' Instead of building a tree where every leaf consists of ''k'' public keys, it is possible instead build a tree where every leaf contains a single ''aggregate'' of those ''k'' keys using [https://eprint.iacr.org/2018/068 MuSig]. This approach is far more efficient, but does require a 3-round interactive signing protocol to jointly produce the (single) signature.\n* '''Native Schnorr threshold signatures''' Multisig policies can also be realized with [http://cacr.uwaterloo.ca/techreports/2001/corr2001-13.ps threshold signatures] using verifiable secret sharing. This results in outputs and inputs that are indistinguishable from single-key payments, but at the cost of needing an interactive protocol (and associated backup procedures) before determining the address to send to.</ref>\n\n===Rules for signature opcodes===\n\nThe following rules apply to <code>OP_CHECKSIG</code>, <code>OP_CHECKSIGVERIFY</code>, and <code>OP_CHECKSIGADD</code>.\n\n* For <code>OP_CHECKSIGVERIFY</code> and <code>OP_CHECKSIG</code>, the public key (top element) and a signature (second to top element) are popped from the stack.\n** If fewer than 2 elements are on the stack, the script MUST fail and terminate immediately.\n* For <code>OP_CHECKSIGADD</code>, the public key (top element), a <code>CScriptNum</code> <code>n</code> (second to top element), and a signature (third to top element) are popped from the stack.\n** If fewer than 3 elements are on the stack, the script MUST fail and terminate immediately.\n** If <code>n</code> is larger than 4 bytes, the script MUST fail and terminate immediately.\n* If the public key size is zero, the script MUST fail and terminate immediately.\n* If the public key size is 32 bytes, it is considered to be a public key as described in BIP340:\n** If the signature is not the empty vector, the signature is validated against the public key (see the next subsection). Validation failure in this case immediately terminates script execution with failure.\n* If the public key size is not zero and not 32 bytes, the public key is of an ''unknown public key type''<ref>'''Unknown public key types''' allow adding new signature validation rules through softforks. A softfork could add actual signature validation which either passes or makes the script fail and terminate immediately. This way, new <code>SIGHASH</code> modes can be added, as well as [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-December/016549.html NOINPUT-tagged public keys] and a public key constant which is replaced by the taproot internal key for signature validation.</ref> and no actual signature verification is applied. During script execution of signature opcodes they behave exactly as known public key types except that signature validation is considered to be successful.\n* If the script did not fail and terminate before this step, regardless of the public key type:\n** If the signature is the empty vector:\n*** For <code>OP_CHECKSIGVERIFY</code>, the script MUST fail and terminate immediately.\n*** For <code>OP_CHECKSIG</code>, an empty vector is pushed onto the stack, and execution continues with the next opcode.\n*** For <code>OP_CHECKSIGADD</code>, a <code>CScriptNum</code> with value <code>n</code> is pushed onto the stack, and execution continues with the next opcode.\n** If the signature is not the empty vector, the opcode is counted towards the sigops budget (see further).\n*** For <code>OP_CHECKSIGVERIFY</code>, execution continues without any further changes to the stack.\n*** For <code>OP_CHECKSIG</code>, a 1-byte value <code>0x01</code> is pushed onto the stack.\n*** For <code>OP_CHECKSIGADD</code>, a <code>CScriptNum</code> with value of <code>n + 1</code> is pushed onto the stack.\n\n===Common Signature Message Extension===\n\nWe define the tapscript message extension ''ext'' to [[bip-0341.mediawiki#common-signature-message|BIP341 Common Signature Message]], indicated by ''ext_flag = 1'':\n* ''tapleaf_hash'' (32): the tapleaf hash as defined in [[bip-0341.mediawiki#design|BIP341]]\n* ''key_version'' (1): a constant value ''0x00'' representing the current version of public keys in the tapscript signature opcode execution.\n* ''codesep_pos'' (4): the opcode position of the last executed <code>OP_CODESEPARATOR</code> before the currently executed signature opcode, with the value in little endian (or ''0xffffffff'' if none executed). The first opcode in a script has a position of 0. A multi-byte push opcode is counted as one opcode, regardless of the size of data being pushed. Opcodes in parsed but unexecuted branches count towards this value as well.\n\n===Signature validation===\n\nTo validate a signature ''sig'' with public key ''p'':\n* Compute the tapscript message extension ''ext'' described above.\n* If the ''sig'' is 64 bytes long, return ''Verify(p, hash<sub>TapSighash</sub>(0x00 || SigMsg(0x00, 1) || ext), sig)'', where ''Verify'' is defined in [[bip-0340.mediawiki#design|BIP340]].\n* If the ''sig'' is 65 bytes long, return ''sig[64] &ne; 0x00 and Verify(p, hash<sub>TapSighash</sub>(0x00 || SigMsg(sig[64], 1) || ext), sig[0:64])''.\n* Otherwise, fail.\n\nIn summary, the semantics of signature validation is identical to BIP340, except the following:\n# The signature message includes the tapscript-specific data ''key_version''.<ref>'''Why does the signature message commit to the ''key_version''?''' This is for future extensions that define unknown public key types, making sure signatures can't be moved from one key type to another.</ref>\n# The signature message commits to the executed script through the ''tapleaf_hash'' which includes the leaf version and script instead of ''scriptCode''. This implies that this commitment is unaffected by <code>OP_CODESEPARATOR</code>.\n# The signature message includes the opcode position of the last executed <code>OP_CODESEPARATOR</code>.<ref>'''Why does the signature message include the position of the last executed <code>OP_CODESEPARATOR</code>?''' This allows continuing to use <code>OP_CODESEPARATOR</code> to sign the executed path of the script. Because the <code>codeseparator_position</code> is the last input to the hash, the SHA256 midstate can be efficiently cached for multiple <code>OP_CODESEPARATOR</code>s in a single script. In contrast, the BIP143 handling of <code>OP_CODESEPARATOR</code> is to commit to the executed script only from the last executed <code>OP_CODESEPARATOR</code> onwards which requires unnecessary rehashing of the script. It should be noted that the one known <code>OP_CODESEPARATOR</code> use case of saving a second public key push in a script by sharing the first one between two code branches can be most likely expressed even cheaper by moving each branch into a separate taproot leaf.</ref>\n\n===Resource limits===\n\nIn addition to changing the semantics of a number of opcodes, there are also some changes to the resource limitations:\n* '''Script size limit''' The maximum script size of 10000 bytes does not apply. Their size is only implicitly bounded by the block weight limit.<ref>'''Why is a limit on script size no longer needed?''' Since there is no <code>scriptCode</code> directly included in the signature hash (only indirectly through a precomputable tapleaf hash), the CPU time spent on a signature check is no longer proportional to the size of the script being executed.</ref>\n* '''Non-push opcodes limit''' The maximum non-push opcodes limit of 201 per script does not apply.<ref>'''Why is a limit on the number of opcodes no longer needed?''' An opcode limit only helps to the extent that it can prevent data structures from growing unboundedly during execution (both because of memory usage, and because of time that may grow in proportion to the size of those structures). The size of stack and altstack is already independently limited. By using O(1) logic for <code>OP_IF</code>, <code>OP_NOTIF</code>, <code>OP_ELSE</code>, and <code>OP_ENDIF</code> as suggested [https://bitslog.com/2017/04/17/new-quadratic-delays-in-bitcoin-scripts/ here] and implemented [https://github.com/bitcoin/bitcoin/pull/16902 here], the only other instance can be avoided as well.</ref>\n* '''Sigops limit''' The sigops in tapscripts do not count towards the block-wide limit of 80000 (weighted). Instead, there is a per-script sigops ''budget''. The budget equals 50 + the total serialized size in bytes of the transaction input's witness (including the <code>CompactSize</code> prefix). Executing a signature opcode (<code>OP_CHECKSIG</code>, <code>OP_CHECKSIGVERIFY</code>, or <code>OP_CHECKSIGADD</code>) with a non-empty signature decrements the budget by 50. If that brings the budget below zero, the script fails immediately. Signature opcodes with unknown public key type and non-empty signature are also counted.<ref>'''The tapscript sigop limit''' The signature opcode limit protects against scripts which are slow to verify due to excessively many signature operations. In tapscript the number of signature opcodes does not count towards the BIP141 or legacy sigop limit. The old sigop limit makes transaction selection in block construction unnecessarily difficult because it is a second constraint in addition to weight. Instead, the number of tapscript signature opcodes is limited by witness weight. Additionally, the limit applies to the transaction input instead of the block and only actually executed signature opcodes are counted. Tapscript execution allows one signature opcode per 50 witness weight units plus one free signature opcode.</ref><ref>'''Parameter choice of the sigop limit''' Regular witnesses are unaffected by the limit as their weight is composed of public key and (<code>SIGHASH_ALL</code>) signature pairs with ''33 + 65'' weight units each (which includes a 1 weight unit <code>CompactSize</code> tag). This is also the case if public keys are reused in the script because a signature's weight alone is 65 or 66 weight units. However, the limit increases the fees of abnormal scripts with duplicate signatures (and public keys) by requiring additional weight. The weight per sigop factor 50 corresponds to the ratio of BIP141 block limits: 4 mega weight units divided by 80,000 sigops. The \"free\" signature opcode permitted by the limit exists to account for the weight of the non-witness parts of the transaction input.</ref><ref>'''Why are only signature opcodes counted toward the budget, and not for example hashing opcodes or other expensive operations?''' It turns out that the CPU cost per witness byte for verification of a script consisting of the maximum density of signature checking opcodes (taking the 50 WU/sigop limit into account) is already very close to that of scripts packed with other opcodes, including hashing opcodes (taking the 520 byte stack element limit into account) and <code>OP_ROLL</code> (taking the 1000 stack element limit into account). That said, the construction is very flexible, and allows adding new signature opcodes like <code>CHECKSIGFROMSTACK</code> to count towards the limit through a soft fork. Even if in the future new opcodes are introduced which change normal script cost there is no need to stuff the witness with meaningless data. Instead, the taproot annex can be used to add weight to the witness without increasing the actual witness size.</ref>.\n* '''Stack + altstack element count limit''' The existing limit of 1000 elements in the stack and altstack together after every executed opcode remains. It is extended to also apply to the size of initial stack.\n* '''Stack element size limit''' The existing limit of maximum 520 bytes per stack element remains, both in the initial stack and in push opcodes.\n\n==Rationale==\n\n<references />\n\n==Deployment==\n\nThis proposal is deployed identically to Taproot ([[bip-0341.mediawiki|BIP341]]).\n\n==Examples==\n\nThe Taproot ([[bip-0341.mediawiki|BIP341]]) test vectors also contain examples for Tapscript execution.\n\n==Acknowledgements==\n\nThis document is the result of many discussions and contains contributions by a number of people. The authors wish to thank all those who provided valuable feedback and reviews, including the participants of the [https://github.com/ajtowns/taproot-review structured reviews].\n", "content_length": 24093}
{"bip_number": 341, "filename": "bip-0341.mediawiki", "content": "<pre>\n  BIP: 341\n  Layer: Consensus (soft fork)\n  Title: Taproot: SegWit version 1 spending rules\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Jonas Nick <jonasd.nick@gmail.com>\n          Anthony Towns <aj@erisian.com.au>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0341\n  Status: Final\n  Type: Standards Track\n  Created: 2020-01-19\n  License: BSD-3-Clause\n  Post-History: 2019-05-06: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016914.html [bitcoin-dev] Taproot proposal\n                2019-10-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017378.html [bitcoin-dev] Taproot updates\n  Requires: 340\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a new SegWit version 1 output type, with spending rules based on Taproot, Schnorr signatures, and Merkle branches.\n\n===Copyright===\n\nThis document is licensed under the 3-clause BSD license.\n\n===Motivation===\n\nThis proposal aims to improve privacy, efficiency, and flexibility of Bitcoin's scripting capabilities without adding new security assumptions<ref>'''What does not adding security assumptions mean?''' Unforgeability of signatures is a necessary requirement to prevent theft. At least when treating script execution as a digital signature scheme itself, unforgeability can be [https://github.com/apoelstra/taproot proven] in the Random Oracle Model assuming the Discrete Logarithm problem is hard. A [https://nbn-resolving.de/urn:nbn:de:hbz:294-60803 proof] for unforgeability of ECDSA in the current script system needs non-standard assumptions on top of that. Note that it is hard in general to model exactly what security for script means, as it depends on the policies and protocols used by wallet software.</ref>. Specifically, it seeks to minimize how much information about the spendability conditions of a transaction output is revealed on chain at creation or spending time and to add a number of upgrade mechanisms, while fixing a few minor but long-standing issues.\n\n==Design==\n\nA number of related ideas for improving Bitcoin's scripting capabilities have been previously proposed: Schnorr signatures ([[bip-0340.mediawiki|BIP340]]), Merkle branches (\"MAST\", [[bip-0114.mediawiki|BIP114]], [[bip-0117.mediawiki|BIP117]]), new sighash modes ([[bip-0118.mediawiki|BIP118]]), new opcodes like CHECKSIGFROMSTACK, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015614.html Taproot], [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015700.html Graftroot], [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016249.html G'root], and [https://bitcointalk.org/index.php?topic=1377298.0 cross-input aggregation].\n\nCombining all these ideas in a single proposal would be an extensive change, be hard to review, and likely miss new discoveries that otherwise could have been made along the way. Not all are equally mature as well. For example, cross-input aggregation [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015838.html interacts] in complex ways with upgrade mechanisms, and solutions to that are still [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-October/016461.html in flux]. On the other hand, separating them all into independent upgrades would reduce the efficiency and privacy gains to be had, and wallet and service providers may not be inclined to go through many incremental updates. Therefore, we're faced with a tradeoff between functionality and scope creep. In this design we strike a balance by focusing on the structural script improvements offered by Taproot and Merkle branches, as well as changes necessary to make them usable and efficient. For things like sighashes and opcodes we include fixes for known problems, but exclude new features that can be added independently with no downsides.\n\nAs a result we choose this combination of technologies:\n* '''Merkle branches''' let us only reveal the actually executed part of the script to the blockchain, as opposed to all possible ways a script can be executed. Among the various known mechanisms for implementing this, one where the Merkle tree becomes part of the script's structure directly maximizes the space savings, so that approach is chosen.\n* '''Taproot''' on top of that lets us merge the traditionally separate pay-to-pubkey and pay-to-scripthash policies, making all outputs spendable by either a key or (optionally) a script, and indistinguishable from each other. As long as the key-based spending path is used for spending, it is not revealed whether a script path was permitted as well, resulting in space savings and an increase in scripting privacy at spending time.\n* Taproot's advantages become apparent under the assumption that most applications involve outputs that could be spent by all parties agreeing. That's where '''Schnorr''' signatures come in, as they permit [https://eprint.iacr.org/2018/068 key aggregation]: a public key can be constructed from multiple participant public keys, and which requires cooperation between all participants to sign for. Such multi-party public keys and signatures are indistinguishable from their single-party equivalents. This means that with taproot most applications can use the key-based spending path, which is both efficient and private. This can be generalized to arbitrary M-of-N policies, as Schnorr signatures support threshold signing, at the cost of more complex setup protocols.\n* As Schnorr signatures also permit '''batch validation''', allowing multiple signatures to be validated together more efficiently than validating each one independently, we make sure all parts of the design are compatible with this.\n* Where unused bits appear as a result of the above changes, they are reserved for mechanisms for '''future extensions'''. As a result, every script in the Merkle tree has an associated version such that new script versions can be introduced with a soft fork while remaining compatible with BIP 341. Additionally, future soft forks can make use of the currently unused <code>annex</code> in the witness (see [[bip-0341.mediawiki#rationale|Rationale]]).\n* While the core semantics of the '''signature hashing algorithm''' are not changed, a number of improvements are included in this proposal. The new signature hashing algorithm fixes the verification capabilities of offline signing devices by including amount and scriptPubKey in the signature message, avoids unnecessary hashing, uses '''tagged hashes''' and defines a default sighash byte.\n* The '''public key is directly included in the output''' in contrast to typical earlier constructions which store a hash of the public key or script in the output. This has the same cost for senders and is more space efficient overall if the key-based spending path is taken. <ref>'''Why is the public key directly included in the output?''' While typical earlier constructions store a hash of a script or a public key in the output, this is rather wasteful when a public key is always involved. To guarantee batch verifiability, the public key must be known to every verifier, and thus only revealing its hash as an output would imply adding an additional 32 bytes to the witness. Furthermore, to maintain [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012198.html 128-bit collision security] for outputs, a 256-bit hash would be required anyway, which is comparable in size (and thus in cost for senders) to revealing the public key directly. While the usage of public key hashes is often said to protect against ECDLP breaks or quantum computers, this protection is very weak at best: transactions are not protected while being confirmed, and a very [https://web.archive.org/web/20220531184542/https://twitter.com/pwuille/status/1108085284862713856 large portion] of the currency's supply is not under such protection regardless. Actual resistance to such systems can be introduced by relying on different cryptographic assumptions, but this proposal focuses on improvements that do not change the security model.</ref>\n\nInformally, the resulting design is as follows: a new witness version is added (version 1), whose programs consist of 32-byte encodings of points ''Q''. ''Q'' is computed as ''P + hash(P||m)G'' for a public key ''P'', and the root ''m'' of a Merkle tree whose leaves consist of a version number and a script. These outputs can be spent directly by providing a signature for ''Q'', or indirectly by revealing ''P'', the script and leaf version, inputs that satisfy the script, and a Merkle path that proves ''Q'' committed to that leaf. All hashes in this construction (the hash for computing ''Q'' from ''P'', the hashes inside the Merkle tree's inner nodes, and the signature hashes used) are tagged to guarantee domain separation.\n\n== Specification ==\n\nThis section specifies the Taproot consensus rules. Validity is defined by exclusion: a block or transaction is valid if no condition exists that marks it failed.\n\nThe notation below follows that of [[bip-0340.mediawiki#design|BIP340]]. This includes the ''hash<sub>tag</sub>(x)'' notation to refer to ''SHA256(SHA256(tag) || SHA256(tag) || x)''. To the best of the authors' knowledge, no existing use of SHA256 in Bitcoin feeds it a message that starts with two single SHA256 outputs, making collisions between ''hash<sub>tag</sub>'' with other hashes extremely unlikely.\n\n=== Script validation rules ===\n\nA Taproot output is a native SegWit output (see [[bip-0141.mediawiki|BIP141]]) with version number 1, and a 32-byte witness program.\nThe following rules only apply when such an output is being spent. Any other outputs, including version 1 outputs with lengths other than 32 bytes, or P2SH-wrapped version 1 outputs<ref>'''Why is P2SH-wrapping not supported?''' Using P2SH-wrapped outputs only provides 80-bit collision security due to the use of a 160-bit hash. This is considered low, and becomes a security risk whenever the output includes data from more than a single party (public keys, hashes, ...).</ref>, remain unencumbered.\n\n* Let ''q'' be the 32-byte array containing the witness program (the second push in the scriptPubKey) which represents a public key according to [[bip-0340.mediawiki#design|BIP340]].\n* Fail if the witness stack has 0 elements.\n* If there are at least two witness elements, and the first byte of the last element is 0x50<ref>'''Why is the first byte of the annex <code>0x50</code>?''' The <code>0x50</code> is chosen as it could not be confused with a valid P2WPKH or P2WSH spending. As the control block's initial byte's lowest bit is used to indicate the parity of the public key's Y coordinate, each leaf version needs an even byte value and the immediately following odd byte value that are both not yet used in P2WPKH or P2WSH spending. To indicate the annex, only an \"unpaired\" available byte is necessary like <code>0x50</code>. This choice maximizes the available options for future script versions.</ref>, this last element is called ''annex'' ''a''<ref>'''What is the purpose of the annex?''' The annex is a reserved space for future extensions, such as indicating the validation costs of computationally expensive new opcodes in a way that is recognizable without knowing the scriptPubKey of the output being spent. Until the meaning of this field is defined by another softfork, users SHOULD NOT include <code>annex</code> in transactions, or it may lead to PERMANENT FUND LOSS.</ref> and is removed from the witness stack. The annex (or the lack of thereof) is always covered by the signature and contributes to transaction weight, but is otherwise ignored during taproot validation.\n* If there is exactly one element left in the witness stack, key path spending is used:\n** The single witness stack element is interpreted as the signature and must be valid (see the next section) for the public key ''q'' (see the next subsection).\n* If there are at least two witness elements left, script path spending is used:\n** Call the second-to-last stack element ''s'', the script.\n** The last stack element is called the control block ''c'', and must have length ''33 + 32m'', for a value of ''m'' that is an integer between 0 and 128<ref>'''Why is the Merkle path length limited to 128?''' The optimally space-efficient Merkle tree can be constructed based on the probabilities of the scripts in the leaves, using the Huffman algorithm. This algorithm will construct branches with lengths approximately equal to ''log<sub>2</sub>(1/probability)'', but to have branches longer than 128 you would need to have scripts with an execution chance below 1 in ''2<sup>128</sup>''. As that is our security bound, scripts that truly have such a low chance can probably be removed entirely.</ref>, inclusive. Fail if it does not have such a length.\n** Let ''p = c[1:33]'' and let ''P = lift_x(int(p))'' where ''lift_x'' and ''[:]'' are defined as in [[bip-0340.mediawiki#design|BIP340]]. Fail if this point is not on the curve.\n** Let ''v = c[0] & 0xfe'' and call it the ''leaf version''<ref>'''What constraints are there on the leaf version?''' First, the leaf version cannot be odd as ''c[0] & 0xfe'' will always be even, and cannot be ''0x50'' as that would result in ambiguity with the annex. In addition, in order to support some forms of static analysis that rely on being able to identify script spends without access to the output being spent, it is recommended to avoid using any leaf versions that would conflict with a valid first byte of either a valid P2WPKH pubkey or a valid P2WSH script (that is, both ''v'' and ''v | 1'' should be an undefined, invalid or disabled opcode or an opcode that is not valid as the first opcode). The values that comply to this rule are the 32 even values between ''0xc0'' and ''0xfe'' and also ''0x66'', ''0x7e'', ''0x80'', ''0x84'', ''0x96'', ''0x98'', ''0xba'', ''0xbc'', ''0xbe''. Note also that this constraint implies that leaf versions should be shared amongst different witness versions, as knowing the witness version requires access to the output being spent.</ref>.\n** Let ''k<sub>0</sub> = hash<sub>TapLeaf</sub>(v || compact_size(size of s) || s)''; also call it the ''tapleaf hash''.\n** For ''j'' in ''[0,1,...,m-1]'':\n*** Let ''e<sub>j</sub> = c[33+32j:65+32j]''.\n*** Let ''k<sub>j+1</sub> depend on whether ''k<sub>j</sub> < e<sub>j</sub>'' (lexicographically)<ref>'''Why are child elements sorted before hashing in the Merkle tree?''' By doing so, it is not necessary to reveal the left/right directions along with the hashes in revealed Merkle branches. This is possible because we do not actually care about the position of specific scripts in the tree; only that they are actually committed to.</ref>:\n**** If ''k<sub>j</sub> < e<sub>j</sub>'': ''k<sub>j+1</sub> = hash<sub>TapBranch</sub>(k<sub>j</sub> || e<sub>j</sub>)''<ref>'''Why not use a more efficient hash construction for inner Merkle nodes?''' The chosen construction does require two invocations of the SHA256 compression functions, one of which can be avoided in theory (see [[bip-0098.mediawiki|BIP98]]). However, it seems preferable to stick to constructions that can be implemented using standard cryptographic primitives, both for implementation simplicity and analyzability. If necessary, a significant part of the second compression function can be optimized out by [https://github.com/bitcoin/bitcoin/pull/13191 specialization] for 64-byte inputs.</ref>.\n**** If ''k<sub>j</sub> &ge; e<sub>j</sub>'': ''k<sub>j+1</sub> = hash<sub>TapBranch</sub>(e<sub>j</sub> || k<sub>j</sub>)''.\n** Let ''t = hash<sub>TapTweak</sub>(p || k<sub>m</sub>)''.\n** If ''t &ge; 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141'' (order of secp256k1), fail.\n** Let ''Q = P + int(t)G''.\n** If ''q &ne; x(Q)'' or ''c[0] & 1 &ne; y(Q) mod 2'', fail<ref>'''Why is it necessary to reveal a bit in a script path spend and check that it matches the parity of the Y coordinate of ''Q''?''' The parity of the Y coordinate is necessary to lift the X coordinate ''q'' to a unique point. While this is not strictly necessary for verifying the taproot commitment as described above, it is necessary to allow batch verification. Alternatively, ''Q'' could be forced to have an even Y coordinate, but that would require retrying with different internal public keys (or different messages) until ''Q'' has that property. There is no downside to adding the parity bit because otherwise the control block bit would be unused.</ref>.\n** Execute the script, according to the applicable script rules<ref>'''What are the applicable script rules in script path spends?''' [[bip-0342.mediawiki|BIP342]] specifies validity rules that apply for leaf version 0xc0, but future proposals can introduce rules for other leaf versions.</ref>, using the witness stack elements excluding the script ''s'', the control block ''c'', and the annex ''a'' if present, as initial stack. This implies that for the future leaf versions (non-''0xC0'') the execution must succeed.<ref>'''Why we need to success on future leaf version validation''' This is required to enable future leaf versions as soft forks</ref>.\n\n''q'' is referred to as ''taproot output key'' and ''p'' as ''taproot internal key''.\n\n=== Signature validation rules ===\n\nWe first define a reusable common signature message calculation function, followed by the actual signature validation as it's used in key path spending.\n\n==== Common signature message ====\n\nThe function ''SigMsg(hash_type, ext_flag)'' computes the common portion of the message being signed as a byte array. It is implicitly also a function of the spending transaction and the outputs it spends, but these are not listed to keep notation simple.\n\nThe parameter ''hash_type'' is an 8-bit unsigned value. The <code>SIGHASH</code> encodings from the legacy script system are reused, including <code>SIGHASH_ALL</code>, <code>SIGHASH_NONE</code>, <code>SIGHASH_SINGLE</code>, and <code>SIGHASH_ANYONECANPAY</code>. We define a new ''hashtype'' <code>SIGHASH_DEFAULT</code> (value ''0x00'') which results in signing over the whole transaction just as for <code>SIGHASH_ALL</code>. The following restrictions apply, which cause validation failure if violated:\n* Using any undefined ''hash_type'' (not ''0x00'', ''0x01'', ''0x02'', ''0x03'', ''0x81'', ''0x82'', or ''0x83''<ref>'''Why reject unknown ''hash_type'' values?''' By doing so, it is easier to reason about the worst case amount of signature hashing an implementation with adequate caching must perform.</ref>).\n* Using <code>SIGHASH_SINGLE</code> without a \"corresponding output\" (an output with the same index as the input being verified).\n\nThe parameter ''ext_flag'' is an integer in range 0-127, and is used for indicating (in the message) that extensions are appended to the output of ''SigMsg()''<ref>'''What extensions use the ''ext_flag'' mechanism?''' [[bip-0342.mediawiki#common-signature-message-extension|BIP342]] reuses the same common signature message algorithm, but adds BIP342-specific data at the end, which is indicated using ''ext_flag = 1''.</ref>.\n\nIf the parameters take acceptable values, the message is the concatenation of the following data, in order (with byte size of each item listed in parentheses). Numerical values in 2, 4, or 8-byte are encoded in little-endian.\n\n* Control:\n** ''hash_type'' (1).\n* Transaction data:\n** ''nVersion'' (4): the ''nVersion'' of the transaction.\n** ''nLockTime'' (4): the ''nLockTime'' of the transaction.\n** If the ''hash_type & 0x80'' does not equal <code>SIGHASH_ANYONECANPAY</code>:\n*** ''sha_prevouts'' (32): the SHA256 of the serialization of all input outpoints.\n*** ''sha_amounts'' (32): the SHA256 of the serialization of all input amounts.\n*** ''sha_scriptpubkeys'' (32): the SHA256 of all spent outputs' ''scriptPubKeys'', serialized as script inside <code>CTxOut</code>.\n*** ''sha_sequences'' (32): the SHA256 of the serialization of all input ''nSequence''.\n** If ''hash_type & 3'' does not equal <code>SIGHASH_NONE</code> or <code>SIGHASH_SINGLE</code>:\n*** ''sha_outputs'' (32): the SHA256 of the serialization of all outputs in <code>CTxOut</code> format.\n* Data about this input:\n** ''spend_type'' (1): equal to ''(ext_flag * 2) + annex_present'', where ''annex_present'' is 0 if no annex is present, or 1 otherwise (the original witness stack has two or more witness elements, and the first byte of the last element is ''0x50'')\n** If ''hash_type & 0x80'' equals <code>SIGHASH_ANYONECANPAY</code>:\n*** ''outpoint'' (36): the <code>COutPoint</code> of this input (32-byte hash + 4-byte little-endian).\n*** ''amount'' (8): value of the previous output spent by this input.\n*** ''scriptPubKey'' (35): ''scriptPubKey'' of the previous output spent by this input, serialized as script inside <code>CTxOut</code>. Its size is always 35 bytes.\n*** ''nSequence'' (4): ''nSequence'' of this input.\n** If ''hash_type & 0x80'' does not equal <code>SIGHASH_ANYONECANPAY</code>:\n*** ''input_index'' (4): index of this input in the transaction input vector. Index of the first input is 0.\n** If an annex is present (the lowest bit of ''spend_type'' is set):\n*** ''sha_annex'' (32): the SHA256 of ''(compact_size(size of annex) || annex)'', where ''annex'' includes the mandatory ''0x50'' prefix.\n* Data about this output:\n** If ''hash_type & 3'' equals <code>SIGHASH_SINGLE</code>:\n*** ''sha_single_output'' (32): the SHA256 of the corresponding output in <code>CTxOut</code> format.\n\nThe total length of ''SigMsg()'' is at most ''206'' bytes<ref>'''What is the output length of ''SigMsg()''?''' The total length of ''SigMsg()'' can be computed using the following formula: ''174 - is_anyonecanpay * 49 - is_none * 32 + has_annex * 32''.</ref>. Note that this does not include the size of sub-hashes such as ''sha_prevouts'', which may be cached across signatures of the same transaction.\n\nIn summary, the semantics of the [[bip-0143.mediawiki|BIP143]] sighash types remain unchanged, except the following:\n# The way and order of serialization is changed.<ref>'''Why is the serialization in the signature message changed?''' Hashes that go into the signature message and the message itself are now computed with a single SHA256 invocation instead of double SHA256. There is no expected security improvement by doubling SHA256 because this only protects against length-extension attacks against SHA256 which are not a concern for signature messages because there is no secret data. Therefore doubling SHA256 is a waste of resources. The message computation now follows a logical order with transaction level data first, then input data and output data. This allows to efficiently cache the transaction part of the message across different inputs using the SHA256 midstate. Additionally, sub-hashes can be skipped when calculating the message (for example `sha_prevouts` if <code>SIGHASH_ANYONECANPAY</code> is set) instead of setting them to zero and then hashing them as in BIP143. Despite that, collisions are made impossible by committing to the length of the data (implicit in ''hash_type'' and ''spend_type'') before the variable length data.</ref>\n# The signature message commits to the ''scriptPubKey'' of the spent output and if the <code>SIGHASH_ANYONECANPAY</code> flag is not set, the message commits to the ''scriptPubKey''s of ''all'' outputs spent by the transaction. <ref>'''Why does the signature message commit to the ''scriptPubKey''?''' This prevents lying to offline signing devices about output being spent, even when the actually executed script (''scriptCode'' in BIP143) is correct. This means it's possible to compactly prove to a hardware wallet what (unused) execution paths existed. Moreover, committing to all spent ''scriptPubKey''s helps offline signing devices to determine the subset that belong to its own wallet. This is useful in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017801.html automated coinjoins].</ref>.\n# If the <code>SIGHASH_ANYONECANPAY</code> flag is not set, the message commits to the amounts of ''all'' transaction inputs.<ref>'''Why does the signature message commit to the amounts of all transaction inputs?''' This eliminates the possibility to lie to offline signing devices about the fee of a transaction.</ref>\n# The signature message commits to all input ''nSequence'' if <code>SIGHASH_NONE</code> or <code>SIGHASH_SINGLE</code> are set (unless <code>SIGHASH_ANYONECANPAY</code> is set as well).<ref>'''Why does the signature message commit to all input ''nSequence'' if <code>SIGHASH_SINGLE</code> or <code>SIGHASH_NONE</code> are set?''' Because setting them already makes the message commit to the <code>prevouts</code> part of all transaction inputs, it is not useful to treat the ''nSequence'' any different. Moreover, this change makes ''nSequence'' consistent with the view that <code>SIGHASH_SINGLE</code> and <code>SIGHASH_NONE</code> only modify the signature message with respect to transaction outputs and not inputs.</ref>\n# The signature message includes commitments to the taproot-specific data ''spend_type'' and ''annex'' (if present).\n\n==== Taproot key path spending signature validation ====\n\nA Taproot signature is a 64-byte Schnorr signature, as defined in [[bip-0340.mediawiki|BIP340]], with the sighash byte appended in the usual Bitcoin fashion. This sighash byte is optional. If omitted, the resulting signatures are 64 bytes, and a SIGHASH_DEFAULT mode is implied.\n\nTo validate a signature ''sig'' with public key ''q'':\n* If the ''sig'' is 64 bytes long, return ''Verify(q, hash<sub>TapSighash</sub>(0x00 || SigMsg(0x00, 0)), sig)''<ref>'''Why is the input to ''hash<sub>TapSighash</sub>'' prefixed with 0x00?''' This prefix is called the sighash epoch, and allows reusing the ''hash<sub>TapSighash</sub>'' tagged hash in future signature algorithms that make invasive changes to how hashing is performed (as opposed to the ''ext_flag'' mechanism that is used for incremental extensions). An alternative is having them use a different tag, but supporting a growing number of tags may become undesirable.</ref>, where ''Verify'' is defined in [[bip-0340.mediawiki#design|BIP340]].\n* If the ''sig'' is 65 bytes long, return ''sig[64] &ne; 0x00<ref>'''Why can the <code>hash_type</code> not be <code>0x00</code> in 65-byte signatures?''' Permitting that would enable malleating (by third parties, including miners) 64-byte signatures into 65-byte ones, resulting in a different `wtxid` and a different fee rate than the creator intended.</ref> and Verify(q, hash<sub>TapSighash</sub>(0x00 || SigMsg(sig[64], 0)), sig[0:64])''.\n* Otherwise, fail<ref>'''Why permit two signature lengths?''' By making the most common type of <code>hash_type</code> implicit, a byte can often be saved.</ref>.\n\n== Constructing and spending Taproot outputs ==\n\nThis section discusses how to construct and spend Taproot outputs. It only affects wallet software that chooses to implement receiving and spending,\nand is not consensus critical in any way.\n\nConceptually, every Taproot output corresponds to a combination of a single public key condition (the internal key), and zero or more general conditions encoded in scripts organized in a tree.\nSatisfying any of these conditions is sufficient to spend the output.\n\n'''Initial steps''' The first step is determining what the internal key and the organization of the rest of the scripts should be. The specifics are likely application dependent, but here are some general guidelines:\n* When deciding between scripts with conditionals (<code>OP_IF</code> etc.) and splitting them up into multiple scripts (each corresponding to one execution path through the original script), it is generally preferable to pick the latter.\n* When a single condition requires signatures with multiple keys, key aggregation techniques like MuSig can be used to combine them into a single key. The details are out of scope for this document, but note that this may complicate the signing procedure.\n* If one or more of the spending conditions consist of just a single key (after aggregation), the most likely one should be made the internal key. If no such condition exists, it may be worthwhile adding one that consists of an aggregation of all keys participating in all scripts combined; effectively adding an \"everyone agrees\" branch. If that is inacceptable, pick as internal key a \"Nothing Up My Sleeve\" (NUMS) point, i.e., a point with unknown discrete logarithm. One example of such a point is ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is [https://github.com/ElementsProject/secp256k1-zkp/blob/11af7015de624b010424273be3d91f117f172c82/src/modules/rangeproof/main_impl.h#L16 constructed] by taking the hash of the standard uncompressed encoding of the [https://www.secg.org/sec2-v2.pdf secp256k1] base point ''G'' as X coordinate. In order to avoid leaking the information that key path spending is not possible it is recommended to pick a fresh integer ''r'' in the range ''0...n-1'' uniformly at random and use ''H + rG'' as internal key. It is possible to prove that this internal key does not have a known discrete logarithm with respect to ''G'' by revealing ''r'' to a verifier who can then reconstruct how the internal key was created.\n* If the spending conditions do not require a script path, the output key should commit to an unspendable script path instead of having no script path. This can be achieved by computing the output key point as ''Q = P + int(hash<sub>TapTweak</sub>(bytes(P)))G''. <ref>'''Why should the output key always have a taproot commitment, even if there is no script path?'''\nIf the taproot output key is an aggregate of keys, there is the possibility for a malicious party to add a script path without being noticed by the other parties.\nThis allows to bypass the multiparty policy and to steal the coin.\nMuSig key aggregation does not have this issue because it already causes the internal key to be randomized.\n\nThe attack works as follows: Assume Alice and Mallory want to aggregate their keys into a taproot output key without a script path.\nIn order to prevent key cancellation and related attacks they use [https://eprint.iacr.org/2018/483.pdf MSDL-pop] instead of MuSig.\nThe MSDL-pop protocol requires all parties to provide a proof of possession of their corresponding secret key and the aggregated key is just the sum of the individual keys.\nAfter Mallory receives Alice's key ''A'', Mallory creates ''M = M<sub>0</sub> + int(t)G'' where ''M<sub>0</sub>'' is Mallory's original key and ''t'' allows a script path spend with internal key ''P = A + M<sub>0</sub>'' and a script that only contains Mallory's key.\nMallory sends a proof of possession of ''M'' to Alice and both parties compute output key ''Q = A + M = P + int(t)G''.\nAlice will not be able to notice the script path, but Mallory can unilaterally spend any coin with output key ''Q''.\n</ref>\n* The remaining scripts should be organized into the leaves of a binary tree. This can be a balanced tree if each of the conditions these scripts correspond to are equally likely. If probabilities for each condition are known, consider constructing the tree as a Huffman tree.\n\n'''Computing the output script''' Once the spending conditions are split into an internal key <code>internal_pubkey</code> and a binary tree whose leaves are (leaf_version, script) tuples, the output script can be computed using the Python3 algorithms below. These algorithms take advantage of helper functions from the [[bip-0340/reference.py|BIP340 reference code]] for integer conversion, point multiplication, and tagged hashes.\n\nFirst, we define <code>taproot_tweak_pubkey</code> for 32-byte [[bip-0340.mediawiki|BIP340]] public key arrays.\nThe function returns a bit indicating the tweaked public key's Y coordinate as well as the public key byte array.\nThe parity bit will be required for spending the output with a script path.\nIn order to allow spending with the key path, we define <code>taproot_tweak_seckey</code> to compute the secret key for a tweaked public key.\nFor any byte string <code>h</code> it holds that <code>taproot_tweak_pubkey(pubkey_gen(seckey), h)[1] == pubkey_gen(taproot_tweak_seckey(seckey, h))</code>.\n\nNote that because tweaks are applied to 32-byte public keys, `taproot_tweak_seckey` may need to negate the secret key before applying the tweak.\n\n<source lang=\"python\">\ndef taproot_tweak_pubkey(pubkey, h):\n    t = int_from_bytes(tagged_hash(\"TapTweak\", pubkey + h))\n    if t >= SECP256K1_ORDER:\n        raise ValueError\n    P = lift_x(int_from_bytes(pubkey))\n    if P is None:\n        raise ValueError\n    Q = point_add(P, point_mul(G, t))\n    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n\ndef taproot_tweak_seckey(seckey0, h):\n    seckey0 = int_from_bytes(seckey0)\n    P = point_mul(G, seckey0)\n    seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n    t = int_from_bytes(tagged_hash(\"TapTweak\", bytes_from_int(x(P)) + h))\n    if t >= SECP256K1_ORDER:\n        raise ValueError\n    return bytes_from_int((seckey + t) % SECP256K1_ORDER)\n</source>\n\nThe following function, <code>taproot_output_script</code>, returns a byte array with the scriptPubKey (see [[bip-0141.mediawiki|BIP141]]).\n<code>ser_script</code> refers to a function that prefixes its input with a CompactSize-encoded length.\n\n<source lang=\"python\">\ndef taproot_tree_helper(script_tree):\n    if isinstance(script_tree, tuple):\n        leaf_version, script = script_tree\n        h = tagged_hash(\"TapLeaf\", bytes([leaf_version]) + ser_script(script))\n        return ([((leaf_version, script), bytes())], h)\n    left, left_h = taproot_tree_helper(script_tree[0])\n    right, right_h = taproot_tree_helper(script_tree[1])\n    ret = [(l, c + right_h) for l, c in left] + [(l, c + left_h) for l, c in right]\n    if right_h < left_h:\n        left_h, right_h = right_h, left_h\n    return (ret, tagged_hash(\"TapBranch\", left_h + right_h))\n\ndef taproot_output_script(internal_pubkey, script_tree):\n    \"\"\"Given a internal public key and a tree of scripts, compute the output script.\n    script_tree is either:\n     - a (leaf_version, script) tuple (leaf_version is 0xc0 for [[bip-0342.mediawiki|BIP342]] scripts)\n     - a list of two elements, each with the same structure as script_tree itself\n     - None\n    \"\"\"\n    if script_tree is None:\n        h = bytes()\n    else:\n        _, h = taproot_tree_helper(script_tree)\n    _, output_pubkey = taproot_tweak_pubkey(internal_pubkey, h)\n    return bytes([0x51, 0x20]) + output_pubkey\n</source>\n\n[[File:bip-0341/tree.png|frame|This diagram shows the hashing structure to obtain the tweak from an internal key ''P'' and a Merkle tree consisting of 5 script leaves. ''A'', ''B'', ''C'' and ''E'' are ''TapLeaf'' hashes similar to ''D'' and ''AB'' is a ''TapBranch'' hash. Note that when ''CDE'' is computed ''E'' is hashed first because ''E'' is less than ''CD''.]]\n\nTo spend this output using script ''D'', the control block would contain the following data in this order:\n\n     <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\n\nThe TapTweak would then be computed as described [[bip-0341.mediawiki#script-validation-rules|above]] like so:\n\n<source>\nD = tagged_hash(\"TapLeaf\", bytes([leaf_version]) + ser_script(script))\nCD = tagged_hash(\"TapBranch\", C + D)\nCDE = tagged_hash(\"TapBranch\", E + CD)\nABCDE = tagged_hash(\"TapBranch\", AB + CDE)\nTapTweak = tagged_hash(\"TapTweak\", p + ABCDE)\n</source>\n\n'''Spending using the key path''' A Taproot output can be spent with the secret key corresponding to the <code>internal_pubkey</code>. To do so, a witness stack consists of a single element: a [[bip-0340.mediawiki|BIP340]] signature on the signature hash as defined above, with the secret key tweaked by the same <code>h</code> as in the above snippet. See the code below:\n\n<source lang=\"python\">\ndef taproot_sign_key(script_tree, internal_seckey, hash_type, bip340_aux_rand):\n    if script_tree is None:\n        h = bytes()\n    else:\n        _, h = taproot_tree_helper(script_tree)\n    output_seckey = taproot_tweak_seckey(internal_seckey, h)\n    sig = schnorr_sign(sighash(hash_type), output_seckey, bip340_aux_rand)\n    if hash_type != 0:\n        sig += bytes([hash_type])\n    return [sig]\n</source>\n\nThis function returns the witness stack necessary and a <code>sighash</code> function to compute the signature hash as defined above (for simplicity, the snippet above ignores passing information like the transaction, the input position, ... to the sighashing code).\n\n'''Spending using one of the scripts''' A Taproot output can be spent by satisfying any of the scripts used in its construction. To do so, a witness stack consisting of the script's inputs, plus the script itself and the control block are necessary. See the code below:\n\n<source lang=\"python\">\ndef taproot_sign_script(internal_pubkey, script_tree, script_num, inputs):\n    info, h = taproot_tree_helper(script_tree)\n    (leaf_version, script), path = info[script_num]\n    output_pubkey_y_parity, _ = taproot_tweak_pubkey(internal_pubkey, h)\n    pubkey_data = bytes([output_pubkey_y_parity + leaf_version]) + internal_pubkey\n    return inputs + [script, pubkey_data + path]\n</source>\n\n== Security ==\n\nTaproot improves the privacy of Bitcoin because instead of revealing all possible conditions for spending an output, only the satisfied spending condition has to be published.\nIdeally, outputs are spent using the key path which prevents observers from learning the spending conditions of a coin.\nA key path spend could be a \"normal\" payment from a single- or multi-signature wallet or the cooperative settlement of hidden multiparty contract.\n\nA script path spend leaks that there is a script path and that the key path was not applicable - for example because the involved parties failed to reach agreement.\nMoreover, the depth of a script in the Merkle root leaks information including the minimum depth of the tree, which suggests specific wallet software that created the output and helps clustering.\nTherefore, the privacy of script spends can be improved by deviating from the optimal tree determined by the probability distribution over the leaves.\n\nJust like other existing output types, taproot outputs should never reuse keys, for privacy reasons.\nThis does not only apply to the particular leaf that was used to spend an output but to all leaves committed to in the output.\nIf leaves were reused, it could happen that spending a different output would reuse the same Merkle branches in the Merkle proof.\nUsing fresh keys implies that taproot output construction does not need to take special measures to randomizing leaf positions because they are already randomized due to the branch-sorting Merkle tree construction used in taproot.\nThis does not avoid leaking information through the leaf depth and therefore only applies to balanced (sub-) trees.\nIn addition, every leaf should have a set of keys distinct from every other leaf.\nThe reason for this is to increase leaf entropy and prevent an observer from learning an undisclosed script using brute-force search.\n\n== Test vectors ==\n\nTest vectors for wallet operation (scriptPubKey computation, key path spending, control block construction) can be found [[bip-0341/wallet-test-vectors.json|here]].\nIt consists of two sets of vectors.\n* The first \"scriptPubKey\" tests concern computing the scriptPubKey and (mainnet) BIP350 address given an internal public key, and a script tree. The script tree is encoded as <code>null</code> to represent no scripts, a JSON object to represent a leaf node, or a 2-element array to represent an inner node. The control blocks needed for script path spending are also provided for each of the script leaves.\n* The second \"keyPathSpending\" tests consists of a list of test cases, each of which provides an unsigned transaction and the UTXOs it spends. For each of its BIP341 inputs, the internal private key and the Merkle root it was derived from is given, as well as the expected witness to spend it. All signatures are created with an all-zero (0x0000...0000) BIP340 auxiliary randomness array.\n* In all cases, hexadecimal values represent byte arrays, not numbers. In particular, that means that provided hash values have the hex digits corresponding to the first bytes first. This differs from the convention used for txids and block hashes, where the hex strings represent numbers, resulting in a reversed order.\n\nValidation test vectors used in the [https://github.com/bitcoin/bitcoin/blob/3820090bd619ac85ab35eff376c03136fe4a9f04/src/test/script_tests.cpp#L1718 Bitcoin Core unit test framework] can be found [https://github.com/bitcoin-core/qa-assets/blob/main/unit_test_data/script_assets_test.json?raw=true here].\n\n== Rationale ==\n\n<references />\n\n== Deployment ==\n\nThis BIP is deployed concurrently with [[bip-0342.mediawiki|BIP342]].\n\nFor Bitcoin signet, these BIPs are always active.\n\nFor Bitcoin mainnet and testnet3, these BIPs are deployed by \"version bits\" with the name \"taproot\" and bit 2, using [[bip-0009.mediawiki|BIP9]] modified to use a lower threshold, with an additional ''min_activation_height'' parameter and replacing the state transition logic for the DEFINED, STARTED and LOCKED_IN states as follows:\n\n    case DEFINED:\n        if (GetMedianTimePast(block.parent) >= starttime) {\n            return STARTED;\n        }\n        return DEFINED;\n\n    case STARTED:\n        int count = 0;\n        walk = block;\n        for (i = 0; i < 2016; i++) {\n            walk = walk.parent;\n            if ((walk.nVersion & 0xE0000000) == 0x20000000 && ((walk.nVersion >> bit) & 1) == 1) {\n                count++;\n            }\n        }\n        if (count >= threshold) {\n            return LOCKED_IN;\n        } else if (GetMedianTimePast(block.parent) >= timeout) {\n            return FAILED;\n        }\n        return STARTED;\n\n    case LOCKED_IN:\n        if (block.nHeight < min_activation_height) {\n            return LOCKED_IN;\n        }\n        return ACTIVE;\n\nFor Bitcoin mainnet, the starttime is epoch timestamp 1619222400 (midnight 24 April 2021 UTC), timeout is epoch timestamp 1628640000 (midnight 11 August 2021 UTC), the threshold is 1815 blocks (90%) instead of 1916 blocks (95%), and the min_activation_height is block 709632.\nThe deployment did activate at height 709632 on Bitcoin mainnet.\n\nFor Bitcoin testnet3, the starttime is epoch timestamp 1619222400 (midnight 24 April 2021 UTC), timeout is epoch timestamp 1628640000 (midnight 11 August 2021 UTC), the threshold is 1512 blocks (75%), and the min_activation_height is block 0.\nThe deployment did activate at height 2011968 on Bitcoin testnet3.\n\n== Backwards compatibility ==\nAs a soft fork, older software will continue to operate without modification.\nNon-upgraded nodes, however, will consider all SegWit version 1 witness programs as anyone-can-spend scripts.\nThey are strongly encouraged to upgrade in order to fully validate the new programs.\n\nNon-upgraded wallets can receive and send bitcoin from non-upgraded and upgraded wallets using SegWit version 0 programs, traditional pay-to-pubkey-hash, etc.\nDepending on the implementation non-upgraded wallets may be able to send to Segwit version 1 programs if they support sending to [[bip-0350.mediawiki|BIP350]] Bech32m addresses.\n\n== Acknowledgements ==\n\nThis document is the result of discussions around script and signature improvements with many people, and had direct contributions from Greg Maxwell and others. It further builds on top of earlier published proposals such as Taproot by Greg Maxwell, and Merkle branch constructions by Russell O'Connor, Johnson Lau, and Mark Friedenbach.\n\nThe authors wish the thank Arik Sosman for suggesting to sort Merkle node children before hashes, removing the need to transfer the position in the tree, as well as all those who provided valuable feedback and reviews, including the participants of the [https://github.com/ajtowns/taproot-review structured reviews].\n", "content_length": 44161}
{"bip_number": 340, "filename": "bip-0340.mediawiki", "content": "<pre>\n  BIP: 340\n  Title: Schnorr Signatures for secp256k1\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Jonas Nick <jonasd.nick@gmail.com>\n          Tim Ruffing <crypto@timruffing.de>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0340\n  Status: Final\n  Type: Standards Track\n  Created: 2020-01-19\n  License: BSD-2-Clause\n  License-Code: BSD-2-Clause\n                MIT\n                CC0-1.0\n  Post-History: 2018-07-06: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html [bitcoin-dev] Schnorr signatures BIP\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\n\nThis document proposes a standard for 64-byte Schnorr signatures over the elliptic curve ''secp256k1''.\n\n=== Copyright ===\n\nThis document is licensed under the 2-clause BSD license.\n\n=== Motivation ===\n\nBitcoin has traditionally used\n[https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm ECDSA] signatures over the [https://www.secg.org/sec2-v2.pdf secp256k1 curve] with [https://en.wikipedia.org/wiki/SHA-2 SHA256] hashes for authenticating\ntransactions. These are [https://www.secg.org/sec1-v2.pdf standardized], but have a number of downsides\ncompared to [http://publikationen.ub.uni-frankfurt.de/opus4/files/4280/schnorr.pdf Schnorr signatures] over the same curve:\n\n* '''Provable security''': Schnorr signatures are provably secure. In more detail, they are ''strongly unforgeable under chosen message attack (SUF-CMA)''<ref>Informally, this means that without knowledge of the secret key but given valid signatures of arbitrary messages, it is not possible to come up with further valid signatures.</ref> [https://www.di.ens.fr/~pointche/Documents/Papers/2000_joc.pdf in the random oracle model assuming the hardness of the elliptic curve discrete logarithm problem (ECDLP)] and [http://www.neven.org/papers/schnorr.pdf in the generic group model assuming variants of preimage and second preimage resistance of the used hash function]<ref>A detailed security proof in the random oracle model, which essentially restates [https://www.di.ens.fr/~pointche/Documents/Papers/2000_joc.pdf the original security proof by Pointcheval and Stern] more explicitly, can be found in [https://eprint.iacr.org/2016/191 a paper by Kiltz, Masny and Pan]. All these security proofs assume a variant of Schnorr signatures that use ''(e,s)'' instead of ''(R,s)'' (see Design above). Since we use a unique encoding of ''R'', there is an efficiently computable bijection that maps ''(R,s)'' to ''(e,s)'', which allows to convert a successful SUF-CMA attacker for the ''(e,s)'' variant to a successful SUF-CMA attacker for the ''(R,s)'' variant (and vice-versa). Furthermore, the proofs consider a variant of Schnorr signatures without key prefixing (see Design above), but it can be verified that the proofs are also correct for the variant with key prefixing. As a result, all the aforementioned security proofs apply to the variant of Schnorr signatures proposed in this document.</ref>. In contrast, the [https://nbn-resolving.de/urn:nbn:de:hbz:294-60803 best known results for the provable security of ECDSA] rely on stronger assumptions.\n* '''Non-malleability''': The SUF-CMA security of Schnorr signatures implies that they are non-malleable. On the other hand, ECDSA signatures are inherently malleable<ref>If ''(r,s)'' is a valid ECDSA signature for a given message and key, then ''(r,n-s)'' is also valid for the same message and key. If ECDSA is restricted to only permit one of the two variants (as Bitcoin does through a policy rule on the network), it can be [https://nbn-resolving.de/urn:nbn:de:hbz:294-60803 proven] non-malleable under stronger than usual assumptions.</ref>; a third party without access to the secret key can alter an existing valid signature for a given public key and message into another signature that is valid for the same key and message. This issue is discussed in [[bip-0062.mediawiki|BIP62]] and [[bip-0146.mediawiki|BIP146]].\n* '''Linearity''': Schnorr signatures provide a simple and efficient method that enables multiple collaborating parties to produce a signature that is valid for the sum of their public keys. This is the building block for various higher-level constructions that improve efficiency and privacy, such as multisignatures and others (see Applications below).\n\nFor all these advantages, there are virtually no disadvantages, apart\nfrom not being standardized. This document seeks to change that. As we\npropose a new standard, a number of improvements not specific to Schnorr signatures can be\nmade:\n\n* '''Signature encoding''': Instead of using [https://en.wikipedia.org/wiki/X.690#DER_encoding DER]-encoding for signatures (which are variable size, and up to 72 bytes), we can use a simple fixed 64-byte format.\n* '''Public key encoding''': Instead of using [https://www.secg.org/sec1-v2.pdf ''compressed''] 33-byte encodings of elliptic curve points which are common in Bitcoin today, public keys in this proposal are encoded as 32 bytes.\n* '''Batch verification''': The specific formulation of ECDSA signatures that is standardized cannot be verified more efficiently in batch compared to individually, unless additional witness data is added. Changing the signature scheme offers an opportunity to address this.\n* '''Completely specified''': To be safe for usage in consensus systems, the verification algorithm must be completely specified at the byte level. This guarantees that nobody can construct a signature that is valid to some verifiers but not all. This is traditionally not a requirement for digital signature schemes, and the lack of exact specification for the DER parsing of ECDSA signatures has caused problems for Bitcoin [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-July/009697.html in the past], needing [[bip-0066.mediawiki|BIP66]] to address it. In this document we aim to meet this property by design. For batch verification, which is inherently non-deterministic as the verifier can choose their batches, this property implies that the outcome of verification may only differ from individual verifications with negligible probability, even to an attacker who intentionally tries to make batch- and non-batch verification differ.\n\nBy reusing the same curve and hash function as Bitcoin uses for ECDSA, we are able to retain existing mechanisms for choosing secret and public keys, and we avoid introducing new assumptions about the security of elliptic curves and hash functions.\n\n== Description ==\n\nWe first build up the algebraic formulation of the signature scheme by\ngoing through the design choices. Afterwards, we specify the exact\nencodings and operations.\n\n=== Design ===\n\n'''Schnorr signature variant''' Elliptic Curve Schnorr signatures for message ''m'' and public key ''P'' generally involve a point ''R'', integers ''e'' and ''s'' picked by the signer, and the base point ''G'' which satisfy ''e = hash(R || m)'' and ''s\u22c5G = R + e\u22c5P''. Two formulations exist, depending on whether the signer reveals ''e'' or ''R'':\n# Signatures are pairs ''(e, s)'' that satisfy ''e = hash(s\u22c5G - e\u22c5P || m)''. This variant avoids minor complexity introduced by the encoding of the point ''R'' in the signature (see paragraphs \"Encoding R and public key point P\" and \"Implicit Y coordinates\" further below in this subsection). Moreover, revealing ''e'' instead of ''R'' allows for potentially shorter signatures: Whereas an encoding of ''R'' inherently needs about 32 bytes, the hash ''e'' can be tuned to be shorter than 32 bytes, and [http://www.neven.org/papers/schnorr.pdf a short hash of only 16 bytes suffices to provide SUF-CMA security at the target security level of 128 bits]. However, a major drawback of this optimization is that finding collisions in a short hash function is easy. This complicates the implementation of secure signing protocols in scenarios in which a group of mutually distrusting signers work together to produce a single joint signature (see Applications below). In these scenarios, which are not captured by the SUF-CMA model due its assumption of a single honest signer, a promising attack strategy for malicious co-signers is to find a collision in the hash function in order to obtain a valid signature on a message that an honest co-signer did not intend to sign.\n# Signatures are pairs ''(R, s)'' that satisfy ''s\u22c5G = R + hash(R || m)\u22c5P''. This supports batch verification, as there are no elliptic curve operations inside the hashes. Batch verification enables significant speedups.<ref>The speedup that results from batch verification can be demonstrated with the cryptography library [https://github.com/jonasnick/secp256k1/blob/schnorrsig-batch-verify/doc/speedup-batch.md libsecp256k1].</ref>\n\nSince we would like to avoid the fragility that comes with short hashes, the ''e'' variant does not provide significant advantages. We choose the ''R''-option, which supports batch verification.\n\n'''Key prefixing''' Using the verification rule above directly makes Schnorr signatures vulnerable to \"related-key attacks\" in which a third party can convert a signature ''(R, s)'' for public key ''P'' into a signature ''(R, s + a\u22c5hash(R || m))'' for public key ''P + a\u22c5G'' and the same message ''m'', for any given additive tweak ''a'' to the signing key. This would render signatures insecure when keys are generated using [[bip-0032.mediawiki#public-parent-key--public-child-key|BIP32's unhardened derivation]] and other methods that rely on additive tweaks to existing keys such as Taproot.\n\nTo protect against these attacks, we choose ''key prefixed''<ref>A limitation of committing to the public key (rather than to a short hash of it, or not at all) is that it removes the ability for public key recovery or verifying signatures against a short public key hash. These constructions are generally incompatible with batch verification.</ref> Schnorr signatures which means that the public key is prefixed to the message in the challenge hash input. This changes the equation to ''s\u22c5G = R + hash(R || P || m)\u22c5P''. [https://eprint.iacr.org/2015/1135.pdf It can be shown] that key prefixing protects against related-key attacks with additive tweaks. In general, key prefixing increases robustness in multi-user settings, e.g., it seems to be a requirement for proving multiparty signing protocols (such as MuSig, MuSig2, and FROST) secure (see Applications below).\n\nWe note that key prefixing is not strictly necessary for transaction signatures as used in Bitcoin currently, because signed transactions indirectly commit to the public keys already, i.e., ''m'' contains a commitment to ''pk''. However, this indirect commitment should not be relied upon because it may change with proposals such as SIGHASH_NOINPUT ([[bip-0118.mediawiki|BIP118]]), and would render the signature scheme unsuitable for other purposes than signing transactions, e.g., [https://bitcoin.org/en/developer-reference#signmessage signing ordinary messages].\n\n'''Encoding R and public key point P''' There exist several possibilities for encoding elliptic curve points:\n# Encoding the full X and Y coordinates of ''P'' and ''R'', resulting in a 64-byte public key and a 96-byte signature.\n# Encoding the full X coordinate and one bit of the Y coordinate to determine one of the two possible Y coordinates. This would result in 33-byte public keys and 65-byte signatures.\n# Encoding only the X coordinate, resulting in 32-byte public keys and 64-byte signatures.\n\nUsing the first option would be slightly more efficient for verification (around 10%), but we prioritize compactness, and therefore choose option 3.\n\n'''Implicit Y coordinates''' In order to support efficient verification and batch verification, the Y coordinate of ''P'' and of ''R'' cannot be ambiguous (every valid X coordinate has two possible Y coordinates). We have a choice between several options for symmetry breaking:\n# Implicitly choosing the Y coordinate that is in the lower half.\n# Implicitly choosing the Y coordinate that is even<ref>Since ''p'' is odd, negation modulo ''p'' will map even numbers to odd numbers and the other way around. This means that for a valid X coordinate, one of the corresponding Y coordinates will be even, and the other will be odd.</ref>.\n# Implicitly choosing the Y coordinate that is a quadratic residue (i.e. has a square root modulo ''p'').\n\nThe second option offers the greatest compatibility with existing key generation systems, where the standard 33-byte compressed public key format consists of a byte indicating the oddness of the Y coordinate, plus the full X coordinate. To avoid gratuitous incompatibilities, we pick that option for ''P'', and thus our X-only public keys become equivalent to a compressed public key that is the X-only key prefixed by the byte 0x02. For consistency, the same is done for ''R''<ref>An earlier version of this draft used the third option instead, based on a belief that this would in general trade signing efficiency for verification efficiency. When using Jacobian coordinates, a common optimization in ECC implementations, it is possible to determine if a Y coordinate is a quadratic residue by computing the Legendre symbol, without converting to affine coordinates first (which needs a modular inversion). As modular inverses and Legendre symbols have similar [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-August/018081.html performance] in practice, this trade-off is not worth it.</ref>.\n\nDespite halving the size of the set of valid public keys, implicit Y coordinates are not a reduction in security. Informally, if a fast algorithm existed to compute the discrete logarithm of an X-only public key, then it could also be used to compute the discrete logarithm of a full public key: apply it to the X coordinate, and then optionally negate the result. This shows that breaking an X-only public key can be at most a small constant term faster than breaking a full one.<ref>This can be formalized by a simple reduction that reduces an attack on Schnorr signatures with implicit Y coordinates to an attack to Schnorr signatures with explicit Y coordinates. The reduction works by reencoding public keys and negating the result of the hash function, which is modeled as random oracle, whenever the challenge public key has an explicit Y coordinate that is odd. A proof sketch can be found [https://medium.com/blockstream/reducing-bitcoin-transaction-sizes-with-x-only-pubkeys-f86476af05d7 here].</ref>.\n\n'''Tagged Hashes''' Cryptographic hash functions are used for multiple purposes in the specification below and in Bitcoin in general. To make sure hashes used in one context can't be reinterpreted in another one, hash functions can be tweaked with a context-dependent tag name, in such a way that collisions across contexts can be assumed to be infeasible. Such collisions obviously can not be ruled out completely, but only for schemes using tagging with a unique name. As for other schemes collisions are at least less likely with tagging than without.\n\nFor example, without tagged hashing a BIP340 signature could also be valid for a signature scheme where the only difference is that the arguments to the hash function are reordered. Worse, if the BIP340 nonce derivation function was copied or independently created, then the nonce could be accidentally reused in the other scheme leaking the secret key.\n\nThis proposal suggests to include the tag by prefixing the hashed data with ''SHA256(tag) || SHA256(tag)''. Because this is a 64-byte long context-specific constant and the ''SHA256'' block size is also 64 bytes, optimized implementations are possible (identical to SHA256 itself, but with a modified initial state). Using SHA256 of the tag name itself is reasonably simple and efficient for implementations that don't choose to use the optimization. In general, tags can be arbitrary byte arrays, but are suggested to be textual descriptions in UTF-8 encoding.\n\n'''Final scheme''' As a result, our final scheme ends up using public key ''pk'' which is the X coordinate of a point ''P'' on the curve whose Y coordinate is even and signatures ''(r,s)'' where ''r'' is the X coordinate of a point ''R'' whose Y coordinate is even. The signature satisfies ''s\u22c5G = R + tagged_hash(r || pk || m)\u22c5P''.\n\n=== Specification ===\n\nThe following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme<ref>Among other pitfalls, using the specification with a curve whose order is not close to the size of the range of the nonce derivation function is insecure.</ref>.\n* Lowercase variables represent integers or byte arrays.\n** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (\u22c5) of an integer and a point] refers to the repeated application of the group operation.\n* Functions and operations:\n** ''||'' refers to byte array concatenation.\n** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n** The function ''bytes(x)'', where ''x'' is an integer, returns the 32-byte encoding of ''x'', most significant byte first.\n** The function ''bytes(P)'', where ''P'' is a point, returns ''bytes(x(P))''.\n** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 = 0''.\n** The function ''lift_x(x)'', where ''x'' is a 256-bit unsigned integer, returns the point ''P'' for which ''x(P) = x''<ref>\n    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n*** Fail if ''x &ge; p''.\n*** Let ''c = x<sup>3</sup> + 7 mod p''.\n*** Let ''y = c<sup>(p+1)/4</sup> mod p''.\n*** Fail if ''c &ne; y<sup>2</sup> mod p''.\n*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y'' if ''y mod 2 = 0'' or ''y(P) = p-y'' otherwise.\n** The function ''hash<sub>name</sub>(x)'' where ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)'', where ''tag'' is the UTF-8 encoding of ''name''.\n\n==== Public Key Generation ====\n\nInput:\n* The secret key ''sk'': a 32-byte array, freshly generated uniformly at random\n\nThe algorithm ''PubKey(sk)'' is defined as:\n* Let ''d' = int(sk)''.\n* Fail if ''d' = 0'' or ''d' &ge; n''.\n* Return ''bytes(d'\u22c5G)''.\n\nNote that we use a very different public key format (32 bytes) than the ones used by existing systems (which typically use elliptic curve points as public keys, or 33-byte or 65-byte encodings of them). A side effect is that ''PubKey(sk) = PubKey(bytes(n - int(sk))'', so every public key has two corresponding secret keys.\n\n==== Public Key Conversion ====\n\nAs an alternative to generating keys randomly, it is also possible and safe to repurpose existing key generation algorithms for ECDSA in a compatible way. The secret keys constructed by such an algorithm can be used as ''sk'' directly. The public keys constructed by such an algorithm (assuming they use the 33-byte compressed encoding) need to be converted by dropping the first byte. Specifically, [[bip-0032.mediawiki|BIP32]] and schemes built on top of it remain usable.\n\n==== Default Signing ====\n\nInput:\n* The secret key ''sk'': a 32-byte array\n* The message ''m'': a byte array\n* Auxiliary random data ''a'': a 32-byte array\n\nThe algorithm ''Sign(sk, m)'' is defined as:\n* Let ''d' = int(sk)''\n* Fail if ''d' = 0'' or ''d' &ge; n''\n* Let ''P = d'\u22c5G''\n* Let ''d = d' '' if ''has_even_y(P)'', otherwise let ''d = n - d' ''.\n* Let ''t'' be the byte-wise xor of ''bytes(d)'' and ''hash<sub>BIP0340/aux</sub>(a)''<ref>The auxiliary random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the private key itself. It is xored with the private key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n* Let ''rand = hash<sub>BIP0340/nonce</sub>(t || bytes(P) || m)''<ref>Including the [https://moderncrypto.org/mail-archive/curves/2020/001012.html public key as input to the nonce hash] helps ensure the robustness of the signing algorithm by preventing leakage of the secret key if the calculation of the public key ''P'' is performed incorrectly or maliciously, for example if it is left to the caller for performance reasons.</ref>.\n* Let ''k' = int(rand) mod n''<ref>Note that in general, taking a uniformly random 256-bit integer modulo the curve order will produce an unacceptably biased result. However, for the secp256k1 curve, the order is sufficiently close to ''2<sup>256</sup>'' that this bias is not observable (''1 - n / 2<sup>256</sup>'' is around ''1.27 * 2<sup>-128</sup>'').</ref>.\n* Fail if ''k' = 0''.\n* Let ''R = k'\u22c5G''.\n* Let ''k = k' '' if ''has_even_y(R)'', otherwise let ''k = n - k' ''.\n* Let ''e = int(hash<sub>BIP0340/challenge</sub>(bytes(R) || bytes(P) || m)) mod n''.\n* Let ''sig = bytes(R) || bytes((k + ed) mod n)''.\n* If ''Verify(bytes(P), m, sig)'' (see below) returns failure, abort<ref>Verifying the signature before leaving the signer prevents random or attacker provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended, but can be omitted if the computation cost is prohibitive.</ref>.\n* Return the signature ''sig''.\n\nThe auxiliary random data should be set to fresh randomness generated at signing time, resulting in what is called a ''synthetic nonce''. Using 32 bytes of randomness is optimal. If obtaining randomness is expensive, 16 random bytes can be padded with 16 null bytes to obtain a 32-byte array. If randomness is not available at all at signing time, a simple counter wide enough to not repeat in practice (e.g., 64 bits or wider) and padded with null bytes to a 32 byte-array can be used, or even the constant array with 32 null bytes. Using any non-repeating value increases protection against [https://moderncrypto.org/mail-archive/curves/2017/000925.html fault injection attacks]. Using unpredictable randomness additionally increases protection against other side-channel attacks, and is '''recommended whenever available'''. Note that while this means the resulting nonce is not deterministic, the randomness is only supplemental to security. The normal security properties (excluding side-channel attacks) do not depend on the quality of the signing-time RNG.\n\n==== Alternative Signing ====\n\nIt should be noted that various alternative signing algorithms can be used to produce equally valid signatures. The 32-byte ''rand'' value may be generated in other ways, producing a different but still valid signature (in other words, this is not a ''unique'' signature scheme). '''No matter which method is used to generate the ''rand'' value, the value must be a fresh uniformly random 32-byte string which is not even partially predictable for the attacker.''' For nonces without randomness, this implies that the same inputs must not be presented in another context. This can be most reliably accomplished by not reusing the same private key across different signing schemes. For example, if the ''rand'' value was computed as per RFC6979 and the same secret key is used in deterministic ECDSA with RFC6979, the signatures can leak the secret key through nonce reuse.\n\n'''Nonce exfiltration protection''' It is possible to strengthen the nonce generation algorithm using a second device. In this case, the second device contributes randomness which the actual signer provably incorporates into its nonce. This prevents certain attacks where the signer's device is compromised and intentionally tries to leak the secret key through its nonce selection.\n\n'''Multisignatures''' This signature scheme is compatible with various types of multisignature and threshold schemes such as [https://eprint.iacr.org/2020/1261.pdf MuSig2], where a single public key requires holders of multiple secret keys to participate in signing (see Applications below).\n'''It is important to note that multisignature signing schemes in general are insecure with the ''rand'' generation from the default signing algorithm above (or any other deterministic method).'''\n\n'''Precomputed public key data''' For many uses, the compressed 33-byte encoding of the public key corresponding to the secret key may already be known, making it easy to evaluate ''has_even_y(P)'' and ''bytes(P)''. As such, having signers supply this directly may be more efficient than recalculating the public key from the secret key. However, if this optimization is used and additionally the signature verification at the end of the signing algorithm is dropped for increased efficiency, signers must ensure the public key is correctly calculated and not taken from untrusted sources.\n\n==== Verification ====\n\nInput:\n* The public key ''pk'': a 32-byte array\n* The message ''m'': a byte array\n* A signature ''sig'': a 64-byte array\n\nThe algorithm ''Verify(pk, m, sig)'' is defined as:\n* Let ''P = lift_x(int(pk))''; fail if that fails.\n* Let ''r = int(sig[0:32])''; fail if ''r &ge; p''.\n* Let ''s = int(sig[32:64])''; fail if ''s &ge; n''.\n* Let ''e = int(hash<sub>BIP0340/challenge</sub>(bytes(r) || bytes(P) || m)) mod n''.\n* Let ''R = s\u22c5G - e\u22c5P''.\n* Fail if ''is_infinite(R)''.\n* Fail if ''not has_even_y(R)''.\n* Fail if ''x(R) &ne; r''.\n* Return success iff no failure occurred before reaching this point.\n\nFor every valid secret key ''sk'' and message ''m'', ''Verify(PubKey(sk),m,Sign(sk,m))'' will succeed.\n\nNote that the correctness of verification relies on the fact that ''lift_x'' always returns a point with an even Y coordinate. A hypothetical verification algorithm that treats points as public keys, and takes the point ''P'' directly as input would fail any time a point with odd Y is used. While it is possible to correct for this by negating points with odd Y coordinate before further processing, this would result in a scheme where every (message, signature) pair is valid for two public keys (a type of malleability that exists for ECDSA as well, but we don't wish to retain). We avoid these problems by treating just the X coordinate as public key.\n\n==== Batch Verification ====\n\nInput:\n* The number ''u'' of signatures\n* The public keys ''pk<sub>1..u</sub>'': ''u'' 32-byte arrays\n* The messages ''m<sub>1..u</sub>'': ''u'' byte arrays\n* The signatures ''sig<sub>1..u</sub>'': ''u'' 64-byte arrays\n\nThe algorithm ''BatchVerify(pk<sub>1..u</sub>, m<sub>1..u</sub>, sig<sub>1..u</sub>)'' is defined as:\n* Generate ''u-1'' random integers ''a<sub>2...u</sub>'' in the range ''1...n-1''. They are generated deterministically using a [https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator CSPRNG] seeded by a cryptographic hash of all inputs of the algorithm, i.e. ''seed = seed_hash(pk<sub>1</sub>..pk<sub>u</sub> || m<sub>1</sub>..m<sub>u</sub> || sig<sub>1</sub>..sig<sub>u</sub> )''. A safe choice is to instantiate ''seed_hash'' with SHA256 and use [https://tools.ietf.org/html/rfc8439 ChaCha20] with key ''seed'' as a CSPRNG to generate 256-bit integers, skipping integers not in the range ''1...n-1''.\n* For ''i = 1 .. u'':\n** Let ''P<sub>i</sub> = lift_x(int(pk<sub>i</sub>))''; fail if it fails.\n** Let ''r<sub>i</sub> = int(sig<sub>i</sub>[0:32])''; fail if ''r<sub>i</sub> &ge; p''.\n** Let ''s<sub>i</sub> = int(sig<sub>i</sub>[32:64])''; fail if ''s<sub>i</sub> &ge; n''.\n** Let ''e<sub>i</sub> = int(hash<sub>BIP0340/challenge</sub>(bytes(r<sub>i</sub>) || bytes(P<sub>i</sub>) || m<sub>i</sub>)) mod n''.\n** Let ''R<sub>i</sub> = lift_x(r<sub>i</sub>)''; fail if ''lift_x(r<sub>i</sub>)'' fails.\n* Fail if ''(s<sub>1</sub> + a<sub>2</sub>s<sub>2</sub> + ... + a<sub>u</sub>s<sub>u</sub>)\u22c5G &ne; R<sub>1</sub> + a<sub>2</sub>\u22c5R<sub>2</sub> + ... + a<sub>u</sub>\u22c5R<sub>u</sub> + e<sub>1</sub>\u22c5P<sub>1</sub> + (a<sub>2</sub>e<sub>2</sub>)\u22c5P<sub>2</sub> + ... + (a<sub>u</sub>e<sub>u</sub>)\u22c5P<sub>u</sub>''.\n* Return success iff no failure occurred before reaching this point.\n\nIf all individual signatures are valid (i.e., ''Verify'' would return success for them), ''BatchVerify'' will always return success. If at least one signature is invalid, ''BatchVerify'' will return success with at most a negligible probability.\n\n=== Usage Considerations ===\n\n==== Messages of Arbitrary Size ====\n\nThe signature scheme specified in this BIP accepts byte strings of arbitrary size as input messages.<ref>In theory, the message size is restricted due to the fact that SHA256 accepts byte strings only up to size of 2^61-1 bytes.</ref>\nIt is understood that implementations may reject messages which are too large in their environment or application context,\ne.g., messages which exceed predefined buffers or would otherwise cause resource exhaustion.\n\nEarlier revisions of this BIP required messages to be exactly 32 bytes.\nThis restriction puts a burden on callers\nwho typically need to perform pre-hashing of the actual input message by feeding it through SHA256 (or another collision-resistant cryptographic hash function)\nto create a 32-byte digest which can be passed to signing or verification\n(as for example done in [[bip-0341.mediawiki|BIP341]].)\n\nSince pre-hashing may not always be desirable,\ne.g., when actual messages are shorter than 32 bytes,<ref>Another reason to omit pre-hashing is to protect against certain types of cryptanalytic advances against the hash function used for pre-hashing: If pre-hashing is used, an attacker that can find collisions in the pre-hashing function can necessarily forge signatures under chosen-message attacks. If pre-hashing is not used, an attacker that can find collisions in SHA256 (as used inside the signature scheme) may not be able to forge signatures. However, this seeming advantage is mostly irrelevant in the context of Bitcoin, which already relies on collision resistance of SHA256 in other places, e.g., for transaction hashes.</ref>\nthe restriction to 32-byte messages has been lifted.\nWe note that pre-hashing is recommended for performance reasons in applications that deal with large messages.\nIf large messages are not pre-hashed,\nthe algorithms of the signature scheme will perform more hashing internally.\nIn particular, the signing algorithm needs two sequential hashing passes over the message,\nwhich means that the full message must necessarily be kept in memory during signing,\nand large messages entail a runtime penalty.<ref>Typically, messages of 56 bytes or longer enjoy a performance benefit from pre-hashing, assuming the speed of SHA256 inside the signing algorithm matches that of the pre-hashing done by the calling application.</ref>\n\n==== Domain Separation ====\n\nIt is good cryptographic practice to use a key pair only for a single purpose.\nNevertheless, there may be situations in which it may be desirable to use the same key pair in multiple contexts,\ni.e., to sign different types of messages within the same application\nor even messages in entirely different applications\n(e.g., a secret key may be used to sign Bitcoin transactions as well plain text messages).\n\nAs a consequence, applications should ensure that a signed application message intended for one context is never deemed valid in a different context\n(e.g., a signed plain text message should never be misinterpreted as a signed Bitcoin transaction, because this could cause unintended loss of funds).\nThis is called \"domain separation\" and it is typically realized by partitioning the message space.\nEven if key pairs are intended to be used only within a single context,\ndomain separation is a good idea because it makes it easy to add more contexts later.\n\nAs a best practice, we recommend applications to use exactly one of the following methods to pre-process application messages before passing it to the signature scheme:\n* Either, pre-hash the application message using ''hash<sub>name</sub>'', where ''name'' identifies the context uniquely (e.g., \"foo-app/signed-bar\"),\n* or prefix the actual message with a 33-byte string that identifies the context uniquely (e.g., the UTF-8 encoding of \"foo-app/signed-bar\", padded with null bytes to 33 bytes).\n\nAs the two pre-processing methods yield different message sizes (32 bytes vs. at least 33 bytes), there is no risk of collision between them.\n\n== Applications ==\n\nThere are several interesting applications beyond simple signatures.\nWhile recent academic papers claim that they are also possible with ECDSA, consensus support for Schnorr signature verification would significantly simplify the constructions.\n\n=== Multisignatures and Threshold Signatures ===\n\nBy means of an interactive scheme such as [https://eprint.iacr.org/2020/1261.pdf MuSig2] ([[bip-0327.mediawiki|BIP327]]), participants can aggregate their public keys into a single public key which they can jointly sign for. This allows ''n''-of-''n'' multisignatures which, from a verifier's perspective, are no different from ordinary signatures, giving improved privacy and efficiency versus ''CHECKMULTISIG'' or other means.\n\nMoreover, Schnorr signatures are compatible with [https://en.wikipedia.org/wiki/Distributed_key_generation distributed key generation], which enables interactive threshold signatures schemes, e.g., the schemes by [http://cacr.uwaterloo.ca/techreports/2001/corr2001-13.ps Stinson and Strobl (2001)], by [https://link.springer.com/content/pdf/10.1007/s00145-006-0347-3.pdf Gennaro, Jarecki, Krawczyk, and Rabin (2007)], or the [https://eprint.iacr.org/2020/852.pdf FROST] scheme including its variants such as [https://eprint.iacr.org/2023/899.pdf FROST3]. These protocols make it possible to realize ''k''-of-''n'' threshold signatures, which ensure that any subset of size ''k'' of the set of ''n'' signers can sign but no subset of size less than ''k'' can produce a valid Schnorr signature.\n\n=== Adaptor Signatures ===\n\n[https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2018-05-18-l2/slides.pdf Adaptor signatures] can be produced by a signer by offsetting his public nonce ''R'' with a known point ''T = t\u22c5G'', but not offsetting the signature's ''s'' value.\nA correct signature (or partial signature, as individual signers' contributions to a multisignature are called) on the same message with same nonce will then be equal to the adaptor signature offset by ''t'', meaning that learning ''t'' is equivalent to learning a correct signature.\nThis can be used to enable atomic swaps or even [https://eprint.iacr.org/2018/472 general payment channels] in which the atomicity of disjoint transactions is ensured using the signatures themselves, rather than Bitcoin script support. The resulting transactions will appear to verifiers to be no different from ordinary single-signer transactions, except perhaps for the inclusion of locktime refund logic.\n\nAdaptor signatures, beyond the efficiency and privacy benefits of encoding script semantics into constant-sized signatures, have additional benefits over traditional hash-based payment channels. Specifically, the secret values ''t'' may be reblinded between hops, allowing long chains of transactions to be made atomic while even the participants cannot identify which transactions are part of the chain. Also, because the secret values are chosen at signing time, rather than key generation time, existing outputs may be repurposed for different applications without recourse to the blockchain, even multiple times.\n\n=== Blind Signatures ===\n\nA blind signature protocol is an interactive protocol that enables a signer to sign a message at the behest of another party without learning any information about the signed message or the signature. Schnorr signatures admit a very [http://publikationen.ub.uni-frankfurt.de/files/4292/schnorr.blind_sigs_attack.2001.pdf simple blind signature scheme] which is however insecure because it's vulnerable to [https://www.iacr.org/archive/crypto2002/24420288/24420288.pdf Wagner's attack]. Known mitigations are to let the signer abort a signing session with a certain probability, which can be [https://eprint.iacr.org/2019/877 proven secure under non-standard cryptographic assumptions], or [https://eprint.iacr.org/2022/1676.pdf to use zero-knowledge proofs].\n\nBlind Schnorr signatures could for example be used in [https://github.com/ElementsProject/scriptless-scripts/blob/master/md/partially-blind-swap.md Partially Blind Atomic Swaps], a construction to enable transferring of coins, mediated by an untrusted escrow agent, without connecting the transactors in the public blockchain transaction graph.\n\n== Test Vectors and Reference Code ==\n\nFor development and testing purposes, we provide a [[bip-0340/test-vectors.csv|collection of test vectors in CSV format]],\na naive, highly inefficient, and non-constant time [[bip-0340/reference.py|pure Python 3.7 reference implementation of the signing and verification algorithm]]\nas well as the [[bip-0340/test-vectors.py|script used to generate the test vectors]]\nunder the BSD-2-Clause License, or the MIT License, or CC0 1.0, at your choice.\nThe reference implementation is for demonstration purposes only and not to be used in production environments.\n\n== Changelog ==\n\nTo help implementers understand updates to this BIP, we keep a list of substantial changes.\n\n* 2022-08: Fix function signature of lift_x in reference code\n* 2023-04: Allow messages of arbitrary size\n* 2024-05: Update \"Applications\" section with more recent references\n* 2025-04: Change license of test vectors and code\n\n== Footnotes ==\n\n<references />\n\n== Acknowledgements ==\n\nThis document is the result of many discussions around Schnorr based signatures over the years, and had input from Johnson Lau, Greg Maxwell, Andrew Poelstra, Rusty Russell, and Anthony Towns. The authors further wish to thank all those who provided valuable feedback and reviews, including the participants of the [https://github.com/ajtowns/taproot-review structured reviews].\n", "content_length": 39968}
{"bip_number": 339, "filename": "bip-0339.mediawiki", "content": "<pre>\n  BIP: 339\n  Layer: Peer Services\n  Title: WTXID-based transaction relay\n  Author: Suhas Daftuar <sdaftuar@chaincode.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0339\n  Status: Final\n  Type: Standards Track\n  Created: 2020-02-03\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes two changes to the p2p protocol to support transaction relay\nbased on the BIP 141 wtxid of a transaction, rather than its txid.\n\n==Motivation==\n\nHistorically, the inv messages sent on the Bitcoin peer-to-peer network to\nannounce transactions refer to transactions by their txid, which is a hash of\nthe transaction that does not include the witness (see BIP 141). This has been\nthe case even since Segregated Witness (BIP 141/143/144) has been adopted by\nthe network.\n\nNot committing to the witness in transaction announcements creates\ninefficiencies: because a transaction's witness can be malleated without\naltering the txid, a node in receipt of a witness transaction that the node\ndoes not accept will generally still download that same transaction when\nannounced by other peers. This is because the alternative -- of not downloading\na given txid after rejecting a transaction with that txid -- would allow a\nthird party to interfere with transaction relay by malleating a transaction's\nwitness and announcing the resulting invalid transaction to nodes, preventing\nrelay of the valid version of the transaction as well.\n\nWe can eliminate this concern by using the wtxid in place of the txid when\nannouncing and fetching transactions.\n\n==Specification==\n\n# A new wtxidrelay message is added, which is defined as an empty message where pchCommand == \"wtxidrelay\".\n# The protocol version of nodes implementing this BIP must be set to 70016 or higher.\n# The wtxidrelay message MUST be sent in response to a version message from a peer whose protocol version is >= 70016 and prior to sending a verack. A wtxidrelay message received after a verack message MUST be ignored or treated as invalid.\n# A new inv type MSG_WTX (0x00000005) is added, for use in both inv messages and getdata requests, indicating that the hash being referenced is a transaction's wtxid. In the case of getdata requests, MSG_WTX implies that the transaction being requested should be serialized with witness as well, as described in BIP 144.\n# After a node has received a wtxidrelay message from a peer, the node MUST use the MSG_WTX inv type when announcing transactions to that peer.\n# After a node has received a wtxidrelay message from a peer, the node SHOULD use a MSG_WTX getdata message to request any announced transactions. A node MAY still request transactions from that peer using MSG_TX getdata messages, such as for transactions not recently announced by that peer (like the parents of recently announced transactions).\n\n==Backward compatibility==\n\nAs wtxid-based transaction relay is only enabled between peers that both support it, older clients remain fully compatible and interoperable after this change.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/18044\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n", "content_length": 3192}
{"bip_number": 338, "filename": "bip-0338.mediawiki", "content": "<pre>\n  BIP: 338\n  Layer: Peer Services\n  Title: Disable transaction relay message\n  Author: Suhas Daftuar <sdaftuar@chaincode.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0338\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2020-09-03\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes a change to the p2p protocol to allow a node to tell a peer\nthat a connection will not be used for transaction relay, to support\nblock-relay-only connections that are currently in use on the network.\n\n==Motivation==\n\nThis proposal is part of an effort to increase the number of inbound\nconnections that a peer can service, by distinguishing peers which will not\nrelay transactions from those that do.\n\nSince 2019, software has been deployed[1] which initiates\nconnections on the Bitcoin network and sets the transaction relay field\n(introduced by BIP 37 and also defined in BIP 60) to false, to prevent\ntransaction relay from occurring on the connection. Additionally, addr messages\nreceived from the peer are ignored by this software.\n\nThe purpose of these connections is two-fold: by making additional\nlow-bandwidth connections on which blocks can propagate, the robustness of a\nnode to network partitioning attacks is strengthened.  Additionally, by not\nrelaying transactions and ignoring received addresses, the ability of an\nadversary to learn the complete network graph (or a subgraph) is reduced[2],\nwhich in turn increases the cost or difficulty to an attacker seeking to carry\nout a network partitioning attack (when compared with having such knowledge).\n\nThe low-bandwidth / minimal-resource nature of these connections is currently\nknown only by the initiator of the connection; this is because the transaction\nrelay field in the version message is not a permanent setting for the lifetime\nof the connection.  Consequently, a node receiving an inbound connection with\ntransaction relay disabled cannot distinguish between a peer that will never\nenable transaction relay (as described in BIP 37) and one that will.  Moreover,\nthe node also cannot determine that the incoming connection will ignore relayed\naddresses; with that knowledge a node would likely choose other peers to\nreceive announced addresses instead.\n\nThis proposal adds a new, optional message that a node can send a peer when\ninitiating a connection to that peer, to indicate that connection should not be\nused for transaction relay for the connection's lifetime. In addition, without\na current mechanism to negotiate whether addresses should be relayed on a\nconnection, this BIP suggests that address messages not be sent on links where\ntransaction relay has been disabled.\n\nAfter this BIP is deployed, nodes could more easily implement inbound\nconnection limiting that differentiates low-resource nodes (such as those\nsending disabletx) from full-relay peers, potentially allowing for an increase\nin the number of block-relay-only connections that can be made on the network.\n\n==Specification==\n\n# A new disabletx message is added, which is defined as an empty message with message type set to \"disabletx\".\n# The protocol version of nodes implementing this BIP must be set to 70017 or higher.\n# If a node sets the transaction relay field in the version message to a peer to false, then the disabletx message MAY also be sent in response to a version message from that peer if the peer's protocol version is >= 70017. If sent, the disabletx message MUST be sent prior to sending a verack.\n# A node MUST NOT send the disabletx message if the transaction relay field in the version message is omitted or set to true.\n# A node that has sent or received a disabletx message to/from a peer MUST NOT send any of these messages to the peer:\n## inv messages for transactions\n## notfound messages for transactions\n## getdata messages for transactions\n## getdata messages for merkleblock (BIP 37)\n## filteradd/filterload/filterclear (BIP 37)\n## feefilter (BIP 133)\n## mempool (BIP 35)\n## tx message\n# It is RECOMMENDED that a node that has sent or received a disabletx message to/from a peer not send any of these messages to the peer:\n## addr/getaddr\n## addrv2 (BIP 155)\n# The behavior regarding sending or processing other message types is not specified by this BIP.\n# Nodes MAY decide to not remain connected to peers that send this message (for example, if trying to find a peer that will relay transactions).\n\n==Compatibility==\n\nNodes with protocol version >= 70017 that do not implement this BIP, and nodes\nwith protocol version < 70017, will continue to remain compatible with\nimplementing software: transactions would not be relayed to peers sending the\ndisabletx message (provided that BIP 37 or BIP 60 has been implemented), and while\nperiodic address relay may still take place, software implementing this BIP\nshould not be disconnecting such peers solely for that reason.\n\nDisabling address relay is suggested but not required by this BIP, to allow for\nfuture protocol extensions that might specify more carefully how address relay\nis to be negotiated. This BIP's recommendations for software to not relay\naddresses is intended to be interpreted as guidance in the absence of any such\nfuture protocol extension, to accommodate existing software behavior.\n\nNote that all messages specified in BIP 152, including blocktxn and\ngetblocktxn, are permitted between peers that have sent/received a disabletx\nmessage, subject to the feature negotiation of BIP 152.\n\nThis proposal is compatible with, but independent of, BIP 37.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/20726\n\n==References==\n\n# Bitcoin Core has [https://github.com/bitcoin/bitcoin/pull/15759 implemented this functionality] since version 0.19.0.1, released in November 2019.\n# For example, see https://www.cs.umd.edu/projects/coinscope/coinscope.pdf and https://arxiv.org/pdf/1812.00942.pdf.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n", "content_length": 5990}
{"bip_number": 337, "filename": "bip-0337.mediawiki", "content": "<pre>\n  BIP: 337\n  Layer: API/RPC\n  Title: Compressed Transactions\n  Author: Tom Briar <tombriar11@protonmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0337\n  Status: Draft\n  Type: Standards Track\n  Created: 2024-02-01\n  License: BSD-3-Clause\n  Post-History: https://github.com/bitcoin/bitcoin/pull/29134\n                https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-August/021924.html\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\nThis document proposes a serialization scheme for compressing Bitcoin transactions. The compressed Bitcoin transactions can reach a serialized size of less than 50% of the original serialized transaction. One method for compressing involves reducing the transaction outpoints in a potentially lossy way. Therefore, it is an optional path for compression. Compressing the outpoints is necessary for compressed transactions to reach less than 70% of the original size.\n\n=== Motivation ===\nTypical Bitcoin transactions usually contain a large amount of white space and padding due to specific fields that are often one of a minimal number of possibilities. We can use this fact and a few similar methods to create an encoding for 90% of Bitcoin transactions that are roughly 25-50% smaller.\n\nThere exists a working-in-progress app that allows the use of steganography to encode data in images to be passed around via various social media groups. When used in conjunction with this compression scheme and an elligator squared encryption, this would allow for a very secure and private form of broadcasting bitcoin transactions.\n\n=== Rationale ===\n\nThe four main methods to achieve a lower transaction size are:\n\n1. Packing transaction metadata before it and each of its inputs and outputs to determine the following data structure.\n\n2. Replacing 32-bit numeric values with either variable-length integers (VarInts) or compact integers (CompactSizes).\n\n3. Using compressed signatures and public key recovery upon decompression.\n\n4. Replacing the 36-byte Outpoint txid/vout pair with a block height and index.\n\n\n=== Backwards Compatibility ===\n\nThere are no concerns with backwards compatibility.\n\n=== Specification ===\n\n==== Primitives ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| CompactSize || 1-5 Bytes || For 0-253, encode the value directly in one byte. For 254-65535, encode 254 followed by two little-endian bytes. For 65536-(2^32-1), encode 255 followed by four little-endian bytes.\n|-\n| CompactSize Flag || 2 Bits || 1, 2, or 3 indicate literal values. 0 indicates that a CompactSize encoding of the value will follow.\n|-\n| VarInt || 1+ Bytes || 7-bit little-endian encoding, with each 7-bit word encoded in a byte. The highest bit of each byte is one if more bytes follow, and 0 for the last byte.\n|-\n| VLP-Bytestream || 2+ Bytes || A VarInt Length Prefixed Bytestream. It uses the prefixed VarInt to determine the length of the following byte stream.\n|}\n\n==== General Schema ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Transaction metadata || 1 Bytes || Information on the structure of the transaction. See [[#transaction-metadata|Transaction Metadata]]\n|-\n| Version || 0-5 Bytes || If present according to the metadata field, a CompactSize encoding of the transaction version.\n|-\n| Input Count || 0-5 Bytes || If present according to the metadata field, a CompactSize encoding of the transaction input count.\n|-\n| Output Count || 0-5 Bytes || If present according to the metadata field, a CompactSize encoding of the transaction output count.\n|-\n| LockTime || 0-5 Bytes || If present according to the metadata field, a CompactSize encoding of the transaction LockTime.\n|-\n| Minimum Blockheight || 1-5 Bytes || If present according to the metadata field, a VarInt encoding of the minimum block height for transaction compressed inputs and LockTime.\n|-\n| Input Metadata+Output Metadata || 1+ Bytes || An encoding containing the metadata for all the inputs followed by all the outputs of the transaction. For each input, see [[#input-metadata|Input Metadata]], and for each output, see [[#output-metadata|Output Metadata]].\n|-\n| Input Data || 66+ Bytes || See [[#input-data|Input Data]].\n|-\n| Output Data || 3+ Bytes || See [[#output-data|Output Data]].\n|}\n\n<span id=\"transaction-metadata\"></span>\n==== Transaction Metadata ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Version || 2 Bits || A CompactSize flag for the transaction version.\n|-\n| Input Count || 2 Bits || A CompactSize flag for the transaction input count.\n|-\n| Output Count || 2 Bits || A CompactSize flag for the transaction output count.\n|-\n| LockTime || 1 Bit || A boolean to indicate if the transaction has a LockTime.\n|-\n| Minimum Blockheight || 1 Bit || A boolean to indicate if the transaction minimum block height is greater than zero.\n|}\n\n<span id=\"input-metadata\"></span>\n==== Input Metadata ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Compressed Signature || 1 Bit || A Boolean do determine if this input's signature is compressed. The signature is only compressed for P2TR on a key spend and for P2SH when it is a wrapped P2SH-WPKH.\n|-\n| Standard Hash || 1 Bit || A Boolean to determine if this input's signature hash type is standard (0x00 for Taproot, 0x01 for Legacy/Segwit).\n|-\n| Standard Sequence || 2 Bits || A CompactSize flag for this input's sequence. Encode literal values as follows: 1 = 0x00000000, 2 = 0xFFFFFFFE, 3 = 0xFFFFFFFF.\n|-\n| Compressed OutPoint || 1 bit || A Boolean to determine if the input's outpoint is compressed.\n|}\n\n<span id=\"output-metadata\"></span>\n==== Output Metadata ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Encoded Script Type || 3 Bits || [[#script-type-encoding|Encoded Script Type]].\n|}\n\n<span id=\"script-type-encoding\"></span>\n==== Script Type Encoding ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Script Type !! Value\n|-\n| Uncompressed Custom Script || 0b000\n|-\n| Uncompressed P2PK || 0b001\n|-\n| Compressed P2PK || 0b010\n|-\n| P2PKH || 0b011\n|-\n| P2SH || 0b100\n|-\n| P2WPKH || 0b101\n|-\n| P2WSH || 0b110\n|-\n| P2TR || 0b111\n|}\n\n<span id=\"input-data\"></span>\n==== Input Data ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Outpoint || 2-37 Bytes || The Outpoint Txid/Vout are determined to be compressed or otherwise by the \"Compressed Outpoint\" Boolean in the input metadata. For each compressed outpoint see [[#compressed-outpoint|Compressed Outpoint]]. For each uncompressed signature see [[#uncompressed-outpoint|Uncompressed Outpoint]].\n|-\n| Signature || 64+ Bytes || The Signature is determined to be compressed or otherwise by the output script of the previous transaction. For each compressed signature see [[#compressed-signature|Compressed Signature]]. For each uncompressed signature see [[#uncompressed-signature|Uncompressed Signature]].\n|-\n| Sequence || 0-5 Bytes || If present due to a non-standard sequence, a VarInt encoding of the sequence.\n|}\n\n<span id=\"compressed-outpoint\"></span>\n==== Compressed Outpoint ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Txid Block Height || 1-5 Bytes || A VarInt containing the offset from Minimum Blockheight for this Txid.\n|-\n| Txid Block Index || 1-5 Bytes || A VarInt containing the flattened index from the Txid block height for the Vout.\n|}\n\n<span id=\"uncompressed-outpoint\"></span>\n==== Uncompressed Outpoint ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Txid || 32 Bytes || Contains the 32 Byte Txid.\n|-\n| Vout || 1-5 Bytes || A CompactSize Containing the Vout of the Txid.\n|}\n\n\n<span id=\"compressed-signature\"></span>\n==== Compressed Signature ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Signature || 64 Bytes || Contains the 64 Byte signature.\n|-\n| Pubkey Hash || 0-20 Bytes || If input is P2SH-P2WPKH contains the 20 byte hash of the public key.\n|-\n| Hash Type || 0-1 Bytes || An Optional Byte containing the Hash Type if it was non-standard.\n|}\n\n<span id=\"uncompressed-signature\"></span>\n==== Uncompressed Signature ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Signature || 2+ Bytes || A VLP-Bytestream containing the signature.\n|}\n\n<span id=\"output-data\"></span>\n==== Output Data ====\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Name !! Width !! Description\n|-\n| Output Script || 2+ Bytes || A VLP-Bytestream containing the output script.\n|-\n| Amount || 1-9 Bytes || A VarInt containing the output amount.\n|}\n\n==== Ideal Transaction ====\n\nThe compression scheme was designed to be optimal for a \"typical\" transaction, spending a few close-in-age inputs and having one or two outputs. Here are size\nvalues for such a transaction, which demonstrate the effectiveness of the compression.\n\n{| class=\"wikitable\" style=\"margin:auto\"\n|-\n! Field !! Requirements !! Savings Up To\n|-\n| Version || Less than four || 30 Bits\n|-\n| Input Count || Less than four || 30 Bits\n|-\n| Output Count || Less than four || 30 Bits\n|-\n| LockTime || 0 || 30 Bits\n|-\n| Input Sequence || 0x00, 0xFFFFFFFE, or 0xFFFFFFFF || 62 Bits For Each Input\n|-\n| Input Txid || Compressed Outpoint || 23 - 31 Bytes For Each Input\n|-\n| Input Vout || Compressed Outpoint || (-1) - 3 Bytes For Each Input\n|-\n| Input Signature  || Non-custom Script Signing || 40 - 72 Bytes For Each Legacy Input\n|-\n| Input Hash Type || 0x00 for Taproot, 0x01 for Legacy || 7 Bits For Each Input\n|-\n| Output Script || Non-custom Scripts || 2 - 5 Bytes For Each Output\n|-\n| Output Amount || No Restrictions || (-1) - 7 Bytes For Each Output\n|}\n\n=== Reference Implementation ===\n\nThis reference implementation adds two new RPC endpoints, compressrawtransaction and decompressrawtransaction. The first accepts a raw hex-encoded transaction and returns a compact hex-encoded transaction; also included in the output is a list of warnings to help ensure there are no unexpected uncompressed values. The second accepts a compact hex transaction and returns the uncompressed raw hex-encoded transaction.\n\nhttps://github.com/bitcoin/bitcoin/pull/29134\n\n=== Test Vectors ===\n\n==== Taproot ====\n\n===== Uncompressed =====\n<code>020000000001017ad1d0cc314504ec06f1b5c786c50cf3cda30bd5be88cf08ead571b0ce7481fb0000000000fdffffff0188130000000000001600142da377ed4978fefa043a58489912f8e28e16226201408ce65b3170d3fbc68e3b6980650514dc53565f915d14351f83050ff50c8609495b7aa96271c3c99cdac1a92b1b45e77a4a870251fc1673596793adf2494565e500000000</code>\n\n===== Compressed =====\n<code>96b1ec7f968001b0218ce65b3170d3fbc68e3b6980650514dc53565f915d14351f83050ff50c8609495b7aa96271c3c99cdac1a92b1b45e77a4a870251fc1673596793adf2494565e58efefefe7d2da377ed4978fefa043a58489912f8e28e162262a608</code>\n\n==== P2WPKH ====\n\n===== Uncompressed =====\n<code>0200000000010144bcf05ab48b8789268a7ca07133241ad654c0739ac7165015b2d669eadb10ea0000000000fdffffff0188130000000000001600142da377ed4978fefa043a58489912f8e28e16226202473044022043ab639a98dfbc704f16a35bf25b8b72acb4cb928fd772285f1fcf63725caa85022001c9ff354504e7024708bce61f30370c8db13da8170cef4e8e4c4cdad0f71bfe0121030072484c24705512bfb1f7f866d95f808d81d343e552bc418113e1b9a1da0eb400000000</code>\n\n===== Compressed =====\n<code>96b1ec71968001932643ab639a98dfbc704f16a35bf25b8b72acb4cb928fd772285f1fcf63725caa8501c9ff354504e7024708bce61f30370c8db13da8170cef4e8e4c4cdad0f71bfe8efefefe7d2da377ed4978fefa043a58489912f8e28e162262a608</code>\n\n==== P2SH-P2WPKH ====\n\n===== Uncompressed =====\n<code>0200000000010192fb2e4332b43dc9a73febba67f3b7d97ba890673cb08efde2911330f77bbdfc00000000171600147a1979232206857167b401fdac1ffbf33f8204fffdffffff0188130000000000001600142da377ed4978fefa043a58489912f8e28e16226202473044022041eb682e63c25b85a5a400b11d41cf4b9c25f309090a5f3e0b69dc15426da90402205644ddc3d5179bab49cce4bf69ebfaeab1afa34331c1a0a70be2927d2836b0e8012103c483f1b1bd24dd23b3255a68d87ef9281f9d080fd707032ccb81c1cc56c5b00200000000</code>\n\n===== Compressed =====\n<code>96b1ec7c9e8001981641eb682e63c25b85a5a400b11d41cf4b9c25f309090a5f3e0b69dc15426da9045644ddc3d5179bab49cce4bf69ebfaeab1afa34331c1a0a70be2927d2836b0e87a1979232206857167b401fdac1ffbf33f8204ff8efefefe7d2da377ed4978fefa043a58489912f8e28e162262a608</code>\n\n==== P2PKH ====\n\n===== Uncompressed =====\n<code>02000000015f5be26862482fe2fcc900f06ef26ee256fb205bc4773e5a402d0c1b88b82043000000006a473044022031a20f5d9212023b510599c9d53d082f8e07faaa2d51482e078f8e398cb50d770220635abd99220ad713a081c4f20b83cb3f491ed8bd032cb151a3521ed144164d9c0121027977f1b6357cead2df0a0a19570088a1eb9115468b2dfa01439493807d8f1294fdffffff0188130000000000001600142da377ed4978fefa043a58489912f8e28e16226200000000</code>\n\n===== Compressed =====\n<code>96b1ec7c968001981431a20f5d9212023b510599c9d53d082f8e07faaa2d51482e078f8e398cb50d77635abd99220ad713a081c4f20b83cb3f491ed8bd032cb151a3521ed144164d9c8efefefe7d2da377ed4978fefa043a58489912f8e28e162262a608</code>\n\n\n== Acknowledgements ==\nThank you to Andrew Poelstra, who helped invent and develop the ideas in the proposal and the code for reference implementation.\n", "content_length": 13151}
{"bip_number": 331, "filename": "bip-0331.mediawiki", "content": "<pre>\n  BIP: 331\n  Layer: Peer Services\n  Title: Ancestor Package Relay\n  Author: Gloria Zhao <gloriajzhao@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n  Status: Draft\n  Type: Standards Track\n  Created: 2022-08-08\n  License: BSD-3-Clause\n  Post-History: 2022-05-17 https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html [bitcoin-dev] post\n</pre>\n\n==Abstract==\n\nPeer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\nof a given transaction, and to request and relay transactions in batches.\n\n==Motivation==\n\n===Propagate High Feerate Transactions===\n\nSince v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\nthe incentive compatibility of transactions in the mempool\n<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\nselecting them for inclusion in blocks\n<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\nIncentive-compatible mempool and miner policies help create a fair, fee-based market for block\nspace. While miners maximize transaction fees in order to earn higher block rewards, non-mining\nusers participating in transaction relay reap many benefits from employing policies that result in a\nmempool with similar contents, including faster compact block relay and more accurate fee\nestimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\nof their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n\nOnly individually considering transactions for submission to the mempool creates a limitation in\nthe node's ability to determine which transactions to include in the mempool, since it cannot take\ninto account descendants until all the transactions are in the mempool. Similarly, it cannot use a\ntransaction's descendants when considering which of two conflicting transactions to keep (Replace by\nFee or RBF).\n\nWhen a user's transaction does not meet a mempool's minimum feerate and they cannot create a\nreplacement transaction directly, their transaction will simply be rejected by this mempool or\nevicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\ntransaction; it would be rejected for spending inputs that do not exist.\n\nThis limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\nissues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n</ref> to prevent cheating.\nIn other words, a key security assumption of many contracting protocols is that all parties can\npropagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\nprevent a transaction from being relayed or getting mined.\n<ref>'''Concerns for pinning attacks in L2 protocols'''\n* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n</ref>\n\nThese transactions must meet a certain confirmation target to be effective, but their feerates\nare negotiated well ahead of broadcast time. If the forecast feerate was too low and no\nfee-bumping options are available, attackers can steal money from their counterparties.  Always\noverestimating fees may sidestep this issue (but only while mempool traffic is low and\npredictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\nthe available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\nan unreasonable security requirement.\n\nPart of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\nmore low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\nmempool policy can help determine if it would actually be economically rational to accept a\ntransaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\nof these policies would create a more purely-feerate-based market for block space and allow\ncontracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n\nTheoretically, developing a safe and incentive-compatible package mempool acceptance policy is\nsufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\ncombinations of transactions rejected from their mempools), but this practice would likely be\ninefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\nsuggests adding new p2p messages enabling nodes to request and share package-validation-related\ninformation with one another, resulting in a more efficient and reliable way to propagate packages.\n\n===Handle Orphans Better===\n\nTxid-based transaction relay is problematic since a transaction's witness may be malleated without\nchanging its txid; a node cannot use txid to deduplicate transactions it has already downloaded\nor validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\never need to use txid-based transaction relay.\n\nA single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\nfrom an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\ncommon for new nodes that have just completed Initial Block Download and do not have an up-to-date\nmempool. Nodes also download transactions from multiple peers. If the peer from which a child\ntransaction was requested responds faster than the peer from which its parent was requested, that\nchild is seen as an orphan transaction.\n\nNodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\nspend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\nfor two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\nnetwork and it relies on txid-based relay between two wtxid-relay peers.\n\nThis proposal makes orphan resolution more efficient and no longer require txid-based relay.\n\n==Definitions==\n\nGiven any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\nTx1 and Tx1 is a '''child''' of Tx0.\n\nA transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\nA transaction's '''descendants''' include, recursively, its children, the children of its children,\netc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n\nA '''package''' is a list of transactions, representable by a connected Directed Acyclic\nGraph (a directed edge exists between a transaction that spends the output of another transaction).\nIn this proposal, a package is limited to unconfirmed transactions.\n\nAn '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\nancestors.\n\nIn a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n\n==Specification==\n\nAncestor Package Relay includes two parts: a package information round and a transaction data\ndownload round.\nThe package information round is used to help a receiver learn what transactions are in a package and\ndecide whether they want to download them. The transaction data round is used to help a node download\nmultiple transactions in one message instead of as separate messages.\n<ref>'''Why are package information and transaction data rounds both necessary?'''\n\nSeveral alternative designs were considered. One should measure alternative solutions based on the\nresources used to communicate (not necessarily trustworthy) information: We would like to minimize\nnetwork bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\nthat are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n\n<br />\n\n'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\npackage and always send the entire package together, skipping the package information round.\nHowever, this protocol would make it very likely for honest nodes to redownload duplicate\ntransactions. See the following example, where the high-feerate ancestors were already downloaded\nand accepted individually.\n\n[[File:./bip-0331/no_package_info.png|600px]]\n<br />\n\n'''Package Information Only:''' Just having package information gives enough information for the\nreceiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\nsend \"getdata\" and download the transactions individually. While this option is a potential fallback\nif batched transaction download fails for some reason, it shouldn't be used as the default because\nit always requires storage of unvalidated transactions.\n[[File:./bip-0331/package_info_only.png|1000px]]\n</ref>\n\nPackage relay is negotiated between two peers during the version handshake using a \"sendpackages\"\nmessage. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\nmultiple versions of packages. Package relay requires both peers to support wtxid-based relay\nbecause package transactions are referenced by their wtxids.\n<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\nAttempting to support arbitrary packages in mempool validation may result in very complex logic, new\nDenial of Service attack vectors, and policy limitations that could be leveraged to censor\ntransactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\npackages based on future desired use cases. Future package information messages may describe\ndifferent types of packages and/or contain more information than a list of wtxids, e.g. feerate or\nrelationships between transactions.</ref>\n<ref>'''Why use a bitfield instead of a numbering system?'''\nIt should be possible to support some subset of the existing package types.</ref>\n\n[[File:./bip-0331/version_negotiation.png|400px]]\n\nNodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\nmessages during version handshake. They indicate support for the ancestor package information\nround (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n\"sendpackages\" messages during version handshake.\n\n===Protocol Flow Examples===\n\nThis package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\ntransaction paying for low-feerate ancestors).\n\n====Orphan Transaction Handling====\n\nUpon receiving an orphan transaction, a node may request ancestor package information delineating\nthe wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\nThe package information can be used to request transaction data. As these transactions are dependent\nupon one another to be valid, the transactions can be requested and sent as a batch.\n\nContrast this protocol with legacy orphan handling, which requires requesting the missing\ntransactions by their txids and may require new round trips for each generation of missing parents.\n[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n\n====Fee-Bumped Transactions====\n\nToo-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\ndescendants can also be relayed this way. If the peers are using BIP133 fee filters and a\nlow-feerate transaction is below the node's fee filter, the sender will not announce it. The\nhigh-feerate transaction will be sent by the sender, and received and handled as an orphan by the\nreceiver, the transactions are validated as a package, and so the protocol naturally works for this\nuse case.\n\nThis does not mean BIP133 is required for package relay to work, provided that nodes do not\nimmediately reject transactions previously found to be too low feerate. If the low-feerate\ntransaction was sent and rejected, the receiver should later re-request and accept it after learning\nthat it is the ancestor of another transaction, and that they meet the receiver's mempool policy\nrequirements when validated together.\n\n[[File:./bip-0331/package_cpfp_flow.png|600px]]\n\nThis protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\nrelay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\nprobably need to request and validate a group of transactions together in order for them to be\naccepted. As with any proactive communication, there is a chance that the receiver already knows\nthis information, so this network bandwidth may be wasted. Shortened latency is less significant\nthan wasted bandwidth.\n\nThe logic used to decide when to announce a package proactively determines whether it is a net\nincrease or decrease for overall bandwidth usage. However, it is difficult to design anything to\nsave bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\nhistorical data is available, as one of the primary goals of this protocol is to enable\ncurrently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\ncan observe its usage and then introduce a sender-initiated package relay protocol informed by data\ncollected from the p2p network.</ref>\n\n===Combined Hash===\n\nA \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\nmeaningful but short \"notfound\" response to \"getpkgtxns.\"\n\nThe combined hash of a package of transactions is equal to the sha256 hash of each transaction's\nwtxid concatenated in lexicographical order.\n\n===New Messages===\n\nFour new protocol messages and two inv types are added.\n\n====sendpackages====\n\n{|\n|  Field Name  ||  Type  ||  Size  ||  Purpose\n|-\n|versions || uint64_t || 8 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n|-\n|}\n\n# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n\n# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n\n# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n\n# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\nYes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\nannounce features without first checking what the other peer has sent, and then apply negotiation\nlogic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n</ref>\n\n====ancpkginfo====\n{|\n|  Field Name  ||  Type  ||  Size  ||   Purpose\n|-\n|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n|-\n|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n|}\n\n# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n\n# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\nA simple feerate is typically insufficient; the receiver must also know the dependency\nrelationships between transactions and their respective sizes.\n</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\nIdeally, there should be a way to enforce that peers are providing correct information to each\nother. However, two peers may have different views of what a transaction's unconfirmed ancestors\nare based on their chainstate. For example, during a reorg or when two blocks are found at the same\ntime, one peer may see a transaction as confirmed while the other peer does not.\nAs such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\nIt was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\nto include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\nmake much sense to stop or delay transaction data requests due to mismatched chainstates, and the\nchainstate may change again between package information and transaction data rounds. Instead,\ndifferences in chainstate should be handled at the validation level. The node has already spent\nnetwork bandwidth downloading these transactions; it should make a best effort to validate them.\nSee [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n</ref><ref>'''Why not require topological order?'''\nIt is not possible to determine whether a list of transactions is topologically sorted without first\nestablishing that the list contains a full ancestor package. It is not possible to determine whether\na list of transactions contains a full ancestor package without knowing what the chainstate is.\n</ref>\n\n# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n\n# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n\n# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n\n# This message must only be used if both peers set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n\n====MSG_ANCPKGINFO====\n\n# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n\n# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n\n# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n\n# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n\n# This inv type must only be used if both peers set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n\n====getpkgtxns====\n\n{|\n|  Field Name  ||  Type  ||  Size  ||   Purpose\n|-\n|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n|-\n|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n|}\n\n# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n\n# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n\n# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n\n# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n\n# This message must only be used if both peers set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n\n====pkgtxns====\n\n{|\n|  Field Name  ||  Type  ||  Size  ||   Purpose\n|-\n|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n|-\n|txns||List of transactions||variable|| The transactions in the package.\n|}\n\n# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n\n# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n\n# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n\n# This message must only be used if both peers set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"pkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n\n====MSG_PKGTXNS====\n\n# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n\n# As a \"notfound\" type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash of the wtxids in the getpkgtxns request.\n\n# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" must never be sent. Upon receipt of an \"inv\" or \"getdata\" message of this type, the sender may be disconnected.\n\n# This inv type must only be used if both peers set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message.\n\n==Compatibility==\n\nOlder clients remain fully compatible and interoperable after this change. Clients implementing this\nprotocol will only attempt to send and request packages if agreed upon during the version handshake.\n<ref>'''Will package relay cause non-package relay nodes to waste bandwidth on low-feerate transactions?'''\nIf a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)\ninto its mempool, but non-package relay nodes would most likely reject them. To mitigate bandwidth\nwaste, a package relay node should not announce descendants of below-fee-filter transactions to\nnon-package relay peers.\n</ref>\n<ref>'''Is Package Erlay possible?'''\nA client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay\nwithout interference. After reconciliation, any transaction with unconfirmed ancestors may have\nthose ancestors resolved using ancestor package relay.\n[[File:./bip-0331/package_erlay.png|700px]]\n</ref>\n\n==Extensibility==\n\nThis protocol can be extended to include more types of package information in the future, while\ncontinuing to use the same messages for transaction data download. One would define a new package\ninformation message (named \"*pkginfo\" in the diagram below), allocate its corresponding inv\ntype (named \"*PKGINFO\" in the diagram below), and specify how to signal support using the\nversions field of \"sendpackages\" (an additional bit named \"PKG_RELAY_*\" in the diagram below). A\nfuture version of package relay may allow a sender-initiated dialogue by specifying that the package\ninfo type inv type can be used in an \"inv\" message.\n<br />\n[[File:./bip-0331/sender_init_future_version.png|700px]]\n\n==Implementation==\n\nSample implementation for Bitcoin Core: https://github.com/bitcoin/bitcoin/pull/27742\n\nA prerequisite for implementing a safe\npackage relay protocol is a mempool acceptance policy that safely validates packages of\ntransactions.\n<ref>'''Package Mempool Acceptance Policy'''\nAccepting packages from peers should not significantly increase a node's DoS attack surface;\nprocessing packages should not permit waste or exhaustion of the node and network's resources.\nAdditionally, a sensible mempool acceptance policy should result in the most incentive-compatible\nsubset of the package in the mempool in order to avoid adding more pinning attacks or censorship\nvectors. For example, It should not be assumed that packages are CPFPs. An ancestor package may\ninclude a high-feerate parent and low-feerate child; the policy may choose to accept the parent but\nnot the child. If one or more transactions are policy-invalid, other transactions that are not\ndependent upon them should still be considered.\n</ref>\n\n==Acknowledgements==\n\nThank you to Suhas Daftuar, John Newbery, Anthony Towns, Martin Zumsande, and others for input on the design.\n\nThank you to Will Clark, Sergi Delgado, Fabian Jahr, John Newbery, Greg Sanders, St\u00e9phan Vuylsteke, Pieter Wuille, and others for input on this document.\n\nMuch of this work is inspired by ideas and code by Suhas Daftuar and Antoine Riard.\n<ref>'''Prior Work on Package Relay'''\n* [https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a Strawman Proposal]\n* [https://github.com/bitcoin/bitcoin/issues/14895 Package relay design questions]\n* [https://github.com/bitcoin/bitcoin/pull/16401 Add package acceptance logic to mempool]\n* [https://github.com/bitcoin/bitcoin/pull/19621 [RFC] Package-relay: sender-initiated]\n</ref>\n\n==References and Rationale==\n\n<references/>\n\n", "content_length": 28701}
{"bip_number": 330, "filename": "bip-0330.mediawiki", "content": "<pre>\n  BIP: 330\n  Layer: Peer Services\n  Title: Transaction announcements reconciliation\n  Author: Gleb Naumenko <naumenko.gs@gmail.com>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0330\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-09-25\n  License: CC0-1.0\n  License-Code: MIT\n</pre>\n\n==Abstract==\n\nThis document specifies a P2P protocol extension for reconciliation of transaction announcements <b>between 2 nodes</b>, which is a building block for efficient transaction relay protocols (e.g., [https://arxiv.org/pdf/1905.10518.pdf Erlay]). This is a step towards increasing the connectivity of the network for almost no bandwidth cost.\n\n==Motivation==\n\nCurrently in the Bitcoin network, every 32-byte transaction ID is announced in at least one direction between every pair of connected peers, via INV messages. This results in high cost of announcing transactions: ''O(nodes * connections_per_node)''.\n\nA <b>reconciliation-based protocol</b> which uses the technique suggested in this document can have better scaling properties than INV-based flooding.\n\nIncreasing the connectivity of the network makes the network more robust to partitioning attacks; thus, improving the bandwidth scaling of transaction relay to ''O(nodes)'' (and without a high constant overhead) would allow us to improve the security of the network by increasing connectivity. It would also reduce the bandwidth required to run a Bitcoin node and potentially enable more users to run full nodes.\n\n===Erlay===\n\n[https://arxiv.org/pdf/1905.10518.pdf Erlay] is an example of a high-level transaction relay protocol which employs set reconciliation for bandwidth efficiency.\n\nNote that what we are going to describe here is a modified version from the protocol (it is different from what is presented in the paper).\n\nErlay uses both flooding (announcing using INV messages to all peers) and reconciliation to announce transactions.\nFlooding is expensive, so Erlay seeks to use it only when necessary to facilitate rapid relay over a small subset of connections.\n\nEfficient set reconciliation is meant to deliver transactions to those nodes which didn't receive a transaction via flooding, and also just make sure remaining connections are in sync (directly connected pairs of nodes are aware they have nothing to learn from each other).\n\nEfficient set reconciliation works as follows:\n1) every node keeps a reconciliation set for each peer, in which transactions are placed which would have been announced using INV messages absent this protocol\n2) once in a while every node chooses a peer from its reconciliation queue to reconcile with, resulting in both sides learning the transactions known to the other side\n3) after every reconciliation round, the corresponding reconciliation set is cleared\n\nA more detailed description of a set reconciliation round can be found below.\n\nErlay allows us to:\n* save a significant portion of the bandwidth consumed by a node\n* increase network connectivity for almost no bandwidth or latency cost\n* keep transaction propagation latency at the same level\n\nThis document proposes a P2P-layer extension which is required to enable efficient reconciliation-based protocols (like Erlay) for transaction relay.\n\n==Specification==\n\n===New data structures===\n\nSeveral new data structures are introduced to the P2P protocol first, to aid with efficient transaction relay.\n\n====32-bit short transaction IDs====\n=\nShort IDs are computed as follows:\n* Let ''salt<sub>1</sub>'' and ''salt<sub>2</sub>'' be the entropy contributed by both sides; see the \"sendtxrcncl\" message further for details how they are exchanged.\n* Sort the two salts such that ''salt<sub>1</sub> &le; salt<sub>2</sub>'' (which side sent what doesn't matter).\n* Compute ''h = TaggedHash(\"Tx Relay Salting\", salt<sub>1</sub>, salt<sub>2</sub>)'', where the two salts are encoded in 64-bit little-endian byte order, and TaggedHash is specified by [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP-340].\n* Let ''k<sub>0</sub>'' be the 64-bit integer obtained by interpreting the first 8 bytes of ''h'' in little-endian byte order.\n* Let ''k<sub>1</sub>'' be the 64-bit integer obtained by interpreting the second 8 bytes of ''h'' in little-endian byte order.\n* Let ''s = SipHash-2-4((k<sub>0</sub>,k<sub>1</sub>),wtxid)'', where ''wtxid'' is the transaction hash including witness data as defined by BIP141.\n* The short ID is equal to ''1 + (s mod 0xFFFFFFFF)''.\n\nThis results in approximately uniformly distributed IDs in the range ''[1..0xFFFFFFFF]'', which is a requirement for using them as elements in 32-bit sketches. See the next paragraph for details.\n\n====Short transaction ID sketches====\n\nReconciliation-based relay uses [https://www.cs.bu.edu/~reyzin/code/fuzzy.html PinSketch] BCH-based secure sketches as introduced by the [https://www.cs.bu.edu/~reyzin/fuzzy.html Fuzzy Extractors paper]. They are a form of set checksums with the following properties:\n* Sketches have a predetermined capacity, and when the number of elements in the set does not exceed the capacity, it is always possible to recover the entire set from the sketch by decoding the sketch. A sketch of nonzero b-bit elements with capacity c can be stored in bc bits.\n* A sketch of the [https://en.wikipedia.org/wiki/Symmetric_difference symmetric difference] between the two sets (i.e., all elements that occur in one but not both input sets), can be obtained by combining the sketches of those sets.\n\nThe sketches used here consists of elements of the [https://en.wikipedia.org/wiki/Finite_field finite field] ''GF(2<sup>32</sup>)''. Specifically, we represent finite field elements as polynomials in ''x'' over ''GF(2)'' modulo ''x<sup>32</sup + x<sup>7</sup> + x<sup>3</sup> + x<sup>2</sup> + 1''. To map integers to finite field elements, simply treat each bit ''i'' (with value ''2<sup>i</sup>'') in the integer as the coefficient of ''x<sup>i</sup>'' in the polynomial representation. For example the integer ''101 = 2<sup>6</sup> + 2<sup>5</sup> + 2<sup>2</sup> + 1'' is mapped to field element ''x<sup>6</sup> + x<sup>5</sup> + x<sup>2</sup> + 1''. These field elements can be added and multiplied together, but the specifics of that are out of scope for this document.\n\nA short ID sketch with capacity ''c'' consists of a sequence of ''c'' field elements. The first is the sum of all short IDs in the set, the second is the sum of the 3rd powers of all short IDs, the third is the sum of the 5th powers etc., up to the last element with is the sum of the ''(2c-1)''th powers. These elements are then encoded as 32-bit integers in little endian byte order, resulting in a ''4c''-byte serialization.\n\nThe following Python 3.2+ code implements the creation of sketches: <pre>\nFIELD_BITS = 32\nFIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n\ndef mul2(x):\n    \"\"\"Compute 2*x in GF(2^FIELD_BITS)\"\"\"\n    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n\ndef mul(x, y):\n    \"\"\"Compute x*y in GF(2^FIELD_BITS)\"\"\"\n    ret = 0\n    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n        ret, y = ret ^ bit * y, mul2(y)\n    return ret\n\ndef create_sketch(shortids, capacity):\n    \"\"\"Compute the bytes of a sketch for given shortids and given capacity.\"\"\"\n    odd_sums = [0 for _ in range(capacity)]\n    for shortid in shortids:\n        squared = mul(shortid, shortid)\n        for i in range(capacity):\n            odd_sums[i] ^= shortid\n            shortid = mul(shortid, squared)\n    return b''.join(elem.to_bytes(4, 'little') for elem in odd_sums)\n</pre>\n\nThe [https://github.com/sipa/minisketch/ minisketch] library implements the construction, merging, and decoding of these sketches efficiently.\n\n===Intended Protocol Flow===\n\nSet reconciliation primarily consists of the transmission and decoding of a reconciliation set sketch upon request.\n\nSince sketches are based on the WTXIDs, the negotiation and support of Erlay should be enabled only if both peers signal [https://github.com/bitcoin/bips/blob/master/bip-0339.mediawiki BIP-339] support.\n\n[[File:bip-0330/recon_scheme_merged.png|framed|center|Protocol flow]]\n\n====Sketch extension====\n\nIf a node is unable to reconstruct the set difference from the received sketch, the node then makes a request for sketch extension. The peer would then send an extension, which is a sketch of a higher capacity (allowing to decode more differences) over the same transactions minus the sketch part which was already sent initially (to save bandwidth).\nTo allow this optimization, the initiator is supposed to locally store a sketch received initially.\nThis optimization is possible because extending a sketch is just concatenating new elements to an array.\n\n===New messages===\nSeveral new protocol messages are added: sendtxrcncl, reqrecon, sketch, reqsketchext, reconcildiff. This section describes their serialization, contents, and semantics.\n\nIn what follows, all integers are serialized in little-endian byte order. Boolean values are encoded as a single byte that must be 0 or 1 exactly. Arrays are serialized with the CompactSize prefix that encodes their length, as is common in other P2P messages.\n\n====sendtxrcncl====\nThe sendtxrcncl message announces support for the reconciliation protocol. It is expected to be only sent once, and ignored by nodes that don't support it.\n\nShould be sent before \"verack\" and accompanied by \"wtxidrelay\" (in any order).\n\nIf \"sendtxrcncl\" was sent after \"verack\", the sender should be disconnected.\n\nIf \"sendtxrcncl\" was sent before \"verack\", but by \"verack\" the \"wtxidrelay\" message was not received,\n\"sendtxrcncl\" should be ignored. The connection should proceed normally, but as if reconciliation\nwas not supported.\n\nMust not be sent if peer specified no support for transaction relay (fRelay=0) in \"version\".\nOtherwise, the sender should be disconnected.\n\nIts payload consists of:\n{|class=\"wikitable\"\n! Data type !! Name !! Description\n|-\n| uint32 || version || Sender must set this to 1 currently, otherwise receiver should ignore the message. v1 is the lowest protocol version, everything below that is a protocol violation.\n|-\n| uint64 || salt || The salt used in the short transaction ID computation.\n|}\n\nAfter both peers have confirmed support by sending \"sendtxrcncl\", the initiator of the P2P connection assumes the role of reconciliation initiator (will send \"reqrecon\" messages) and the other peer assumes the role of reconciliation responder (will respond to \"reqrecon\" messages).\n\"reqrecon\" messages can only be sent by the reconciliation initiator.\n\n====reqrecon====\nThe reqrecon message initiates a reconciliation round.\n\n{|class=\"wikitable\"\n! Data type !! Name !! Description\n|-\n| uint16 || set_size || Size of the sender's reconciliation set, used to estimate set difference.\n|-\n| uint16 || q || Coefficient used to estimate set difference. Multiplied by PRECISION=(2^15) - 1 and rounded up by the sender and divided by PRECISION by the receiver.\n|}\n\nUpon receipt of a \"reqrecon\" message, the receiver:\n* Constructs and sends a \"sketch\" message (see below), with a sketch of certain ''capacity=f(set_size, local_set_size, q)'' (the exact function is suggested below), where ''local_set_size'' represents size of the receiver's reconciliation set.\n* Makes a snapshot of their current reconciliation set, and clears the set itself. The snapshot is kept until a \"reconcildiff\" message is received by the node.\n\nNo new \"reqrecon\" message can be sent until a \"reconcildiff\" message is sent.\n\n====sketch====\nThe sketch message is used to communicate a sketch required to perform set reconciliation.\n\n{|class=\"wikitable\"\n! Data type !! Name !! Description\n|-\n| byte[] || skdata || The sketch of the sender's reconciliation snapshot\n|}\n\nThe sketch message may be received in two cases.\n\n1. Initial sketch. Upon receipt of a \"sketch\" message, a node computes the difference sketch by combining the received sketch with a sketch computed locally for a corresponding reconciliation set. The receiving node then tries to decode the difference sketch and based on the result:\n* If the decoding failed, the receiving node requests an extension sketch by sending a \"reqsketchext\" message. Alternatively, the node may terminate the reconciliation right away by sending a \"reconcildiff\" message is sent with the failure flag set (success=false).\n* If the decoding succeeded, a \"reconcildiff\" message with success=true.\nThe receiver also makes snapshot of their current reconciliation set, and clears the set itself. The snapshot is kept until a \"reconcildiff\" message is sent by the node. It is needed to enable sketch extension.\n\n2. Sketch extension. By combining the sketch extension with the initially received sketch, an extended sketch is obtained. The receiving node then computes the extended difference sketch by combining the received extended sketch with an extended sketch computed locally over a corresponding reconciliation set snapshot. The receiving node then tries to decode the extended difference sketch and based on the result:\n* If the decoding failed, the receiving node terminates the reconciliation right away by sending a \"reconcildiff\" message is sent with the failure flag set (success=false).\n* If the decoding succeeded, a \"reconcildiff\" message with success=true.\n\nIn either cases, a \"reconcildiff\" with success=false should also be accompanied with announcing all transactions from the reconciliation set (or set snapshot if failed after extension) as a fallback to flooding.\nA \"reconcildiff\" with success=true should contain unknown short IDs of the transactions from the decoded difference, corresponding to the transactions missing on the sender's side. Known short IDs from the difference correspond to what the receiver of the message is missing, and they should be announced via an \"inv\" message.\n\n====reqsketchext====\nThe reqsketchext message is used by reconciliation initiator to signal that initial set reconciliation has failed and a sketch extension is needed to find set difference.\n\nIt has an empty payload.\n\nUpon receipt of a \"reqsketchext\" message, a node responds to it with a \"sketch\" message, which contains a sketch extension: a sketch (of the same transactions sketched initially) of higher capacity without the part sent initially.\n\n====reconcildiff====\nThe reconcildiff message is used by reconciliation initiator to announce transactions which are found to be missing during set reconciliation on the sender's side.\n\n{|class=\"wikitable\"\n! Data type !! Name !! Description\n|-\n| uint8 || success || Indicates whether sender of the message succeeded at set difference decoding.\n|-\n| uint32[] || ask_shortids || The short IDs that the sender did not have.\n|}\n\nUpon receipt a \"reconcildiff\" message with ''success=1'' (reconciliation success), a node sends an \"inv\" message for the transactions requested by 32-bit IDs (first vector) containing their wtxids (with parent transactions occurring before their dependencies).\nIf ''success=0'' (reconciliation failure), receiver should announce all transactions from the reconciliation set via an \"inv\" message.\nIn both cases, transactions the sender of the message thinks the receiver is missing are announced via an \"inv\" message.\nThe regular \"inv\" deduplication should apply.\n\nThe <b>snapshot</b> of the corresponding reconciliation set is cleared by the sender and the receiver of the message.\n\nThe sender should also send their own \"inv\" message along with the reconcildiff message to announce transactions which are missing on the receiver's side.\n\n==Local state==\n\nThis BIP suggests a stateful protocol and it requires storing several variables at every node to operate properly.\n\n====Reconciliation salt====\nWhen negotiating reconciliation support, peers send each other their contribution to the reconciliation salt (see how we construct short IDs above). These salts (or just the resulting salt) should be stored on both sides of the connection.\n\n====Reconciliation sets====\nEvery node stores a set of wtxids for every peer which supports transaction reconciliation, representing the transactions which would have been sent according to the regular flooding protocol.\nIncoming transactions are added to sets when those transactions are received (if they satisfy the policies such as minimum fee set by a peer).\nA reconciliation set is moved to the corresponding set snapshot after the transmission of the initial sketch.\n\n====Reconciliation set snapshot====\nAfter transmitting the initial sketch (either sending or receiving of the reconcildiff message), every node should store the snapshot of the current reconciliation set, and clear the set.\nThis is important to make sketch extension more stable (extension should be computed over the set snapshot). Otherwise, extension would contain transactions received after sending out the initial sketch.\nThe snapshot is cleared after the end of the reconciliation round (sending or receiving of the reconcildiff message).\n\n====Sketch capacity estimation and q-coefficient====\n\nEarlier we suggested that upon receiving a reconciliation request, a node should estimate the sketch capacity it should send: ''capacity=f(set_size, local_set_size, q)''.\n\nWe suggest the following function: ''capacity=|set_size - local_set_size| + q * min(set_size, local_set_size) + c''.\n\nIntuitively, ''q'' represents the discrepancy in sets: the closer the sets are, the lower optimal ''q'' is.\nPer the Erlay paper, ''q'' should be derived as an optimal ''q'' value for the previous reconciliation with a given peer, once the actual set sizes and set difference are known.\nFor example, if in previous round ''set_size=30'' and ''local_set_size=20'', and the *actual* difference was ''12'', then a node should compute ''q'' as following:\n''q=(12 - |30-20|) / min(30, 20)=0.1''\n\nThe derivation of ''q'' can be changed according to the version of the protocol. For example, a static value could be chosen for simplicity. However, we suggest that ''q'' remains a parameter sent in every reconciliation request to enable future compatibility with more sophisticated (non-static) choices of this parameter.\n\nAs for the ''c'' parameter, it is suggested to use ''c=1'' to avoid sending empty sketches and reduce the overhead caused by under-estimations.\n\n==Backward compatibility==\n\nOlder clients remain fully compatible and interoperable after this change.\n\nClients which do not implement this protocol remain fully compatible after this change using existing protocols, because transaction announcement reconciliation is used only for peers that negotiate support for it.\n\n==Rationale==\n\n====Why use PinSketch for set reconciliation?====\n\nPinSketch is more bandwidth efficient than IBLT, especially for the small differences in sets we expect to operate over.\nPinSketch is as bandwidth efficient as CPISync, but PinSketch has quadratic decoding complexity, while CPISync have cubic decoding complexity. This makes PinSketch significantly faster.\n\n====Why use 32-bit short transaction IDs?====\n\nTo use Minisketch in practice, transaction IDs should be shortened (ideally, not more than 64 bits per element).\nA small number of bits per transaction also allows saving extra bandwidth and make operations over sketches faster.\nAccording to our estimates, 32 bits provides low collision rate in a non-adversarial model (which is enabled by using independent salts per-link).\n\n====Why use sketch extensions instead of bisection?====\n\nBisection is an alternative to sketch extensions, per which a second sketch with the same initial capacity is computed over half of the txID space.\nDue to the linearity of sketches, transmitting just this one allows a reconciliation initiator to compute the sketch of the same capacity of another half. Two sketches allow the initiator to reconstruct twice as many differences as was allowed by an initial sketch.\n\nIn practice this allows the initiator to amortize the bandwidth overhead of initial reconciliation failure, similarly to extension sketches, making the overhead negligible.\n\nThe main benefit of sketch extensions is a much simpler implementation. Implementing bisection is hard (see [https://github.com/naumenkogs/bitcoin/commit/b5c92a41e4cc0599504cf838d20212f1a403e573 implementation]) because, in the end, we have to operate with two sketches and handle scenarios where one sketch decoded and another sketch failed.\n\nIt becomes even more difficult if in the future we decide to allow more than one extension/bisection. Bisection in this case have to be recursive (and spawn 4/8/16/... sketches), while for extensions we always end up with one extended sketch.\n\nSketch extensions are also more flexible: extending a sketch of capacity 10 with 4 more means just computing a sketch of capacity 14 and sending the extension, while for bisection increasing the capacity to something different than 10*2/10*4/10*8/... is sophisticated implementation-wise.\n\nThe only advantage of bisection is that it doesn't require computing sketches of higher capacities (exponential cost). We believe that since\nthe protocol is currently designed to operate in the conditions where sketches usually have at most the capacity of 20, this efficiency is not crucial.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/21515\n\n==Acknowledgments==\n\nA large fraction of this proposal was done during designing Erlay with Gregory Maxwell, Sasha Fedorova and Ivan Beschastnikh.\nWe would like to thank Suhas Daftuar for contributions to the design and BIP structure.\nWe would like to thank Ben Woosley for contributions to the high-level description of the idea.\n\n==Copyright==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n", "content_length": 21815}
{"bip_number": 329, "filename": "bip-0329.mediawiki", "content": "<pre>\n  BIP: 329\n  Layer: Applications\n  Title: Wallet Labels Export Format\n  Author: Craig Raw <craig@sparrowwallet.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0329\n  Status: Draft\n  Type: Informational\n  Created: 2022-08-23\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document specifies a format for the export of labels that may be attached to various common types of records in a wallet.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nThe export and import of funds across different Bitcoin wallet applications is well defined through standards such as BIP39, BIP32, BIP44 etc.\nThese standards are well supported and allow users to move easily between different wallets.\nThere is, however, no defined standard to transfer any labels the user may have applied to the transactions, addresses, public keys, inputs, outputs or xpubs in their wallet.\nThe UTXO model that Bitcoin uses makes these labels particularly valuable as they may indicate the source of funds, whether received externally or as a result of change from a prior transaction.\nIn both cases, care must be taken when spending to avoid undesirable leaks of private information.\n\nLabels provide valuable guidance in this regard, and have even become mandatory when spending in several Bitcoin wallets.\nAllowing users to import and export their labels in a standardized way ensures that they do not experience lock-in to a particular wallet application.\nIn addition, many wallets allow unspent outputs to be frozen or made unspendable within the wallet. Since this wallet-related metadata is similar to labels and not captured elsewhere, it is also included in this format.\n\n==Rationale==\n\nWhile there is currently no widely accepted format for exporting and importing labels, there are existing formats in use.\nSLIP-0015<ref>[https://github.com/satoshilabs/slips/blob/master/slip-0015.md SLIP-0015]</ref> defines a format for exporting address and output labels, but requires encryption using a private key associated with the wallet seed, and thus cannot be used independently by coordinator wallets which cannot access private keys.\nThe Electrum wallet imports and exports address and transaction labels in a JSON format which could be used with other record types, but the format used is not self describing making record type identification difficult.\n\n==Specification==\n\nIn order to be lightweight, human readable and well structured, this BIP uses a JSON format.\nFurther, the JSON Lines format is used (also called newline-delimited JSON)<ref>[https://jsonlines.org/ jsonlines.org]</ref>.\nThis allows a document to be split, streamed, or incrementally added to, and limits the potential for formatting errors to invalidate an entire import.\nIt is also a convenient format for command-line processing, which is often line-oriented.\n\nFurther to the JSON Lines specification, an export of labels from a wallet must be a UTF-8 encoded text file, containing one record per line consisting of a valid JSON object.\nLines are separated by <tt>\\n</tt>. Multiline values are not permitted.\nEach JSON object must contain 3 or 4 key/value pairs, defined as follows:\n\n{| class=\"wikitable\"\n|-\n! Key\n! Description\n|-\n| <tt>type</tt>\n| One of <tt>tx</tt>, <tt>addr</tt>, <tt>pubkey</tt>, <tt>input</tt>, <tt>output</tt> or <tt>xpub</tt>\n|-\n| <tt>ref</tt>\n| Reference to the transaction, address, public key, input, output or extended public key\n|-\n| <tt>label</tt>\n| The label applied to the reference\n|-\n| <tt>origin</tt>\n| Optional key origin information referencing the wallet associated with the label\n|-\n| <tt>spendable</tt>\n| One of <tt>true</tt> or <tt>false</tt>, denoting if an output should be spendable by the wallet\n|}\n\nThe reference is defined for each <tt>type</tt> as follows:\n\n{| class=\"wikitable\"\n|-\n! Type\n! Description\n! Example\n|-\n| <tt>tx</tt>\n| Transaction id in hexadecimal format\n| <tt>f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd</tt>\n|-\n| <tt>addr</tt>\n| Address in base58 or bech32 format\n| <tt>bc1q34aq5drpuwy3wgl9lhup9892qp6svr8ldzyy7c</tt>\n|-\n| <tt>pubkey</tt>\n| 32, 33 or 65 byte public key in hexadecimal format\n| <tt>0283409659355b6d1cc3c32decd5d561abaac86c37a353b52895a5e6c196d6f448</tt>\n|-\n| <tt>input</tt>\n| Transaction id and input index separated by a colon\n| <tt>f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd:0</tt>\n|-\n| <tt>output</tt>\n| Transaction id and output index separated by a colon\n| <tt>f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd:1</tt>\n|-\n| <tt>xpub</tt>\n| Extended public key as defined by BIP32\n| <tt>xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8Nq...</tt>\n|}\n\nEach JSON object must contain both <tt>type</tt> and <tt>ref</tt> properties. The <tt>label</tt>, <tt>origin</tt> and <tt>spendable</tt> properties are optional. If the <tt>label</tt> or <tt>spendable</tt> properties are omitted, the importing wallet should not alter these values. The <tt>spendable</tt> property should only appear where type is <tt>output</tt>.\n\nIf present, the optional <tt>origin</tt> property must contain an abbreviated output descriptor (as defined by BIP380<ref>[https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki BIP-0380]</ref>) describing a BIP32 compatible originating wallet, including all key origin information but excluding any actual keys, any child path elements, or a checksum.\nThis property should be used to disambiguate transaction labels from different wallets contained in the same export, particularly when exporting multiple accounts derived from the same seed.\n\nCare should be taken when exporting due to the privacy sensitive nature of the data.\nEncryption in transit over untrusted networks is highly recommended, and encryption at rest should also be considered.\nUnencrypted exports should be deleted as soon as possible.\nFor security reasons no private key types are defined.\n\n==Importing==\n\n* An importing wallet may ignore records it does not store, and truncate labels if necessary. A suggested default for maximum label length is 255 characters, and an importing wallet should consider warning the user if truncation is applied.\n* Wallets importing public key records may derive addresses from them to match against known wallet addresses.\n* Wallets importing extended public keys may match them against signers, for example in a multisig setup.\n\n==Backwards Compatibility==\n\nThe nature of this format makes it naturally extensible to handle other record types.\nHowever, importing wallets complying to this specification should ignore types not defined here.\n\n==Test Vectors==\n\nThe following fragment represents a wallet label export:\n<pre>\n{ \"type\": \"tx\", \"ref\": \"f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd\", \"label\": \"Transaction\", \"origin\": \"wpkh([d34db33f/84'/0'/0'])\" }\n{ \"type\": \"addr\", \"ref\": \"bc1q34aq5drpuwy3wgl9lhup9892qp6svr8ldzyy7c\", \"label\": \"Address\" }\n{ \"type\": \"pubkey\", \"ref\": \"0283409659355b6d1cc3c32decd5d561abaac86c37a353b52895a5e6c196d6f448\", \"label\": \"Public Key\" }\n{ \"type\": \"input\", \"ref\": \"f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd:0\", \"label\": \"Input\" }\n{ \"type\": \"output\", \"ref\": \"f91d0a8a78462bc59398f2c5d7a84fcff491c26ba54c4833478b202796c8aafd:1\", \"label\": \"Output\", \"spendable\": false }\n{ \"type\": \"xpub\", \"ref\": \"xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8\", \"label\": \"Extended Public Key\" }\n{ \"type\": \"tx\", \"ref\": \"f546156d9044844e02b181026a1a407abfca62e7ea1159f87bbeaa77b4286c74\", \"label\": \"Account #1 Transaction\", \"origin\": \"wpkh([d34db33f/84'/0'/1'])\" }\n</pre>\n\n==Additional Fields==\n\nIf the goal is solely to move labels between cooperating wallets,\nthen the above values are the minimum needed. However, wallet data\nexports can serve other purposes. Many values associated with\naddresses, transactions and outputs are already on hand for the\nwallet generating the export, and yet would be hard or impossible\nfor importing tools to reconstruct.\n\nAll of the following values are optional for the exporter to provide,\nbut should be given if they are readily available.\n\n=== Transactions ===\n\n* <tt>height</tt>: An integer giving the block height where this fully confirmed transaction can be found. For transactions that are confirmed by less than 6 blocks, omit this field or provide a value of zero.  (Background: Until it is fully confirmed, the \"height\" of a transaction is in flux and may vary due to chain reorgs. However, the consumer of the labels, may not know the current block height, so it cannot know if the height is \"real\" (firm, fixed) or just transitory. Therefore, it is important to omit the height unless the generating wallet considers the transaction to be confirmed.)\n\n* <tt>time</tt>: ISO-8601 formatted timestamp of the block given by the \"height\" field, preferably in UTC, although ISO-8601 can represent local times. Example: <tt>2025-01-23T11:40:35Z</tt>.\n\n* <tt>fee</tt>: Integer giving the number of Satoshis that went to the miner for this transaction.\n\n* <tt>value</tt>: Signed integer giving the number of Satoshis that came into the wallet by this transaction. Will be negative when sats leave the wallet. Could be zero if it is a consolidation transaction that moves from old UTXO to new. \n\n* <tt>rate</tt>: Exchange rate at time of transaction. This is the value of a Bitcoin, expressed in another currency, at the time of the transaction, based on user preferences for data source. Multiple currencies can be given. Keys are ISO 4217 currency codes where possible. Example: <tt>\"rate\": { \"USD\":  105620.00 }</tt>\n\n=== Address, Inputs, and Outputs ===\n\n* <tt>keypath</tt>: The data needed to build full descriptor down to the specific address.  This extends <tt>origin</tt> with the final two components that are unhardened (in the typical case, assuming BIP-84).  Provide string <tt>/1/123</tt> for <tt>wpkh([d34db33f/84'/0'/0'/1/123])</tt>. If the first character is not <tt>/</tt>, then it should be interpreted as a full descriptor, independent of <tt>origin</tt> (if any).\n\n=== Inputs and Outputs ===\n\n* <tt>value</tt>: Integer with the number of Satoshis (<tt>nValue</tt>) of the input or output.\n\n* <tt>fmv</tt>: Fair market value of the input/output relative to some other currency, typically fiat. The value should be a mapping, from currency code to decimal number. Example: <tt>\"fmv\": { \"USD\":  1233.45 }</tt>. Most situations will have only a single currency value, and it represents the real price of the goods/services expressed in some fiat currency. This is not an exchange *rate*, but an absolute value. By dividing by the <tt>value</tt> (above), it is possible to calculate an effective change rate for the transaction.\n\n* <tt>height</tt> and <tt>time</tt>: Same definition as defined in Transactions.\n\n=== Address ===\n\n* <tt>heights</tt>: a list of block heights that contain any activity related to this address, include outputs that deposit to the address, and transactions that spend UTXOs of this address. Omit heights for transactions that are not fully confirmed. An empty array indicates the address is unused for confirmed transactions.\n\n== Comment on Types in JSON ==\n\nJSON can serialize a number of basic types, including string, integer\nand boolean (true/false).  Decimal values (<tt>123.45</tt>) can\nalso be serialized, but some parsing libraries may interpret them as floating\npoint values, which is generally not what we want in financial applications.\nWhen hand-crafting JSON data, be careful not to write <tt>\"false\"</tt> (with quotes),\nsince that is a string with 5 characters and not a boolean.\n\n==Reference Implementation==\n\n* [https://github.com/Labelbase/python-bip329 Python-BIP329 package]\n\n==References==\n\n<references />\n", "content_length": 11853}
{"bip_number": 328, "filename": "bip-0328.mediawiki", "content": "<pre>\n  BIP: 328\n  Layer: Applications\n  Title: Derivation Scheme for MuSig2 Aggregate Keys\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0328\n  Status: Proposed\n  Type: Informational\n  Created: 2024-06-04\n  License: CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies how BIP 32 extended public keys can be constructed from a BIP 327 MuSig2\naggregate public key and how such keys should be used for key derivation.\n\n==Copyright==\n\nThis BIP is licensed under the Creative Commons CC0 1.0 Universal license.\n\n==Motivation==\n\nMultiple signers can create a single aggregate public key with MuSig2 that is indistinguishable\nfrom a random public key. The cosigners need a method for generating additional aggregate pubkeys\nto follow the best practice of using a new address for every payment.\n\nThe obvious method is for the cosigners to generate multiple public keys and produce a\nnew aggregate pubkey every time one is needed. This is similar to how multisig using Bitcoin script\nworks where all of the cosigners share their extended public keys and do derivation to produce\nthe multisig script. The same could be done with MuSig2 and instead of producing a multisig script,\nthe result would be a MuSig2 aggregate pubkey.\n\nHowever, it is much simpler to be able to derive from a single extended public key instead of having\nto derive from many extended public keys and aggregate them. As MuSig2 produces a normal looking\npublic key, the aggregate public can be used in this way. This reduces the storage and computation\nrequirements for generating new aggregate pubkeys.\n\n==Specification==\n\nA synthetic xpub can be created from a BIP 327 MuSig2 plain aggregate public key by setting\nthe depth to 0, the child number to 0, and attaching a chaincode with the byte string\n<tt>868087ca02a6f974c4598924c36b57762d32cb45717167e300622c7167e38965</tt><ref>'''Where does this\nconstant chaincode come from?''' It is the SHA256 of the text <tt>MuSig2MuSig2MuSig2</tt></ref>.\nThis fixed chaincode should be used by all such synthetic xpubs following this specification.\nUnhardened child public keys can be derived from the synthetic xpub as with any other xpub. Since\nthe aggregate public key is all that is necessary to produce the synthetic xpub, any aggregate\npublic key that will be used in this way shares the same privacy concerns as typical xpubs.\n\nFurthermore, as there is no aggregate private key, only unhardened derivation from the aggregate\npublic key is possible.\n\nWhen signing, all signers must compute the tweaks used in the BIP 32 derivation for the child key\nbeing signed for. The I<sub>L</sub> value computed in ''CKDpub'' is the tweak used at each\nderivation step. These are provided in the session context, each with a tweak mode of plain\n(''is_xonly_t = false''). When the ''Sign'' algorithm is used, the tweaks will be applied to the\npartial signatures.\n\n==Test Vectors==\n\n* Aggregate pubkey <tt>0354240c76b8f2999143301a99c7f721ee57eee0bce401df3afeaa9ae218c70f23</tt>\n** Synthetic xpub <tt>xpub661MyMwAqRbcFt6tk3uaczE1y6EvM1TqXvawXcYmFEWijEM4PDBnuCXwwXEKGEouzXE6QLLRxjatMcLLzJ5LV5Nib1BN7vJg6yp45yHHRbm</tt>\n** Keys:\n*** <tt>03935F972DA013F80AE011890FA89B67A27B7BE6CCB24D3274D18B2D4067F261A9</tt>\n*** <tt>02F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9</tt>\n* Aggregate pubkey <tt>0290539eede565f5d054f32cc0c220126889ed1e5d193baf15aef344fe59d4610c</tt>\n** Synthetic xpub <tt>xpub661MyMwAqRbcFt6tk3uaczE1y6EvM1TqXvawXcYmFEWijEM4PDBnuCXwwVk5TFJk8Tw5WAdV3DhrGfbFA216sE9BsQQiSFTdudkETnKdg8k</tt>\n** Keys:\n*** <tt>02F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9</tt>\n*** <tt>03DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659</tt>\n*** <tt>023590A94E768F8E1815C2F24B4D80A8E3149316C3518CE7B7AD338368D038CA66</tt>\n* Aggregate pubkey <tt>022479f134cdb266141dab1a023cbba30a870f8995b95a91fc8464e56a7d41f8ea</tt>\n** Synthetic xpub <tt>xpub661MyMwAqRbcFt6tk3uaczE1y6EvM1TqXvawXcYmFEWijEM4PDBnuCXwwUvaZYpysLX4wN59tjwU5pBuDjNrPEJbfxjLwn7ruzbXTcUTHkZ</tt>\n** Keys:\n*** <tt>02DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659</tt>\n*** <tt>023590A94E768F8E1815C2F24B4D80A8E3149316C3518CE7B7AD338368D038CA66</tt>\n*** <tt>02F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9</tt>\n*** <tt>03935F972DA013F80AE011890FA89B67A27B7BE6CCB24D3274D18B2D4067F261A9</tt>\n\n==Backwards Compatibility==\n\nOnce a synthetic xpub is created, it is fully backwards compatible with BIP 32 - only unhardened\nderivation can be done, and the signers will be able to produce a signature for any derived children.\n\n==Rationale==\n\n<references/>\n\n==Reference Implementation==\n\nA Python reference implementation is available in this BIP's [[bip-0328|Auxiliary Files]].\n\n==Acknowledgements==\n\nThanks to Pieter Wuille, Andrew Poelstra, Sanket Kanjalkar, Salvatore Ingala, and all others who\nparticipated in discussions on this topic.\n", "content_length": 4967}
{"bip_number": 327, "filename": "bip-0327.mediawiki", "content": "<pre>\n  BIP: 327\n  Title: MuSig2 for BIP340-compatible Multi-Signatures\n  Author: Jonas Nick <jonasd.nick@gmail.com>\n          Tim Ruffing <crypto@timruffing.de>\n          Elliott Jin <elliott.jin@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0327\n  Status: Final\n  Type: Informational\n  Created: 2022-03-22\n  License: BSD-3-Clause\n  Post-History: 2022-04-05: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020198.html [bitcoin-dev] MuSig2 BIP\n                2022-10-11: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html [bitcoin-dev] MuSig2 BIP\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\n\nThis document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] multi-signature scheme.\nThe standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\nIt supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate public keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n\n=== Copyright ===\n\nThis document is licensed under the 3-clause BSD license.\n\n=== Motivation ===\n\nMuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate public key.\nSigning requires interaction between ''all'' signers involved in key aggregation.\n(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n\nThe primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\nSuch an output contains a public key which, in this case, would be the aggregate of all users' individual public keys.\nIt can be spent using MuSig2 to produce a signature for the key-based spending path.\n\nThe on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\nAs a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n\nMoreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate public key, the shared Taproot output can have script spending paths that are hidden unless used.\n\nThere are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\nThe MuSig2 variant proposed below stands out by combining all the following features:\n* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature schemes such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the algorithms and reduces the probability that implementations and users make security-relevant mistakes.\n* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n\n=== Design ===\n\n* '''Compatibility with BIP340''': In this proposal, the aggregate public key is a BIP340 X-only public key, and the signature output at the end of the signing protocol is a BIP340 signature that passes BIP340 verification for the aggregate public key and a message. The individual public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n* '''Tweaking for BIP32 derivations and Taproot''': This proposal supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See [[#tweaking-the-aggregate-public-key|below]] for details.\n* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or the exact set of signers is determined. Once the parameters of the signing session are finalized, the signers can send partial signatures without additional interaction.\n* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order in which the individual public keys are provided as input. Key aggregation does not sort the individual public keys by default because applications often already have a canonical order of signers. Nonetheless, applications can mandate sorting before aggregation,<ref>Applications that sort individual public keys before aggregation should ensure that the implementation of sorting is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref> and this proposal specifies a canonical order to sort the individual public keys before key aggregation. Sorting will ensure the same output, independent of the initial order.\n* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the signing protocol, the signing session will fail to produce a valid Schnorr signature. This proposal specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n* '''MuSig2* optimization''': This proposal uses an optimized scheme MuSig2*, which allows saving a point multiplication in key aggregation as compared to MuSig2. MuSig2* is proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization consists of assigning the constant key aggregation coefficient ''1'' to the second distinct key in the list of individual public keys to be aggregated (as well as to any key identical to this key).\n* '''Size of the nonce and security''': In this proposal, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n\n== Overview ==\n\nImplementers must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n\n=== Optionality of Features ===\n\nThe goal of this proposal is to support a wide range of possible application scenarios.\nGiven a specific application scenario, some features may be unnecessary or not desirable, and implementers can choose not to support them.\nSuch optional features include:\n* Applying plain tweaks after x-only tweaks.\n* Applying tweaks at all.\n* Dealing with messages that are not exactly 32 bytes.\n* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n* Dealing with duplicate individual public keys in key aggregation.\nIf applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\nSimilarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n\n=== General Signing Flow ===\n\nThe signers start by exchanging their individual public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\nWhenever they want to sign a message, the basic order of operations to create a multi-signature is as follows:\n\n'''First broadcast round:'''\nThe signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''.<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>\nThen, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n\n'''Second broadcast round:'''\nAt this point, every signer has the required data to sign, which, in the algorithms specified below, is stored in a data structure called [[#session-context|Session Context]].\nEvery signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\nThen, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\nIf all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n\nBoth broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregate result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n\n'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\nOtherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\nTo avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\nA ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n\nTo simplify the specification of the algorithms, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\nActual implementations can cache these values.\nAs a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\nHowever, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\nThis party would have complete control over the aggregate public key and message to be signed.\n\n=== Public Key Aggregation  ===\n\nWe distinguish between two public key types, namely ''plain public keys'', the key type traditionally used in Bitcoin, and ''X-only public keys''.\nPlain public keys are byte strings of length 33 (often called ''compressed'' format).\nIn contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n\nThe individual public keys of signers as input to the key aggregation algorithm ''KeyAgg'' (and to ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\nThe output of ''KeyAgg'' is a [[#keyagg-context|KeyAgg Context]] which stores information required for tweaking the aggregate public key (see [[#tweaking-the-aggregate-public-key|below]]),\nand it can be used to produce an X-only aggregate public key, or a plain aggregate public key.\nIn order to obtain an X-only public key compatible with BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyAgg Context.\nTo get the plain aggregate public key, which is required for some applications of [[#tweaking-the-aggregate-public-key|tweaking]], implementations call ''GetPlainPubkey'' instead.\n\nThe aggregate public key produced by ''KeyAgg'' (regardless of the type) depends on the order of the individual public keys.\nIf the application does not have a canonical order of the signers, the individual public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate public key is independent of the order of signers.\n\nThe same individual public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\nThis is by design: All algorithms in this proposal handle multiple signers who (claim to) have identical individual public keys properly,\nand applications are not required to check for duplicate individual public keys.\nIn fact, applications are recommended to omit checks for duplicate individual public keys in order to simplify error handling.\nMoreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with an individual public key honestly and which disruptive signer copied it.\nIn contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifying-disruptive-signers|Identifying Disruptive Signers]]).\n\nWhile the algorithms in this proposal are able to handle duplicate individual public keys, there are scenarios where applications may choose to abort when encountering duplicates.\nFor example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\nIn that case, duplicates may not result from a malicious signing device copying an individual public key of another signing device but from accidental initialization of two devices with the same seed.\nSince MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate individual public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n\n=== Nonce Generation ===\n\n'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\nIn contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active adversaries can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n\nThe optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\nIf the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed to be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\nTherefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\nThe auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\ne.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\nHowever, the protection provided by the optional arguments should only be viewed as a last resort.\nIn most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active adversary.\n\nIn some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their individual public keys, or the message to sign is known.\nIn this case, only the available arguments are provided to the ''NonceGen'' algorithm.\nAfter this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\nThis way, the final signature is created quicker and with fewer round trips.\nHowever, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\nMoreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n\nInstead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\nThis technique reduces the overall communication.\nA malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n\nIn general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\nHowever, it is possible for one of the signers to be stateless.\nThis signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, individual public keys, and tweaks are determined.\nThen, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\nStateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n\n=== Identifying Disruptive Signers ===\n\nThe signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\nThis property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n\nAborts are identifiable for an honest party if the following conditions hold in a signing session:\n* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n\nIf these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\nAdditionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n\n==== Further Remarks ====\n\nSome of the algorithms specified below may also assign blame to a malicious aggregator.\nWhile this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\nMore specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n\nThe only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\nIn particular, partial signatures are ''not'' signatures.\nAn adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed individual public key.<ref>Assume an adversary wants to forge a partial signature for individual public key ''P''. It joins the signing session pretending to be two different signers, one with individual public key ''P'' and one with another individual public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'' but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b a write up by Adam Gibson].</ref>\nHowever, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of individual public keys, it is an open question whether a BIP-340 signature valid under the corresponding aggregate public key is a proof of knowledge of all secret keys of the individual public keys.</ref>\n\n=== Tweaking the Aggregate Public Key ===\n\nThe aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\nIn order to apply a tweak, the KeyAgg Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\nThe resulting KeyAgg Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n\nThe purpose of supporting tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\nThe MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the security of the scheme.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\nInstead, signers should obtain the tweaks according to other specifications.\nThis typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\nDepending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\nFor example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n\nThe tweak mode provided to ''ApplyTweak'' depends on the application:\nPlain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\nOn the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\nA Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\nScript path spends require a control block that contains a parity bit for the tweaked X-only public key.\nThe bit can be obtained with ''GetPlainPubkey(keyagg_ctx)[0] & 1''.\n\n== Algorithms ==\n\nThe following specification of the algorithms has been written with a focus on clarity.\nAs a result, the specified algorithms are not always optimal in terms of computation and space.\nIn particular, some values are recomputed but can be cached in actual implementations (see [[#general-signing-flow|General Signing Flow]]).\n\n=== Notation ===\n\nThe following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n* Lowercase variables represent integers or byte arrays.\n** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n** ''is_infinite(P)'' returns whether ''P'' is the point at infinity.\n** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (\u22c5) of an integer and a point] refers to the repeated application of the group operation.\n* Functions and operations:\n** ''||'' refers to byte array concatenation.\n** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n*** Fail if ''x &gt; p-1''.\n*** Let ''c = x<sup>3</sup> + 7 mod p''.\n*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n* Other:\n** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n\n=== Key Generation and Aggregation ===\n\n==== Key Generation of an Individual Signer ====\n\n<div>\nAlgorithm ''IndividualPubkey(sk)'':<ref>The ''IndividualPubkey'' algorithm matches the key generation procedure traditionally used for ECDSA in Bitcoin</ref>\n* Inputs:\n** The secret key ''sk'': a 32-byte array, freshly generated uniformly at random\n* Let ''d' = int(sk)''.\n* Fail if ''d' = 0'' or ''d' &ge; n''.\n* Return ''cbytes(d'\u22c5G)''.\n</div>\n\n==== KeyAgg Context ====\n\nThe KeyAgg Context is a data structure consisting of the following elements:\n* The point ''Q'' representing the potentially tweaked aggregate public key: an elliptic curve point\n* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n* The value ''gacc'' : 1 or -1 mod n\n\nWe write \"Let ''(Q, gacc, tacc) = keyagg_ctx''\" to assign names to the elements of a KeyAgg Context.\n\n<div>\nAlgorithm ''GetXonlyPubkey(keyagg_ctx)'':\n* Let ''(Q, _, _) = keyagg_ctx''\n* Return ''xbytes(Q)''\n</div>\n\n<div>\nAlgorithm ''GetPlainPubkey(keyagg_ctx)'':\n* Let ''(Q, _, _) = keyagg_ctx''\n* Return ''cbytes(Q)''\n</div>\n\n==== Key Sorting ====\n\n<div>\nAlgorithm ''KeySort(pk<sub>1..u</sub>)'':\n* Inputs:\n** The number ''u'' of individual public keys with ''0 < u < 2^32''\n** The individual public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n</div>\n\n==== Key Aggregation ====\n\n<div>\nAlgorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n* Inputs:\n** The number ''u'' of individual public keys with ''0 < u < 2^32''\n** The individual public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n* For ''i = 1 .. u'':\n** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid individual public key.\n** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n* Let ''Q = a<sub>1</sub>\u22c5P<sub>1</sub> + a<sub>2</sub>\u22c5P<sub>2</sub> + ... + a<sub>u</sub>\u22c5P<sub>u</sub>''\n* Fail if ''is_infinite(Q)''.\n* Let ''gacc = 1''\n* Let ''tacc = 0''\n* Return ''keyagg_ctx = (Q, gacc, tacc)''.\n</div>\n\n<div>\nInternal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n</div>\n\n<div>\nInternal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n* For ''j = 1 .. u'':\n** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n*** Return ''pk<sub>j</sub>''\n* Return ''bytes(33, 0)''\n</div>\n\n<div>\nInternal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n</div>\n\n<div>\nInternal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n* If ''pk' = pk2'':\n** Return 1\n* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the individual public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n</div>\n\n==== Applying Tweaks ====\n\n<div>\nAlgorithm ''ApplyTweak(keyagg_ctx, tweak, is_xonly_t)'':\n* Inputs:\n** The ''keyagg_ctx'': a [[#keyagg-context|KeyAgg Context]] data structure\n** The ''tweak'': a 32-byte array\n** The tweak mode ''is_xonly_t'': a boolean\n* Let ''(Q, gacc, tacc) = keyagg_ctx''\n* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n** Let ''g = -1 mod n''\n* Else:\n** Let ''g = 1''\n* Let ''t = int(tweak)''; fail if ''t &ge; n''\n* Let ''Q' = g\u22c5Q + t\u22c5G''\n** Fail if ''is_infinite(Q')''\n* Let ''gacc' = g\u22c5gacc mod n''\n* Let ''tacc' = t + g\u22c5tacc mod n''\n* Return ''keyagg_ctx' = (Q', gacc', tacc')''\n</div>\n\n=== Nonce Generation ===\n\n<div>\nAlgorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n* Inputs:\n** The secret signing key ''sk'': a 32-byte array (optional argument)\n** The individual public key ''pk'': a 33-byte array (see [[#signing-with-tweaked-individual-keys|Signing with Tweaked Individual Keys]] for the reason that this argument is mandatory)\n** The x-only aggregate public key ''aggpk'': a 32-byte array (optional argument)\n** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n* If the optional argument ''sk'' is present:\n** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>\n* Else:\n** Let ''rand = rand' ''\n* If the optional argument ''aggpk'' is not present:\n** Let ''aggpk = empty_bytestring''\n* If the optional argument ''m'' is not present:\n** Let ''m_prefixed = bytes(1, 0)''\n* Else:\n** Let ''m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m''\n* If the optional argument ''extra_in'' is not present:\n** Let ''extra_in = empty_bytestring''\n* Let ''k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n* Let ''R<sub>\u204e,1</sub> = k<sub>1</sub>\u22c5G, R<sub>\u204e,2</sub> = k<sub>2</sub>\u22c5G''\n* Let ''pubnonce = cbytes(R<sub>\u204e,1</sub>) || cbytes(R<sub>\u204e,2</sub>)''\n* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''<ref name=\"secnonce\">The algorithms as specified here assume that the ''secnonce'' is stored as a 97-byte array using the serialization ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''. The same format is used in the reference implementation and in the test vectors. However, since the ''secnonce'' is (obviously) not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the ''secnonce'' is merely a suggestion.<br />\nThe ''secnonce'' is effectively a local data structure of the signer which comprises the value triple ''(k<sub>1</sub>, k<sub>2</sub>, pk)'', and implementations may choose any suitable method to carry it from ''NonceGen'' (first communication round) to ''Sign'' (second communication round). In particular, implementations may choose to hide the ''secnonce'' in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a ''secnonce'' accidentally.</ref>\n* Return ''(secnonce, pubnonce)''\n</div>\n\n=== Nonce Aggregation ===\n\n<div>\nAlgorithm ''NonceAgg(pubnonce<sub>1..u</sub>)'':\n* Inputs:\n** The number ''u'' of ''pubnonces'' with ''0 < u < 2^32''\n** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n* For ''j = 1 .. 2'':\n** For ''i = 1 .. u'':\n*** Let ''R<sub>i,j</sub> = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])''; fail if that fails and blame signer ''i'' for invalid ''pubnonce''.\n** Let ''R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... + R<sub>u,j</sub>''\n* Return ''aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)''\n</div>\n\n=== Session Context ===\n\nThe Session Context is a data structure consisting of the following elements:\n* The aggregate public nonce ''aggnonce'': a 66-byte array\n* The number ''u'' of individual public keys with ''0 < u < 2^32''\n* The individual public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n* The message ''m'': a byte array<ref name=\"mlen\" />\n\nWe write \"Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\" to assign names to the elements of a Session Context.\n\n<div>\nAlgorithm ''GetSessionValues(session_ctx)'':\n* Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\n* Let ''keyagg_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n* For ''i = 1 .. v'':\n** Let ''keyagg_ctx<sub>i</sub> = ApplyTweak(keyagg_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n* Let ''(Q, gacc, tacc) = keyagg_ctx<sub>v</sub>''\n* Let ''b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) || m)) mod n''\n* Let ''R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> = cpoint_ext(aggnonce[33:66])''; fail if that fails and blame nonce aggregator for invalid ''aggnonce''.\n* Let ''R' = R<sub>1</sub> + b\u22c5R<sub>2</sub>''\n* If ''is_infinite(R'):\n** Let final nonce ''R = G'' (see [[#dealing-with-infinity-in-nonce-aggregation|Dealing with Infinity in Nonce Aggregation]])\n* Else:\n** Let final nonce ''R = R' ''\n* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n* Return ''(Q, gacc, tacc, b, R, e)''\n</div>\n\n<div>\nAlgorithm ''GetSessionKeyAggCoeff(session_ctx, P)'':\n* Let ''(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx''\n* Let ''pk = cbytes(P)''\n* Fail if ''pk'' not in ''pk<sub>1..u</sub>''\n* Return ''KeyAggCoeff(pk<sub>1..u</sub>, pk)''\n</div>\n\n=== Signing ===\n\n<div>\nAlgorithm ''Sign(secnonce, sk, session_ctx)'':\n* Inputs:\n** The secret nonce ''secnonce'' that has never been used as input to ''Sign'' before: a 97-byte array<ref name=\"secnonce\" />\n** The secret key ''sk'': a 32-byte array\n** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n* Let ''k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' = int(secnonce[32:64])''\n* Fail if ''k<sub>i</sub>' = 0'' or ''k<sub>i</sub>' &ge; n'' for ''i = 1..2''\n* Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>' '' if ''has_even_y(R)'', otherwise let ''k<sub>1</sub> = n - k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''\n* Let ''d' = int(sk)''\n* Fail if ''d' = 0'' or ''d' &ge; n''\n* Let ''P = d'\u22c5G''\n* Let ''pk = cbytes(P)''\n* Fail if ''pk &ne; secnonce[64:97]''\n* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails<ref>Failing ''Sign'' when ''GetSessionKeyAggCoeff(session_ctx, P)'' fails is not necessary for unforgeability. It merely indicates to the caller that the scheme is not being used correctly.</ref>\n* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n* <div id=\"Sign negation\"></div>Let ''d = g\u22c5gacc\u22c5d' mod n'' (See [[#negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]])\n* Let ''s = (k<sub>1</sub> + b\u22c5k<sub>2</sub> + e\u22c5a\u22c5d) mod n''\n* Let ''psig = bytes(32, s)''\n* Let ''pubnonce = cbytes(k<sub>1</sub>'\u22c5G) || cbytes(k<sub>2</sub>'\u22c5G)''\n* If ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'' (see below) returns failure, fail<ref>Verifying the signature before leaving the signer prevents random or adversarially provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended but can be omitted if the computation cost is prohibitive.</ref>\n* Return partial signature ''psig''\n</div>\n\n=== Partial Signature Verification ===\n\n<div>\nAlgorithm ''PartialSigVerify(psig, pubnonce<sub>1..u</sub>, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)'':\n* Inputs:\n** The partial signature ''psig'': a 32-byte array\n** The number ''u'' of public nonces and individual public keys with ''0 < u < 2^32''\n** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n** The individual public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n** The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n** The message ''m'': a byte array<ref name=\"mlen\" />\n** The index of the signer ''i'' in the of public nonces and individual public keys with ''0 < i &le; u''\n* Let ''aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)''; fail if that fails\n* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n* Run ''PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>, pk<sub>i</sub>, session_ctx)''\n* Return success iff no failure occurred before reaching this point.\n</div>\n\n<div>\nInternal Algorithm ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'':\n* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n* Let ''s = int(psig)''; fail if ''s &ge; n''\n* Let ''R<sub>\u204e,1</sub> = cpoint(pubnonce[0:33]), R<sub>\u204e,2</sub> = cpoint(pubnonce[33:66])''\n* Let ''Re<sub>\u204e</sub>' = R<sub>\u204e,1</sub> + b\u22c5R<sub>\u204e,2</sub>''\n* Let effective nonce ''Re<sub>\u204e</sub> = Re<sub>\u204e</sub>' '' if ''has_even_y(R)'', otherwise let ''Re<sub>\u204e</sub> = -Re<sub>\u204e</sub>' ''\n* Let ''P = cpoint(pk)''; fail if that fails\n* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''<ref>''GetSessionKeyAggCoeff(session_ctx, P)'' cannot fail when called from ''PartialSigVerifyInternal''.</ref>\n* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n* <div id=\"SigVerify negation\"></div>Let ''g' = g\u22c5gacc mod n'' (See [[#negation-of-the-individual-public-key-when-partially-verifying|Negation Of The Individual Public Key When Partially Verifying]])\n* Fail if ''s\u22c5G &ne; Re<sub>\u204e</sub> + e\u22c5a\u22c5g'\u22c5P''\n* Return success iff no failure occurred before reaching this point.\n</div>\n\n=== Partial Signature Aggregation ===\n\n<div>\nAlgorithm ''PartialSigAgg(psig<sub>1..u</sub>, session_ctx)'':\n* Inputs:\n** The number ''u'' of signatures with ''0 < u < 2^32''\n** The partial signatures ''psig<sub>1..u</sub>'': ''u'' 32-byte arrays\n** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n* Let ''(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n* For ''i = 1 .. u'':\n** Let ''s<sub>i</sub> = int(psig<sub>i</sub>)''; fail if ''s<sub>i</sub> &ge; n'' and blame signer ''i'' for invalid partial signature.\n* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n* Let ''s = s<sub>1</sub> + ... + s<sub>u</sub> + e\u22c5g\u22c5tacc mod n''\n* Return ''sig = ''xbytes(R) || bytes(32, s)''\n</div>\n\n=== Test Vectors and Reference Code ===\n\nWe provide a naive, highly inefficient, and non-constant time [[bip-0327/reference.py|pure Python 3 reference implementation of the key aggregation, partial signing, and partial signature verification algorithms]].\n\nStandalone JSON test vectors are also available in the [[bip-0327|same directory]], to facilitate porting the test vectors into other implementations.\n\nThe reference implementation is for demonstration purposes only and not to be used in production environments.\n\n== Remarks on Security and Correctness ==\n\n=== Signing with Tweaked Individual Keys ===\n\nThe scheme in this proposal has been designed to be secure\neven if signers tweak their individual secret keys with tweaks known to the adversary (e.g., as in BIP32 unhardened derivation)\nbefore providing the corresponding individual public keys as input to key aggregation.\nIn particular, the scheme as specified above requires each signer to provide a final individual public key ''pk'' already to ''NonceGen'',\nwhich writes it into the ''secnonce'' array\nso that it can be checked against ''IndividualPubkey(sk)'' in the ''Sign'' algorithm.\nThe purpose of this check in ''Sign'' is to ensure that ''pk'',\nand thus the secret key ''sk'' that will be provided to ''Sign'',\nis determined before the signer sends out the ''pubnonce''.\n\nIf the check in ''Sign'' was omitted,\nand a signer supported signing with at least two different secret keys ''sk<sub>1</sub>'' and ''sk<sub>2</sub>''\nwhich have been obtained via tweaking another secret key with tweaks known to the adversary,\nthen the adversary could, after having seen the ''pubnonce'',\ninfluence whether ''sk<sub>1</sub>'' or ''sk<sub>2</sub>'' is provided to ''Sign''.\nThis degree of freedom may allow the adversary to perform a generalized birthday attack and thereby forge a signature\n(see [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list post] and [https://github.com/jonasnick/musig2-tweaking writeup] for details).\n\nChecking ''pk'' against ''IndividualPubkey(sk)'' is a simple way to ensure\nthat the secret key provided to ''Sign'' is fully determined already when ''NonceGen'' is invoked.\nThis removes the adversary's ability to influence the secret key after having seen the ''pubnonce''\nand thus rules out the attack.<ref>Ensuring that the secret key provided to ''Sign'' is fully determined already when ''NonceGen'' is invoked is a simple policy to rule out the attack,\nbut more flexible polices are conceivable.\nIn fact, if the signer uses nothing but the message to be signed and the list of the individual public keys of all signers to decide which secret key to use,\nthen it is not a problem that the adversary can influence this decision after having seen the ''pubnonce''.<br />\nMore formally, consider modified algorithms ''NonceGen' '' and ''Sign' '', where ''NonceGen' '' does not take the individual public key of the signer as input and does not store it in pubnonce, and Sign' does not check read the individual public key from pubnonce and does not check it against the secret key taken as input.\nThen it suffices that for each invocation of ''NonceGen' '' with output ''(secnonce, pubnonce)'',\na function ''fsk'' is determined before sending out ''pubnonce'',\nwhere ''fsk'' maps a pair consisting of a list of individual public keys and a message to a secret key,\nsuch that the secret key ''sk'' and the session context ''session_ctx = (_, _, pk<sub>1..u</sub>, _, _, _, m)''\nprovided to the corresponding invocation of ''Sign'(secnonce, sk, session_ctx)'',\nadhere to the condition ''fsk(pk<sub>1..u</sub>, m) = sk''.<br />\nHowever, this requirement is complex and hard to enforce in implementations.\nThe algorithms ''NonceGen'' and ''Sign'' specified in this BIP are effectively restricted to constant functions ''fsk(_, _) = sk''.\nIn other words, their usage ensure that the secret key ''sk'' of the signers is determined entirely when invoking ''NonceGen'',\nwhich is enforced easily by letting ''NonceGen'' take the corresponding individual public key ''pk'' as input and checking  ''pk'' against ''IndividualPubKey(sk)'' in ''Sign''.</ref>\nNote that the scheme as given in the [https://eprint.iacr.org/2020/1261 MuSig2 paper] does not perform the check in ''Sign''.\nHowever, the security model in the paper does not cover tweaking at all and assumes a single fixed secret key.\n\n=== Modifications to Nonce Generation ===\n\nImplementers must avoid modifying the ''NonceGen'' algorithm without being fully aware of the implications.\nWe provide two modifications to ''NonceGen'' that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n\n{| class=\"wikitable\" style=\"margin:auto\"\n!                   !! needs secure randomness !! needs secure counter !! needs to keep state securely !! needs aggregate nonce of all other signers (only possible for one signer)\n|-\n! NonceGen          || \u2713      || &nbsp; || \u2713      || &nbsp;\n|-\n! CounterNonceGen   || &nbsp; || \u2713      || \u2713      || &nbsp;\n|-\n! DeterministicSign || &nbsp; || &nbsp; || &nbsp; || \u2713\n|}\n\nFirst, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify ''NonceGen''.\nThe resulting algorithm ''CounterNonceGen'' does not draw ''rand' '' uniformly at random but instead sets ''rand' '' to the value of an atomic counter that is incremented whenever it is read.\nWith this modification, the secret signing key ''sk'' of the signer generating the nonce is '''not''' an optional argument and must be provided to ''NonceGen''.\nThe security of the resulting scheme then depends on the requirement that reading the counter must never yield the same counter value in two ''NonceGen'' invocations with the same ''sk''.\n\nSecond, if there is a unique signer who is supposed to send the ''pubnonce'' last, it is possible to modify nonce generation for this single signer to not require high-quality randomness.\nSuch a nonce generation algorithm ''DeterministicSign'' is specified below.\nNote that the only optional argument is ''rand'', which can be omitted if randomness is entirely unavailable.\n''DeterministicSign'' requires the argument ''aggothernonce'' which should be set to the output of ''NonceAgg'' run on the ''pubnonce'' value of '''all''' other signers (but can be provided by an untrusted party).\nHence, using ''DeterministicSign'' is only possible for the last signer to generate a nonce and makes the signer stateless, similar to the stateless signer described in the [[#nonce-generation|Nonce Generation]] section.\n\n==== Deterministic and Stateless Signing for a Single Signer ====\n\n<div>\nAlgorithm ''DeterministicSign(sk, aggothernonce, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, rand)'':\n* Inputs:\n** The secret signing key ''sk'': a 32-byte array\n** The aggregate public nonce ''aggothernonce'' (see [[#modifications-to-nonce-generation|above]]): a 66-byte array\n** The number ''u'' of individual public keys with ''0 < u < 2^32''\n** The individual public keys ''pk<sub>1..u</sub>'': ''u'' 32-byte arrays\n** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n** The tweak methods ''is_xonly_t<sub>1..v</sub>'': ''v'' booleans\n** The message ''m'': a byte array<ref name=\"mlen\" />\n** The auxiliary randomness ''rand'': a 32-byte array (optional argument)\n* If the optional argument ''rand'' is present:\n** Let ''sk' '' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand)''\n* Else:\n** Let ''sk' = sk''\n* Let ''keyagg_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n* For ''i = 1 .. v'':\n** Let ''keyagg_ctx<sub>i</sub> = ApplyTweak(keyagg_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n* Let ''aggpk = GetXonlyPubkey(keyagg_ctx<sub>v</sub>)''\n* Let ''k<sub>i</sub> = int(hash<sub>MuSig/deterministic/nonce</sub>(sk' || aggothernonce || aggpk || bytes(8, len(m)) || m || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n* Let ''R<sub>\u204e,1</sub> = k<sub>1</sub>\u22c5G, R<sub>\u204e,2</sub> = k<sub>2</sub>\u22c5G''\n* Let ''pubnonce = cbytes(R<sub>\u204e,2</sub>) || cbytes(R<sub>\u204e,2</sub>)''\n* Let ''d = int(sk)''\n* Fail if ''d = 0'' or ''d &ge; n''\n* Let ''pk = cbytes(d\u22c5G)''\n* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n* Let ''aggnonce = NonceAgg((pubnonce, aggothernonce))''; fail if that fails and blame nonce aggregator for invalid ''aggothernonce''.\n* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n* Return ''(pubnonce, Sign(secnonce, sk, session_ctx))''\n</div>\n\n=== Tweaking Definition ===\n\nTwo modes of tweaking the aggregate public key are supported. They correspond to the following algorithms:\n\n<div>\nAlgorithm ''ApplyPlainTweak(P, t)'':\n* Inputs:\n** ''P'': a point\n** The tweak ''t'': an integer with ''0 &le; t < n ''\n* Return ''P + t\u22c5G''\n</div>\n\n<div>\nAlgorithm ''ApplyXonlyTweak(P, t)'':\n* Return ''with_even_y(P) + t\u22c5G''\n</div>\n\n=== Negation Of The Secret Key When Signing ===\n\nIn order to produce a partial signature for an X-only aggregate public key that is an aggregate of ''u'' individual public keys and tweaked ''v'' times (X-only or plain), the ''[[#Sign negation|Sign]]'' algorithm may need to negate the secret key during the signing process.\n\n<poem>\nThe following elliptic curve points arise as intermediate steps when creating a signature:\n\u2022 ''P<sub>i</sub>'' as computed in ''KeyAgg'' is the point corresponding to the ''i''-th signer's individual public key. Defining ''d<sub>i</sub>' '' to be the ''i''-th signer's secret key as an integer, i.e., the ''d' '' value as computed in the ''Sign'' algorithm of the ''i''-th signer, we have\n    ''P<sub>i</sub> = d<sub>i</sub>'\u22c5G ''.\n\u2022 ''Q<sub>0</sub>'' is the aggregate of the individual public keys. It is identical to value ''Q'' computed in ''KeyAgg'' and therefore defined as\n    ''Q<sub>0</sub> = a<sub>1</sub>\u22c5P<sub>1</sub> + a<sub>2</sub>\u22c5P<sub>2</sub> + ... + a<sub>u</sub>\u22c5P<sub>u</sub>''.\n\u2022 ''Q<sub>i</sub>'' is the tweaked aggregate public key after the ''i''-th execution of ''ApplyTweak'' for ''1 &le; i &le; v''. It holds that\n    ''Q<sub>i</sub> = f(i-1) + t<sub>i</sub>\u22c5G'' for ''i = 1, ..., v'' where\n        ''f(i-1) := with_even_y(Q<sub>i-1</sub>)'' if ''is_xonly_t<sub>i</sub>'' and\n        ''f(i-1) := Q<sub>i-1</sub>'' otherwise.\n\u2022 ''with_even_y(Q<sub>v</sub>)'' is the final result of the key aggregation and tweaking operations. It corresponds to the output of ''GetXonlyPubkey'' applied on the final KeyAgg Context.\n</poem>\n\nThe signer's goal is to produce a partial signature corresponding to the final result of key aggregation and tweaking, i.e., the X-only public key ''with_even_y(Q<sub>v</sub>)''.\n\n<poem>\nFor ''1 &le; i &le; v'', we denote the value ''g'' computed in the ''i''-th execution of ''ApplyTweak'' by ''g<sub>i-1</sub>''. Therefore, ''g<sub>i-1</sub>'' is ''-1 mod n'' if and only if ''is_xonly_t<sub>i</sub>'' is true and ''Q<sub>i-1</sub>'' has an odd Y coordinate. In other words, ''g<sub>i-1</sub>'' indicates whether ''Q<sub>i-1</sub>'' needed to be negated to apply an X-only tweak:\n    ''f(i-1) = g<sub>i-1</sub>\u22c5Q<sub>i-1</sub>'' for ''1 &le; i &le; v''.\n\nFurthermore, the ''Sign'' and ''PartialSigVerify'' algorithms set value ''g'' depending on whether ''Q<sub>v</sub>'' needed to be negated to produce the (X-only) final output. For consistency, this value ''g'' is referred to as ''g<sub>v</sub>'' in this section.\n    ''with_even_y(Q<sub>v</sub>) = g<sub>v</sub>\u22c5Q<sub>v</sub>''.\n</poem>\n\n<poem>\nSo, the (X-only) final public key is\n    ''with_even_y(Q<sub>v</sub>)\n        = g<sub>v</sub>\u22c5Q<sub>v</sub>\n        = g<sub>v</sub>\u22c5(f(v-1) + t<sub>v</sub>\u22c5G)\n        = g<sub>v</sub>\u22c5(g<sub>v-1</sub>\u22c5(f(v-2) + t<sub>v-1</sub>\u22c5G) + t<sub>v</sub>\u22c5G)\n        = g<sub>v</sub>\u22c5g<sub>v-1</sub>\u22c5f(v-2) + g<sub>v</sub>\u22c5(t<sub>v</sub> + g<sub>v-1</sub>\u22c5t<sub>v-1</sub>)\u22c5G\n        = g<sub>v</sub>\u22c5g<sub>v-1</sub>\u22c5f(v-2) + (sum<sub>i=v-1..v</sub> t<sub>i</sub>\u22c5prod<sub>j=i..v</sub> g<sub>j</sub>)\u22c5G\n        = g<sub>v</sub>\u22c5g<sub>v-1</sub>\u22c5...\u22c5g<sub>1</sub>\u22c5f(0) + (sum<sub>i=1..v</sub> t<sub>i</sub>\u22c5prod<sub>j=i..v</sub> g<sub>j</sub>)\u22c5G\n        = g<sub>v</sub>\u22c5...\u22c5g<sub>0</sub>\u22c5Q<sub>0</sub> + g<sub>v</sub>\u22c5tacc<sub>v</sub>\u22c5G''\n    where ''tacc<sub>i</sub>'' is computed by ''KeyAgg'' and ''ApplyTweak'' as follows:\n      ''tacc<sub>0</sub> = 0\n      tacc<sub>i</sub> = t<sub>i</sub> + g<sub>i-1</sub>\u22c5tacc<sub>i-1</sub> for i=1..v mod n''\n    for which it holds that ''g<sub>v</sub>\u22c5tacc<sub>v</sub> = sum<sub>i=1..v</sub> t<sub>i</sub>\u22c5prod<sub>j=i..v</sub> g<sub>j</sub>''.\n</poem>\n\n<poem>\n''KeyAgg'' and ''ApplyTweak'' compute\n    ''gacc<sub>0</sub> = 1\n    gacc<sub>i</sub> = g<sub>i-1</sub>\u22c5gacc<sub>i-1</sub> for i=1..v mod n''\nSo we can rewrite above equation for the final public key as\n  ''with_even_y(Q<sub>v</sub>) = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5Q<sub>0</sub> + g<sub>v</sub>\u22c5tacc<sub>v</sub>\u22c5G''.\n</poem>\n\n<poem>\nThen we have\n    ''with_even_y(Q<sub>v</sub>) - g<sub>v</sub>\u22c5tacc<sub>v</sub>\u22c5G\n        = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5Q<sub>0</sub>\n        = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5(a<sub>1</sub>\u22c5P<sub>1</sub> + ... + a<sub>u</sub>\u22c5P<sub>u</sub>)\n        = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5(a<sub>1</sub>\u22c5d<sub>1</sub>'\u22c5G + ... + a<sub>u</sub>\u22c5d<sub>u</sub>'\u22c5G)\n        = sum<sub>i=1..u</sub>(g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5a<sub>i</sub>\u22c5d<sub>i</sub>')*G''.\n</poem>\n\nIntuitively, ''gacc<sub>i</sub>'' tracks accumulated sign flipping and ''tacc<sub>i</sub>'' tracks the accumulated tweak value after applying the first ''i'' individual tweaks. Additionally, ''g<sub>v</sub>'' indicates whether ''Q<sub>v</sub>'' needed to be negated to produce the final X-only result. Thus, signer ''i'' multiplies its secret key ''d<sub>i</sub>' '' with ''g<sub>v</sub>\u22c5gacc<sub>v</sub>'' in the ''[[#Sign negation|Sign]]'' algorithm.\n\n==== Negation Of The Individual Public Key When Partially Verifying ====\n\n<poem>\nAs explained in [[#negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]] the signer uses a possibly negated secret key\n    ''d = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5d' mod n''\nwhen producing a partial signature to ensure that the aggregate signature will correspond to an aggregate public key with even Y coordinate.\n</poem>\n\n<poem>\nThe ''[[#SigVerify negation|PartialSigVerifyInternal]]'' algorithm is supposed to check\n  ''s\u22c5G = Re<sub>\u204e</sub> + e\u22c5a\u22c5d\u22c5G''.\n</poem>\n\n<poem>\nThe verifier doesn't have access to ''d\u22c5G'' but can construct it using the individual public key ''pk'' as follows:\n''d\u22c5G\n    = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5d'\u22c5G\n    = g<sub>v</sub>\u22c5gacc<sub>v</sub>\u22c5cpoint(pk)''\nNote that the aggregate public key and list of tweaks are inputs to partial signature verification, so the verifier can also construct ''g<sub>v</sub>'' and ''gacc<sub>v</sub>''.\n</poem>\n\n=== Dealing with Infinity in Nonce Aggregation ===\n\nIf the nonce aggregator provides ''aggnonce = bytes(33,0) || bytes(33,0)'', either the nonce aggregator is dishonest or there is at least one dishonest signer (except with negligible probability).\nIf signing aborted in this case, it would be impossible to determine who is dishonest.\nTherefore, signing continues so that the culprit is revealed when collecting and verifying partial signatures.\n\nHowever, the final nonce ''R'' of a BIP340 Schnorr signature cannot be the point at infinity.\nIf we would nonetheless allow the final nonce to be the point at infinity, then the scheme would lose the following property:\nif ''PartialSigVerify'' succeeds for all partial signatures, then ''PartialSigAgg'' will return a valid Schnorr signature.\nSince this is a valuable feature, we modify MuSig2* (which is defined in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]) to avoid producing an invalid Schnorr signature while still allowing detection of the dishonest signer: In ''GetSessionValues'', if the final nonce ''R'' would be the point at infinity, set it to the generator instead (an arbitrary choice).\n\nThis modification to ''GetSessionValues'' does not affect the unforgeability of the scheme.\nGiven a successful adversary against the unforgeability game (EUF-CMA) for the modified scheme, a reduction can win the unforgeability game for the original scheme by simulating the modification towards the adversary:\nWhen the adversary provides ''aggnonce' = bytes(33, 0) || bytes(33, 0)'', the reduction sets ''aggnonce = cbytes_ext(G) || bytes(33, 0)''.\nFor any other ''aggnonce' '', the reduction sets ''aggnonce = aggnonce' ''.\n(The case that the adversary provides an ''aggnonce' \u2260 bytes(33, 0) || bytes(33, 0) '' but nevertheless ''R' '' in ''GetSessionValues'' is the point at infinity happens only with negligible probability.)\n\n=== Choosing the Size of the Nonce ===\n\nThe [https://eprint.iacr.org/2020/1261 MuSig2 paper] contains two security proofs that apply to different variants of the scheme.\nThe first proof relies on the random oracle model (ROM) and applies to a scheme variant where each signer's nonce consists of four elliptic curve points.\nThe second proof requires a stronger model, namely the combination of the ROM and the algebraic group model (AGM),\nand applies to an optimized scheme variant where the signers' nonces consist of only two points.\nThis proposal uses the latter, optimized scheme variant.\nRelying on the stronger model is a legitimate choice for the following reasons:\n\nFirst, an approach widely taken is interpreting a Forking Lemma proof in the ROM merely as design justification and ignoring the loss of security due to the Forking Lemma.\nIf one believes in this approach, then the ROM may not be the optimal model in the first place because some parts of the concrete security bound are arbitrarily ignored.\nOne may just as well move to the ROM+AGM model, which produces bounds close to the best-known attacks, e.g., for Schnorr signatures.\n\nSecond, as of this writing, there is no instance of a serious cryptographic scheme with a security proof in the AGM that is not secure in practice.\nThere are, however, insecure toy schemes with AGM security proofs, but those explicitly violate the requirements of the AGM.\n[https://eprint.iacr.org/2022/226.pdf Broken AGM proofs of toy schemes] provide group elements to the adversary without declaring them as group element inputs.\nIn contrast, in MuSig2, all group elements that arise in the scheme are known to the adversary and declared as group element inputs.\nA scheme very similar to MuSig2 and with two-point nonces was independently proven secure in the ROM and AGM by [https://eprint.iacr.org/2020/1245 Alper and Burdges].\n\n== Backwards Compatibility ==\n\nThis document proposes a standard for the MuSig2 multi-signature scheme that is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\nMuSig2 is ''not'' compatible with ECDSA signatures traditionally used in Bitcoin.\n\n== Change Log ==\n\nTo help implementers understand updates to this document, we attach a version number that resembles ''semantic versioning'' (<code>MAJOR.MINOR.PATCH</code>).\nThe <code>MAJOR</code> version is incremented if changes to the BIP are introduced that are incompatible with prior versions.\nAn exception to this rule is <code>MAJOR</code> version zero (0.y.z) which is for development and does not need to be incremented if backwards incompatible changes are introduced.\nThe <code>MINOR</code> version is incremented whenever the inputs or the output of an algorithm changes in a backward-compatible way or new backward-compatible functionality is added.\nThe <code>PATCH</code> version is incremented for other changes that are noteworthy (bug fixes, test vectors, important clarifications, etc.).\n\n* '''1.0.2''' (2024-07-22):\n** Fix minor bug in the specification of ''DeterministicSign'' and add small improvement to a ''PartialSigAgg'' test vector.\n* '''1.0.1''' (2024-05-14):\n** Fix minor issue in ''PartialSigVerify'' vectors.\n* '''1.0.0''' (2023-03-26):\n** Number 327 was assigned to this BIP.\n* '''1.0.0-rc.4''' (2023-03-02):\n** Add expected value of ''pubnonce'' to ''NonceGen'' test vectors.\n* '''1.0.0-rc.3''' (2023-02-28):\n** Improve ''NonceGen'' test vectors by not using an all-zero hex string as ''rand_'' values. This change addresses potential issues in some implementations that interpret this as a special value indicating uninitialized memory or a broken random number generator and therefore return an error.\n** Fix invalid length of a ''pubnonce'' in the ''PartialSigVerify'' test vectors.\n** Improve ''KeySort'' test vector.\n** Add explicit ''IndividualPubkey'' algorithm.\n** Rename KeyGen Context to KeyAgg Context.\n* '''1.0.0-rc.2''' (2022-10-28):\n** Fix vulnerability that can occur in certain unusual scenarios (see [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list]: Add mandatory ''pk'' argument to ''NonceGen'', append ''pk'' to ''secnonce'' and check in ''Sign'' that the ''pk'' in ''secnonce'' matches. Update test vectors.\n** Make sure that signer's key is in list of individual public keys by adding failure case to ''GetSessionKeyAggCoeff'' and add test vectors.\n* '''1.0.0-rc.1''' (2022-10-03): Submit draft BIP to the BIPs repository\n* '''0.8.6''' (2022-09-15): Clarify that implementations do not need to support every feature and add a test vector for signing with a tweaked key\n* '''0.8.5''' (2022-09-05): Rename some functions to improve clarity.\n* '''0.8.4''' (2022-09-02): Make naming of nonce variants ''R'' in specifications of the algorithms and reference code easier to read and more consistent.\n* '''0.8.3''' (2022-09-01): Overwrite ''secnonce'' in ''sign'' reference implementation to help prevent accidental reuse and add test vector for invalid ''secnonce''.\n* '''0.8.2''' (2022-08-30): Fix ''KeySort'' input length and add test vectors\n* '''0.8.1''' (2022-08-26): Add ''DeterministicSign'' algorithm\n* '''0.8.0''' (2022-08-26): Switch from X-only to plain public key for individual public keys. This requires updating a large portion of the test vectors.\n* '''0.7.2''' (2022-08-17): Add ''NonceGen'' and ''Sign/PartialSigVerify'' test vectors for messages longer than 32 bytes.\n* '''0.7.1''' (2022-08-10): Extract test vectors into separate JSON file.\n* '''0.7.0''' (2022-07-31): Change ''NonceGen'' such that output when message is not present is different from when message is present but has length 0.\n* '''0.6.0''' (2022-07-31): Allow variable length messages, change serialization of the message in the ''NonceGen'' hash function, and add test vectors\n* '''0.5.2''' (2022-06-26): Fix ''aggpk'' in ''NonceGen'' test vectors.\n* '''0.5.1''' (2022-06-22): Rename \"ordinary\" tweaking to \"plain\" tweaking.\n* '''0.5.0''' (2022-06-21): Separate ApplyTweak from KeyAgg and introduce KeyGen Context.\n* '''0.4.0''' (2022-06-20): Allow the output of NonceAgg to be infinity and add test vectors\n* '''0.3.2''' (2022-06-02): Add a lot of test vectors and improve handling of invalid contributions in reference code.\n* '''0.3.1''' (2022-05-24): Add ''NonceGen'' test vectors\n* '''0.3.0''' (2022-05-24): Hash ''i - 1'' instead of ''i'' in ''NonceGen''\n* '''0.2.0''' (2022-05-19): Change order of arguments in ''NonceGen'' hash function\n* '''0.1.0''' (2022-05-19): Publication of draft BIP on the bitcoin-dev mailing list\n\n== Footnotes ==\n\n<references />\n\n== Acknowledgements ==\n\nWe thank Brandon Black, Riccardo Casatta, Sivaram Dhakshinamoorthy, Lloyd Fournier, Russell O'Connor, and Pieter Wuille for their contributions to this document.\n", "content_length": 69046}
{"bip_number": 326, "filename": "bip-0326.mediawiki", "content": "<pre>\n  BIP: 326\n  Layer: Applications\n  Title: Anti-fee-sniping in taproot transactions\n  Author: Chris Belcher <belcher@riseup.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0326\n  Status: Draft\n  Type: Informational\n  Created: 2021-06-10\n  License: CC0-1.0\n  Post-History: 2021-6-10: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019048.html\n</pre>\n\n\n== Abstract ==\n\nThis document proposes a certain type of wallet behaviour which uses BIP341 taproot[1]. It provides a greater anonymity set for off-chain protocols which will make use of point-time-locked contracts (PTLCs) such as CoinSwap, Lightning and Discrete Log Contracts.\n\n== Motivation ==\n\nWith taproot recently added to bitcoin, and wallet software about to implement taproot wallets, we are in a unique position to improve the privacy of off-chain protocols if we act soon.\n\nTaproot allows for point-time-locked contracts (PTLCs) as a more private replacement for hash-time-locked contracts (HTLCs). If an off-chain contract (for example a Lightning channel) is closed using a PTLC instead of an HTLC, then the blockchain will just see a regular taproot script instead of a hash value and preimage. However, if a contract is closed using the timelock path, then the blockchain will either see a OP_CHECKSEQUENCEVERIFY opcode or a nSequence value in the transaction, neither of which are very common today, and this would mark the closing transaction as something special and unusual.\n\nThis BIP proposes to improve the privacy and fungibility of off-chain protocols by having on-chain wallets like Bitcoin Core also set the nSequence field in their taproot transactions as in BIP68[5]. This would be in place of their regular nLockTime anti-fee-sniping protection. The end result is that, if an observer of the blockchain sees a taproot spend with an nSequence value, then that could be either: a regular spend from a wallet, or an off-chain settlement transaction spent with a timelock. The two cases would be indistinguishable, and this could greatly improve the privacy and fungibility of bitcoin. The community and wallet developers should act now to implement this so that the anonymity set of nSequence transactions starts to be built up as soon as taproot itself becomes adopted by wallets.\n\n== Background ==\n\n=== Fee sniping ===\n\nFee sniping is a hypothetical outcome of bad incentives to bitcoin mining in the low-inflation future. For a large miner the value of the transactions in the best block and the mempool can be exceeded by the cost of deliberately attempting to mine two blocks to orphan the best block. However with anti-fee-sniping protection using nLockTime or nSequence the bad miner will soon run out of transactions that can be put in the first block, which means they now need to go in the second. Anti-fee-sniping adds to the incentive to move the blockchain forward.\n\nThe nLockTime field is being used this way today. It is implemented in Bitcoin Core[2] and Electrum[3], and adopted by approximately 20% of all recent transactions[4].\n\n=== Absolute vs relative locktime ===\n\nnLockTime is an absolute lock time, it allows the transaction to only be mined after a certain block height or unix time. The widespread adoption of it might have provided a good anonymity set for off-chain protocols. Unfortunately those protocols also commonly use relative lock times, because it allows contracts (for example Lightning payment channels or CoinSwaps) to remain open indefinitely as the countdown clock only starts ticking when the closing transaction is confirmed.\n\nAbsolute locktimes are also still used, so we should keep using nLockTime, but also often use nSequence.\n\n=== Transaction pinning ===\n\nTransaction pinning[8] is a method for making fee bumping prohibitively expensive by abusing node protections against attacks that can waste bandwidth, CPU, and memory. This can make fee management more difficult in multipart contract protocols (such as Lightning Network or CoinSwap). One possible way of solving the problem is to include a 1-block relative timelock `1 OP_CSV` to all spend paths, making it impossible to spend the unconfirmed UTXO. Such a 1-block locktime can also be created with an nSequence value of 1. Many on-chain transactions in bitcoin spend inputs that were created just one or two blocks ago, following this BIP such transactions with `nSequence=1` would also provide cover traffic for off-chain transactions which disable transaction pinning.\n\n== Specifications ==\n\nWhen wallets create transactions spending UTXOs protected by BIP341 taproot, they should set either an nLockTime value or nSequence values to discourage fee sniping, by allowing the transaction to only be mined in the next block after the tip, not the current block. This BIP suggests 50% probability for using nLockTime and 50% for nSequence. If nSequence is set it should apply to at least one of the inputs of the transaction, if it has multiple inputs. It is suggested that on-chain wallets pick an input randomly.\n\nWallets should also have a second random branch which sets the nLockTime or nSequence value even further back, so that transactions that are delayed after signing for whatever reason (e.g. high-latency mix networks) have better privacy. Existing behaviour is that with a probability of 10%, choose a random number between 0 and 99, and subtract it from the current block height. See the Bitcoin Core and Electrum source codes linked in the references for an example.\n\nnSequence can only encode up to 65535 for the block distance[5] so if the UTXOs being spent have more than 65535 confirmations, then the wallet should use nLockTime instead.\n\n=== Pseudocode ===\n\n<source>\ndef apply_anti_fee_sniping_fields(transaction, rbf_set):\n    # bip68 requires v=2\n    transaction.version = 2\n    # Initialize all nsequence to indicate the requested RBF state\n    # nsequence can not be 2**32 - 1 in order for nlocktime to take effect\n    for input in transaction.inputs:\n        if rbf_set:\n            input.nsequence = 2**32 - 3\n        else:\n            input.nsequence = 2**32 - 2\n    # always set nlocktime if any of the transaction inputs have more\n    # confirmations than 65535 or are not taproot inputs, or have\n    # unconfirmed inputs\n    # otherwise choose either nlocktime or nsequence with 50% probability\n    if not rbf_set || any(map(lambda input: input.confirmations() > 65535\n            || !input.is_taproot() || input.confirmations() == 0,\n            transaction.inputs)) || randint(2) == 0:\n        transaction.nlocktime = blockchain.height()\n        if randint(10) == 0:\n            transaction.nlocktime = max(0, transaction.nlocktime\n            - randint(0, 99))\n        # nsequence must be set in order for nlocktime to take effect\n    else:\n        transaction.nlocktime = 0\n        input_index = randint(len(transaction.inputs))\n        transaction.inputs[input_index].nsequence = transaction.inputs\\\n            [input_index].confirmations()\n        if randint(10) == 0:\n            transaction.inputs[input_index].nsequence = max(1,\n                transaction.inputs[input_index].nsequence - randint(0, 99))\n</source>\n\n== Compatibility ==\n\nThis BIP doesn't need any consensus changes. It can be adopted unilaterally and gradually by wallets. Although for greater privacy it would be good for software to adopt it as soon as possible. Ideally during the process of developers implementing their taproot wallets, so that when taproot starts to be used it will already include the nSequence code.\n\nAll wallet software already keeps track of how many confirmations its UTXOs have, so the information required to set the nSequence field is already available.\n\n== Acknowledgements ==\n\nOriginally suggested by David Harding[6] and mentioned to me by ZmnSCPxj.\n\nThanks to craigraw for suggesting a new value for input nsequence in the absolute locktime case[7].\n\n== Copyright ==\n\nThis BIP is licensed under the Creative Commons CC0 1.0 Universal licence.\n\n== References ==\n\n[1] https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki\n\n[2] https://github.com/bitcoin/bitcoin/pull/2340\n\n[3]\nhttps://github.com/spesmilo/electrum/blob/7e6d65ec11c0dccfc24478471c5951d3ae586937/electrum/wallet.py#L211-L224\n\n[4]\nhttps://txstats.com/dashboard/db/blocks-statistics?panelId=4&fullscreen&orgId=1\n\n[5] https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki\n\n[6]\nhttps://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002412.html\n\n[7] https://github.com/sparrowwallet/sparrow/issues/161#issuecomment-925003231\n\n[8] https://bitcoinops.org/en/topics/transaction-pinning/\n", "content_length": 8685}
{"bip_number": 325, "filename": "bip-0325.mediawiki", "content": "<pre>\n  BIP: 325\n  Layer: Applications\n  Title: Signet\n  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n          Anthony Towns <aj@erisian.com.au>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0325\n  Status: Proposed\n  Type: Standards Track\n  Created: 2019-03-20\n  License: CC0-1.0\n</pre>\n\n== Abstract ==\n\nA new type of test network where signatures are used in addition to proof of work for block progress, enabling much better coordination and robustness (be reliably unreliable), for persistent, longer-term testing scenarios involving multiple independent parties.\n\n== Motivation ==\n\nTestnet is a great place to try out new things without risking real money, but it is notoriously unreliable. Huge block reorgs, long gaps in between blocks being mined or sudden bursts of blocks in rapid succession mean that realistic testing of software, especially involving multiple independent parties running software over an extended period of time, becomes infeasible in practice.\n\nA new type of test network would be more suitable for integration testing by organizations such as exchanges, or testing of next generation Layer-2 protocols like Eltoo or sidechain pegs. The goal is not to be perfectly reliable but rather to have a predictable amount of unreliability. You want a test network to behave like mainnet (i.e. no thousands of block reorgs) while also making it easier to trigger expected but rare events like a 6-block reorg. Regtest is not suitable for longer-term scenarios involving multiple independent parties because creating blocks costs nothing, so any party can completely control the test network.\n\n== Specification ==\n\nA new type of network (\"signet\"), which takes an additional consensus parameter called the challenge (scriptPubKey). The challenge can be a simple pubkey (P2PKH style), or a k-of-n multisig, or any other script you would want.\n\nSignet requires all blocks to have a BIP 141 commitment in the coinbase transaction. In order to provide a non-empty solution to the block challenge the block's BIP 141 commitment's optional data must include an additional commitment of the signature/solution for the block:\n\n    1-5 bytes - Push the following (4 + x + y) bytes\n    4 bytes - Signet header (0xecc7daa2)\n    x bytes - scriptSig\n    y bytes - scriptWitness\n\nIn the special case where an empty solution is valid (ie scriptSig and scriptWitness are both empty) this additional commitment can optionally be left out. This special case is to allow non-signet-aware block generation code to be used to test a custom signet chain where the challenge is trivially true.\n\nThe scriptSig is serialized by first encoding its length as CompactSize. The scriptWitness stack is serialized as described in BIP 141.\n\nAny push operations that do not start with the 4 byte Signet header are ignored. Multiple push operations with the 4 byte Signet header are ignored except for the first instance of the header.\n\nTo sign the block or verify a block signature, two virtual transactions, each with a single input and output are constructed from the block as follows.\n\nThe \"to_spend\" transaction is:\n\n    nVersion = 0\n    nLockTime = 0\n    vin[0].prevout.hash = 0000...000\n    vin[0].prevout.n = 0xFFFFFFFF\n    vin[0].nSequence = 0\n    vin[0].scriptSig = OP_0 PUSH72[ block_data ]\n    vin[0].scriptWitness = []\n    vout[0].nValue = 0\n    vout[0].scriptPubKey = signet_challenge\n\nwhere block_data is the serialization of the block's nVersion, hashPrevBlock, signet_merkle_root, and nTime. The <code>signet_merkle_root</code> is obtained by generating the merkle root of the block transactions, after modifying the coinbase witness commitment by replacing the signet solution with an empty solution (that is, the witness commitment includes a four byte push of the Signet header with no additional solution data, and no prior pushes beginning with the Signet header). This means the merkle root of the block is different from the merkle root in the signet commitment. This is needed, because the signature can never be included in the very message (in this case, a block) that is being signed.\n\nThe \"to_sign\" transaction is:\n\n    nVersion = 0\n    nLockTime = 0\n    vin[0].prevout.hash = to_spend.txid\n    vin[0].prevout.n = 0\n    vin[0].nSequence = 0\n    vin[0].sigScript = [ signet_solution sigScript (x bytes), if any ]\n    vin[0].scriptWitness = [ signet_solution scriptWitness (y bytes), if any ]\n    vout[0].nValue = 0\n    vout[0].scriptPubKey = OP_RETURN\n\nThe scriptSig and/or scriptWitness for <code>vin[0]</code> are filled in from the Signet header push above.\n\nTo simplify block generation (mining), the signature also does not commit to the block nonce value, so that rolling the nonce to generate proof-of-work does not also require regenerating signatures. When grinding proof of work, the extended nonce cannot be used as it would invalidate the signature. Instead, simply resigning the same (or an updated) block will give a new search space.\n\nA block is considered fully validated only if the to_sign transaction is a valid spend of the to_spend transaction. It is recommended that this verification is done directly before or after the witness commitment verification, as the data required to do both is approximately the same.\n\nThere is one other acceptable special case: if a block's challenge is e.g. `OP_TRUE` (`0x51`), where an empty solution would result in success, the block is also considered valid if the signet commitment is absent.\n\n== Genesis Block and Message Start ==\n\nThe genesis block is the same for all signet networks, whereas the message start is defined as the first four bytes of the sha256d of the challenge script as a single data push (see below).\n\n=== Genesis Block ===\n\n* Time stamp: 1598918400\n* Nonce: 52613770\n* Difficulty: 0x1e0377ae\n* Version: 1\n\nThe resulting genesis block hash is 00000008819873e925422c1ff0f99f7cc9bbb232af63a077a480a3633bee1ef6, and the block hex is 0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a008f4d5fae77031e8ad222030101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000.\n\n=== Message Start ===\n\nThe message start is defined as the first four bytes of the sha256d of the challenge script, as a single push (i.e. prefixed with the challenge script length). Example:\n\n* Challenge script = 512103ad5e0edad18cb1f0fc0d28a3d4f1f3e445640337489abb10404f2d1e086be43051ae\n* Sha256d(len || challenge script) = sha256d(25512103ad...51ae) = 7ec653a59b1912f9db10da2c461ed827d48f9404d5ef0346a6c94aadd4203646\n* First four bytes = the message start = 7ec653a5\n\n== Compatibility ==\n\nThis specification is backwards compatible in the sense that existing software can use Signet out of the box.\n\nSimply by adding the network parameters for signet (magic number, etc), a client can connect to and use any signet network without further modifications. The block headers have valid proof of work, so clients can trivially check that blocks are \"probably\" valid.\n\nHowever, anyone can mine blocks that are accepted by the client for any given signet network. These blocks do not contain the required signatures, however, so any fully validating node will promptly reject them. As such, clients need to either validate the block signature inside the coinbase transaction, or connect to trusted peers.\n\nOther software need not add block signature validation code that they will not use in production. This is adequate for non-production test purposes where the goal is to have a network behave as much like mainnet as possible.\n\n== Reference implementation ==\n\nPull request at https://github.com/bitcoin/bitcoin/pull/18267\n\n== References ==\n\n# Original mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016734.html\n# Bitcoin Wiki entry: https://en.bitcoin.it/wiki/Signet\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n", "content_length": 8370}
{"bip_number": 324, "filename": "bip-0324.mediawiki", "content": "<pre>\n  BIP: 324\n  Layer: Peer Services\n  Title: Version 2 P2P Encrypted Transport Protocol\n  Author: Dhruv Mehta <dhruv@bip324.com>\n          Tim Ruffing <crypto@timruffing.de>\n          Jonas Schnelli <dev@jonasschnelli.ch>\n          Pieter Wuille <bitcoin-dev@wuille.net>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0324\n  Status: Final\n  Type: Standards Track\n  Created: 2019-03-08\n  License: BSD-3-Clause\n  Replaces: 151\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\nThis document proposes a new Bitcoin P2P transport protocol, which features opportunistic encryption, a mild bandwidth reduction, and the ability to negotiate upgrades before exchanging application messages.\n\n=== Copyright ===\nThis document is licensed under the 3-clause BSD license.\n\n=== Motivation ===\nBitcoin is a permissionless network whose purpose is to reach consensus over public data. Since all data relayed in the Bitcoin P2P network is inherently public, and the protocol lacks a notion of cryptographic identities, peers talk to each other over unencrypted and unauthenticated connections. Nevertheless, this plaintext nature of the current P2P protocol (referred to as v1 in this document) has severe drawbacks in the presence of attackers:\n\n* While the relayed data itself is public in nature, the associated metadata may reveal private information and hamper privacy of users. For example, a global passive attacker eavesdropping on all Bitcoin P2P connections can trivially identify the source and timing of a transaction.\n* Since connections are unauthenticated, they can be tampered with at a low cost and often even with a low risk of detection. For example, an attacker can alter specific bytes of a connection (such as node flags) on-the-fly without the need to keep any state.\n* The protocol is self-revealing. For example, deep packet inspection can identify a P2P connection trivially because connections start with a fixed sequence of magic bytes. The ability to detect connections enables censorship and facilitates the aforementioned attacks as well as other attacks which require the attacker to control the connections of victims, e.g., eclipse attacks targeted at miners.\n\nThis proposal for a new P2P protocol version (v2) aims to improve upon this by raising the costs for performing these attacks substantially, primarily through the use of unauthenticated, opportunistic transport encryption. In addition, the bytestream on the wire is made pseudorandom (i.e., indistinguishable from uniformly random bytes) to a passive eavesdropper.\n\n* Encryption, even when it is unauthenticated and only used when both endpoints support v2, impedes eavesdropping by forcing the attacker to become active: either by performing a persistent man-in-the-middle (MitM) attack, by downgrading connections to v1, or by spinning up their own nodes and getting honest nodes to make connections to them. Active attacks at scale are more resource intensive in general, but in the case of manual, deliberate connections (as opposed to automatic, random ones), they are also in principle detectable: even very basic checks, e.g., operators manually comparing protocol versions and session IDs (as supported by the proposed protocol), will expose the attacker.\n* Tampering, while already an inherently active attack, is costlier if the attacker is forced to maintain the state necessary for a full MitM interception.\n* A pseudorandom bytestream excludes identification techniques based on pattern matching, and makes it easier to shape the bytestream in order to mimic other protocols used on the Internet. This raises the cost of a connection censoring firewall, forcing them to either resort to a full MitM attack, or operate on a more obvious allowlist basis, rather than a blocklist basis.\n\n''' Why encrypt without authentication?'''\n\nAs we have argued above, unauthenticated encryption<ref name=\"what_does_auth_mean\">'''What does ''authentication'' mean in this context?''' Unfortunately, the term authentication in the context of secure channel protocols is ambiguous. It can refer to:\n* The encryption scheme guaranteeing that a message obtained via successful decryption was encrypted by someone having access to the (symmetric) encryption key, and not modified after encryption by a third party. The proposal in this document achieves that property through the use of an AEAD.\n* The communication protocol establishing that the communication partner's identity matches who we expect them to be, through some public key mechanism. The proposal in this document does '''not''' include such a mechanism.</ref> provides strictly better security than no encryption. Thus, all connections should use encryption, even if they are unauthenticated.\n\nWhen it comes to authentication, the situation is not as clear as for encryption. Due to Bitcoin's permissionless nature, authentication will always be restricted to specific scenarios (e.g., connections between peers belonging to the same operator), and whether some form of (possibly partially anonymous) authentication is desired depends on the specific requirements of the involved peers. As a consequence, we believe that authentication should be addressed separately (if desired), and this proposal aims to provide a solid technical basis for future protocol upgrades, including the addition of optional authentication (see [https://github.com/sipa/writeups/tree/main/private-authentication-protocols Private authentication protocols]).\n\n''' Why have a pseudorandom bytestream when traffic analysis is still possible? '''\n\nTraffic analysis, e.g., observing packet lengths and timing, as well as active attacks can still reveal that the Bitcoin v2 P2P protocol is in use. Nevertheless, a pseudorandom bytestream raises the cost of fingerprinting the protocol substantially, and may force some intermediaries to attack any protocol they cannot identify, causing collateral cost.\n\nA pseudorandom bytestream is not self-identifying. Moreover, it is unopinionated and thus a canonical choice for similar protocols. As a result, Bitcoin P2P traffic will be indistinguishable from traffic of other protocols which make the same choice (e.g., [https://gitlab.com/yawning/obfs4 obfs4] and a recently proposed [https://datatracker.ietf.org/doc/draft-cpbs-pseudorandom-ctls/ cTLS extension]). Moreover, traffic shapers and protocol wrappers (for example, making the traffic look like HTTPS or SSH) can further mitigate traffic analysis and active attacks but are out of scope for this proposal.\n\n''' Why not use a secure tunnel protocol? '''\n\nOur goal includes making opportunistic encryption ubiquitously available, as that provides the best defense against large-scale attacks. That implies protecting both the manual, deliberate connections node operators instruct their software to make, and the automatic connections Bitcoin nodes make with each other based on IP addresses obtained via gossip. While encryption per se is already possible with proxy networks or VPN protocols, these are not desirable or applicable for automatic connections at scale:\n* Proxy networks like Tor or I2P introduce a separate address space, independent of network topology, with a very low cost per address making eclipse attacks cheaper. In comparison, clearnet IPv4 and IPv6 networks make obtaining multiple network identities in distinct, well-known network partitions carry a non-trivial cost. Thus, it is not desirable to have a substantial portion of nodes be exclusively connected this way, as this would significantly reduce Eclipse attack costs.<ref name=\"pure_tor_attack\">'''Why is it a bad idea to have nodes exclusively connected over Tor?''' See the [https://arxiv.org/abs/1410.6079 Bitcoin over Tor isn't a Good Idea] paper</ref> Additionally, Tor connections come with significant bandwidth and latency costs that may not be desirable for all network users.\n* VPN protocols like WireGuard or OpenVPN inherently define a private network, which requires manual configuration and therefore is not a realistic avenue for automatic connections.\n\nThus, to achieve our goal, we need a solution that has minimal costs, works without configuration, and is always enabled \u2013 on top of any network layer rather than be part of the network layer.\n\n''' Why not use a general-purpose transport encryption protocol? '''\n\nWhile it would be possible to rely on an off-the-shelf transport encryption protocol such as TLS or Noise, the specific requirements of the Bitcoin P2P network laid out above make these protocols an unsuitable choice.\n\nThe primary requirement which existing protocols fail to meet is a sufficiently modular treatment of encryption and authentication. As we argue above, whether and which form of authentication is desired in the Bitcoin P2P network will depend on the specific requirements of the involved peers (resulting in a mix of authenticated and unauthenticated connections), and thus the question of authentication should be decoupled from encryption. However, native support for a handful of standard authentication scenarios (e.g., using digital signatures and certificates) is at the core of the design of existing general-purpose transport encryption protocols. This focus on authentication would not provide clear benefits for the Bitcoin P2P network but would come with a large amount of additional complexity.\n\nIn contrast, our proposal instead aims for a simple modular design that makes it possible to address authentication separately. Our proposal provides a foundation for authentication by exporting a ''session ID'' that uniquely identifies the encrypted channel. After an encrypted channel has been established, the two endpoints are able to use any authentication protocol to confirm that they have the same session ID. (This is sometimes called ''channel binding'' because the session ID binds the encrypted channel to the authentication protocol.) Since in our proposal, any authentication needs to run after an encrypted connection has been established, the price we pay for this modularity is a possibly higher number of roundtrips as opposed to other protocols that perform authentication alongside the Diffie-Hellman key exchange.<ref name=\"channel_binding_noise_tls\">'''Do other protocols not support exporting a session ID?''' While [https://noiseprotocol.org/noise.html#channel-binding Noise] and [https://datatracker.ietf.org/doc/draft-ietf-kitten-tls-channel-bindings-for-tls13/ TLS (as a draft)] offer similar protocol extensions for exporting session IDs, using channel binding for authentication is not at the focus of their design and would not avoid the bulk of additional complexity due to the native support of authentication methods. </ref> However, the resulting increase in connection establishment latency is a not a concern for Bitcoin's long-lived connections, [https://www.dsn.kastel.kit.edu/bitcoin/ which typically live for hours or even weeks].\n\nBesides this fundamentally different treatment of authentication, further technical issues arise when applying TLS or Noise to our desired use case:\n\n* Neither offers a pseudorandom bytestream.\n* Neither offers native support for elliptic curve cryptography on the curve secp256k1 as otherwise used in Bitcoin. While using secp256k1 is not strictly necessary, it is the obvious choice is for any new asymmetric cryptography in Bitcoin because it minimizes the cryptographic hardness assumptions as well as the dependencies that Bitcoin software will need.\n* Neither offers shapability of the bytestream.\n* Both provide a stream-based interface to the application layer, whereas Bitcoin requires a packet-based interface, resulting in the need for an additional thin layer to perform packet serialization and deserialization.\n\nWhile existing protocols could be amended to address all of the aforementioned issues, this would negate the benefits of using them as off-the-shelf solution, e.g., the possibility to re-use existing implementations and security analyses.\n\n== Goals ==\n\nThis proposal aims to achieve the following properties:\n\n* Confidentiality against passive attacks: A passive attacker having recorded a v2 P2P bytestream (without timing and fragmentation information) must not be able to determine the plaintext being exchanged by the nodes.\n* Observability of active attacks: A session ID identifying the encrypted channel uniquely is derived deterministically from a Diffie-Hellman negotiation. An active man-in-the-middle attacker is forced to incur a risk of being detected as peer operators can compare session IDs manually, or using optional authentication methods possibly introduced in future protocol versions.\n* Pseudorandom bytestream: A passive attacker having recorded a v2 P2P bytestream (without timing information and fragmentation information) must not be able to distinguish it from a uniformly random bytestream.\n* Shapable bytestream: It should be possible to shape the bytestream to increase resistance to traffic analysis (for example, to conceal block propagation), or censorship avoidance.<ref name=\"shapable_hs_tor_circumvention\">'''How can shapability help circumvent fragmentation-pattern based censoring?''' See [https://gitlab.torproject.org/legacy/trac/-/issues/20348#note_2229522 this Tor issue] as an example.</ref>\n* Forward secrecy: An eavesdropping attacker who compromises a peer's sessions secrets should not be able to decrypt past session traffic, except for the latest few packets.\n* Upgradability: The proposal provides an upgrade path using transport versioning which can be used to add features like authentication, PQC handshake upgrade, etc. in the future.\n* Compatibility: v2 clients will allow inbound v1 connections to minimize risk of network partitions.\n* Low overhead: the introduction of a new P2P transport protocol should not substantially increase computational cost or bandwidth for nodes that implement it, compared to the current protocol.\n\n== Specification ==\n\nThe specification consists of three parts:\n\n* The '''Transport layer''' concerns how to set up an encrypted connection between two nodes, capable of transporting application-level messages between them.\n* The '''Application layer''' concerns how to encode Bitcoin P2P messages and commands for transport by the Transport Layer.\n* The '''Signaling''' concerns how v2 nodes advertise their support for the v2 protocol to potential peers.\n\n=== Transport layer specification ===\n\nIn this section, we define the encryption protocol for messages between peers.\n\n==== Overview and design ====\n\nWe first give an informal overview of the entire protocol flow and packet encryption.\n\n'''Protocol flow overview'''\n\nGiven a newly established connection (typically TCP/IP) between two v2 P2P nodes, there are 3 phases the connection goes through. The first starts immediately, i.e. there are no v1 messages or any other bytes exchanged on the link beforehand. The two parties are called the '''initiator''' (who established the connection) and the '''responder''' (who accepted the connection).\n\n# The '''Key exchange phase''', where nodes exchange data to establish shared secrets.\n#* The initiator:\n#** Generates a random ephemeral secp256k1 private key and sends a corresponding 64-byte ElligatorSwift<ref name=\"ellswift_paper\">'''What is ElligatorSwift and why use it?''' The [https://eprint.iacr.org/2022/759.pdf SwiftEC paper] describes a method called ElligatorSwift which allows encoding elliptic curve points in a way that is indistinguishable from a uniformly distributed bitstream. While a random 256-bit string has about 50% chance of being a valid X coordinate on the secp256k1 curve, every 512-bit string is a valid ElligatorSwift encoding of a curve point, making the encoded point indistinguishable from random when using an encoder that can sample uniformly.</ref><ref name=\"ellswift_perf\">'''How fast is ElligatorSwift?''' Our benchmarks show that ElligatorSwift encoded ECDH is about 50% more expensive than unencoded ECDH. Given the fast performance of ECDH and the low frequency of new connections, we found the performance trade-off acceptable for the pseudorandom bytestream and future censorship resistance it can enable.</ref>-encoded public key to the responder.\n#** May send up to 4095<ref name=\"why_4095_garbage\">'''How was the limit of 4095 bytes garbage chosen?''' It is a balance between having sufficient freedom to hide information, and allowing it to be large enough so that the necessary 64 bytes of public key is small compared to it on the one hand, and bandwidth waste on the other hand.</ref> bytes of arbitrary data after their public key, called '''garbage''', providing a form of shapability and avoiding a recognizable pattern of exactly 64 bytes.<ref name=\"why_garbage\">'''Why does the affordance for garbage exist in the protocol?''' The garbage strings after the public keys are needed for shapability of the handshake. Neither peer can send decoy packets before having received at least the other peer's public key, i.e., neither peer can send more than 64 bytes before having received 64 bytes.</ref>\n#* The responder:\n#** Waits until one byte is received which does not match the 16 bytes consisting of the network magic followed by \"version\\x00\\x00\\x00\\x00\\x00\". If the first 16 bytes do match, the connection is treated as using the v1 protocol instead.<ref name=\"why_no_prefix_check\">'''What if a v2 initiator's public key starts accidentally with these 16 bytes?''' This is so unlikely (probability of ''2<sup>-128</sup>'') to happen randomly in the v2 protocol that the initiator does not need to specifically avoid it. The optional detection of wrong-network v1 peers has a probability of ''2<sup>-96</sup>'', which is still negligible compared to random network failures.</ref><ref>Bitcoin Core versions <=0.4.0 and >=22.0 ignore valid P2P messages that are received prior to a VERSION message. Bitcoin Core versions between 0.4.0 and 22.0 assign a misbehavior score to the peer upon receiving such messages. v2 clients implementing this proposal will interpret any message other than VERSION received as the first message to be the initiation of a v2 connection, and will result in disconnection for v1 initiators that send any message type other than VERSION as the first message. We are not aware of any implementations where this could pose a problem.</ref>\n#** If the first 4 received bytes do not match the network magic, but the 12 bytes after that do match the version message encoding above, implementations may interpret this as a v1 peer of a different network, and disconnect them.\n#** Similarly generates a random ephemeral private key and sends a corresponding 64-byte ElligatorSwift-encoded public key to the initiator.\n#** Similarly may send up to 4095 bytes of garbage data after their public key.\n#* Both parties:\n#** Receive (the remainder of) the full 64-byte public key from the other side.\n#** Use X-only<ref name=\"xonly_ecdh\">'''Why use X-only ECDH?''' Using only the X coordinate provides the same security as using a full encoding of the secret curve point but allows for more efficient implementation by avoiding the need for square roots to compute Y coordinates.</ref> ECDH to compute a shared secret from their private key and the exchanged public keys<ref name=\"why_ecdh_pubkeys\">'''Why is the shared secret computation a function of the exact 64-byte public encodings sent?''' This makes sure that an attacker cannot modify the public key encoding used without modifying the rest of the stream. If a third party wants the ability to modify stream bytes, they need to perform a full MitM attack on the connection.</ref>, and deterministically derive from the secret 4 '''encryption keys''' (two in each direction: one for packet lengths, one for content encryption), a '''session id''', and two 16-byte '''garbage terminators'''<ref>'''What length is sufficient for garbage terminators?''' The length of the garbage terminators determines the probability of accidental termination of a legitimate v2 connection due to garbage bytes (sent prior to ECDH) inadvertently including the terminator. 16 byte terminators with 4095 bytes of garbage yield a negligible probability of such collision which is likely orders of magnitude lower than random connection failure on the Internet.</ref><ref>'''What does a garbage terminator in the wild look like?''' <div>[[File:bip-0324/garbage_terminator.png|none|256px|A garbage terminator model TX-v2 in the wild... sent by the responder]]</div>\n</ref> (one in each direction) using HKDF-SHA256.\n#** Send their 16-byte garbage terminator.<ref name=\"why_garbage_term\">'''Why does the protocol need a garbage terminator?''' While it is in principle possible to use the first packet after the garbage directly as a terminator (scan until a valid packet follows), this would be significantly slower than just scanning for a fixed byte sequence, as it would require recomputing a Poly1305 tag after every received byte.</ref>\n#** Receive up to 4111 bytes, stopping when encountering the garbage terminator.\n#* At this point, both parties have the same keys, and all further communication proceeds in the form of '''encrypted packets'''.\n#** Encrypted packets have an '''ignore bit''', which makes them '''decoy packets''' if set. Decoy packets are to be ignored by the receiver apart from verifying they decrypt correctly. Either peer may send such decoy packets at any point from here on. These form the primary shapability mechanism in the protocol. How and when to use them is out of scope for this document.\n#** For each of the two directions, the first encrypted packet that will be sent in that direction (regardless of it being a decoy packet or not) will make use of the associated authenticated data (AAD) feature of the AEAD to authenticate the garbage that has been sent in that direction.<ref name=\"why_garbage_auth\">'''Why does the protocol authenticate the garbage?''' Without garbage authentication, the garbage would be modifiable by a third party without consequences. We want to force any active attacker to have to maintain a full protocol state. In addition, such malleability without the consequence of connection termination could enable protocol fingerprinting.</ref>\n# The '''Version negotiation phase''', where parties negotiate what transport version they will use, as well as data defined by that version.<ref name=\"example_versions\">'''What features could be added in future protocol versions?''' Examples of features that could be added in future versions include post-quantum cryptography upgrades to the handshake, and optional authentication.</ref>\n#* The responder:\n#** Sends a '''version packet''' with empty content, to indicate support for the v2 P2P protocol proposed by this document. Any other value for content is reserved for future versions.\n#* The initiator:\n#** Receives a packet, ignores its contents. The idea is that features added by future versions get negotiated based on what is supported by both parties. Since there is just one version so far, the contents here can simply be ignored. But in the future, receiving a non-empty contents here may trigger other behavior; we defer specifying the encoding for such version content until there is a need for it.<ref name=\"version_negotiation\">'''How will future versions encode version numbers in the version packet?''' Future versions could, for example, specify that the contents of the version packet is to be interpreted as an integer version number (with empty representing 0), and if the minimum of both numbers is N, that being interpreted as choosing a \"v2.N\" protocol version. Alternatively, certain bytes of the version packet contents could be interpreted as a bitvector of optional features.</ref>\n#** Sends a '''version packet''' with empty content as well, to indicate support for the v2 P2P protocol.\n#* The responder:\n#** Receives a packet, ignores its contents.\n# The '''Application phase''', where the packets exchanged have contents to be interpreted as application data.\n#* Whenever either peer has a message to send, it sends a packet with that application message as '''contents'''.\n\nTo avoid the recognizable pattern of first messages being at least 64 bytes, a future backwards-compatible upgrade to this protocol may allow both peers to send their public key + garbage + garbage terminator in multiple rounds, slicing those bytes up into messages arbitrarily, as long as progress is guaranteed.<ref name=\"handshake_progress\">'''How can progress be guaranteed in a backwards-compatible way?''' In order to guarantee progress, it must be ensured that no deadlock occurs, i.e., no state is reached in which each party waits for the other party indefinitely. For example, any upgrade that adheres to the following conditions will guarantee progress:\n\n* The initiator must start by sending at least as many bytes as necessary to mismatch the magic/version 16 bytes prefix.\n* The responder must start sending after having received at least one byte that mismatches that 16-byte prefix.\n* As soon as either party has received the other peer's garbage terminator, or has received 4095 bytes of garbage, they must send their own garbage terminator. (When either of these conditions is met, the other party has nothing to respond with anymore that would be needed to guarantee progress otherwise.)\n* Whenever either party receives any nonzero number of bytes, while not having sent their garbage terminator completely yet, they must send at least one byte in response without waiting for more bytes.\n* After either party has sent their garbage terminator, they must transition to the version negotiation phase without waiting for more bytes.\n\nSince the protocol as specified here adheres to these conditions, any upgrade which also adheres to these conditions will be backwards-compatible.</ref>\n\nNote that the version negotiation phase does not need to wait for the key exchange phase to complete; version packets can be sent immediately after sending the garbage terminator. So the first two phases together, jointly called '''the handshake''', comprise just 1.5 roundtrips:\n\n* the initiator sends public key + garbage\n* the responder sends public key + garbage + garbage terminator + decoy packets (optional) + version packet\n* the initiator sends garbage terminator + decoy packets (optional) + version packet\n\n'''Packet encryption overview'''\n\nAll data on the wire after the garbage terminators takes the form of encrypted packets. Every packet encodes an encrypted variable-length byte array, called the '''contents''', as well as an '''ignore bit''' as mentioned before. The total size of a packet is 20 bytes plus the length of its contents.\n\nEach packet consists of:\n* A 3-byte encrypted '''length''' field, encoding the length of the '''contents''' (between ''0'' and ''2<sup>24</sup>-1''<ref name=\"max_packet_length\">'''Is ''2<sup>24</sup>-1'' bytes sufficient as maximum content size?''' The current Bitcoin P2P protocol has no messages which support more than 4000000 bytes of application payload. By supporting up to ''2<sup>24</sup>-1'' we can accommodate future evolutions needing more than 4 times that value. Hypothetical protocol changes that have even more data to exchange than that should probably use multiple separate messages anyway, because of the per-peer receive buffer sizes involved, and the inability to start processing a message before it is fully received. Of course, future versions of the transport protocol could change the size of the length field, if this were really needed.</ref>, inclusive).\n* An authenticated encryption of the '''plaintext''', which consists of:\n** A 1-byte '''header''' which consists of transport layer protocol flags. Currently, only the highest bit is defined as the '''ignore bit'''. The other bits are ignored, but this may change in future versions<ref>'''Why is the header a part of the plaintext and not included alongside the length field?''' The packet length field is the minimum information that must be available before we can leverage the standard RFC8439 AEAD. Any other data, including metadata like the header being in the content encryption makes it easier to reason about the protocol security w.r.t. data being used before it is authenticated. If the ignore bit was not part of the content, another mechanism would be needed to authenticate it; for example, it could be fed as AAD to the AEAD cipher. We feel the complexity of such an approach outweighs the benefit of saving one byte per message.</ref>.\n** The variable-length '''contents'''.\n\nThe encryption of the plaintext uses '''[https://en.wikipedia.org/wiki/ChaCha20-Poly1305 ChaCha20Poly1305]'''<ref name=\"why_chacha20\">'''Why is ChaCha20Poly1305 chosen as the basis for packet encryption?''' It is a very widely used authenticated encryption cipher (used among others in SSH, TLS 1.2, TLS 1.3, [https://en.wikipedia.org/wiki/QUIC QUIC], Noise, and [https://www.wireguard.com/protocol/ WireGuard]; in the latter it is currently even the only supported cipher), with very good performance in general purpose software implementations. While AES-based ciphers (including the winners in the [https://competitions.cr.yp.to/caesar.html CAESAR] competition in non-lightweight categories) perform significantly better on systems with AES hardware acceleration, they are also significantly slower in pure software implementations. We choose to optimize for the weakest hardware.</ref>, an [https://en.wikipedia.org/wiki/Authenticated_encryption authenticated encryption with associated data] (AEAD) cipher specified in [https://datatracker.ietf.org/doc/html/rfc8439 RFC 8439]. Every packet's plaintext is treated as a separate AEAD message, with a different nonce for each.\n\nThe length must be dealt with specially, as it is needed to determine packet boundaries before the whole packet is received and authenticated. As we want a stream that is pseudorandom to a passive attacker, it still needs encryption. We use unauthenticated<ref name=\"why_no_len_auth\">'''Why is the length encryption not separately authenticated?''' Informally, the relevant security goal we aim for is to hide the number of packets and their lengths (i.e., the packet boundaries) against a passive attacker that receives the bytestream without timing or fragmentation information. (A formal definition can be found for example in [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Definition 22)] under the name \"boundary hiding against chosen-plaintext attacks (BH-CPA)\".) However, we do not aim to hide packet boundaries against active attackers because active attackers can always exploit the fact that the Bitcoin P2P protocol is largely query-response based: they can trickle the bytes on the stream one-by-one unmodified and observe when a response comes (see [https://himsen.github.io/pdf/thesis.pdf Hansen 2016 (Section 3.9)] for a in-depth discussion). With that in mind, we accept that an active (non-MitM) attacker is able to figure out some information about packet boundaries by flipping certain bits in the unauthenticated length field, and observing the other side disconnecting immediately or later. Thus, we choose to use unauthenticated encryption for the length data, which is sufficient to achieve boundary hiding against passive attackers, and saves 16 bytes of bandwidth per packet.</ref> '''ChaCha20''' encryption for this, with an independent key. Note that the plaintext length is still implicitly authenticated by the encryption of the plaintext, but this can only be verified after receiving the whole packet. This design is inspired by that of the ChaCha20Poly1305 cipher suite in [http://bxr.su/OpenBSD/usr.bin/ssh/PROTOCOL.chacha20poly1305 OpenSSH].<ref name=\"openssl_changes\">'''How does packet encryption differ from the OpenSSH design?''' The differences are:\n* The length field is only 3 bytes instead of 4, as that is sufficient for our purposes.\n* Length encryption keeps drawing pseudorandom bytes from the same ChaCha20 cipher for multiple packets, rather than incrementing the nonce for every packet.\n* The Poly1305 authentication tag only covers the encrypted plaintext, and not the encrypted length field. This means that plaintext encryption uses the standard ChaCha20Poly1305 construction without any modifications, maximizing applicability of analysis and review of that cipher. The length encryption can be seen as a separate layer, using a separate key, and thus cannot affect any of the confidentiality or integrity guarantees of the plaintext encryption. On the other hand, this change w.r.t. OpenSSH also does not worsen any properties, as incorrect lengths will still trigger authentication failure for the overall packet (the plaintext length is implicitly authenticated by ChaCha20Poly1305).\n* A hash step is performed every 224<ref name=\"rekey_interval\">'''How was the rekeying interval 224 chosen?''' Assuming a node sends only ping messages every 20 minutes (the timeout interval for post-[https://github.com/bitcoin/bips/blob/master/bip-0031.mediawiki BIP31] connections) on a connection, the node will transmit 224 packets in about 3.11 days. This means ''soft rekeying'' after a fixed number of packets automatically translates to an upper-bound of time interval for rekeying, while being much simpler to coordinate than an actual time-based rekeying regime. At the same time, doing it once every 224 messages is sufficiently infrequent that it has only negligible impact on performance. Furthermore, 224 times 3 bytes (the number of bytes consumed by each length encryption) is 672, which is a multiple of 64 minus 32. This means that at the end of 224 length encryptions, exactly 32 bytes of keystream data remain that can be used as next key.</ref> messages to rekey the encryption ciphers, in order to provide forward security.\n</ref> Because only fixed-length chunks (3-byte length fields) are encrypted, we do not need to treat all length chunks as separate messages. Instead, a single cipher (with the same nonce) is used for multiple consecutive length fields. This avoids wasting 61 pseudorandom bytes per packet, and makes the cost of having a separate cipher for length encryption negligible.<ref name=\"ok_to_batch\">'''Is it acceptable to use a less standard construction for length encryption?''' The fact that multiple (non-overlapping) bytes generated by a single ChaCha20 cipher are used for the encryption of multiple consecutive length fields is uncommon. We feel the performance cost gained by this deviation is worth it (especially for small packets, which are very common in Bitcoin's P2P protocol), given the low guarantees that are feasible for length encryption in the first place, and the result is still sufficient to provide pseudorandomness from the view of passive attackers. For plaintext encryption, we independently use a very standard construction, as the stakes for confidentiality and integrity there are much higher.</ref>\n\nIn order to provide forward security<ref name=\"rekey\">'''What value does forward security provide?''' Re-keying ensures [https://eprint.iacr.org/2001/035.pdf forward secrecy within a session], i.e., an attacker compromising the current session secrets cannot derive past encryption keys in the same session.</ref><ref>'''Why have a cipher with forward secrecy but no periodical refresh of the ECDH key exchange?''' Our cipher ratchets encryption keys forward in order to protect messages encrypted under ''past'' encryption keys. In contrast, re-performing ECDH key exchange would protect messages encrypted under ''future'' encryption keys, i.e., it would re-establish security after the attacker had compromised one of the peers ''temporarily'' (e.g., the attacker obtains a memory dump). We do not believe protecting against that is a priority: an attacker that, for whatever reason, is capable of an attack that reveals encryption keys (or other session secrets) of a peer once is likely capable of performing the same attack again after peers have re-performed the ECDH key exchange. Thus, we do not believe the benefits of re-performing key exchange outweigh the additional complexity that comes with the necessary coordination between the peers. We note that the initiator could choose to close and re-open the entire connection to force a refresh of the ECDH key exchange, but that introduces other issues: a connection slot needs to be kept open at the responder side, it is not cryptographically guaranteed that really the same initiator will use it, and the observable TCP reset and handshake may create a detectable pattern.</ref>, the encryption keys for both plaintext and length encryption are cycled every 224 messages, by switching to a new key that is generated by the key stream using the old key.\n\n==== Handshake: key exchange and version negotiation ====\n\nNext we specify the handshake of a connection in detail.\n\nAs explained before, these messages are sent to set up the connection:\n\n<pre>\n ----------------------------------------------------------------------------------------------------\n | Initiator                         Responder                                                      |\n |                                                                                                  |\n | x, ellswift_X = ellswift_create()                                                                |\n |                                                                                                  |\n |    ---- ellswift_X + initiator_garbage (initiator_garbage_len bytes; max 4095) --->              |\n |                                                                                                  |\n |                                   y, ellswift_Y = ellswift_create()                              |\n |                                   ecdh_secret = v2_ecdh(                                         |\n |                                                     y, ellswift_X, ellswift_Y, initiating=False) |\n |                                   v2_initialize(initiator, ecdh_secret, initiating=False)        |\n |                                                                                                  |\n |    <--- ellswift_Y + responder_garbage (responder_garbage_len bytes; max 4095) +                 |\n |             responder_garbage_terminator (16 bytes) +                                            |\n |             v2_enc_packet(initiator, RESPONDER_TRANSPORT_VERSION, aad=responder_garbage) ----    |\n |                                                                                                  |\n | ecdh_secret = v2_ecdh(x, ellswift_Y, ellswift_X, initiating=True)                                |\n | v2_initialize(responder, ecdh_secret, initiating=True)                                           |\n |                                                                                                  |\n |     ---- initiator_garbage_terminator (16 bytes) +                                               |\n |              v2_enc_packet(responder, INITIATOR_TRANSPORT_VERSION, aad=initiator_garbage) --->   |\n |                                                                                                  |\n ----------------------------------------------------------------------------------------------------\n</pre>\n\n===== Shared secret computation =====\n\nThe peers derive their shared secret through X-only ECDH, hashed together with the exactly 64-byte public keys' encodings sent over the wire.\n\n<pre>\ndef v2_ecdh(priv, ellswift_theirs, ellswift_ours, initiating):\n    ecdh_point_x32 = ellswift_ecdh_xonly(ellswift_theirs, priv)\n    if initiating:\n        # Initiating, place our public key encoding first.\n        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_ours + ellswift_theirs + ecdh_point_x32)\n    else:\n        # Responding, place their public key encoding first.\n        return sha256_tagged(\"bip324_ellswift_xonly_ecdh\", ellswift_theirs + ellswift_ours + ecdh_point_x32)\n</pre>\n\nHere, <code>sha256_tagged(tag, x)</code> returns a tagged hash value <code>SHA256(SHA256(tag) || SHA256(tag) || x)</code> as in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n\n===== ElligatorSwift encoding of curve X coordinates =====\n\nThe functions <code>ellswift_create</code> and <code>ellswift_ecdh_xonly</code> encapsulate the construction of ElligatorSwift-encoded public keys, and the computation of X-only ECDH with\nElligatorSwift-encoded public keys.\n\nFirst we define a constant:\n* Let ''c = 0xa2d2ba93507f1df233770c2a797962cc61f6d15da14ecd47d8d27ae1cd5f852''.<ref name=\"sqrt_minus3\">'''What is the ''c'' constant used in ''XSwiftEC''?''' The algorithm requires a constant ''&radic;-3 (mod p)''; in other words, a number ''c'' such that ''-c<sup>2</sup> mod p = 3''. There are two solutions to this equation, one which is itself a square modulo ''p'', and its negation. We choose the square one.</ref>\n\nTo define the needed functions, we first introduce a helper function, matching the <code>XSwiftEC</code> function from the [https://eprint.iacr.org/2022/759.pdf SwiftEC] paper, instantiated for the secp256k1 curve, with minor modifications. It maps pairs of integers ''(u, t)'' (both in range ''0..p-1'') to valid X coordinates on the curve. Note that the specification here does not attempt to be constant time, as it does not operate on secret data. In what follows, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n\n* ''XSwiftEC(u, t)'':\n** Alter the inputs to guarantee an X coordinate on the curve:<ref name=\"ellswift_deviation\">'''Why do the inputs to the XSwiftEC algorithm need to be altered?''' This step deviates from the paper, which maps a negligibly small subset of inputs (around ''3/2<sup>256</sup>'') to the point at infinity. To avoid the need to deal with the case where a peer could craft encodings that intentionally trigger this edge case, we remap them to inputs that yield a valid X coordinate.</ref>\n*** If ''u mod p = 0'', let ''u = 1'' instead.\n*** If ''t mod p = 0'', let ''t = 1'' instead.\n*** If ''(u<sup>3</sup> + t<sup>2</sup> + 7) mod p = 0'', let ''t = 2t (mod p)'' instead.\n** Let ''X = (u<sup>3</sup> + 7 - t<sup>2</sup>)/(2t) (mod p).''<ref name=\"modinv\">'''What does the division (/) sign in modular arithmetic refer to?''' Note that the division in these expressions corresponds to multiplication with the modular inverse modulo ''p'', i.e. ''a / b (mod p)'' with nonzero ''b'' is the unique solution ''x'' for which ''bx = a (mod p)''. It can be computed as ''ab<sup>p-2</sup> (mod p)'', but more efficient algorithms exist.</ref>\n** Let ''Y = (X + t)/(cu) (mod p)''.\n** For every ''x'' in ''{u + 4Y<sup>2</sup>, (-X/Y - u)/2, (X/Y - u)/2}'' (all ''mod p''; the order matters):\n*** If ''lift_x(x)'' succeeds, return ''x''. There is at least one such ''x''.\n\nTo find encodings of a given X coordinate ''x'', we first need the inverse of ''XSwiftEC''. The function ''XSwiftECInv(x, u, case)'' either returns ''t'' such that ''XSwiftEC(u, t) = x'', or ''None''. The ''case'' variable is an integer in range ''0..7'', which selects which of the up to 8 valid such ''t'' values to return:\n\n* ''XSwiftECInv(x, u, case)'':\n** If ''case & 2 = 0'':\n*** If ''lift_x(-x - u)'' succeeds, return ''None''.\n*** Let ''v = x''.\n*** Let ''s = -(u<sup>3</sup> + 7)/(u<sup>2</sup> + uv + v<sup>2</sup>) (mod p)''.\n** Else (''case & 2 = 2''):\n*** Let ''s = x - u (mod p)''.\n*** If ''s = 0'', return ''None''.\n*** Let ''r'' be the square root of ''-s(4(u<sup>3</sup> + 7) + 3u<sup>2</sup>s) (mod p).''<ref name=\"modsqrt\">'''How to compute a square root mod ''p''?''' Due to the structure of ''p'', a candidate for the square root of ''a'' mod ''p'' can be computed as ''x = a<sup>(p+1)/4</sup> mod p''. If ''a'' is not a square mod ''p'', this formula returns the square root of ''-a mod p'' instead, so it is necessary to verify that ''x<sup>2</sup> mod p = a''. If that is the case ''-x mod p'' is a solution too, but we define \"the\" square root to be equal to that expression (the square root will therefore always be a square itself, as ''(p+1)/4'' is even). This algorithm is a specialization of the [https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm Tonelli-Shanks algorithm].</ref> Return ''None'' if it does not exist.\n*** If ''case & 1 = 1'' and ''r = 0'', return ''None''.\n*** Let ''v = (r/s - u)/2''.\n** Let ''w'' be the square root of ''s (mod p)''. Return ''None'' if it does not exist.\n** If ''case & 5 = 0'', return ''-w(u(1 - c)/2 + v)''.\n** If ''case & 5 = 1'', return ''w(u(1 + c)/2 + v)''.\n** If ''case & 5 = 4'', return ''w(u(1 - c)/2 + v)''.\n** If ''case & 5 = 5'', return ''-w(u(1 + c)/2 + v)''.\n\nThe overall ''XElligatorSwift'' algorithm, matching the name used in the paper, then uses this inverse to randomly''<ref name=\"ellswift_helps_parroting\">'''Can the ElligatorSwift encoding be used to construct public key encodings that satisfy a certain structure (and not pseudorandom)?''' The algorithm chooses the first 32 bytes (i.e., the value ''u'') and then computes a corresponding ''t'' such that the mapping to the curve point holds. In general, picking ''u'' from a uniformly random distribution provides pseudorandomness. But we can also fix any of the 32 bytes in ''u'', and the algorithm will still find a corresponding ''t''. The fact that it is possible to fix the first 32 bytes, combined with the garbage bytes in the handshake, provides a limited but very simple method of parroting other protocols such as [https://tls13.xargs.org/ TLS 1.3], which can be deployed by one of the peers without explicit support from the other peer. More general methods of parroting, e.g., introduced by defining new protocol or a protocol upgrade, are not precluded.</ref> sample encodings of ''x'':\n\n* ''XElligatorSwift(x)'':\n** Loop:\n*** Let ''u'' be a random non-zero integer in range ''1..p-1'' inclusive.\n*** Let ''case'' be a random integer in range ''0..7'' inclusive.\n*** Compute ''t = XSwiftECInv(x, u, case)''.\n*** If ''t'' is not ''None'', return ''(u, t)''. Otherwise, restart loop.\n\nThis is used to define the <code>ellswift_create</code> algorithm used in the previous section; it generates a random private key, along with a uniformly sampled 64-byte ElligatorSwift-encoded public key corresponding to it:\n\n* ''ellswift_create()'':\n** Generate a random private key ''priv'' in range ''1..p-1''.\n** Let ''P = priv\u22c5G'', the corresponding public key point to ''priv''.\n** Let ''(u, t) = XElligatorSwift(x(P))'', an encoding of ''x(P)''.\n** ''ellswift_pub = bytes(u) || bytes(t)'', its encoding as 64 bytes.\n** Return ''(priv, ellswift_pub)''.\n\nFinally the <code>ellswift_ecdh_xonly</code> algorithm is:\n\n* ''ellswift_ecdh_xonly(ellswift_theirs, priv)'':\n** Let ''u = int(ellswift_theirs[:32]) mod p''.\n** Let ''t = int(ellswift_theirs[32:]) mod p''.\n** Return ''bytes(x(priv\u22c5lift_x(XSwiftEC(u, t))))''.<ref name=\"lift_x_choice\">'''Does it matter which point ''lift_x'' maps to?''' Either point is valid, as they are negations of each other, and negations do not affect the output X coordinate.</ref>\n\n===== Keys and session ID derivation =====\n\nThe authenticated encryption construction proposed here requires two 32-byte keys per communication direction. These (in addition to a session ID) are computed using HKDF<ref name=\"why_hkdf\">'''Why use HKDF for deriving key material?''' The shared secret already involves a hash function to make sure the public key encodings contribute to it, which negates some of the need for HKDF already. We still use it as it is the standard mechanism for deriving many keys from a single secret, and its computational cost is low enough to be negligible compared to the rest of a connection setup.</ref> as specified in [https://tools.ietf.org/html/rfc5869 RFC 5869] with SHA256 as the hash function:\n\n<pre>\ndef initialize_v2_transport(peer, ecdh_secret, initiating):\n    # Include NETWORK_MAGIC to ensure a connection between nodes on different networks will immediately fail\n    prk = HKDF_Extract(Hash=sha256, salt=b'bitcoin_v2_shared_secret' + NETWORK_MAGIC, ikm=ecdh_secret)\n\n    peer.session_id = HKDF_Expand(Hash=sha256, PRK=prk, info=b'session_id', L=32)\n\n    # Initialize the packet encryption ciphers.\n    initiator_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_L', L=32)\n    initiator_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'initiator_P', L=32)\n    responder_L = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_L', L=32)\n    responder_P = HKDF_Expand(Hash=sha256, PRK=prk, info=b'responder_P', L=32)\n    garbage_terminators = HKDF_Expand(Hash=sha256, PRK=prk, info=b'garbage_terminators', L=32)\n    initiator_garbage_terminator = garbage_terminators[:16]\n    responder_garbage_terminator = garbage_terminators[16:]\n\n    if initiating:\n        peer.send_L = FSChaCha20(initiator_L)\n        peer.send_P = FSChaCha20Poly1305(initiator_P)\n        peer.send_garbage_terminator = initiator_garbage_terminator\n        peer.recv_L = FSChaCha20(responder_L)\n        peer.recv_P = FSChaCha20Poly1305(responder_P)\n        peer.recv_garbage_terminator = responder_garbage_terminator\n    else:\n        peer.send_L = FSChaCha20(responder_L)\n        peer.send_P = FSChaCha20Poly1305(responder_P)\n        peer.send_garbage_terminator = responder_garbage_terminator\n        peer.recv_L = FSChaCha20(initiator_L)\n        peer.recv_P = FSChaCha20Poly1305(initiator_P)\n        peer.recv_garbage_terminator = initiator_garbage_terminator\n\n    # To achieve forward secrecy we must wipe the key material used to initialize the ciphers:\n    memory_cleanse(ecdh_secret, prk, initiator_L, initiator_P, responder_L, responder_K)\n</pre>\n\nThe session ID uniquely identifies the encrypted channel. v2 clients supporting this proposal may present the entire session ID (encoded as a hex string) to the node operator to allow for manual, out of band comparison with the peer node operator. Future transport versions may introduce optional authentication methods that compare the session ID as seen by the two endpoints in order to bind the encrypted channel to the authentication.\n\n===== Overall handshake pseudocode =====\n\nTo establish a v2 encrypted connection, the initiator generates an ephemeral secp256k1 keypair and sends an unencrypted ElligatorSwift encoding of the public key to the responding peer followed by unencrypted pseudorandom bytes <code>initiator_garbage</code> of length <code>garbage_len < 4096</code>.\n\n<pre>\ndef initiate_v2_handshake(peer, garbage_len):\n    peer.privkey_ours, peer.ellswift_ours = ellswift_create()\n    peer.sent_garbage = rand_bytes(garbage_len)\n    send(peer, peer.ellswift_ours + peer.sent_garbage)\n</pre>\n\nThe responder generates an ephemeral keypair for itself and derives the shared ECDH secret (using the first 64 received bytes) which enables it to instantiate the encrypted transport. It then sends 64 bytes of the unencrypted ElligatorSwift encoding of its own public key and its own <code>responder_garbage</code> also of length <code>garbage_len < 4096</code>. If the first 16 bytes received match the v1 prefix, the v1 protocol is used instead.\n\n<pre>\nTRANSPORT_VERSION = b''\nNETWORK_MAGIC = b'\\xf9\\xbe\\xb4\\xd9' # Mainnet network magic; differs on other networks.\nV1_PREFIX = NETWORK_MAGIC + b'version\\x00\\x00\\x00\\x00\\x00'\n\ndef respond_v2_handshake(peer, garbage_len):\n    peer.received_prefix = b\"\"\n    while len(peer.received_prefix) < len(V1_PREFIX):\n        peer.received_prefix += receive(peer, 1)\n        if peer.received_prefix[-1] != V1_PREFIX[len(peer.received_prefix) - 1]:\n            peer.privkey_ours, peer.ellswift_ours = ellswift_create()\n            peer.sent_garbage = rand_bytes(garbage_len)\n            send(peer, ellswift_Y + peer.sent_garbage)\n            return\n    use_v1_protocol()\n</pre>\n\nUpon receiving the encoded responder public key, the initiator derives the shared ECDH secret and instantiates the encrypted transport. It then sends the derived 16-byte <code>initiator_garbage_terminator</code>, optionally followed by an arbitrary number of decoy packets. Afterwards, it receives the responder's garbage (delimited by the garbage terminator). The responder performs very similar steps but includes the earlier received prefix bytes in the public key. Both the initiator and the responder set the AAD of the first encrypted packet they send after the garbage terminator (i.e., either an optional decoy packet or the version packet) to the garbage they have just sent, not including the garbage terminator.\n\n<pre>\ndef complete_handshake(peer, initiating, decoy_content_lengths=[]):\n    received_prefix = b'' if initiating else peer.received_prefix\n    ellswift_theirs = receive(peer, 64 - len(received_prefix))\n    if not initiating and ellswift_theirs[4:16] == V1_PREFIX[4:16]:\n        # Looks like a v1 peer from the wrong network.\n        disconnect(peer)\n    ecdh_secret = v2_ecdh(peer.privkey_ours, ellswift_theirs, peer.ellswift_ours,\n                          initiating=initiating)\n    initialize_v2_transport(peer, ecdh_secret, initiating=True)\n    # Send garbage terminator\n    send(peer, peer.send_garbage_terminator)\n    # Optionally send decoy packets after garbage terminator.\n    aad = peer.sent_garbage\n    for decoy_content_len in decoy_content_lengths:\n        send(v2_enc_packet(peer, decoy_content_len * b'\\x00', aad=aad))\n        aad = b''\n    # Send version packet.\n    send(v2_enc_packet(peer, TRANSPORT_VERSION, aad=aad))\n    # Skip garbage, until encountering garbage terminator.\n    received_garbage = recv(peer, 16)\n    for i in range(4096):\n        if received_garbage[-16:] == peer.recv_garbage_terminator:\n            # Receive, decode, and ignore version packet.\n            # This includes skipping decoys and authenticating the received garbage.\n            v2_receive_packet(peer, aad=received_garbage[:-16])\n            return\n        else:\n            received_garbage += recv(peer, 1)\n    # Garbage terminator was not seen after 4 KiB of garbage.\n    disconnect(peer)\n</pre>\n\n==== Packet encryption ====\n\nLastly, we specify the packet encryption cipher in detail.\n\n===== Existing cryptographic primitives =====\n\nPacket encryption is built on two existing primitives:\n\n* '''ChaCha20Poly1305''' is specified as <code>AEAD_CHACHA20_POLY1305</code> in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8 RFC 8439 section 2.8]. It is an authenticated encryption protocol with associated data (AEAD), taking a 256-bit key, 96-bit nonce, and an arbitrary-length byte array of associated authenticated data (AAD). Due to the built-in authentication tag, ciphertexts are 16 bytes longer than the corresponding plaintext. In what follows:\n** <code>aead_chacha20_poly1305_encrypt(key, nonce, aad, plaintext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''plaintext'', and returns a byte array ''ciphertext'', 16 bytes longer than the plaintext.\n** <code>aead_chacha20_poly1305_decrypt(key, nonce, aad, ciphertext)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', an arbitrary-length byte array ''aad'', and an arbitrary-length byte array ''ciphertext'', and returns either a byte array ''plaintext'' (16 bytes shorter than the ciphertext), or ''None'' in case the ciphertext was not a valid ChaCha20Poly1305 encryption of any plaintext with the specified ''key'', ''nonce'', and ''aad''.\n* The '''ChaCha20 Block Function''' is specified in [https://datatracker.ietf.org/doc/html/rfc8439#section-2.3 RFC 8439 section 2.3]. It is a pseudorandom function (PRF) taking a 256-bit key, 96-bit nonce, and 32-bit counter, and outputs 64 pseudorandom bytes. It is the underlying building block on which ChaCha20 (and ultimately, ChaCha20Poly1305) is built. In what follows:\n** <code>chacha20_block(key, nonce, count)</code> refers to a function that takes as input a 32-byte array ''key'', a 12-byte array ''nonce'', and an integer ''count'' in range ''0..2<sup>32</sup>-1'', and returns a byte array of length 64.\n\nThese will be used for plaintext encryption and length encryption, respectively.\n\n===== Rekeying wrappers: FSChaCha20Poly1305 and FSChaCha20 =====\n\nTo provide re-keying every 224 packets, we specify two wrappers.\n\nThe first is '''FSChaCha20Poly1305''', which represents a ChaCha20Poly1305 AEAD, which automatically changes the nonce after every message, and rekeys every 224 messages by encrypting 32 zero bytes<ref name=\"rekey_why_aead\">'''Why is rekeying implemented in terms of an invocation of the AEAD?''' This means the FSChaCha20Poly1305 wrapper can be thought of as a pure layer around the ChaCha20Poly1305 AEAD. Actual implementations can take advantage of the fact that this formulation is equivalent to using byte 64 through 95 of the keystream output of the underlying ChaCha20 cipher as new key, avoiding the need for Poly1305 in the process.</ref>, and using the first 32 bytes of the result. Each message will be used for one packet. Note that in our protocol, any FSChaCha20Poly1305 instance is always either exclusively encryption or exclusively decryption, as separate instances are used for each direction of the protocol. The nonce used for a message is composed of the 32-bit little-endian encoding of the number of messages with the current key, followed by the 64-bit little-endian encoding of the number of rekeyings performed. For rekeying, the first 32-bit integer is set to ''0xffffffff''.\n\n<pre>\nREKEY_INTERVAL = 224\n\nclass FSChaCha20Poly1305:\n    \"\"\"Rekeying wrapper AEAD around ChaCha20Poly1305.\"\"\"\n\n    def __init__(self, initial_key):\n        self.key = initial_key\n        self.packet_counter = 0\n\n    def crypt(self, aad, text, is_decrypt):\n        nonce = ((self.packet_counter % REKEY_INTERVAL).to_bytes(4, 'little') +\n                 (self.packet_counter // REKEY_INTERVAL).to_bytes(8, 'little'))\n        if is_decrypt:\n            ret = aead_chacha20_poly1305_decrypt(self.key, nonce, aad, text)\n        else:\n            ret = aead_chacha20_poly1305_encrypt(self.key, nonce, aad, text)\n        if (self.packet_counter + 1) % REKEY_INTERVAL == 0:\n            rekey_nonce = b\"\\xFF\\xFF\\xFF\\xFF\" + nonce[4:]\n            self.key = aead_chacha20_poly1305_encrypt(self.key, rekey_nonce, b\"\", b\"\\x00\" * 32)[:32]\n        self.packet_counter += 1\n        return ret\n\n    def decrypt(self, aad, ciphertext):\n        return self.crypt(aad, ciphertext, True)\n\n    def encrypt(self, aad, plaintext):\n        return self.crypt(aad, plaintext, False)\n</pre>\n\nThe second is '''FSChaCha20''', a (single) stream cipher which is used for the lengths of all packets. Encryption and decryption are identical here, so a single function <code>crypt</code> is exposed. It XORs the input with bytes generated using the ChaCha20 block function, rekeying every 224 chunks using the next 32 bytes of the block function output as new key. A ''chunk'' refers here to a single invocation of <code>crypt</code>. As explained before, the same cipher is used for 224 consecutive chunks, to avoid wasting cipher output. The nonce used for these batches of 224 chunks is composed of 4 zero bytes followed by the 64-bit little-endian encoding of the number of rekeyings performed. The block counter is reset to 0 after every rekeying.\n\n<pre>\nclass FSChaCha20:\n    \"\"\"Rekeying wrapper stream cipher around ChaCha20.\"\"\"\n\n    def __init__(self, initial_key):\n        self.key = initial_key\n        self.block_counter = 0\n        self.chunk_counter = 0\n        self.keystream = b''\n\n    def get_keystream_bytes(self, nbytes):\n        while len(self.keystream) < nbytes:\n            nonce = ((0).to_bytes(4, 'little') +\n                     (self.chunk_counter // REKEY_INTERVAL).to_bytes(8, 'little'))\n            self.keystream += chacha20_block(self.key, nonce, self.block_counter)\n            self.block_counter += 1\n        ret = self.keystream[:nbytes]\n        self.keystream = self.keystream[nbytes:]\n        return ret\n\n    def crypt(self, chunk):\n        ks = self.get_keystream_bytes(len(chunk))\n        ret = bytes([ks[i] ^ chunk[i] for i in range(len(chunk))])\n        if ((self.chunk_counter + 1) % REKEY_INTERVAL) == 0:\n            self.key = self.get_keystream_bytes(32)\n            self.block_counter = 0\n        self.chunk_counter += 1\n        return ret\n</pre>\n\n===== Overall packet encryption and decryption pseudocode =====\n\nEncryption and decryption of packets then follow by composing the ciphers from the previous section as building blocks.\n\n<pre>\nLENGTH_FIELD_LEN = 3\nHEADER_LEN = 1\nIGNORE_BIT_POS = 7\n\ndef v2_enc_packet(peer, contents, aad=b'', ignore=False):\n    assert len(contents) <= 2**24 - 1\n    header = (ignore << IGNORE_BIT_POS).to_bytes(HEADER_LEN, 'little')\n    plaintext = header + contents\n    aead_ciphertext = peer.send_P.encrypt(aad, plaintext)\n    enc_contents_len = peer.send_L.encrypt(len(contents).to_bytes(LENGTH_FIELD_LEN, 'little'))\n    return enc_contents_len + aead_ciphertext\n</pre>\n\n<pre>\nCHACHA20POLY1305_EXPANSION = 16\n\ndef v2_receive_packet(peer, aad=b''):\n    while True:\n        enc_contents_len = receive(peer, LENGTH_FIELD_LEN)\n        contents_len = int.from_bytes(peer.recv_L.crypt(enc_contents_len), 'little')\n        aead_ciphertext = receive(peer, HEADER_LEN + contents_len + CHACHA20POLY1305_EXPANSION)\n        plaintext = peer.recv_P.decrypt(aad, aead_ciphertext)\n        if plaintext is None:\n            disconnect(peer)\n            break\n        # Only the first packet is expected to have non-empty AAD.\n        aad = b''\n        header = plaintext[:HEADER_LEN]\n        if not (header[0] & (1 << IGNORE_BIT_POS)):\n            return plaintext[HEADER_LEN:]\n</pre>\n\n==== Performance ====\n\nEach v1 P2P message uses a double-SHA256 checksum truncated to 4 bytes. Roughly the same amount of computation power is required for encrypting and authenticating a v2 P2P message as proposed.\n\n=== Application layer specification ===\n==== v2 Bitcoin P2P message structure ====\nv2 Bitcoin P2P transport layer packets use the encrypted message structure shown above. An unencrypted application layer '''contents''' is composed of:\n\n{|class=\"wikitable\"\n! Field !! Size in bytes !! Comments\n|-\n| <code>message_type</code> || 1 or 13 || either a one byte ID in range ''1..255'' or <code>b'\\x00'</code> followed by a 12-byte ASCII message type (as in the v1 P2P protocol)\n|-\n| <code>message_payload</code> || <code>message_length</code> || message payload\n|}\n\nIf the first byte of <code>message_type</code> is <code>b'\\x00'</code>, the following 12 bytes are interpreted as an ASCII message type (as in the v1 P2P protocol), trailing padded with <code>b'\\x00'</code> as necessary. If the first byte of <code>message_type</code> is in the range ''1..255'', it is interpreted as a message type ID. This structure results in smaller messages than the v1 protocol, as most messages sent/received will have a message type ID. We recommend reserving 1-byte type IDs for message types that are sent more than once per direction per connection.<ref name=\"smaller_messages\">'''How do the lengths between v1 and v2 compare?''' For messages that use the 1-byte short message type ID, v2 packets use 3 bytes less per message than v1.</ref><ref name\"fixed_length_long_ids\">'''Why not allow variable length long message type IDs?''' Allowing for variable length long IDs reduces the available 1-byte ID space by 12 (to encode the length itself) and incentivizes less descriptive message types. In addition, limiting message types to fixed lengths of 1 or 13 hampers traffic analysis.</ref>\n\nThe following table lists currently defined message type IDs:\n\n{| class=\"wikitable\"\n|-\n!\n!0\n!1\n!2\n!3\n|-\n!+0\n|(12 bytes follow)||<code>ADDR</code>||<code>BLOCK</code>||<code>BLOCKTXN</code>\n|-\n!+4\n|<code>CMPCTBLOCK</code>||<code>FEEFILTER</code>||<code>FILTERADD</code>||<code>FILTERCLEAR</code>\n|-\n!+8\n|<code>FILTERLOAD</code>||<code>GETBLOCKS</code>||<code>GETBLOCKTXN</code>||<code>GETDATA</code>\n|-\n!+12\n|<code>GETHEADERS</code>||<code>HEADERS</code>||<code>INV</code>||<code>MEMPOOL</code>\n|-\n!+16\n|<code>MERKLEBLOCK</code>||<code>NOTFOUND</code>||<code>PING</code>||<code>PONG</code>\n|-\n!+20\n|<code>SENDCMPCT</code>||<code>TX</code>||<code>GETCFILTERS</code>||<code>CFILTER</code>\n|-\n!+24\n|<code>GETCFHEADERS</code>||<code>CFHEADERS</code>||<code>GETCFCHECKPT</code>||<code>CFCHECKPT</code>\n|-\n!+28\n|<code>ADDRV2</code>\n|-\n!&geq;29\n|| colspan=\"4\" | (undefined)\n|}\n\n\nAdditional message types may be added separately after BIP finalization.\n\n=== Signaling specification ===\n==== Signaling v2 support ====\nPeers supporting the v2 transport protocol signal support by advertising the <code>NODE_P2P_V2 = (1 << 11)</code> service flag in addr relay. If met with immediate disconnection when establishing a v2 connection, clients implementing this proposal are encouraged to retry connecting using the v1 protocol.<ref>'''Why are v2 clients met with immediate disconnection encouraged to retry with a v1 connection?''' Service flags propagated through untrusted intermediaries using ADDR and ADDRV2 P2P messages and are OR'ed when received from multiple sources. An untrusted intermediary could falsely advertise a potential peer as supportive of v2 connections. Connection downgrades to v1 mitigate the risk of a network participant being blackholed via false advertising.</ref>\n\n\n== Test Vectors ==\n\nFor development and testing purposes, we provide a collection of test vectors in CSV format, and a naive, highly inefficient, [[bip-0324/reference.py|reference implementation]] of the relevant algorithms. This code is for demonstration purposes only:\n* [[bip-0324/ellswift_decode_test_vectors.csv|XElligatorSwift decoding vectors]] provide examples of ElligatorSwift-encoded public keys, and the X coordinate they map to.\n* [[bip-0324/xswiftec_inv_test_vectors.csv|XSwiftECInv vectors]] provide examples of ''(u, x)'' pairs, and the various ''t'' values that ''xswiftec_inv'' maps them to.\n* [[bip-0324/packet_encoding_test_vectors.csv|Packet encoding vectors]] illustrate the lifecycle of the authenticated encryption scheme proposed in this document.\n\n== Rationale and References ==\n<references/>\n\n== Acknowledgements ==\nThanks to everyone (last name order) that helped invent and develop the ideas in this proposal:\n\n* Matt Corallo\n* Lloyd Fournier\n* Gregory Maxwell\n* Anthony Towns\n", "content_length": 66609}
{"bip_number": 322, "filename": "bip-0322.mediawiki", "content": "<pre>\n  BIP: 322\n  Layer: Applications\n  Title: Generic Signed Message Format\n  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322\n  Status: Draft\n  Type: Standards Track\n  Created: 2018-09-10\n  License: CC0-1.0\n</pre>\n\n== Abstract ==\n\nA standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as the intended recipient of funds sent to the invoice address.\n\n== Motivation ==\n\nThe current message signing standard only works for P2PKH (1...) invoice addresses. We propose to extend and generalize the standard by using a Bitcoin Script based approach. This ensures that any coins, no matter what script they are controlled by, can in-principle be signed for. For easy interoperability with existing signing hardware, we also define a signature message format which resembles a Bitcoin transaction (except that it contains an invalid input, so it cannot be spent on any real network).\n\nAdditionally, the current message signature format uses ECDSA signatures which do not commit to the public key, meaning that they do not actually prove knowledge of any secret keys. (Indeed, valid signatures can be tweaked by 3rd parties to become valid signatures on certain related keys.)\n\nUltimately no message signing protocol can actually prove control of funds, both because a signature is obsolete as soon as it is created, and because the possessor of a secret key may be willing to sign messages on others' behalf even if it would not sign actual transactions. No signmessage protocol can fix these limitations.\n\n== Types of Signatures ==\n\nThis BIP specifies three formats for signing messages: ''legacy'', ''simple'' and ''full''. Additionally, a variant of the ''full'' format can be used to demonstrate control over a set of UTXOs.\n\n=== Legacy ===\n\nNew proofs should use the new format for all invoice address formats, including P2PKH.\n\nThe legacy format MAY be used, but must be restricted to the legacy P2PKH invoice address format.\n\n=== Simple ===\n\nA ''simple'' signature consists of a witness stack, consensus encoded as a vector of vectors of bytes, and base64-encoded. Validators should construct <code>to_spend</code> and <code>to_sign</code> as defined below, with default values for all fields except that\n\n* <code>message_hash</code> is a BIP340-tagged hash of the message, as specified below\n* <code>message_challenge</code> in <code>to_spend</code> is set to the scriptPubKey being signed with\n* <code>message_signature</code> in <code>to_sign</code> is set to the provided simple signature.\n\nand then proceed as they would for a full signature.\n\n=== Full ===\n\nFull signatures follow an analogous specification to the BIP-325 challenges and solutions used by Signet.\n\nLet there be two virtual transactions <code>to_spend</code> and <code>to_sign</code>.\n\nThe <code>to_spend</code> transaction is:\n\n    nVersion = 0\n    nLockTime = 0\n    vin[0].prevout.hash = 0000...000\n    vin[0].prevout.n = 0xFFFFFFFF\n    vin[0].nSequence = 0\n    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n    vin[0].scriptWitness = []\n    vout[0].nValue = 0\n    vout[0].scriptPubKey = message_challenge\n\nwhere <code>message_hash</code> is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = <code>BIP0322-signed-message</code> and <code>m</code> is the message as is without length prefix or null terminator, and <code>message_challenge</code> is the to be proven (public) key script.\n\nThe <code>to_sign</code> transaction is:\n\n    nVersion = 0 or (FULL format only) as appropriate (e.g. 2, for time locks)\n    nLockTime = 0 or (FULL format only) as appropriate (for time locks)\n    vin[0].prevout.hash = to_spend.txid\n    vin[0].prevout.n = 0\n    vin[0].nSequence = 0 or (FULL format only) as appropriate (for time locks)\n    vin[0].scriptWitness = message_signature\n    vout[0].nValue = 0\n    vout[0].scriptPubKey = OP_RETURN\n\nA full signature consists of the base64-encoding of the <code>to_sign</code> transaction in standard network serialisation once it has been signed.\n\n=== Full (Proof of Funds) ===\n\nA signer may construct a proof of funds, demonstrating control of a set of UTXOs, by constructing a full signature as above, with the following modifications.\n\n* All outputs that the signer wishes to demonstrate control of are included as additional inputs of <code>to_sign</code>, and their witness and scriptSig data should be set as though these outputs were actually being spent.\n\nUnlike an ordinary signature, validators of a proof of funds need access to the current UTXO set, to learn that the claimed inputs exist on the blockchain, and to learn their scriptPubKeys.\n\n== Detailed Specification ==\n\nFor all signature types, except legacy, the <code>to_spend</code> and <code>to_sign</code> transactions must be valid transactions which pass all consensus checks, except of course that the output with prevout <code>000...000:FFFFFFFF</code> does not exist.\n\n=== Verification ===\n\nA validator is given as input an address ''A'' (which may be omitted in a proof-of-funds), signature ''s'' and message ''m'', and outputs one of three states\n* ''valid at time T and age S'' indicates that the signature has set timelocks but is otherwise valid\n* ''inconclusive'' means the validator was unable to check the scripts\n* ''invalid'' means that some check failed\n\n==== Verification Process ====\n\nValidation consists of the following steps:\n\n# Basic validation\n## Compute the transaction <code>to_spend</code> from ''m'' and ''A''\n## Decode ''s'' as the transaction <code>to_sign</code>\n## If ''s'' was a full transaction, confirm all fields are set as specified above; in particular that\n##* <code>to_sign</code> has at least one input and its first input spends the output of </code>to_spend</code>\n##* <code>to_sign</code> has exactly one output, as specified above\n## Confirm that the two transactions together satisfy all consensus rules, except for <code>to_spend</code>'s missing input, and except that ''nSequence'' of <code>to_sign</code>'s first input and ''nLockTime'' of <code>to_sign</code> are not checked.\n# (Optional) If the validator does not have a full script interpreter, it should check that it understands all scripts being satisfied. If not, it should stop here and output ''inconclusive''.\n# Check the **required rules**:\n## All signatures must use the SIGHASH_ALL flag.\n## The use of <code>CODESEPARATOR</code> or <code>FindAndDelete</code> is forbidden.\n## <code>LOW_S</code>, <code>STRICTENC</code> and <code>NULLFAIL</code>: valid ECDSA signatures must be strictly DER-encoded and have a low-S value; invalid ECDSA signature must be the empty push\n## <code>MINIMALDATA</code>: all pushes must be minimally encoded\n## <code>CLEANSTACK</code>: require that only a single stack element remains after evaluation\n## <code>MINIMALIF</code>: the argument of <code>IF</code>/<code>NOTIF</code> must be exactly 0x01 or empty push\n## If any of the above steps failed, the validator should stop and output the ''invalid'' state.\n# Check the **upgradeable rules**\n## The version of <code>to_sign</code> must be 0 or 2.\n## The use of NOPs reserved for upgrades is forbidden.\n## The use of segwit versions greater than 1 are forbidden.\n## If any of the above steps failed, the validator should stop and output the ''inconclusive'' state.\n# Let ''T'' by the nLockTime of <code>to_sign</code> and ''S'' be the nSequence of the first input of <code>to_sign</code>. Output the state ''valid at time T and age S''.\n\n=== Signing ===\n\nSigners who control an address ''A'' who wish to sign a message ''m'' act as follows:\n\n# They construct <code>to_spend</code> and <code>to_sign</code> as specified above, using the scriptPubKey of ''A'' for <code>message_challenge</code> and tagged hash of ''m'' as <code>message_hash</code>.\n# Optionally, they may set nLockTime of <code>to_sign</code> or nSequence of its first input.\n# Optionally, they may add any additional outputs to <code>to_sign</code> that they wish to prove control of.\n# They satisfy <code>to_sign</code> as they would any other transaction.\n\nThey then encode their signature, choosing either ''simple'' or ''full'' as follows:\n\n* If they added no inputs to <code>to_sign</code>, left nSequence and nLockTime at 0, and ''A'' is a Segwit address (either pure or P2SH-wrapped), then they may base64-encode <code>message_signature</code>\n* Otherwise they must base64-encode <code>to_sign</code>.\n\n== Compatibility ==\n\nThis specification is backwards compatible with the legacy signmessage/verifymessage specification through the special case as described above.\n\n== Reference implementation ==\n\n* Bitcoin Core pull request (basic support) at: https://github.com/bitcoin/bitcoin/pull/24058\n\n== Acknowledgements ==\n\nThanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille, Andrew Poelstra, and many others for their feedback on the specification.\n\n== References ==\n\n# Original mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n== Test vectors ==\n\n=== Message hashing ===\n\nMessage hashes are BIP340-tagged hashes of a message, i.e. sha256_tag(m), where tag = <code>BIP0322-signed-message</code>, and m is the message as is without length prefix or null terminator:\n\n* Message = \"\" (empty string): <code>c90c269c4f8fcbe6880f72a721ddfbf1914268a794cbb21cfafee13770ae19f1</code>\n* Message = \"Hello World\": <code>f0eb03b1a75ac6d9847f55c624a99169b5dccba2a31f5b23bea77ba270de0a7a</code>\n\n=== Message signing ===\n\nGiven below parameters:\n\n* private key <code>L3VFeEujGtevx9w18HD1fhRbCH67Az2dpCymeRE1SoPK6XQtaN2k</code>\n* corresponding address <code>bc1q9vza2e8x573nczrlzms0wvx3gsqjx7vavgkx0l</code>\n\nProduce signatures:\n\n* Message = \"\" (empty string): <code>AkcwRAIgM2gBAQqvZX15ZiysmKmQpDrG83avLIT492QBzLnQIxYCIBaTpOaD20qRlEylyxFSeEA2ba9YOixpX8z46TSDtS40ASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=</code> or <code>AkgwRQIhAPkJ1Q4oYS0htvyuSFHLxRQpFAY56b70UvE7Dxazen0ZAiAtZfFz1S6T6I23MWI2lK/pcNTWncuyL8UL+oMdydVgzAEhAsfxIAMZZEKUPYWI4BruhAQjzFT8FSFSajuFwrDL1Yhy</code>\n* Message = \"Hello World\": <code>AkcwRAIgZRfIY3p7/DoVTty6YZbWS71bc5Vct9p9Fia83eRmw2QCICK/ENGfwLtptFluMGs2KsqoNSk89pO7F29zJLUx9a/sASECx/EgAxlkQpQ9hYjgGu6EBCPMVPwVIVJqO4XCsMvViHI=</code> or <code>AkgwRQIhAOzyynlqt93lOKJr+wmmxIens//zPzl9tqIOua93wO6MAiBi5n5EyAcPScOjf1lAqIUIQtr3zKNeavYabHyR8eGhowEhAsfxIAMZZEKUPYWI4BruhAQjzFT8FSFSajuFwrDL1Yhy</code>\n\n=== Transaction Hashes ===\n\nto_spend:\n\n* Message = \"\" (empty string): <code>c5680aa69bb8d860bf82d4e9cd3504b55dde018de765a91bb566283c545a99a7</code>\n* Message = \"Hello World\": <code>b79d196740ad5217771c1098fc4a4b51e0535c32236c71f1ea4d61a2d603352b</code>\n\nto_sign:\n\n* Message = \"\" (empty string): <code>1e9654e951a5ba44c8604c4de6c67fd78a27e81dcadcfe1edf638ba3aaebaed6</code>\n* Message = \"Hello World\": <code>88737ae86f2077145f93cc4b153ae9a1cb8d56afa511988c149c5c8c9d93bddf</code>\n", "content_length": 11116}
{"bip_number": 321, "filename": "bip-0321.mediawiki", "content": "<pre>\n  BIP: 321\n  Layer: Applications\n  Title: URI Scheme\n  Author: Matt Corallo <bip21@bluematt.me>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0321\n  Status: Proposed\n  Type: Standards Track\n  Created: 2024-11-15\n  License: BSD-2-Clause\n  Replaces: 21\n</pre>\n\n== Copyright ==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n== Abstract ==\n\nThis BIP proposes a URI scheme for describing Bitcoin payment instructions.\n\n== Motivation ==\n\nThe purpose of this URI scheme is to enable users to easily make payments by simply clicking links on webpages or scanning QR Codes.\n\nThis BIP is a modification and intended replacement of [[bip-0021.mediawiki|BIP 0021]] to add information about the modern usage of bitcoin: URIs (including standard query parameters and modern address types) as well as provide forward-looking guidance on how to incorporate new payment instructions. It further adds an optional extension to provide the payment initiator with proof of payment. BIP 21 was based on BIP 20, which was, in turn based on an earlier document by Nils Schneider.\n\n== Specification ==\n\n=== General rules for handling (important!) ===\n\nBitcoin clients MUST NOT act on URIs without getting the user's authorization.\nThey SHOULD require the user to manually approve each payment individually, though in some cases they MAY allow the user to automatically make this decision.\n\n=== Operating system integration ===\n\nGraphical bitcoin clients SHOULD register themselves as the handler for the \"bitcoin:\" URI scheme by default, if no other handler is already registered. If there is already a registered handler, they MAY prompt the user to change it once when they first run the client.\n\n=== General Format ===\n\nBitcoin URIs follow the general format for URIs as set forth in RFC 3986. The path component consists of a bitcoin address, and the query component provides additional payment options.\n\nElements of the query component may contain characters outside the valid range. These must first be encoded according to UTF-8, and then each octet of the corresponding UTF-8 sequence must be percent-encoded as described in RFC 3986.\n\n=== ABNF grammar ===\n\n bitcoinurn     = \"bitcoin:\" [ bitcoinaddress ] [ \"?\" bitcoinparams ]\n bitcoinaddress = *base58 / *bech32 / *bech32m\n bitcoinparams  = bitcoinparam [ \"&\" bitcoinparams ]\n bitcoinparam   = [ amountparam / labelparam / messageparam / responseparam / otherparam / reqparam ]\n amountparam    = \"amount=\" *digit [ \".\" *digit ]\n labelparam     = \"label=\" *qchar\n messageparam   = \"message=\" *qchar\n responseparam  = [ \"req-\" ] \"pop=\" *qchar\n otherparam     = qchar *qchar [ \"=\" *qchar ]\n reqparam       = \"req-\" qchar *qchar [ \"=\" *qchar ]\n\nHere, \"qchar\" corresponds to valid characters of an RFC 3986 URI query component, excluding the \"=\" and \"&\" characters, which this BIP takes as separators.\n\nThe scheme component (\"bitcoin:\") is case-insensitive, and implementations must accept any combination of uppercase and lowercase letters. The query parameter keys are also case-insensitive. Query parameter values and bitcoin address fields may be case-sensitive depending on their content.\n\nMultiple query parameters with the same key MAY be included for query parameters representing payment instructions. Multiple query parameters with the same key MUST NOT be included for keys \"label\", \"message\", or \"pop\". Multiple query parameters with the same key for other keys MUST be allowed for unknown query parameters. Future query parameter keys may or may not allow for duplicate parameters.\n\n=== Bitcoin Address ===\n\nThe bitcoinaddress body MUST be either a base58 P2SH or P2PKH address, bech32 Segwit version 0 address, bech32m Segwit address, or empty. Future address formats SHOULD instead be placed in query keys as optional payment instructions to provide backwards compatibility during upgrade cycles. The bitcoinaddress part of the URI MAY be left empty if there is at least one payment instruction provided in a query parameter, allowing for recipients wishing to avoid a standard on-chain fallback.\n\n=== Query Keys ===\n\nThe following keys are defined generally and apply to any URI regardless of payment instructions:\n\n*label: Label for the recipient (e.g. name of receiver)\n*message: message that describes the transaction to the user ([[#Examples|see examples below]])\n*pop: a URI which the Bitcoin Wallet may return to in order to provide the application which initiated the payment with proof that a payment was completed.\n\nThe following keys are currently defined for payment instructions of various forms:\n\n*lightning: Lightning BOLT 11 invoices\n*lno: Lightning BOLT12 offers\n*pay: [[bip-0351.mediawiki|BIP 351 Private Payment addresses]]\n*sp: [[bip-0352.mediawiki|BIP 352 Silent Payment addresses]]\n\nNew payment instructions using bech32 or bech32m encodings SHOULD reuse their address format's Human Readable Part as the parameter key.\n\n==== Transfer amount ====\n\nIf an amount is provided, it MUST be specified in decimal BTC.\nAll amounts MUST contain no commas and use a period (.) as the separating character to separate whole numbers and decimal fractions.\nI.e. amount=50.00 or amount=50 is treated as 50 BTC, and amount=50,000.00 is invalid.\n\n=== Proof of Payment ===\n\nThe URI MAY include a \"pop\" (or \"req-pop\") parameter whose value can be used to build a URI which the wallet application can, after payment completes, \"open\" to provide proof the payment was completed or other information about the payment.\n\nThe value of a \"pop\" (or \"req-pop\") parameter shall be a percent-encoded (per RFC 3986 section 2.1) URI prefix. The wallet application, if it supports providing payment information SHOULD percent-decode the provided URI once, append the query parameter key from which the payment instructions used were read, append a single =, and finally append the Payment Information to the resulting URI and open it with the default system handler for the URI. For payment instructions read from the body of the URI, \"onchain\" SHALL be used in place of the key.\n\nA wallet MUST validate that the provided URI's scheme is not (case-insensitive) \"http\", \"https\", \"file\", \"javascript\", \"mailto\" or any other scheme which will open in a web browser prior to opening it.\n\nIf a wallet will not open the pop scheme (either because it does not support returning payment information for the selected payment method or because it uses a URI scheme which should not be opened) and the parameter was passed as a \"req-pop\" parameter, the wallet MUST NOT initiate payment.\n\nFor payments made using an on-chain transaction, the Payment Information shall be the full (including witness data) Bitcoin transaction as it was broadcasted to the Bitcoin network, encoded in hex.\n\nFor payments made using a BOLT 11 invoice (communicated via the `lightning` parameter), the Payment Information shall be the hex-encoded payment preimage.\n\nOther payment schemes will define their own Payment Information format. This BIP may be updated from time to time with Payment Information formats for other payment schemes.\n\n== Rationale ==\n\n=== Payment identifiers, not person identifiers ===\n\nBest practices are that a unique address should be used for every transaction on-chain.\nTherefore, a URI which contains an on-chain payment address MUST NOT represent an exchange of personal information, but a one-time payment instruction. URIs which represent only reusable non-address-reusing payment instructions (like Lightning BOLT12 offers or Silent Payments) MAY be reused as a wallet sees fit.\n\n=== Proof of Payment ===\n\nOn many mobile operating systems (especially, or any operating system more generally), applications may \"open\" a bitcoin: URI in order to initiate a payment with the user's default wallet application. These payment-initiating applications may wish to learn about the completed payment.\n\nFor payments completed on-chain, this is largely addressed by having the payment-initiating application monitor the blockchain for payment completion, however for other payment schemes (e.g. lightning), no such global ledger of transactions exists. In that case, proof of payment must be provided via some other mechanism.\n\nIn order to avoid inadvertently revealing the sender's IP address or other information to the recipient, proof URIs must only be opened when they will simply switch to another locally-installed application (i.e. the application which initiated the payment). When clicking a URI from a website, the website should already have plenty of logic on its backend to process payment completion and a proof-of-payment callback is unnecessary.\n\n== Reference Implementation ==\n\nDocumentation: https://docs.rs/bitcoin-payment-instructions\n\nCode repository: https://github.com/rust-bitcoin/bitcoin-payment-instructions\n\n== Forward compatibility ==\n\nQuery parameter keys which are prefixed with a req- are considered required.  If a client does not implement handling a query parameter which has a key prefixed with req-, it MUST consider the entire URI invalid.  Any other query parameters which are not implemented, but which are not prefixed with a req-, can be safely ignored.\n\nAs future new address types should be added using query parameters rather than the `bitcoinaddress` field, URIs seamlessly support various payment instructions while senders only need to support legacy instructions. This allows old senders to pay newer recipients which offer more modern payment instruction formats.\n\n== Backward compatibility ==\n\nCompared to BIP 21, this document describes standard query parameters containing payment instructions, makes query parameters case-insensitive, allows bech32 and bech32m addresses in the `bitcoinaddress` field, and allows for URIs with an empty `bitcoinaddress` field. Use of bech32 and bech32m `bitcoinaddress` fields were long-since common practice in 2024, and the `lightning` query parameter storing BOLT 11 payment instructions became common practice in the year or three leading up to 2024. Inclusion of standard query parameters was added to provide guidance on query parameter usage going forward.\n\nAdditionally, this BIP describes the \"pop\" query parameter, which was unused and will be ignored by BIP 21 implementations.\n\nAny existing BIP 21 implementation should automatically be fully compliant with this BIP, as the changes only describe existing practice or impact future address format inclusion, with the one possible exception of query parameters being made case-insensitive. Note, however, that treating query parameters as case-insensitive is already common practice due to the use of mostly-uppercase URIs in QR codes.\n\n== Appendix ==\n\n=== Examples ===\n\n==== URIs ====\n\nJust the address:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\n\nAddress with recipient's name as label:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?label=Luke-Jr\n\nRequest 20.30 BTC to \"Luke-Jr\":\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=20.3&label=Luke-Jr\n\nRequest 50 BTC with message:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=50&label=Luke-Jr&message=Donation%20for%20project%20xyz\n\nRequest funds to be paid over lightning to a BOLT 11 invoice with a fallback to on-chain payments:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?lightning=lnbc420bogusinvoice\n\nRequest funds to be paid over lightning to a BOLT 11 invoice with no fallback:\n bitcoin:?lightning=lnbc420bogusinvoice\n\nRequest funds to be paid over lightning to a BOLT 12 offer with no fallback:\n bitcoin:?lno=lno1bogusoffer\n\nRequest funds to be paid over lightning to a BOLT 12 offer or silent payments address with no fallback:\n bitcoin:?lno=lno1bogusoffer&sp=sp1qsilentpayment\n\nRequest funds to be paid to a silent payments address with no fallback:\n bitcoin:?sp=sp1qsilentpayment\n\nRequest funds to be paid to a silent payments address with a fallback:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?sp=sp1qsilentpayment\n\nSome future version that has variables which are (currently) not understood and required and thus invalid:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?req-somethingyoudontunderstand=50&req-somethingelseyoudontget=999\n\nSome future version that has variables which are (currently) not understood but not required and thus valid:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?somethingyoudontunderstand=50&somethingelseyoudontget=999\n\nMultiple segwit addresses may be included for various versions of segwit, note that the human-readable part for all of them is `bc`\n bitcoin:?bc=bc1qufgy354j3kmvuch987xe4s40836x3h0lg8f5n2&bc=bc1p5swkugezn97763tl0yty6556856uug0q6jflljvep9m4p7339x5qzyrh4g\n\nMany QR codes utilize all-uppercase URIs, which should be handled fine\n BITCOIN:BC1QUFGY354J3KMVUCH987XE4S40836X3H0LG8F5N2?BC=BC1P5SWKUGEZN97763TL0YTY6556856UUG0Q6JFLLJVEP9M4P7339X5QZYRH4G\n BITCOIN:?BC=BC1QUFGY354J3KMVUCH987XE4S40836X3H0LG8F5N2&BC=BC1P5SWKUGEZN97763TL0YTY6556856UUG0Q6JFLLJVEP9M4P7339X5QZYRH4G\n\nA testnet segwit addresses must be included in the `tb` parameter\n bitcoin:?tb=tb1qghfhmd4zh7ncpmxl3qzhmq566jk8ckq4gafnmg\n\nCharacters must be URI encoded properly.\n\n==== Invalid URIs ====\n\nLabels must not appear twice:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?label=Luke-Jr&label=Matt\n\nAmounts must not appear twice:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=42&amount=10\n\nAmounts must not appear twice even if they are the same:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=42&amount=42\n\nMultiple proof of payment URIs must not appear, even if they are sometimes prefixed with req-:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?pop=callback%3a&req-pop=callback%3a\n\nA testnet segwit addresses must be included in the `tb` parameter, not the `bc` parameter.\n bitcoin:?bc=tb1qghfhmd4zh7ncpmxl3qzhmq566jk8ckq4gafnmg\n\n==== Proof of Payment ====\n\nIf the original URI is\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?pop=initiatingapp%3a\nthe wallet should perform the payment information callback by opening\n initiatingapp:onchain=$HEX_ENCODED_TRANSACTION\n\nIf the original URI is\n bitcoin:?lightning=lnbc420bogusinvoice&pop=callbackuri%3abody%3fpop=\nthe wallet should perform the proof-of-payment callback by opening\n callbackuri:body?pop=lightning=$HEX_ENCODED_PAYMENT_PREIMAGE\n\nIf the original URI is\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?lightning=lnbc420bogusinvoice&pop=app%3a%3f\nand the wallet pays on-chain, it should perform the payment information callback by opening\n app:?onchain=$HEX_ENCODED_TRANSACTION\nbut if the app pays using lightning, it should perform the proof-of-payment callback by opening\n app:?lightning=$HEX_ENCODED_PAYMENT_PREIMAGE\n\nIf the original URI is\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?pop=https%3aiwantyouripaddress.com\nthe wallet should make a payment as it normally would but MUST NOT interact with iwantyouripaddress.com\n\nIf the original URI is\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?req-pop=https%3aevilwebsite.com\nthe wallet MUST NOT make a payment\n", "content_length": 14943}
{"bip_number": 320, "filename": "bip-0320.mediawiki", "content": "<pre>\n  BIP: 320\n  Title: nVersion bits for general purpose use\n  Author: BtcDrak <btcdrak@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0320\n  Status: Draft\n  Type: Standards Track\n  Created: 2018-03-01\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis BIP reserves 16 bits of the block header nVersion field for general purpose use and removes their meaning for the purpose of version bits soft-fork signalling.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n==Motivation==\n\nThere are a variety of things that miners may desire to use some of the nVersion field bits for. However, due to their use to coordinate miner activated soft-forks, full node software will generate false warnings about unknown soft forks if those bits are used for non soft fork signalling purposes. By reserving bits from the nVersion field for general use, node software can be updated to ignore those bits and therefore will not emit false warnings. Reserving 16 bits for general use leaves enough for 13 parallel soft-forks using version bits.\n\n===Example Uses===\n\nThe following are example cases that would benefit from using some of the bits from the nVersion field. This list is not exhaustive.\n\nBitcoin mining hardware currently can exhaust the 32 bit nonce field in less than 200ms requiring the controller to distribute new jobs very frequently to each mining chip consuming a lot of bandwidth and CPU time. This can be greatly reduced by rolling more bits. Rolling too many bits from nTime is not ideal because it may distort the timestamps over a longer period.\n\nVersion-rolling AsicBoost requires two bits from the nVersion field to calculate 4-way collisions. Any two bits can be used and mining equipment can negotiate which bits are to be used with mining pools via the Stratum \"version-rolling\" extension.\n\n==Specification==\n\nSixteen bits from the block header nVersion field, starting from 13 and ending at 28 inclusive (0x1fffe000), are reserved for general use and removed from BIP8 and BIP9 specifications. A mask of 0xe0001fff should be applied to nVersion bits so bits 13-28 inclusive will be ignored for soft-fork signalling and unknown soft-fork warnings.\n\nThis specification does not reserve specific bits for specific purposes.\n\n==Reference Implementation==\n\nhttps://github.com/btcdrak/bitcoin/commit/d12516e136d4a8952904a13eedc9f4225f35dc3b\n\n==Backwards Compatibility==\n\nNon-upgraded nodes will interpret the reserved bits of this proposal as signals for soft forks, and may additionally activate the warning system for unknown soft forks.\n\nThis proposal does not require a soft fork to implement.\n\nAt the time of writing no known soft forks are pending using any of 16 bits reserved in this BIP, and given that a non-trivial percentage of the  hashrate is already making uses of those bits, future soft forks SHOULD NOT utilise those bits for activation signalling.\n\n==Acknowledgements==\n\nTimo Hanke and Sergio Lerner for originally proposing 15-bit extra nNonce2.\n\n==References==\n\n[[bip-0008.mediawiki|BIP8]]\n\n[[bip-0009.mediawiki|BIP9]]\n\n[https://arxiv.org/pdf/1604.00575.pdf AsicBoost white paper]\n\n[https://github.com/BlockheaderNonce2/bitcoin/wiki Blockheader Extra nNonce2 proposal]\n\n[https://github.com/slushpool/stratumprotocol/blob/master/stratum-extensions.mediawiki Stratum protocol extension BIP for version-rolling]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n", "content_length": 3676}
{"bip_number": 310, "filename": "bip-0310.mediawiki", "content": "<pre>\n  BIP: 310\n  Layer: Applications\n  Title: Stratum protocol extensions\n  Author: Pavel Moravec <pavel.moravec@braiins.cz>\n          Jan \u010capek <jan.capek@braiins.cz>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0310\n  Status: Draft\n  Type: Informational\n  Created: 2018-03-10\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis BIP provides a generic mechanism for specifying stratum protocol\nextensions. At the same time, one of the important extensions that is\nspecified by this BIP is configuration of bits for \"version rolling\"\nin nVersion field of bitcoin block header.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\ndocument are to be interpreted as described in RFC 2119.\n\n==Motivation==\n\nThe initial motivation for specifying some general support for stratum\nprotocol extensions was a need to allow miners to do so called\n\"version rolling\", changing value in the first field of the Bitcoin\nblock header.\n\nVersion rolling is backwards incompatible change to the stratum protocol\nbecause the miner couldn't communicate different block version value to\nthe server in the original version of the stratum protocol. Similarly,\na server couldn't communicate safe bits for rolling to a miner. So\nboth miners and pools need to implement some protocol extension to\nsupport version rolling.\n\nTypically, if a miner sends an unknown message to a server, the server\ncloses the connection (not all implementations do that but some\ndo). So it is not very safe to try to send unknown messages to\nservers.\n\nWe can use this opportunity to make one backwards incompatible\nchange to the protocol to support multiple extensions in the\nfuture. In a way that a miner can advertise its capabilities and at\nthe same time it can request some needed features from the server.\n\nIt is preferable that the same mechanism for feature negotiation can\nbe used for not yet known features. It SHOULD be easy to implement in\nthe mining software too.\n\nWe introduce one new message to the stratum protocol ('''\"mining.configure\"''') which handles the initial configuration/negotiation of features in a generic way. So that adding features in the future can be done without a necessity to add new messages to stratum protocol.\n\nEach extension has its unique string name, so called '''extension code'''.\n\n\n==Specification==\nCurrently, the following extensions are defined:\n\n* '''\"version-rolling\"'''\n* '''\"minimum-difficulty\"'''\n* '''\"subscribe-extranonce\"'''\n\n\n===Additional data types===\n\nThe following names are used as type aliases, making the message\ndescription easier.\n\n* '''TMask''' - case independent hexadecimal string of length 8, encoding an unsigned 32-bit integer (~<code>[0-9a-fA-F]{8}</code>)\n\n* '''TExtensionCode''' - non-empty string with a value equal to the name of some protocol extension.\n\n* '''TExtensionResult''' - <code>true</code> / <code>false</code> / ''String''.\n** <code>true</code> = The requested feature is supported and its configuration understood and applied.\n** <code>false</code> = The feature is not supported or unknown.\n** ''String'' = Error message containing information about what went wrong.\n\n\n===Request \"mining.configure\"===\n\nThis message (JSON RPC Request) SHOULD be the '''first message''' sent\nby the miner after the connection with the server is established. The client\nuses the message to advertise its features and to request/allow some\nprotocol extensions.\n\nThe reason for it being the first is that we want the implementation and\npossible interactions to be as easy and simple as possible. An extension\ncan define explicitly what does a repeated configuration of that\nextension mean.\n\nEach extension code provides a namespace for its extension parameters\nand extension return values. By convention, the names are formed from\nextension codes by adding \".\" and a parameter name. The same applies\nfor the return values, which are transferred in a result map\ntoo. E.g. \"version-rolling.mask\" is the name of the parameter \"mask\" of\nextension \"version-rolling\".\n\n'''Parameters''':\n\n* '''extensions''' (REQUIRED, List of ''TExtensionCode'')\n::- Each string in the list MUST be a valid extension code. The meaning of each code is described independently as part of the extension definition. A miner SHOULD advertise all its available features.\n\n* '''extension-parameters''' (REQUIRED, ''Map of (String -> Any)'')\n::- Parameters of the requested/allowed extensions from the first parameter.\n\n\n'''Return value''':\n\n* ''Map of (String -> Any)''\n::- Each code from the '''extensions''' list MUST have a defined return value (''TExtensionCode'' -> ''TExtensionResult''). This way the miner knows if the extension is activated or not. E.g. <code>{\"version-rolling\":false}</code> for unsupported version rolling.\n::- Some extensions need additional information to be delivered to the miner. The return value map is used for this purpose.\n\n\nExample request (new-lines added):\n\n<pre>\n {\"method\": \"mining.configure\",\n  \"id\": 1,\n  \"params\": [[\"minimum-difficulty\", \"version-rolling\"],\n\t     {\"minimum-difficulty.value\": 2048,\n\t      \"version-rolling.mask\": \"1fffe000\", \"version-rolling.min-bit-count\": 2}]}\n</pre>\n\n(The miner requests extensions <code>\"version-rolling\"</code> and\n<code>\"minimum-difficulty\"</code>. It sets the parameters according to the extensions'\ndefinitions.)\n\nExample result (new-lines added):\n\n<pre>\n {\"error\": null,\n  \"id\": 1,\n  \"result\": {\"version-rolling\": true,\n\t     \"version-rolling.mask\": \"18000000\",\n\t     \"minimum-difficulty\": true}}\n</pre>\n\n=Defined extensions=\n\n==Extension \"version-rolling\"==\n\nThis extension allows the miner to change the value of some bits in the\nversion field in the block header. Currently there are no standard bits\nused for version rolling so they need to be negotiated between a\nminer and a server.\n\nA miner sends the server a mask describing bits which the miner is\ncapable of changing. 1 = changeable bit, 0 = not changeable (<code>miner_mask</code>)\nand a minimum number of bits that it needs for efficient version rolling.\n\nA server typically allows you to change only some of the version bits\n(<code>server_mask</code>) and the rest of the version bits are\nfixed. E.g. because the block needs to be valid or some signaling is\nin place.\n\nThe server responds to the configuration message by sending a mask\nwith common bits intersection of the miner's mask and its a mask\n(<code>response = server_mask & miner_mask</code>)\n\nExample request (a miner capable of changing any 2 bits from a 16-bit mask):\n\n {\"method\": \"mining.configure\", \"id\": 1, \"params\": [[\"version-rolling\"], {\"version-rolling.mask\": \"1fffe000\", \"version-rolling.min-bit-count\": 2}]}\n\n\nExample result (success):\n\n {\"error\": null, \"id\": 1, \"result\": {\"version-rolling\": true, \"version-rolling.mask\": \"18000000\"}}\n\n\nExample result (unknown extension):\n\n {\"error\": null, \"id\": 1, \"result\": {\"version-rolling\": false}}\n\n\n'''Extension parameters''':\n\n* '''\"version-rolling.mask\"''' (OPTIONAL, ''TMask'', default value <code>\"ffffffff\"</code>)\n::- Bits set to 1 can be changed by the miner. This value is expected\nto be stable for the whole mining session. A miner doesn't have to\nsend the mask, in this case a default full mask is used.\n\n'''Extension return values''':\n\n* '''\"version-rolling\"''' (REQUIRED, ''TExtensionResult'')\n::- When responded with <code>true</code>, the server will accept new parameter of '''\"mining.submit\"''', see later.\n\n* '''\"version-rolling.mask\"''' (REQUIRED, ''TMask'')\n::- Bits set to 1 are allowed to be changed by the miner. If a miner changes bits with mask value 0, the server will reject the submit.\n::- The server SHOULD return the largest mask possible (as many bits set to 1 as possible). This can be useful in a mining proxy setup when a proxy needs to negotiate the best mask for its future clients. There is a [https://github.com/bitcoin/bips/pull/661/files Draft BIP] describing available nVersion bits. The server SHOULD pick a mask that preferably covers all bits specified in the BIP.\n\n* '''\"version-rolling.min-bit-count\"''' (REQUIRED, ''TMask'')\n::- The miner also provides a minimum number of bits that it needs for efficient version rolling in hardware. Note that this parameter provides important diagnostic information to the pool server. If the requested bit count exceeds the limit of the pool server, the miner always has the chance to operate in a degraded mode without using full hashing power. The pool server SHOULD NOT terminate miner connection if this rare mismatch case occurs.\n\n===Notification '''\"mining.set_version_mask\"'''===\n\nServer notifies the miner about a new mask valid for the\nconnection. This message can be sent at any time after the successful\nsetup of the version rolling extension by the \"mining.configure\"\nmessage. The new mask is valid '''immediately''', so that the server\ndoesn't wait for the next job.\n\n\n'''Parameters''':\n\n* ''mask'' (REQUIRED, ''TMask''): The meaning is the same as the '''\"version-rolling.mask\"''' return parameter.\n\nExample:\n\n {\"params\":[\"00003000\"], \"id\":null, \"method\": \"mining.set_version_mask\"}\n\n\n===Changes in request '''\"mining.submit\"'''===\n\nImmediately after successful activation of the version-rolling extension\n(result to '''\"mining.configure\"''' sent by server), the server MUST accept\nan additional parameter of the message '''\"mining.submit\"'''. The client MUST\nsend one additional parameter, '''version_bits''' (6th parameter, after\n''worker_name'', ''job_id'', ''extranonce2'', ''ntime'' and ''nonce'').\n\n\n'''Additional parameters''':\n\n* ''version_bits'' (REQUIRED, ''TMask'') - Version bits set by miner.\n::- Miner can set only bits corresponding to the set bits in the last received mask from the server either as response to \"mining.configure\" or \"mining.set_version_mask\" notification (<code>last_mask</code>). This must hold:\n version_bits & ~last_mask ==  0\n::- The server computes ''nVersion'' for the submit as follows:\n nVersion = (job_version & ~last_mask) | (version_bits & last_mask)\nwhere <code>job_version</code> is the block version sent to miner as part of job with id <code>job_id</code>.\n\n==Extension \"minimum-difficulty\"==\n\nThis extension allows miner to request a minimum difficulty for the\nconnected machine. It solves a problem in the original stratum\nprotocol where there is no way how to communicate hard limit of the\nconnected device.\n\n'''Extension parameters''':\n* '''\"minimum-difficulty.value\"''' (REQUIRED, ''Integer/Float'', >= 0)\n::- The minimum difficulty value acceptable for the miner/connection. The value can be 0 for essentially disabling the feature.\n\n'''Extension return values''':\n* '''\"minimum-difficulty\"''' (REQUIRED, ''TExtensionResult'')\n::- Whether the minimum difficulty was accepted or not.\n::- This extension can be configured multiple times by calling \"mining.configure\" with \"minimum-difficulty\" code again.\n\n\n==Extension \"subscribe-extranonce\"==\n\nParameter-less extension. Miner advertises its capability of receiving\nmessage '''\"mining.set_extranonce\"''' message (useful for hash rate\nrouting scenarios).\n\n==Extension \"info\"==\n\nMiner provides additional text-based information.\n\n'''Extension parameters''':\n* '''\"info.connection-url\"''' (OPTIONAL, ''String'')\n::- Exact URL used by the mining software to connect to the stratum server.\n\n* '''\"info.hw-version\"''' (OPTIONAL, ''String'')\n::- Manufacturer specific hardware revision string.\n\n* '''\"info.sw-version\"''' (OPTIONAL, ''String'')\n::- Manufacturer specific software version\n\n* '''\"info.hw-id\"''' (OPTIONAL, ''String'')\n::- Unique  identifier of the mining device\n\n==Compatibility==\n\nCurrently, there is a similar protocol feature '''mining.capabilities''' that\nwas intended for various protocol extensions.  However, '''mining.configure'''\nis incompatible with this feature as it requires a server response confirming\nall accepted/negotiated extensions. The reason why we made it incompatible is\nthat '''mining.capabilities''' request has no associated response.\n\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n", "content_length": 12194}
{"bip_number": 301, "filename": "bip-0301.mediawiki", "content": "<pre>\n  BIP: 301\n  Layer: Consensus (soft fork)\n  Title: Blind Merged Mining (Consensus layer)\n  Author: Paul Sztorc <truthcoin@gmail.com>\n          CryptAxe <cryptaxe@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0301\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-07-23\n  License: BSD-2-Clause\n</pre>\n\n\n==Abstract==\n\nBlind Merged Mining (BMM) allows SHA-256d miners to collect transaction fee revenue from other blockchains, without running any new software (i.e., without \"looking\" at those alt-chains, hence \"blind\").\n\nInstead, this block-assembly work is done by alt-chain users. They choose the alt-chain block, and what txns go in it, the fees etc. Simultaneously, these users \"bid\" on L1 to win the right to be the sole creator of the alt-chain block. BIP-301 ensures that L1 miners only accept one bid (per 10 minutes, per L2 category), instead of taking all of them (which is what they would ordinarily do).\n\n\n==Motivation==\n\n\"Merged-Mining\" (MM) allows miners to reuse their hashing work to secure other chains (for example, as in Namecoin).\n\nHowever, traditional MM has two drawbacks:\n\n# Miners must run a full node of the other chain(s). (Thus, they must run \"non-Bitcoin\" software which may be buggy.)\n# Miners are paid on the other chain, in Alt-currency. (Miners who MM Namecoin, will earn NMC.)\n\n\n==Notation and Example==\n\nWe use notation side:\\* and main:\\* in front of otherwise ambiguous words (such as \"block\", \"node\", or \"chain\"), to distinguish the mainchain version from its sidechain/alt-chain counterpart. We name all sidechain users \"Simon\", and name all mainchain miners \"Mary\".\n\nFurthermore, here is an example of BIP-301 in use. Imagine that a side:block contains 20,000 txns, each paying a $0.10 fee; therefore, the side:block is worth $2000 of fee revenue. In BIP-301, the sidechain's coinbase txn will pay this $2000 to \"Simon\". Simon does no hashing, but instead makes one L1 txn paying $1999 to the L1 miners (\"Mary\"). Thus, Mary ends up with all of the fee revenue, even though she didn't do anything on the sidechain.\n\n\n{| class=\"wikitable\"\n|-\n! colspan=\"3\" | Upon finding a sidechain block worth $2000...\n|- style=\"font-weight:bold; text-decoration:underline;\"\n| Item\n| Layer1 Miner (\"Mary\")\n| Sidechain User (\"Simon\")\n|-\n| Runs a sidechain node?\n| No\n| Yes\n|-\n| How much hashing?\n| 100%\n| 0%\n|-\n| Coins collected, on Layer2\n| $0\n| $2000\n|-\n| Coins paid out, on Layer1\n| $0\n| $1999\n|-\n| Coins rec'd, on Layer1\n| $1999\n| $0\n|-\n| d(Net Worth)\n| +$1999\n| +$1\n|}\n\n\nBIP-301 makes this specialization-of-labor trustless on L1. If Mary takes Simon's money, then she must let Simon control the side:block.\n\n\n\n==Specification==\n\nEach candidate for next side:block is defined by its unique side:blockhash \"h*\". (Even if the entire rest of the L2 block is identical, different Simons will have different side:coinbases and therefore different h*.)\n\nBIP-301 consists of two messages: \"BMM Accept\" and \"BMM Request\".\n\n# \"BMM Accept\" -- A coinbase output in L1, which contains h*. Mary can only choose one h* to endorse.\n# \"BMM Request\" -- A transaction where Simon offers to pay Mary, if (and only if) Mary's L1 block contains Simon's h*.\n\nAs a miner, Mary controls the main:coinbase, so she may select any h*. Her selection determines which side:block is \"found\" -- and which associated BMM Request she can collect.\n\n\n=== BMM Accept  ===\n\nTo \"Accept\" a BMM proposal (endorsing Simon's side:block, and allowing Mary to accept Simon's money later in the block), Mary places an OP_RETURN output into the main:coinbase as follows:\n\n<pre>\n    1-byte - OP_RETURN (0x6a)\n    4-bytes - Message header (0xD1617368)\n    1-byte - Sidechain number (0-255)\n    32-bytes - h* (obtained from Simon)\n</pre>\n\n[https://github.com/LayerTwo-Labs/bip300301_messages/blob/dd26518ff9505ea9088436797171799f359d0076/src/lib.rs#L256-L268 Code details here].\n\nIf these OP_RETURN outputs are not present, then no Requests were accepted. (And, Mary would get no money from Requests.)\n\nIt is possible for Mary and Simon to be the same person. They would trust each other completely, so the BMM process would stop here. There would only be Accepts; Requests would be unnecessary.\n\nWhen Simon and Mary are different people, Simon will need to use BMM Requests.\n\n=== BMM Request ===\n\nSimon will use BMM Requests to buy the \"right\" to find a sidechain block, from Mary.\n\nFor each side:block that Simon wants to attempt, he broadcasts a txn containing the following as an OP_RETURN:\n\n<pre>\n    1-byte - OP_RETURN (0x6a)\n    3-bytes - Message header (0x00bf00)\n    1-byte - Sidechain number (0-255)\n    32-bytes  - h* (obtained from L2 node)\n    32-bytes  - prevMainBlock (the blockhash of the previous main:block)\n</pre>\n\nh* is chosen by Simon to correspond to the side:block he wants to mine on the alt-chain. nSidechain is the number assigned to the sidechain/alt-chain when it was created.\n\nThis txn is invalid if it fails any of the following checks:\n\n# Each \"BMM Request\", must match one corresponding \"BMM Accept\" (previous section).\n# Only one BMM Request is allowed in each main:block, per nSidechain. In other words, if 700 users broadcast BMM Requests for sidechain #4, then the main:miner must single out one BMM_Request_4 to include in this L1 block.\n# The 32-bytes of prevMainBlock must match the previous main:blockhash. Thus, Simon's txns are only valid for the current block, in the block history that he knows about.\n\n\nMost BMM Request txns will never make it into a block. Simon will make many BMM Requests, but only one will be accepted. Since only one BMM Request can enter the L1 block, Simon may feel comfortable making multiple offers all day long. This means Mary has many offers to choose from, and can choose the one that pays her the most.\n\nThis BIP allows BMM Requests to take place over Lightning. One method is [https://www.drivechain.info/media/bmm-note/bmm-lightning/ here]. (BMM Accepts cannot be over LN, since they reside in main:coinbase txns.)\n\n\n==Backward compatibility==\n\nThis soft fork can be deployed without modifying Bitcoin Core at all (ie, via [https://bip300cusf.com/ CUSF]).\n\n\n==Deployment==\n\nThis BIP deploys when/if >51% hashrate runs [https://github.com/LayerTwo-Labs/bip300301_enforcer/ the enforcer client].\n\nIdeally, a critical mass of users would also run the enforcer client -- this would strongly dissuade miners from ever de-activating it.\n\n\n==Reference Implementation==\n\nThe enforcer is [https://github.com/LayerTwo-Labs/bip300301_enforcer/ here].\n\nAlso, several example L2s using BIP-301 are [https://releases.drivechain.info/ here].\n\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n", "content_length": 6731}
{"bip_number": 300, "filename": "bip-0300.mediawiki", "content": "<pre>\n  BIP: 300\n  Layer: Consensus (soft fork)\n  Title: Hashrate Escrows (Consensus layer)\n  Author: Paul Sztorc <truthcoin@gmail.com>\n          CryptAxe <cryptaxe@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0300\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-08-14\n  License: BSD-2-Clause\n  Post-History: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014364.html\n</pre>\n\n==Abstract==\n\nBIP-300 enables a new type of L2, where \"withdrawals\" (the L2-to-L1 txns) are governed by proof-of-work -- instead of a federation or fixed set of pubkeys.\n\nBIP-300 emphasizes slow, transparent, and auditable withdrawals that are easy for honest users to get right and hard for dishonest miners to abuse. The main design goal for BIP-300 is ''partitioning'' -- users can ignore BIP-300 txns if they wish; it makes no difference to L1 if the user validates all, some, or none of them. The second design goal is ''security'' -- users of the L2 should feel confident that, [https://www.drivechain.info/blog/fees/ if the L2 network is paying a lot of fees], then miners will want to keep it around, and the withdrawals will therefore be processed accurately.\n\nOnce BIP-300 has established a \"bridge\" between L1 and these L2s, users can swap coins in and out instantly, only using BIP-300 for final settlement. This setup allows Bitcoin to process all the transactions in the world, of any shape or size, regardless of blocksize, node software, tech stack, or decentralization level -- all without altering L1 at all.\n\n\n==Motivation==\n\nBIP-300 allows us to achieve [https://www.truthcoin.info/blog/zside-meltcast/ strong privacy], [https://www.truthcoin.info/blog/thunder/ planetary scale], and [https://www.truthcoin.info/blog/all-world-txns/ hundreds of billions of dollars in annual mining revenues], all with a [https://www.drivechain.info/blog/fees/ security model] that is [https://x.com/Truthcoin/status/1701959339508965405 much stronger than] that of the [https://www.truthcoin.info/blog/ln-blackpill/ Lightning Network].\n\nThe original motivation stretches back to Reid Hoffman, who [https://blockstream.com/2015/01/13/en-reid-hoffman-on-the-future-of-the-bitcoin-ecosystem/ wrote in 2014]: \"Sidechains allow developers to add features and functionality to the Bitcoin universe without actually modifying the Bitcoin Core code...Consequently, innovation can occur faster, in more flexible and distributed ways, without losing the synergies of a common platform with a single currency.\"\n\nSee [http://www.drivechain.info/ drivechain.info] for more information.\n\n\n\n==Specification==\n\n===Overview===\n\nBIP-300 consists of six new blockchain messages:\n\n* M1. \"Propose New Sidechain\"\n* M2. \"ACK Proposal\"\n* M3. \"Propose Bundle\"\n* M4. \"ACK Bundle\"\n* M5. Deposit  -- a transfer of BTC from-main-to-side\n* M6. Withdrawal -- a transfer of BTC from-side-to-main\n\n\nNodes organize this data into [https://github.com/LayerTwo-Labs/bip300301_enforcer/blob/13a4353c39a26d9d40180ea361b7580fd682e5b5/src/bip300.rs#L79-L96 a few caches], mainly these two:\n\n* D1. \"The Sidechain List\"\n* D2. \"The Withdrawal List\"\n\n==== D1 (The Sidechain List) ====\n\nD1 is a list of active sidechains. D1 is populated via M1 and M2. Fields #9 and #10 are updated via M5 and M6.\n\n{| class=\"wikitable\"\n|- style=\"font-weight:bold; text-align:center; vertical-align:middle;\"\n! Field No.\n! Label\n! Type\n! Description / Purpose\n|- style=\"vertical-align:middle;\"\n| 1\n| Escrow Number\n| uint8_t\n| The escrow's ID number. Used to uniquely refer to each sidechain.\n|-\n| 2\n| Version\n| int32_t\n| Version number.\n|-\n| 3\n| Sidechain Name\n| string\n| A human-readable name of the sidechain.\n|- style=\"vertical-align:middle;\"\n| 4\n| Sidechain Description\n| string\n| A human-readable name description of the sidechain.\n|- style=\"vertical-align:middle;\"\n| 5\n| Hash1 - tarball hash\n| uint256\n| Intended as the sha256 hash of the tar.gz of the canonical sidechain software. (This is not enforced by BIP-300, and is for human purposes only.)\n|- style=\"vertical-align:middle;\"\n| 6\n| Hash2 - git commit hash\n| uint160\n| Intended as the git commit hash of the canonical sidechain node software. (This is not enforced by BIP-300, and is for human purposes only.)\n|-\n| 7\n| Active\n| bool\n| Does this sidechain slot contain an active sidechain?<br />\n|- style=\"vertical-align:middle;\"\n| 8\n| Activation Status\n| int , int\n| The age of the proposal (in blocks); and the number of \"fails\" (a block that does NOT ack the sidechain). This is discarded after the sidechain activates.\n|- style=\"vertical-align:middle;\"\n| 9\n| \"CTIP\" -- \"TxID\"\n| uint256\n| A UTXO that holds the sidechain's money. (Part 1 of 2).\n|- style=\"vertical-align:middle;\"\n| 10\n| \"CTIP\" -- \"vout\"\n| int32_t\n| A UTXO that holds the sidechain's money. (Part 2 of 2).\n|}\n\n\n==== D2 (The Withdrawal List) ====\n\nWithdrawals are transactions that remove coins \"from\" L2 (i.e., from the BIP-300 locked UTXO), and place them back on L1. Each BIP-300 withdrawal can pay out up to 6,000 withdrawals, and only one withdrawal can succeed at a time (per L2). Therefore, since all L2 users share the same large withdrawal-event, on L1 we call these withdrawals \"bundles\".\n\nD2 is driven by M3, M4, M5, and M6. Those messages enforce the following principles:\n\n# The database has a canonical order (first come first serve).\n# From one block to the next, every \"Blocks Remaining\" field decreases by 1.\n# When \"Blocks Remaining\" reaches zero, the bundle is removed.\n# From one block to the next, the value in \"ACKs\" may either increase or decrease, by a maximum of 1 (see M4).\n# If a bundle's \"ACKs\" reach 13150 or greater, it \"succeeds\" and its corresponding M6 message can be included in a block.\n# If the M6 of a bundle is paid out, it is also removed.\n# If a bundle cannot possibly succeed ( 13150 - \"ACKs\"  >  \"Blocks Remaining\" ), it is removed immediately.\n\n\n{| class=\"wikitable\"\n! Field No.\n! Label\n! Type\n! Description / Purpose\n|-\n| 1\n| Sidechain Number\n| uint8_t\n| Links the withdrawal-request to a specific hashrate escrow.\n|-\n| 2\n| Bundle Hash\n| uint256\n| A withdrawal attempt. Specifically, it is a \"blinded transaction id\" (i.e., the double-Sha256 of a txn that has had two fields zeroed out, see M6) of a txn which could withdraw funds from a sidechain.\n|-\n| 3\n| Work Score (ACKs)\n| uint16_t\n| How many miner upvotes a withdrawal has. Starts at 0. Fastest possible rate of increase is 1 per block.\n|-\n| 4\n| Blocks Remaining\n| uint16_t\n| How long this bundle has left to live (measured in blocks). Starts at 26,300 and counts down.\n|}\n\n\n\n\n=== M1 -- Propose Sidechain ===\n\nNew sidechains are proposed with M1, and ACKed with M2.\n\nM1 is a coinbase OP Return output containing the following:\n\n    1-byte - OP_RETURN (0x6a)\n    4-byte - Message header (0xD5E0C4AF)\n    N-byte - The serialization of the sidechain.\n      1-byte nSidechain\n      4-byte nVersion\n      x-byte title\n      x-byte description\n      32-byte hashID1\n      20-byte hashID2\n\n\nM1 is invalid if:\n\n* It would add a duplicate entry to D1.\n* There is already an M1 in this block.\n* The sidechain serialization does not parse.\n\nOtherwise:\n\n* A new entry is added to D1, whose initial Activation Status is (age=0, fails=0).\n\n\n=== M2 -- ACK Sidechain Proposal ===\n\nM2 is a coinbase OP Return output containing the following:\n\n    1-byte - OP_RETURN (0x6a)\n    4-byte - Message header (0xD6E1C5BF)\n    32-byte - the sha256D hash of sidechain's serialization\n\n\nM2 is ignored if it doesn't parse, or if it is for a sidechain that doesn't exist.\n\nM2 is invalid if:\n\n* An M2 is already in this block.\n* It tries to ACK two different M1s for the same slot.\n\nOtherwise:\n\n* The sidechain is \"ACK\"ed and does NOT get a \"fail\" for this block. (As it otherwise would.)\n\nA sidechain fails to activate if:\n\n* If the slot is unused: during the next 2016 blocks, it accumulates 1008 fails (i.e., 50% hashrate threshold).\n* If the slot is in use: during the next 26,300 blocks, it accumulates 13,150 fails (i.e., 50% hashrate threshold).\n\n( Thus we can overwrite a used sidechain slot. BIP-300 sidechains are already vulnerable to one catastrophe per 13150 blocks (the invalid withdrawal), so this slot-overwrite option does not change the security assumptions. )\n\nOtherwise, the sidechain activates (Active is set to TRUE).\n\n\n=== Withdrawing in Bundles ===\n\nSidechain withdrawals take the form of \"bundles\" -- named because they \"bundle up\" many individual withdrawal-requests into a single rare L1 transaction.\n\nOn the L2 side, individual withdrawal requests are periodically combined into a single CoinJoin-like withdrawal bundle. This bundle is hashed [https://github.com/LayerTwo-Labs/bip300301_messages/blob/398b224981c7c236c8354704e655996d33685149/src/lib.rs#L374C1-L419C2 in a particular way] (on both L2 and L1) -- this \"blinded hash\" commits to its own L1 fee, but (notably) it does not commit to its first tx-input (in that way, it is like [https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki BIP-118]).\n\nThis hash is what L1 miners will slowly ACK over 3-6 months, not the M6 itself (nor any sidechain data, of course).\n\nA bundle will either pay all its withdrawals out (via M6), or fail (and pay nothing out for anyone).\n\n\n=== M3 -- Propose Bundle ===\n\nM3 is a coinbase OP Return output containing the following:\n\n    1-byte - OP_RETURN (0x6a)\n    4-byte - Commitment header (0xD45AA943)\n    32-byte - The bundle hash, to populate a new D2 entry\n    1-byte - nSidechain (the slot number)\n\nM3 is ignored if it does not parse, or if it is for a sidechain that doesn't exist.\n\nM3 is invalid if:\n\n* This block already has an M3 for that nSidechain.\n* A bundle with this hash is already in D2.\n* A bundle with this hash already paid out.\n* A bundle with this hash was rejected in the past.\n\nOtherwise: M3 adds an entry to D2, with initial ACK score = 1 and initial Blocks Remaining = 26,299. (Merely being added to D2, does count as your first upvote.)\n\n\n=== M4 -- ACK Bundle(s) ===\n\nOnce a bundle is in D2, how can we give it enough ACKs to make it valid?\n\nM4 is a coinbase OP Return output containing the following:\n\n    1-byte - OP_RETURN (0x6a)\n    4-byte - Commitment header (0xD77D1776)\n    1-byte - Version\n    n-byte - The \"upvote vector\" -- describes which bundle-choice is \"upvoted\", for each sidechain.\n\nThe M4 message will be invalid (and invalidate the block), if:\n\n* It tries to upvote a bundle that doesn't exist. (For example, trying to upvote the 7th bundle on sidechain #2, when sidechain #2 has only three bundles.)\n* There are no bundles at all, from any sidechain.\n\nIf M4 is NOT present in a block, then it is treated as an \"abstain\" for all sidechains.\n\nIf M4 is present and valid: each withdrawal-bundle that is ACKed, will gain one upvote.\n\nEach sidechain always has two \"virtual bundles\" -- an \"abstain\" bundle (0xFF), and an \"alarm\" bundle (0xFE). Abstain leaves the ACK count unchanged, and alarm reduces all ACK counts of all bundles by 1.\n\nAny bundle which fails to receive a vote, is downvoted (and loses 1 ACK). If a sidechain has no pending bundles, then it is skipped over when M4 is created and parsed.\n\n\n==== Examples ====\n\nTo upvote the 7th bundle on sidechain #1, and upvote the 4th bundle on sidechain #2, the upvote vector would be { 07, 04 }. And M4 would be [0x6A,D77D1776,00,0006,0003].\n\nIf block 900,000 has D2 of...\n\n{| class=\"wikitable\"\n|-\n! SC#\n! Bundle Hash\n! ACKs\n! Blocks Remaining\n|-\n| 1\n| h1\n| 45\n| 22,109\n|-\n| 1\n| h2\n| 12\n| 22,008\n|-\n| 2\n| h3\n| 13\n| 22,999\n|-\n| 2\n| h4\n| 8\n| 23,550<br />\n|-\n| 2\n| h5\n| 2\n| 22,560\n|}\n\n\n...and then D2 wants to become:\n\n\n{| class=\"wikitable\"\n|-\n! SC#\n! Bundle Hash\n! ACKs\n! Blocks Remaining\n|-\n| 1\n| h1\n| 46\n| 22,108\n|-\n| 1\n| h2\n| 11\n| 22,007\n|-\n| 2\n| h3\n| 12\n| 22,998\n|-\n| 2\n| h4\n| 9\n| 23,549<br />\n|-\n| 2\n| h5\n| 1\n| 22,559\n|}\n\n... then M4 would have been [0x6A,D77D1776,00,0000,0001].\n\n==== Saving Space ====\n\nThe version number allows us to shrink the upvote vector in many cases.\nVersion 0x00 omits the upvote vector entirely (i.e., 6 bytes for the whole M4) and sets this block's M4 equal to the previous block's M4.\nVersion 0x01 uses 1 byte per sidechain, and can be used while all ACKed withdrawals have an index <256 (i.e., 99.99%+ of the time).\nVersion 0x02 uses 2 bytes per sidechain, but it always works, even in astronomically unlikely cases (such as when >1 sidechains have >256 bundle candidates).\nVersion 0x03 omits the upvote vector, and instead upvotes only those withdrawals that are leading their rivals by at least 50 votes.\n\nFor example, an upvote vector of { 2 , N/A, 1 } would be represented as [0x6A,D77D1776,01,01,00]. It means: \"upvote the second bundle in sidechain #1; and the first bundle in sidechain #3\" (iff sidechains #2 has no bundles proposed).\n\nAn upvote vector of { N/A, N/A, 4 } would be [0x6A,D77D1776,01,03].\n\n\n\n=== M5 -- Deposit BTC (from L1 to L2) ===\n\nFinally, we describe Deposits (M5) and Withdrawals (M6). These are not coinbase outputs, they are txns on L1.\n\nWe call a transaction \"M5\" if it spends from the escrow output and '''increases''' the quantity of coins. Conversely, we call a transaction \"M6\" if it spends from the escrow output and '''decreases''' the quantity of coins. See [https://github.com/LayerTwo-Labs/bip300301_enforcer/blob/13a4353c39a26d9d40180ea361b7580fd682e5b5/src/bip300.rs#L462C1-L462C47 here].\n\nEvery time a deposit/withdrawal is made, the old UTXO is spent and a single new UTXO is created. (Deposits/Withdrawals never cause UTXO bloat.) At all times, the specific treasury UTXO (\"CTIP\") of each sidechain is cached in D1 (above).\n\nEvery M5 is valid, as long as:\n\n* It has exactly one OP_DRIVECHAIN output -- this becomes the new CTIP.\n* The new CTIP has '''more''' coins in it, than before.\n\n\n=== M6 -- Withdraw BTC (from L2 to L1) ===\n\n\nM6 is invalid if:\n\n* The blinded hash of M6 does NOT match one of the approved bundle-hashes.  (In other words: M6 must first be approved by 13,150 upvotes.)\n* The first output of M6 is NOT an OP_DRIVECHAIN. (This OP_DRIVECHAIN becomes the new CTIP. In other words: all non-withdrawn coins are paid back to the sidechain.)\n* The second output is NOT a zero-value OP_RETURN script of exactly 10 bytes, of which 8 bytes are a serialized Bitcoin amount.\n* The txn fee of M6 is NOT exactly equal to the amount of the previous bullet point.\n* There are additional OP_DRIVECHAIN outputs after the first one.\n\nElse, M6 is valid -- and the funds are withdrawn.\n\n(The point of the latter two bullet points, is to allow the bundle hash to cover the L1 transaction fee.)\n\n===OP_DRIVECHAIN===\n\nThis proposal adds a single new opcode, OP_DRIVECHAIN, which has strict semantics for usage.\nOP_NOP5 (0xb4) is redefined as OP_DRIVECHAIN if and only if the entire script is OP_DRIVECHAIN followed by a single-byte push and OP_TRUE (exactly 4 bytes).\nThe single-byte push contains the sidechain number.\nNote that this is not a \"script number\", and cannot be OP_1..OP_16 or any other kind of push; it is also unsigned, and must not be padded even if over sidechain number 127.\nThe final OP_TRUE is to ensure this change remains a softfork:\nwithout it, sidechain numbers 0 and 128 would cause the legacy script interpreter to fail.\n\nIf an OP_DRIVECHAIN input is spent, the additional rules for M5 or M6 (see above) must be enforced.\n\n<!--\n\nWeight adjustments\n\nTo account for the additional drivechain checks, each message adds to the block's weight:\n\n{|class=\"wikitable\"\n! Message !! Additional weight\n|-\n| M1 || 840\n|-\n| M2 || 336\n|-\n| M3 || 848\n|-\n| M4 || ?\n|-\n| M5 || 340\n|-\n| M6 || 352\n|}\n\n\nget: 168 WU for 1 byte\ndelete: free?\ncreate: 168 WU for 33 bytes\nhash: 4 WU??\nsearch outputs: ?\npermanent \"proposal rejected\" lookup: infinite??\nread prev block: a lot?? maybe store...\ncomparison: 4 WU?\nencode script: ?\n\nM1: 3 get, 2 create\nM2: 1 get, 1 delete, 1 create\nM3: 3 get, 1 delete, 2 create, 2 hash\n  for each coinbase output: search for prior M3 for this sidechain\n  lookup if M3 was ever rejected or paid in the past\n  for each prior proposed withdrawal: (included in 1 get+delete+create)\nM4: 1 get\n  + for every proposed withdraw, 1 get, 1 delete, 1 create, 1 add\n  v0 needs to read and parse previous block\nM5/M6 OP_DRIVECHAIN spends require 2 additional input lookups\n  for each output: check for duplicate OP_DRIVECHAINs\n  amount comparison\n  M6: encode & compare fee amount, 2 hash, counter compare\n-->\n\n\n\n\n==Backward compatibility==\n\nThis soft fork can be deployed without modifying Bitcoin Core at all (i.e., via [https://bip300cusf.com/ CUSF]).\n\n\n==Deployment==\n\nThis BIP deploys when/if >51% hashrate runs [https://github.com/LayerTwo-Labs/bip300301_enforcer/ the enforcer client].\n\nIdeally, a critical mass of users would also run the enforcer client -- this would strongly dissuade miners from ever de-activating it.\n\n\n==Reference Implementation==\n\nThe enforcer is [https://github.com/LayerTwo-Labs/bip300301_enforcer/ here].\n\nAlso, several example L2s are [https://releases.drivechain.info/ here].\n\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n", "content_length": 17107}
{"bip_number": 199, "filename": "bip-0199.mediawiki", "content": "<pre>\n  BIP: 199\n  Layer: Applications\n  Title: Hashed Time-Locked Contract transactions\n  Author: Sean Bowe <sean@z.cash>\n          Daira Hopwood <daira@z.cash>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0199\n  Status: Rejected\n  Type: Standards Track\n  Created: 2017-03-27\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis BIP describes a script for generalized off-chain contract negotiation.\n\n==Summary==\n\nA Hashed Time-Locked Contract (HTLC) is a script that permits a designated party (the \"seller\") to spend funds by disclosing the preimage of a hash.  It also permits\na second party (the \"buyer\") to spend the funds after a timeout is reached, in a refund situation.\n\nThe script takes the following form:\n\n    OP_IF\n        [HASHOP] <digest> OP_EQUALVERIFY OP_DUP OP_HASH160 <seller pubkey hash>\n    OP_ELSE\n        <num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <buyer pubkey hash>\n    OP_ENDIF\n    OP_EQUALVERIFY\n    OP_CHECKSIG\n\n[HASHOP] is either OP_SHA256 or OP_HASH160.\n\n[TIMEOUTOP] is either OP_CHECKSEQUENCEVERIFY or OP_CHECKLOCKTIMEVERIFY.\n\n===Interaction===\n\n* Victor (the \"buyer\") and Peggy (the \"seller\") exchange public keys and mutually agree upon a timeout threshold.  Peggy provides a hash digest.  Both parties can now construct the script and P2SH address for the HTLC.\n* Victor sends funds to the P2SH address.\n* Either:\n** Peggy spends the funds, and in doing so, reveals the preimage to Victor in the transaction; OR\n** Victor recovers the funds after the timeout threshold.\n\nVictor is interested in a lower timeout to reduce the amount of time that his funds are encumbered in the event that Peggy does not reveal the preimage.  Peggy is\ninterested in a higher timeout to reduce the risk that she is unable to spend the funds before the threshold, or worse, that her transaction spending the funds does\nnot enter the blockchain before Victor's but does reveal the preimage to Victor anyway.\n\n==Motivation==\n\nIn many off-chain protocols, secret disclosure is used as part of a settlement mechanism.  In some others, the secrets themselves are valuable.  HTLC transactions are\na safe and cheap method of exchanging secrets for money over the blockchain, due to the ability to recover funds from an uncooperative counterparty, and the\nopportunity that the possessor of a secret has to receive the funds before such a refund can occur.\n\n===Lightning network===\n\nIn the lightning network, HTLC scripts are used to perform atomic swaps between payment channels.\n\nAlice constructs K and hashes it to produce L.  She sends an HTLC payment to Bob for the preimage of L.  Bob sends an HTLC payment to Carol for the same preimage and\namount.  Only when Alice releases the preimage K does any exchange of value occur, and because the secret is divulged for each hop, all parties are compensated.  If\nat any point some parties become uncooperative, the process can be aborted via the refund conditions.\n\n===Zero-knowledge contingent payments===\n\nVarious practical zero-knowledge proving systems exist which can be used to guarantee that a hash preimage derives valuable information.  As an example, a\nzero-knowledge proof can be used to prove that a hash preimage acts as a decryption key for an encrypted sudoku puzzle solution.  (See\n[https://github.com/zcash/pay-to-sudoku pay-to-sudoku] for a concrete example of such a protocol.)\n\nHTLC transactions can be used to exchange such decryption keys for money without risk, and they do not require large or expensive-to-validate transactions.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/7601\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n\n", "content_length": 3757}
{"bip_number": 197, "filename": "bip-0197.mediawiki", "content": "<pre>\n  BIP: 197\n  Layer: Applications\n  Title: Hashed Time-Locked Collateral Contract\n  Author: Matthew Black <matthew@atomicloans.io>\n          Tony Cai <tony@atomicloans.io>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0197\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-03-19\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis BIP describes a script for generalized debt agreement contract based on Hashed Time-Lock Contract (BIP 199) transactions according to the Atomic Loans specification (https://arxiv.org/pdf/1901.05117.pdf). For more details visit https://atomicloans.io.\n\n==Summary==\n\nA Hashed Time-Locked Collateral Contract (HTLCC) consists of two scripts that permit a designated party (the \"borrower\") to lock funds on the Bitcoin chain for a specified amount of time as collateral in a debt agreement where the loan principal is denominated in a currency on another blockchain. We denote the blockchain on which the loan principal is issued the principal blockchain.\n\nThe purpose of each script is to enable the creation of a debt agreement between two parties (the \"borrower\" and the \"lender\"), where the collateral is locked in a P2SH, and can only be spent once the borrower repays the principal and interest in the debt agreement on the principal blockchain. In the case that the borrower does not repay, the borrower or lender can opt for liquidation of the collateral, which will involve the atomic swapping of collateral for the loan currency. In the case that at least one of the two parties don't opt for liquidation, then each party will be entitled to a percentage of the collateral, decided when the funds are initially locked in the P2SH.\n\nThese funds are locked into two scripts. Refundable Collateral and Seizable Collateral scripts. The funds sent to these scripts represent the percentage of collateral that each party is entitled to in the case that repayment fails, and the parties don't opt for liquidation.\n\nThe Refundable Collateral script takes the following form:\n\n    OP_IF\n        OP_SIZE <secret b2 length> OP_EQUALVERIFY [HASHOP] <secret hash b2> OP_EQUALVERIFY OP_DUP OP_HASH160 <borrower pubkey hash> OP_EQUALVERIFY OP_CHECKSIG\n    OP_ELSE\n        OP_IF\n            <loan expiration num> [TIMEOUTOP] OP_DROP OP_SIZE OP_PUSHDATA(1) <secret a2 length> OP_EQUALVERIFY [HASHOP] <secret hash a2> OP_EQUALVERIFY OP_SIZE <secret b3 length> OP_EQUALVERIFY [HASHOP] <secret hash b3> OP_EQUALVERIFY OP_2 <borrower pubkey> <lender pubkey> OP_2 OP_CHECKMULTISIG\n        OP_ELSE\n            <liquidation expiration num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <borrower pubkey hash> OP_EQUALVERIFY OP_CHECKSIG\n        OP_ENDIF\n    OP_ENDIF\n\nThe Seizable Collateral script takes the following form:\n\n    OP_IF\n        OP_SIZE <secret b2 length> OP_EQUALVERIFY [HASHOP] <secret hash b2> OP_EQUALVERIFY OP_DUP OP_HASH160 <borrower pubkey hash> OP_EQUALVERIFY OP_CHECKSIG\n    OP_ELSE\n        OP_IF\n            <loan expiration num> [TIMEOUTOP] OP_DROP OP_SIZE <secret a2 length> OP_EQUALVERIFY [HASHOP] <secret hash a2> OP_EQUALVERIFY OP_SIZE <secret b3 length> OP_EQUALVERIFY [HASHOP] <secret hash b3> OP_EQUALVERIFY OP_2 <borrower pubkey> <lender pubkey> OP_2 OP_CHECKMULTISIG\n        OP_ELSE\n            OP_IF\n                <bidding expiration num> [TIMEOUTOP] OP_DROP OP_SIZE <secret a1 length> OP_EQUALVERIFY [HASHOP] <secret hash a1> OP_EQUALVERIFY OP_DUP OP_HASH160 <lender pubkey hash> OP_EQUALVERIFY OP_CHECKSIG\n            OP_ELSE\n                <seizure expiration num> [TIMEOUTOP] OP_DROP OP_DUP OP_HASH160 <borrower pubkey hash> OP_EQUALVERIFY OP_CHECKSIG\n            OP_ENDIF\n        OP_ENDIF\n    OP_ENDIF\n\n[HASHOP] is either OP_SHA256 or OP_HASH160.\n\n[TIMEOUTOP] is either OP_CHECKSEQUENCEVERIFY or OP_CHECKLOCKTIMEVERIFY.\n\n===Interaction===\n\n* Alice (the \"borrower\") and Bob (the \"lender\") exchange public keys as well as two secret hashes A1, A2 created by Alice and three hashes B1, B2, B3 created by Bob. They then mutually agree upon a timeout threshold for the Loan Period, Liquidation Period, and Seizure Period. Alice constructs the script and P2SH address for the Refundable Collateral Contract and Seizable Collateral Contract. Bob constructs the script for the blockchain on which the loan principal will be issued - the principal blockchain.\n\n* Bob sends loan principal funds to the loan script on the principal blockchain\n\n* Alice sends funds to the Refundable Collateral P2SH address and the Seizable Collateral P2SH address. The amount of funds she sends to the two addresses will be determined beforehand off-chain between Alice and Bob.\n\n* Either\n** Bob accepts locking of collateral by Alice and reveals B1, allowing Alice to withdraw the loan amount on the principal blockchain.\n** Bob doesn't accept locking of collateral by Alice, and recovers the funds after the approve expiration while revealing B2, which allows Alice to refund the Refundable and Seizable collateral.\n\n** If Bob accepts the locking of collateral by Alice\n\n*** Either\n**** Alice repays the loan by the end of the Loan Period and Bob reveals the secret to Alice by revealing it in the loan repayment acceptance transaction; OR\n**** Alice defaults on the loan and Alice and Bob both opt for collateral liquidation, where any third-party is able to bid on the collateral. The winning bidder, Charlie, will subsequently receive the liquidated collateral by way of an Atomic Swap between the collateral funds (ie. BTC locked in both the Refundable Collateral P2SH and the Seizable Collateral P2SH) and the bid funds (ie. funds denominated in the loan currency, put forth by Charlie as part of his bid).  This is done by both Alice and Bob signing a multisig and revealing A2 and B2; OR\n**** Alice defaults on the loan and at least one of Alice or Bob opts out of collateral liquidation, then Alice recovers the Refundable Collateral funds and Bob spends the Seizable Collateral funds.\n**** Alice defaults on the loan and at least one of Alice or Bob opts out of collateral liquidation. But Bob doesn't spend the Seizable Collateral funds,  so Alice recovers both the Refundable Collateral funds and the Seizable Collateral funds.\n\n==Compatibility==\n\nBIP 197 is compatible with [https://github.com/ethereum/EIPs/pull/1850 ERC 1850] for [https://arxiv.org/pdf/1901.05117.pdf atomic loans] with Ethereum. Can be extended in the future to be compatible with other HTLC and smart contract compatible chains.\n\n==Motivation==\n\nIn many different protocols, the revealing of secrets is used as a settlement mechanism. HTLCC transactions are a safe way of exchanging secrets to advance the state of a debt agreement, due to the ability to recover a percentage of collateral funds from an uncooperative counterparty, and ensure principal + interest + liquidation fee is paid with a cooperative party.\n\n==Definitions==\n\nborrower: entity that locks collateral on the Bitcoin chain and receives loan amount on principal blockchain from lender following the approval of the borrower\u2019s borrow request\n\nlender: entity that contributes funds to the Hashed Time-Locked Principal Contract (HTLPC) on the principal blockchain, to be borrowed by the borrower upon the locking of collateral on the Bitcoin chain and the lender\u2019s approval\n\nrepay: when the borrower pays back the principal + interest before loanExpiration\n\ndefault: when the borrower fails to pay back the principal + interest before the loanExpiration\n\nsecret: random number chosen by the borrower or lender, revealed to allow the parties to change the state of the debt agreement\n\nsecretHash: hash of the secret, used in the construction of HTLCC\n\nSecretA1: secret generated by the borrower, used to prove that the borrower has withdrawn the loan\n\nSecretA2: secret generated by the borrower, used to allow  the bidder to withdraw the liquidated collateral funds\n\nSecretB1: secret generated by the lender, used to accept the locking of collateral by borrower, enabling borrower to withdraw the loan amount\n\nSecretB2: secret generated by the lender, used to refund themselves in the event they aren't satisfied with borrower\u2019slocking of collateral.  Also used to accept borrower\u2019s repayment of principal plus interest\n\nSecretB3: secret generated by the lender, used to allow the bidder to withdraw the liquidated collateral funds\n\nSecretC: secret generated by the bidder, used to accept the signatures of the borrower and lender for authorizing the liquidation of collateral\n\nloan expiration num: timestamp before which the borrower must repay the loan; or otherwise risk the liquidation or seizure of their collateral\n\nbidding expiration num: timestamp that determines the amount of time allocated to bidding before seizure period occurs\n\nseizure expiration num: timestamp that determines the amount of time during which the lender can seize funds within the Seizable Collateral P2SH, after which the borrower can refund their corresponding amount of the collateral they are entitled to (ie. either just the funds within the Refundable Collateral P2SH, or both the Refundable Collateral and Seizable Collateral in the event where the lender failed to seize).\n\n===Approve Period===\nDuring this time, the lender deploys the HTLPC on the principal blockchain. Following this, the borrower locks their collateral on the Bitcoin blockchain in a HTLCC. The lender then either reveals secretB1 to signify that they are satisfied with the collateral, and the borrower can withdraw the loan by revealing secretA1. If the lender is not satisfied with the collateral locked by the borrower, the lender can refunds their loan amount by revealing secretB2, which will subsequently allow the borrower to refund the collateral amount they deposited.\n\n===Loan Period===\nOnce the borrower has withdrawn the loan amount, the Loan Period begins. Once the Loan Period is finished, the borrower is expected to repay the loan. If they do, the lender can then accept the repayment by revealing secretB2, enabling the borrower to refund their collateral amount. In the case that the borrower defaults or does not repay the full principal plus interest amount, the lender can choose to not accept the loan repayment, and the parties can opt for liquidation of the collateral in the Bidding Period.\n\n===Bidding Period===\nIn the case of a default or the lender not accepting the borrower repayment, the lender and borrower can opt for liquidation of the collateral through the process of third party bidders bidding on the collateral.  The Bidding Period can be initiated by either the lender or the borrower. Once the bidding timeout occurs, the lender and borrower must each provide a signature, followed by secretC revealed by the winning bidder once they have checked that the signature is proper. Finally, the lender and borrower must each reveal secretA2 and secretB3 to allow the collateral to be withdrawn by the winning bidder.\n\n===Seizure Period===\nIn the case that either the lender or borrower don\u2019t accept the bid, the lender can seize a percentage of the collateral. The amount is dependent on the amount of collateral locked in the Seizable Collateral and Refundable Collateral script as described in this BIP. During this period, the borrower can also refund the funds locked in the Refundable Collateral script.\n\n===Refund Period===\nIn the case that the lender does not seize the collateral locked in the Seizable Collateral script, then the borrower can refund the funds locked in the Seizable Collateral script.\n\n==Rationale==\n\nThe rational for the following script checking the length of secrets pushed to the stack that are used with OP_SHA256 in the following script\n\n  OP_SIZE <secret b2 length> OP_EQUALVERIFY\n\nis to ensure that the secret size is exactly a certain number of bytes long.\n\nThis is especially important when this script is used alongside the HTLPC on other chains like Ethereum where the sha256 opcode only takes up 32 bytes and disregards the rest, there is a need to ensure that the length on the Bitcoin side is 32 bytes.\n\n==Backwards Compatibility==\n\nAs this is a new standard for collateralized debt, there is no need for backward compatibility. Once this is accepted as a standard there are certain aspects of the contract that can be modified while still retaining backwards compatibility, such as removing the need to verify the size of the hash if being used with two blockchains with the same maximum block size, which would be backward compatible with the current script.\n\n==Implementation==\n\nhttps://github.com/AtomicLoans/chainabstractionlayer/blob/dev/packages/bitcoin-collateral-provider/lib/BitcoinCollateralProvider.js\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n", "content_length": 12813}
{"bip_number": 180, "filename": "bip-0180.mediawiki", "content": "<pre>\n  BIP: 180\n  Layer: Peer Services\n  Title: Block size/weight fraud proof\n  Author: Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0180\n  Status: Rejected\n  Type: Standards Track\n  Created: 2017-03-17\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nA fraud proof that enables light clients to detect oversized (or overweight) blocks.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Definitions==\n\n; full tx size proof : SHA2 midstate and tail data proving the size of the full transaction data being hashed.\n; size component : Either a merkle link and height in the merkle tree thereof, or a full tx size proof.\n; full-size proof : The set of size components proving the lower-bound size of the block.\n; stripped-size proof : The set of size components proving the lower-bound size of the block when stripped of segwit witness data.\n\n==Specification==\n\n===Proof format===\n\n* varint: ceil(log2(number of transactions in block))\n* varint: number of size components in stripped-size proof\n* foreach:\n** varint: ceil(log2(number of transactions represented by this size-component)) + 1\n** if zero:\n*** (this indicates a full tx size proof)\n*** 256-bit: SHA2 midstate up until just before the final SHA2 chunk\n*** varint: total size of tx\n*** uint8: size of final SHA2 chunk (0-55)\n*** 0-55 bytes: final SHA2 chunk\n** if one or more:\n*** (this indicates default tx size counting)\n*** 256-bit: SHA2 hash of merkle link\n* varint: number of size components in full-size proof (zero in case of a size-exceeded proof; non-zero for a weight-exceeded proof)\n* foreach: (same as with stripped-size proof)\n\n===Proof verification===\n\nTo verify an individual size proof:\n\n#Check that at least one size component is a full tx size proof. (At least one size component MUST be a full tx size proof.)\n#Determine the lower-bound number of transactions in the block (lowTxCount). It is either <code>pow(ceil(log2(txcount)) - 1, 2)</code>, or the position of the last full tx proof (plus one, if using 0-based positions). Note that the last full tx proof from *either* of the size proofs (stripped-size and full-size) should be used here.\n#Calculate the lower-bound transaction-data size as the default size * lowTxCount.\n#For each full tx size proof:\n##Subtract the default size it was presumed to consume, and add the claimed total size of tx.\n##Take the SHA2 midstate, and update it with the final SHA2 chunk (which needs to be padded, including with the total tx size). The final SHA2 hash is the transaction id (stripped-size proof) or hash (full-size proof).\n#For the full-size proof, replace the 60 byte default with any larger sizes proven from the stripped-size proof.\n#Build the merkle root, and compare it to the block header (stripped-size proof) or witness commitment (full-size proof). Ensure when building the merkle root, that there are no duplicate merkle links, and each merkle link claims to represent the correct number of represented transactions.\n#Add 80 bytes, plus the size of the tx-count varint, to the calculated lower-bound size.\n#The calculated size is returned as the lower-bound possible size of the block.\n\nFor the stripped-size proof, the default size of transactions is 60 bytes.\nFor the full-size proof, it is the size established by the stripped-size proof.\n\nTo verify the complete weight proof:\n\n# Verify the stripped-size proof. Save the resulting lower-bound size (call it lowStrippedSize).\n# Verify the full-size proof. Save the resulting lower-bound size (call it lowFullSize).\n# Calculate minFullSize + (minStrippedSize * 3). This is the lower-bound block weight.\n# Compare the lower-bound block weight to the applicable block weight limit.\n\n===Network protocol===\n\nIf a light client detects that one or more of its peers do not consider the block it knows to have the most work as their best block, it should inquire with all those peers for a fraud proof by sending a new message <code>getfraud</code>, with a block locator (between the last common block, and the presumed best tip) as the sole parameter (extra parameters should be ignored).\n\nCompatible nodes will respond with a (new) <code>fraud</code> message, which has 2-3 parameters:\n\n* uint256: The hash of the most recent block in the locator (or a parent thereof) that it has checked. In the event of an invalid block, this should be the exact invalid block's hash (post-invalid blocks should be treated as unchecked, even if the node has independently checked them for some reason).\n* varint: Fraud proof type code\n** 0 = Block is valid\n** 1 = No fraud proof available\n** 2 = Size/weight exceeded\n* (For type 2) the fraud proof\n\nIf none of the blocks in the locator are recognised, compatible nodes should send a <code>fraud</code> message with no parameters.\n(To avoid this outcome, clients may include a known-common block in the locator.)\n\nIn the event that the peer claims a block earlier than the client's tip is valid, the light client should prepare a new locator between that block and its tip, and rerequest <code>getfraud</code> until it has determined which block the peer rejects and why.\n\nOnce a block is proven to be invalid, the light client should never consider any blockchain including it as a candidate for the best chain.\nIt should not recheck blocks known to be invalid, nor continue proving it from other nodes.\n(To avoid doubt: the user MAY be given the opportunity to override any rejections, but should be warned of the implications of doing so.)\n\nIf an invalid fraud proof is provided, the client SHOULD CONSIDER disconnecting and possibly banning the node providing it.\nHowever, if any change has been made to the size/weight limits, that should be taken into consideration (eg, if the limit increases, an innocent node may prove a size smaller than the limit).\n\n==Information==\n\n===Creation of proofs===\n\nProofs should ideally use the smallest amount of data required to prove excess of the limit.\nThe most obvious mechanism in doing so, would be to include full tx size proofs for the largest transactions until the limit is exceeded.\nHowever, in some cases, a smaller size may be accomplished by collapsing more merkle links.\n\nBecause optimisation of proof size may be complicated, nodes are not required to implement it in any particular manner, so long as the proofs meet the requirements given above in [[#proof-verification|Proof verification]].\n\n==Motivation==\n\nRecently, there have been proposals for hardforks to increase the block size limit.\nWhile no consensus has been reached, proponents of these ideas often threaten and attempt to have miners force them through anyway.\nAs things presently are, light clients cannot detect invalid blocks at all, and could be fooled into accepting an invalid chain created in such a manner.\nBy supporting block size fraud proofs, light clients can protect their users from this form of unconsensual \"hardfork\" attempt.\n\n==Rationale==\n\nWhy must a full tx size proof be included?\n\n* This is necessary to establish that the claimed block transaction count is not inflated. Otherwise, a prover could claim any number of represented transactions for merkle links, and rely on the default size alone to exceed the limit.\n\nHow does the full tx size proof actually prove the size?\n\n* The first step of SHA2 hashing is to transform the input data into chunks (per [https://tools.ietf.org/html/rfc4634#section-4.1 RFC 4634]). The final chunk is required to include the absolute length of the input data at the end of the final chunk. Therefore, by committing to the midstate prior to the final chunk, and replaying only the final chunk, we can confirm that the claimed size matches the full transaction data being hashed.\n\nHow does this prove the block weight?\n\n* The block weight defined by [[bip-0141.mediawiki|BIP 141]] is the size of the block stripped of its segwit signatures times 3, plus the full size of the block. By proving lower-bound sizes of both the stripped block and the full block, a lower-bound weight can also be calculated.\n\nWhy is the number of transactions in the block represented as a log2?\n\n* To avoid attacks that rely on fooling clients by claiming an amount they cannot verify.\n\nWhy does it matter if a full tx size proof is on the right side of a duplicate merkle link?\n\n* We assume full tx size proofs show the number of transactions in the block. This assumption doesn't hold if the proof is provided on the right-hand side of duplicate links.\n\nWhy a fraud proof only for oversized/overweight blocks?\n\n* While it is currently believed to be impossible to prove all invalid (or rather, won't-be-part-of-the-main-chain) blocks, there are regularly active proposals of miners attacking with simply oversized blocks in an attempt to force a hardfork. This specific attack can be proven, and reliably so, since the proof cannot be broken without also breaking the attempted hardfork at the same time.\n\n==Backwards compatibility==\n\nThese fraud proofs protect only clients which use them.\nIn non-attack scenarios, they are unnecessary and clients supporting them will otherwise behave as any other.\n\n==Reference implementation==\n\nTODO\n", "content_length": 9225}
{"bip_number": 179, "filename": "bip-0179.mediawiki", "content": "<pre>\n  BIP: 179\n  Title: Name for payment recipient identifiers\n  Author: Emil Engler <me@emilengler.com>\n          Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0179\n  Status: Draft\n  Type: Informational\n  Created: 2019-10-17\n  License: CC0-1.0\n</pre>\n\n==Abstract==\nThis BIP proposes a new term for 'address'\n\n==Specification==\nThe new term is:\n''Bitcoin'' '''Invoice''' ''Address''\n\nThe ''Bitcoin'' and ''Address'' parts are optional.\nThe address suffix should only be used as a transitional step.\n\nA ''Bitcoin'' Invoice ''Address'' is a string of characters that can be used to indicate the intended recipient and purpose of a transaction.\n\n==Motivation==\nBitcoin addresses are intended to be only used '''once''' and you should generate a new one for every new incoming payment.\nThe term 'address' however indicates consistency because nearly everything on the internet or the offline world with the term 'address'\nis something that rarely or even never changes (postal address, email address, IP addresses (depends heavily on the provider), etc.)\nThe motivation for this BIP is to change the term address to something that indicates that the address is connected to a single transaction.\n\n==Rationale==\nThe reason why we use ''Bitcoin Invoice Address'' or just ''Invoice'' is to emphasize that it is single-use.\nThe terms ''Bitcoin'' and ''Address'' are optional for the following reasons:\nFor ''Bitcoin'':\n* Useful for multicoin wallets to indicate that it belongs to Bitcoin\n* Indicates a difference between a lightning and an on-chain invoice\nFor ''Address'':\n* To not confuse users with a completely new term\n* To show that it is where you send something to\n* To not break backwards compatibility\n\nThis gives us the four following possibilities:\n* Bitcoin Invoice Address\n* Bitcoin Invoice\n* Invoice Address\n* Invoice\n\n==Backwards Compatibility==\nTo avoid issues, the 'Address' suffix is permitted, but not recommended.\nThe suffix 'Address' remains so users should be immediately able to recognize it until the new term is widely known.\n\n==Acknowledgements==\nThanks to Chris Belcher for the suggestion of the term 'Bitcoin Invoice Address'\n\n==Copyright==\nThis BIP is released under CC0-1.0 and therefore Public Domain.\n", "content_length": 2320}
{"bip_number": 178, "filename": "bip-0178.mediawiki", "content": "<pre>\n  BIP: 178\n  Layer: Applications\n  Title: Version Extended WIF\n  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n  Comments-Summary: Discouraged for implementation (one person)\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0178\n  Status: Draft\n  Type: Standards Track\n  Created: 2018-04-04\n  License: CC0-1.0\n</pre>\n\n== Abstract ==\n\nAn extension to the Wallet Import Format (WIF) to specify what kind of bitcoin address the private key corresponds to.\n\n== Motivation ==\n\nThere are several types of bitcoin addresses which can all be associated with a given private key: P2PKH (legacy <code>1...</code> format), P2SH-P2WPKH (SegWit public key inside P2SH), P2WPKH (bech32), etc.\n\nWhile private keys have a 1-byte suffix indicating whether the corresponding public key is compressed (<code>0x01</code>) or not (through suffix absence), there is no way of knowing what kind of bitcoin address were associated with the private key. As a result, when importing a private key, the wallet has to assume all kinds, and keep track of each possible alternative.\n\nBy extending the suffix, we can specify what kind of bitcoin address was associated with a given private key.\n\n== Specification ==\n\nCurrently, private keys are stored as a uint256 (private key data) followed by an optional uint8 (compressed flag). The latter is extended to specify the address types:\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!Value\n!Type\n!Compr\n!Clarification\n|-\n|No suffix||P2PKH_UNCOMPRESSED||No||Uncompressed legacy public key. Unknown public key format\n|-\n|<code>0x01</code>||P2PKH_COMPRESSED||Yes||Compressed legacy public key. Unknown public key format\n|-\n|<code>0x10</code>||P2PKH||Yes||Compressed legacy public key. Legacy public key format (<code>1...</code>)\n|-\n|<code>0x11</code>||P2WPKH||Yes||Bech32 format (native Segwit)\n|-\n|<code>0x12</code>||P2WPKH_P2SH||Yes||Segwit nested in BIP16 P2SH (<code>3...</code>)\n|}\n\nWhen a wallet imports a private key, it will have two outcomes:\n\n* the key is using one of the legacy types, in which case all types must be accounted for\n* the key is using one of the extended types, in which case the wallet need only track the specific corresponding address\n\nNote: the difference between `0x01` and `0x10` is that the former can correspond to any of the types above, whereas the latter *only* corresponds to a P2PKH (legacy non-segwit).\n\n== Compatibility ==\n\nThis proposal is not backwards compatible, in that software that does not recognize the new types will not understand the compressed flag. It would be trivial to change this, by keeping the 'uncompressed' state as it is (no suffix) and changing 'compressed' to be 'anything not 0', as opposed to 'the value 1'.\n\nThe proposal ''is'' backwards compatible in that new wallet software will always understand the old WIF format, however. It will, as it does today, assume that any kind of bitcoin address is possible, and will have to track all of them, as it has to today.\n\n== Acknowledgements ==\n\nThis BIP is based on the initial proposal by Thomas Voegtlin (thomasv at electrum dot org) on the Bitcoin Dev mailing list<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015007.html</ref> and the Electrum 3.0 implementation<ref>https://github.com/spesmilo/electrum/blob/82e88cb89df35288b80dfdbe071da74247351251/RELEASE-NOTES#L95-L108</ref>\n\n== Reference implementation ==\n\nThere is a partial implementation which adds, but does not use, the types described in this BIP here: https://github.com/bitcoin/bitcoin/pull/12869\n\n== References ==\n\n<references/>\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n", "content_length": 3691}
{"bip_number": 177, "filename": "bip-0177.mediawiki", "content": "<pre>\n  BIP: 177\n  Title: Redefine Bitcoin's Base Unit\n  Author: John Carvalho <bitcoinerrorlog@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0177\n  Status: Draft\n  Type: Informational\n  Created: 2025-04-23\n  License: CC0-1.0\n</pre>\n\n\n==Introduction==\n\n===Abstract===\n\nThis BIP proposes redefining the commonly recognized \"bitcoin\" unit so that the base unit becomes the primary reference unit. Under this proposal, one bitcoin is defined as that indivisible base unit, eliminating the convention of synthetic decimal places. By making the base unit the standard measure, this BIP aims to simplify user comprehension, reduce confusion, and align on-chain values directly with their displayed representation.\n\n===Motivation===\n\nThe current convention defines one bitcoin as 100,000,000 base units. This representation requires dealing with eight simulated decimal places, which can be confusing and foster the misconception that bitcoin is inherently decimal-based. In reality, Bitcoin\u2019s ledger represents values as integral base units. The decimal point is merely a human-imposed abstraction.\n\nBy redefining the base unit as \"one bitcoin,\" this BIP aligns user perception with the protocol\u2019s true nature. It reduces cognitive overhead, ensures users understand Bitcoin as counting discrete units, and ultimately improves educational clarity and user experience.\n\n===Specification===\n\n'''Redefinition of the Unit:'''\n\n* Internally, the base units remain unchanged.\n* Historically, 1 bitcoin = 100,000,000 base units. Under this proposal, \"1 bitcoin\" equals one base unit.\n* What was previously referred to as \"1 bitcoin\" now corresponds to 100 million bitcoins under the new definition.\n\n'''Terminology:'''\n\n* The informal terms \"satoshi\" or \"sat\" are deprecated.\n* All references, interfaces, and documentation SHOULD refer to the base unit simply as \"bitcoin.\"\n* The currency code \"BTC\" is unaffected by these changes, and continues to mean 100,000,000 base units.\n\n'''Display and Formatting:'''\n\n* Applications SHOULD allow users to toggle between the legacy BTC format (1 BTC = 100,000,000 base units) and the new integral format (1 bitcoin = 1 base unit).\n* Use of the \u20bf symbol MAY be used to represent base-unit bitcoins but is OPTIONAL.\n\nExample 1:\n\n* Old display: <code>0.00010000 bitcoin</code>\n* New display: <code>\u20bf10,000</code> or <code>10,000 bitcoins</code> or <code>0.00010000 BTC</code>\n\nExample 2:\n\n* Old display: <code>10.23486 bitcoin</code>\n* New display: <code>\u20bf1,023,486,000</code> or <code>1,023,486,000 bitcoins</code> or <code>10.23486 BTC</code>\n\nExample 3:\n\n* Old display: <code>0.345 BTC</code>\n* New display: No changes required or <code>\u20bf34,500,000</code> or <code>34,500,000 bitcoins</code>\n\nNOTE: Traditional number display abbreviations, like <code>2.5M</code> for millions, are also optional.\n\n'''Conversion:'''\n\n* Ledger and consensus rules remain unchanged.\n* <code>BTC</code> as a currency code remains unchanged (1 BTC = 100,000,000 base units)\n* Implementations adopting this standard MUST multiply previously displayed bitcoin amounts by 100,000,000 to determine the new integer representation.\n\n===Rationale===\n\n'''Usability:'''\nInteger-only displays simplify mental arithmetic and reduce potential confusion or user error.\n\n'''Protocol Alignment:'''\nThe Bitcoin protocol inherently counts discrete units. Removing the artificial decimal format aligns user perception with Bitcoin\u2019s actual integral design.\n\n'''Educational Clarity:'''\nPresenting integers ensures newcomers do not mistakenly assume that Bitcoin\u2019s nature is decimal-based. It conveys Bitcoin\u2019s true design from the start.\n\n'''Future-Proofing:'''\nAdopting the base unit as the primary measure ensures a consistent standard that can scale smoothly as Bitcoin adoption grows.\n\n'''Perception of Supply:'''\nWhile the total count of base units is roughly 2.1 quadrillion, this proposal does not alter supply in any way. The change is purely representational. Comparisons can be drawn to other currencies like the Japanese yen or Indonesian rupiah, where high unit counts are standard and not perceived as inflationary.\n\n===Addressing Alternative Approaches===\n\n'''Refuting the \"Bits\" Proposal''' \n([https://github.com/bitcoin/bips/blob/master/bip-0176.mediawiki BIP\u202f176])\n\nAn alternative suggestion (BIP\u202f176) proposes using \"bits\" to represent one-millionth of a bitcoin (100 satoshis). While this reduces the number of decimal places in certain contexts, it fails to fully address the core issues our BIP aims to solve:\n\n1. '''Persistent Decimal Mindset:'''\nUsing \"bits\" still retains a layered decimal approach, requiring users to think in terms of multiple denominations (BTC and bits). This shifts complexity rather than eliminating it.\n\n2. '''Inconsistent User Experience:'''\nUsers must learn to toggle between BTC for large amounts and bits for small amounts. Instead of providing a unified view of value, it fragments the user experience.\n\n3. '''Incomplete Alignment with the Protocol\u2019s Nature:'''\nThe \"bits\" proposal does not realign the displayed value with the integral nature of Bitcoin\u2019s ledger. It continues to rely on fractional units, masking the fundamental integer-based accounting that Bitcoin employs.\n\n4. '''Not Permanently Future-Proof:'''\nThough \"bits\" may simplify certain price ranges, future circumstances could demand additional denominations or scaling adjustments. Our integral approach resolves this problem entirely by making the base unit the standard measure, avoiding future fragmentation.\n\nIn essence, while BIP\u202f176 attempts to simplify small amount representations, it only replaces one decimal representation with another. By redefining \"bitcoin\" as the base unit, this BIP eliminates reliance on decimal fractions and separate denominations entirely, offering a clearer, more intuitive, and ultimately more durable solution.\n\n===Handling the Terms \u201csatoshi\u201d and \u201csat\u201d===\n\n'''Background'''\n\n\u201cSatoshi\u201d (or its shorthand \u201csat\u201d) emerged organically some years ago, to honour Bitcoin\u2019s creator and to give a friendly name to the 100-millionth \"fraction\" of a bitcoin.  \nOver time \u201cstacking sats\u201d became a meme, and the term now appears in podcasts, apparel, and some wallet UIs.\n\nWhile culturally valuable, the term introduces an implicit second denomination layer that contradicts the goal of this BIP: a single base unit, called simply \"bitcoin\". Of course this BIP cannot stop anyone from using any colloquial term they prefer, but this document exists to specify how to display Bitcoin's only units as \"bitcoin\" correctly.\n\n===Backward Compatibility===\n\nNo consensus rules are altered, and on-chain data remains unchanged. Differences arise solely in display formats:\n\n* '''For Developers:''' Update GUIs, APIs, and documentation to present values as integers. Remove references to fractional Bitcoin. <code>BTC</code> units remain unchanged.\n\n* '''For Users:''' The actual value of holdings does not change. Transitional measures, such as dual displays or explanatory tooltips, can ease the adjustment period.\n\n===Security Considerations===\n\nA short-term risk of confusion exists as users adapt to the new representation. Users accustomed to decimals may misinterpret initial displays. To mitigate this:\n\n* Offer dual displays and tooltips during the transition.\n* Provide clear educational materials and coordinated messaging.\n* Use alerts or confirmations in applications if input values appear unexpectedly large or small.\n* Highlight the unchanging 21M BTC supply cap and equivalence to avoid misinterpretation as inflationary.\n\n===Reference Implementation===\n\nSome wallets, such as Bitkit, have successfully adopted integer-only displays, demonstrating the feasibility of this approach, without incident. Transitional features \u2014 like showing both old and new formats side-by-side \u2014 can help smooth the transition.\n\n===Test Vectors===\n\n* Old: <code>1.00000000 Bitcoin</code> \u2192 New: <code>\u20bf100,000,000</code> (or <code>100,000,000 bitcoins</code>)\n* Old: <code>0.00010000 Bitcoin</code> \u2192 New: <code>\u20bf10,000</code> (or <code>10,000 bitcoins</code>)\n* Old: <code>0.00500000 Bitcoin</code> \u2192 New: <code>\u20bf500,000</code> (or <code>500,000 bitcoins</code>)\n* Old: <code>0.005 BTC</code> \u2192 New: <code>0.005 BTC</code> (or <code>\u20bf500,000</code> or <code>500,000 bitcoins</code>)\n\nAll formerly fractional representations now directly correspond to whole-number multiples of the base unit.\n\n===Implementation Timeline===\n\n'''Phase 1 (3-6 months):''' Introduce the concept, provide dual displays and educational materials. Begin pilot testing in willing wallet apps.\n\n'''Phase 2 (6-12 months):''' Prominent services adopt integer-only displays by default. Community coordination and media campaigns ensure consistency.\n\n'''Phase 3 (12+ months):''' Integer representation becomes standard. Documentation and user guides no longer reference decimal-based formats.\n\n===Conclusion===\n\nRedefining \"bitcoin\" as the smallest indivisible unit, and removing decimal-based representations, simplifies comprehension and aligns displayed values with the protocol\u2019s integral accounting. While a transition period may be necessary, the long-term benefits include clearer communication, reduced confusion, and a more accurate understanding of Bitcoin\u2019s fundamental design.\n\n===Copyright===\n\nThis BIP is licensed under CC0-1.0.\n", "content_length": 9372}
{"bip_number": 176, "filename": "bip-0176.mediawiki", "content": "<pre>\n  BIP: 176\n  Title: Bits Denomination\n  Author: Jimmy Song <jaejoon@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0176\n  Status: Draft\n  Type: Informational\n  Created: 2017-12-12\n  License: BSD-2-Clause\n</pre>\n\n== Abstract ==\nBits is presented here as the standard term for 100 (one hundred) satoshis or 1/1,000,000 (one one-millionth) of a bitcoin.\n\n== Motivation ==\nThe bitcoin price has grown over the years and once the price is past $10,000 USD or so, bitcoin amounts under $10 USD start having enough decimal places that it's difficult to tell whether the user is off by a factor of 10 or not. Switching the denomination to \"bits\" makes comprehension easier. For example, when BTC is $15,000 USD, $10.05 is a somewhat confusing 0.00067 BTC, versus 670 bits, which is a lot clearer.\n\nAdditionally, reverse comparisons are easier as 59 bits being $1 is easier to comprehend for most people than 0.000059 BTC being $1. Similar comparisons can be made to other currencies: 1 yen being 0.8 bits, 1 won being 0.07 bits and so on.\n\nPotential benefits of utilizing \"bits\" include:\n\n# Reduce user error on small bitcoin amounts.\n# Reduce unit bias for users that want a \"whole\" bitcoin.\n# Allow easier comparisons of prices for most users.\n# Allow easier bi-directional comparisons to fiat currencies.\n# Allows all UTXO amounts to need at most 2 decimal places, which can be easier to handle.\n\n== Specification ==\nDefinition: 1 bit = 100 satoshis.\nPlural of \"bit\" is \"bits.\" The terms \"bit\" and \"bits\" are not proper nouns and thus should not be capitalized unless used at the start of a sentence, etc.\n\nAll bitcoin-denominated items are encouraged to also show the denomination in bits, either as the default or as an option.\n\n== Rationale ==\nAs bitcoin grows in price versus fiat currencies, it's important to give users the ability to quickly and accurately calculate prices for transactions, savings and other economic activities. \"Bits\" have been used as a denomination within the Bitcoin ecosystem for some time. The idea of this BIP is to formalize this name. Additionally, \"bits\" is likely the only other denomination that will be needed for Bitcoin as 0.01 bit = 1 satoshi, meaning that two decimal places will be sufficient to describe any current utxo.\n\nExisting terms used in bitcoin such as satoshi, milli-bitcoin (mBTC) and bitcoin (BTC) do not conflict as they operate at different orders of magnitude.\n\nThe term micro-bitcoin (\u00b5BTC) can continue to exist in tandem with the term \"bits.\"\n\n== Backwards Compatibility ==\nSoftware such as the Bitcoin Core GUI currently use the \u00b5BTC denomination and can continue to do so. There is no obligation to switch to \"bits.\"\n\nThe term \"bit\" has many different definitions, but the ones of particular note are these:\n\n* 1 bit = 1/8 dollar (e.g., that candy cost me 2 bits {or 1/4 dollar})\n* bit meaning some amount of data (e.g., the first bit of the version field is 0)\n* bit meaning strength of a cryptographic algorithm (e.g., 256-bit ECDSA is used in Bitcoin)\n\nThe first is a bit dated and isn't likely to confuse people dealing with Bitcoin. The second and third are computer science terms and context should be sufficient to figure out what the user of the word means.\n\n== Copyright ==\nThis BIP is licensed under the BSD 2-clause license.\n\n== Credit ==\nIt's hard to ascertain exactly who invented the term \"bits,\" but the term has been around for a while and the author of this BIP does not take any credit for inventing the term.\n", "content_length": 3561}
{"bip_number": 175, "filename": "bip-0175.mediawiki", "content": "<pre>\n  BIP: 175\n  Layer: Applications\n  Title: Pay to Contract Protocol\n  Author: Omar Shibli <omar@commerceblock.com>\n          Nicholas Gregory <nicholas@commerceblock.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0175\n  Status: Rejected\n  Type: Informational\n  Created: 2017-07-17\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nUtilizing hierarchical deterministic wallets as described in BIP-0032 and the \"Purpose Field\" in BIP-0043, this document specifies the multiparty pay-to-contract key derivation scheme outlined by Ilja Gerhardt and Timo Hanke.[0]\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n==Motivation==\n\nA Bitcoin transaction represents a \"real world\" contract between two parties transferring value. Counterparties in a business interaction traditionally keep track of a payment with bills (invoices) and receipts. Delivery of a good is made by the payee once the payer has signed the receipt, agreeing to pay for the items on the invoice. Gerhardt and Hanke [0] formulate this interaction within the confines of the Bitcoin protocol using homomorphic payment addresses and the multiparty pay-to-contract protocol.\n\nThe protocol is constructed in such a way that all parties have cryptographic proof of both who is being paid and for what. Using the technique described in this BIP, an address can be provably derived from the terms of a contract and the payee's public key. This derivation scheme does not bloat the UTXO and is completely hidden to network participants; the derived address looks like any other P2(W)PKH or P2(W)SH address. Redemption of the funds requires knowledge of the contract and the payee's private key.\n\nThis scheme utilizes the foundations of BIP-0032, providing a consistent way for preexisting wallet developers to implement the specification.\n\n==Specification==\n\nThis key derivation scheme requires two parties: a payer (customer) and a payee (merchant).\nThe customer submits to the merchant a purchase request, specifying what goods/services they would like to buy. From the purchase request the merchant constructs an invoice (contract), specifying the billable items and total amount to be paid.\nThe merchant must give this contract alongside a \u201cpayment base\u201d extended public key to the customer. Given this information, the customer will be able to fulfill the contract by generating the public key of the payment address associated with the contract and the payment base, then sending the funds there.\n\nWe define the following levels in BIP32 path:\n\n<code>\nm / purpose' / coin_type' / contract_hash\n</code>\n\n<code>contract_hash</code> consists of multiple levels.\n\nApostrophe in the path indicates that BIP32 hardened derivation is used.\n\nWe define the following extended public keys:\n\nPayment base denoted as <code>payment_base</code>:\n\n    m / purpose' / coin_type'\n\nPayment address denoted as <code>payment_address</code>:\n\n    m / purpose' / coin_type' / contract_hash\n    or\n    m / payment_base / contract_hash\n\nEach level has special meaning described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set to <code>175'</code> (or <code>0x800000AF</code>) following the BIP-0043 recommendation. It indicates that the subtree of this node is used according to this specification.\n\n<code>\nm / 175' / *\n</code>\n\nHardened derivation is used at this level.\n\n===Coin type===\n\nThe coin type field is identical to the same field in BIP-0044.\n\nHardened derivation is used at this level.\n\n===Payment address generation===\n\nFor a given contract documents denoted by c<sub>1</sub>,...,c<sub>n</sub>, payment base extended public key denoted by <code>payment_base</code>, and cryptographic hash function denoted by <code>h</code>.\n\n1. Compute cryptographic hashes for all contract documents, by applying the hash function.\n\n  h(c1),...,h(cn)\n\n2. Sort all hashes lexicographically.\n\n  hash_1,...,hash_n\n\n3. Prepend payment_base and concatenate the sorted hashes and apply the hash function.\n\n  h(payment_base+hash_1+...+hash_n)\n\n4. Compute a partial BIP32 derivation path from the combined hash as defined in Hash to Partial Derivation Path Mapping procedure below.\n\n  contract_hash\n\n5. Prepend <code>payment_base</code> to contract_hash derivation path.\n\n  payment_base / contract_hash\n\n6. Compute public extended key from the derivation path in step 5.\n\n7. Compute address of the public extended key (P2PKH) from step 6.\n\n===Payment address verification===\n\nFor a given Bitcoin address, <code>payment_base</code> extended public key, contract documents denoted by c<sub>1</sub>,...,c<sub>n</sub>, and cryptographic hash function denoted by <code>h</code>, we can verify the integrity of the address by the following steps:\n\n1. Compute contract address from the given inputs as described in Contract Address Generation section.\n\n2. Compare the computed address from step 1 with the given Bitcoin address as an input.\n\n===Redemption===\n\nThe merchant is able to construct the private key offline using the method described in the Payment Address Generation section.\nThe merchant should actively monitor the blockchain for the payment to the payment address.\nBecause the address is generated from the payment base and the contract, the merchant must implicitly agree to those terms in order to spend the funds.\nThe act of making the payment to that address thus serves as a receipt for the customer.\n\n===Hash to partial derivation path mapping===\n\nAt this section, we define hash to partial BIP32 derivation path mapping procedure that maps between an arbitrary hex number to a partial BIP32 derivation path.\n\nFor a given hex number, do the following:\n\n1. Partition hex number into parts, each part length is 4 chars.\n\n2. Convert each part to integer in decimal format.\n\n3. Concatenate all numbers with slash <code>/</code>.\n\n==Examples==\n\nFor the following given inputs:\n\n  master private extended key:\n  xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8imbZKLYVBxFPND1pniTZ81vKfd45EHKX73\n  coin type:\n  0\n\nwe can compute payment base as follows:\n\n  payment base derivation path:\n  m/175'/0'\n  contract base public extended key:\n  xpub6B3JSEWjqm5GgfzcjPwBixxLPzi15pFM3jq4E4yCzXXUFS5MFdXiSdw7b5dbdPGHuc7c1V4zXbbFRtc9G1njMUt9ZvMdGVGYQSQsurD6HAW\n\nIn the below examples, we are going to use SHA256 as a cryptographic hash function, and the above contract base public key.\n\n====Payment address generation====\n\nAs an input, we have a contract that consists of two documents, below are contents:\n\ndocument 1:\n\n  bar\n\ndocument 2:\n\n  foo\n\n1. Apply the hash function:\n\n  document 1:\n  fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\n  document 2:\n  2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n\n2. Sort all hashes lexicographically:\n\n  2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n  fcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\n\n3. Concatenate hashes and apply the hash function.\n\n  concatenated hash: payment_base\n  xpub6B3JSEWjqm5GgfzcjPwBixxLPzi15pFM3jq4E4yCzXXUFS5MFdXiSdw7b5dbdPGHuc7c1V4zXbbFRtc9G1njMUt9ZvMdGVGYQSQsurD6HAW2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7aefcde2b2edba56bf408601fb721fe9b5c338d10ee429ea04fae5511b68fbf8fb9\n  combined hash:\n  310057788c6073640dc222466d003411cd5c1cc0bf2803fc6ebbfae03ceb4451\n\n4. Compute the partial BIP32 derivation path of the combined hash.\n\n  12544/22392/35936/29540/3522/8774/27904/13329/52572/7360/48936/1020/28347/64224/15595/17489\n\n5. Prepend <code>payment_base</code> to <code>contract_hash</code> derivation path.\n\n  contract_base_pub/12544/22392/35936/29540/3522/8774/27904/13329/52572/7360/48936/1020/28347/64224/15595/17489\n  or\n  m/175'/0'/12544/22392/35936/29540/3522/8774/27904/13329/52572/7360/48936/1020/28347/64224/15595/17489\n\n6. Compute public extended key.\n\n  xpub6hefaATTG5LbcwyPDvmNfnkyzefoM2TJDoo5astH7Gvs1g8vZURviBWvAvBnWc2CNb8ybJ6mDpnQYVsvNSZ3oUmbssX3rUVG97TFYa6AXVk\n\n7. Compute address of the public extended key (P2PKH).\n\n  1C7f322izqMqLzZzfzkPAjxBzprxDi47Yf\n\n\n====Verification example (negative test)====\n\nSimilar to the input above, except this time we have a contract that consists of one document, below is the content:\n\ndocument 1:\n\n  baz\n\n1. Apply the hash function.\n\n  baa5a0964d3320fbc0c6a922140453c8513ea24ab8fd0577034804a967248096\n\n2. Prepend payment_base\n\n  xpub6B3JSEWjqm5GgfzcjPwBixxLPzi15pFM3jq4E4yCzXXUFS5MFdXiSdw7b5dbdPGHuc7c1V4zXbbFRtc9G1njMUt9ZvMdGVGYQSQsurD6HAWbaa5a0964d3320fbc0c6a922140453c8513ea24ab8fd0577034804a967248096\n\n2. Apply hash function\n\n  3a08605829413ce0bf551b08d21e4a28dbda6e407f90eff1c448e839050c73a1\n\n3. Compute the partial derivation path.\n\n  5338/54412/19213/962/30664/62597/11873/59874/56779/24089/54550/19585/28087/36422/18666/17562\n\n4. Prepend contract_base<sub>pub</sub> to contract_hash derivation path.\n\n  contract_base_pub/5338/54412/19213/962/30664/62597/11873/59874/56779/24089/54550/19585/28087/36422/18666/17562\n  or\n  m/175'/0'/5338/54412/19213/962/30664/62597/11873/59874/56779/24089/54550/19585/28087/36422/18666/17562\n\n5. Compute public extended key.\n\n  xpub6h9k2KqsMpwghxt7naj1puhGV1ZDC88sxvpYN1HibCf8yQZdPsuhYmmvdK32Kf2Lb3rS1sV8UcZ1f84DJEiXuVfLCAj4bC85aEUCxh38m8i\n\n7. Compute address of the public extended key (P2PKH).\n\n  1QGe5LaDMAmHeibJbZBmZqhQDZSp7QCqSs\n\n8. As expected the address doesn't match the Bitcoin address from the last example <code>1C7f322izqMqLzZzfzkPAjxBzprxDi47Yf</code>.\n\nVerification operation will succeed only if we use identical documents to ones that have been used in the contract address generation.\n\n==Compatibility==\n\nThis specification is not backward compatible with BIP32 specification, the proposed derivation scheme in this BIP is a BIP32 compliant.\nCommunication between payer and payee as well as hashing the contract and generating the path requires significant modification to the wallet.\n\n==Reference implementations==\n\n* Reference implementation to Hash to Partial Derivation Path Mapping in javascript ([[https://github.com/commerceblock/pay-to-contract-lib/blob/master/lib/contract.js|https://github.com/commerceblock/pay-to-contract-lib]])\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[https://arxiv.org/abs/1212.3257|Homomorphic Payment Addresses and the Pay-to-Contract Protocol]]\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n", "content_length": 10708}
{"bip_number": 174, "filename": "bip-0174.mediawiki", "content": "<pre>\n  BIP: 174\n  Layer: Applications\n  Title: Partially Signed Bitcoin Transaction Format\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0174\n  Status: Final\n  Type: Standards Track\n  Created: 2017-07-12\n  License: BSD-2-Clause\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a binary transaction format which contains the information\nnecessary for a signer to produce signatures for the transaction and holds the\nsignatures for an input while the input does not have a complete set of signatures.\nThe signer can be offline as all necessary information will be provided in the\ntransaction.\n\nThe generic format is described here in addition to the specification for version 0\nof this format.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nCreating unsigned or partially signed transactions to be passed around to multiple\nsigners is currently implementation dependent, making it hard for people who use\ndifferent wallet software from being able to easily do so. One of the goals of this\ndocument is to create a standard and extensible format that can be used between clients to allow\npeople to pass around the same transaction to sign and combine their signatures. The\nformat is also designed to be easily extended for future use which is harder to do\nwith existing transaction formats.\n\nSigning transactions also requires users to have access to the UTXOs being spent. This transaction\nformat will allow offline signers such as air-gapped wallets and hardware wallets\nto be able to sign transactions without needing direct access to the UTXO set and without\nrisk of being defrauded.\n\n==Specification==\n\nThe Partially Signed Bitcoin Transaction (PSBT) format consists of key-value maps.\nEach map consists of a sequence of key-value records, terminated by a <tt>0x00</tt> byte <ref>'''Why\nis the separator here <tt>0x00</tt> instead of <tt>0xff</tt>?'''\nThe separator here is used to distinguish between each chunk of data. A separator of 0x00 would mean that\nthe unserializer can read it as a key length of 0, which would never occur with actual keys. It can thus\nbe used as a separator and allow for easier unserializer implementation.</ref>.\n\n\n <psbt> := <magic> <global-map> <input-map>* <output-map>*\n <magic> := 0x70 0x73 0x62 0x74 0xFF\n <global-map> := <keypair>* 0x00\n <input-map> := <keypair>* 0x00\n <output-map> := <keypair>* 0x00\n <keypair> := <key> <value>\n <key> := <keylen> <keytype> <keydata>\n <value> := <valuelen> <valuedata>\n\nWhere:\n\n;<tt><keytype></tt>\n: A [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer compact size] unsigned integer representing the type. This compact size unsigned integer must be minimally encoded, i.e. if the value can be represented using one byte, it must be represented as one byte. There can be multiple entries with the same <tt><keytype></tt> within a specific <tt><map></tt>, but the <tt><key></tt> must be unique.\n;<tt><keylen></tt>\n: The compact size unsigned integer containing the combined length of <tt><keytype></tt> and <tt><keydata></tt>\n;<tt><valuelen></tt>\n: The compact size unsigned integer containing the length of <tt><valuedata></tt> (which must be exactly this many bytes).\n;<tt><magic></tt>\n: Magic bytes which are ASCII for psbt <ref>'''Why use 4 bytes for psbt?''' The\ntransaction format needed to start with a 5 byte header which uniquely identifies\nit. The first bytes were chosen to be the ASCII for psbt because that stands for\nPartially Signed Bitcoin Transaction. </ref> followed by a separator of <tt>0xFF</tt><ref>'''Why Use a separator after the magic bytes?''' The separator\nis part of the 5 byte header for PSBT. This byte is a separator of <tt>0xff</tt> because\nthis will cause any non-PSBT unserializer to fail to properly unserialize the PSBT\nas a normal transaction. Likewise, since the 5 byte header is fixed, no transaction\nin the non-PSBT format will be able to be unserialized by a PSBT unserializer.</ref>. This integer must be serialized in most significant byte order.\n\nThe currently defined global types are as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n! Parent BIP\n|-\n| Unsigned Transaction\n| <tt>PSBT_GLOBAL_UNSIGNED_TX = 0x00</tt>\n| None\n| No key data\n| <tt><bytes transaction></tt>\n| The transaction in network serialization. The scriptSigs and witnesses for each input must be empty. The transaction must be in the old serialization format (without witnesses).\n| 0\n| 2\n| 0\n| 174\n|-\n| Extended Public Key\n| <tt>PSBT_GLOBAL_XPUB = 0x01</tt>\n| <tt><bytes xpub></tt>\n| The 78 byte serialized extended public key as defined by BIP 32. Extended public keys are those that can be used to derive public keys used in the inputs and outputs of this transaction. It should be the public key at the highest hardened derivation index so that the unhardened child keys used in the transaction can be derived.\n| <tt><4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| The master key fingerprint as defined by BIP 32 concatenated with the derivation path of the public key. The derivation path is represented as 32-bit little endian unsigned integer indexes concatenated with each other. The number of 32 bit unsigned integer indexes must match the depth provided in the extended public key.\n|\n|\n| 0, 2\n| 174\n|-\n| Transaction Version\n| <tt>PSBT_GLOBAL_TX_VERSION = 0x02</tt>\n| None\n| No key data\n| <tt><32-bit little endian int version></tt>\n| The 32-bit little endian signed integer representing the version number of the transaction being created. Note that this is not the same as the PSBT version number specified by the PSBT_GLOBAL_VERSION field.\n| 2\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Fallback Locktime\n| <tt>PSBT_GLOBAL_FALLBACK_LOCKTIME = 0x03</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint locktime></tt>\n| The 32-bit little endian unsigned integer representing the transaction locktime to use if no inputs specify a required locktime.\n|\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Input Count\n| <tt>PSBT_GLOBAL_INPUT_COUNT = 0x04</tt>\n| None\n| No key data\n| <tt><compact size uint input count></tt>\n| Compact size unsigned integer representing the number of inputs in this PSBT.\n| 2\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Output Count\n| <tt>PSBT_GLOBAL_OUTPUT_COUNT = 0x05</tt>\n| None\n| No key data\n| <tt><compact size uint input count></tt>\n| Compact size unsigned integer representing the number of outputs in this PSBT.\n| 2\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Transaction Modifiable Flags\n| <tt>PSBT_GLOBAL_TX_MODIFIABLE = 0x06</tt>\n| None\n| No key data\n| <tt><8-bit uint flags></tt>\n| An 8 bit little endian unsigned integer as a bitfield for various transaction modification flags. Bit 0 is the Inputs Modifiable Flag and indicates whether inputs can be modified. Bit 1 is the Outputs Modifiable Flag and indicates whether outputs can be modified. Bit 2 is the Has SIGHASH_SINGLE flag and indicates whether the transaction has a SIGHASH_SINGLE signature who's input and output pairing must be preserved. Bit 2 essentially indicates that the Constructor must iterate the inputs to determine whether and how to add an input.\n|\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Silent Payment Global ECDH Share\n| <tt>PSBT_GLOBAL_SP_ECDH_SHARE = 0x07</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this ECDH share is for.\n| <tt><33 byte share></tt>\n| An ECDH share for a scan key. The ECDH shared is computed with ''a * B_scan'', where ''a'' is the sum of all private keys of all eligible inputs, and ''B_scan'' is the scan key of a recipient.\n|\n| 0\n| 2\n| [[bip-0375.mediawiki|375]]\n|-\n| Silent Payment Global DLEQ Proof\n| <tt>PSBT_GLOBAL_SP_DLEQ = 0x08</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this proof covers.\n| <tt><64-byte proof></tt>\n| A BIP374 DLEQ proof computed for the matching ECDH share.\n|\n| 0\n| 2\n| [[bip-0375.mediawiki|375]]\n|-\n| PSBT Version Number\n| <tt>PSBT_GLOBAL_VERSION = 0xFB</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint version></tt>\n| The 32-bit little endian unsigned integer representing the version number of this PSBT. If omitted, the version number is 0.\n|\n|\n| 0, 2\n| 174\n|-\n| Proprietary Use Type\n| <tt>PSBT_GLOBAL_PROPRIETARY = 0xFC</tt>\n| <tt><compact size uint identifier length> <bytes identifier> <compact size uint subtype> <bytes subkeydata></tt>\n| Compact size unsigned integer of the length of the identifier, followed by identifier prefix, followed by a compact size unsigned integer subtype, followed by the key data itself.\n| <tt><bytes data></tt>\n| Any value data as defined by the proprietary type user.\n|\n|\n| 0, 2\n| 174\n|}\n\nThe currently defined per-input types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n! Parent BIP\n|-\n| Non-Witness UTXO\n| <tt>PSBT_IN_NON_WITNESS_UTXO = 0x00</tt>\n| None\n| No key data\n| <tt><bytes transaction></tt>\n| The transaction in network serialization format the current input spends from. This should be present for inputs that spend non-segwit outputs and can be present for inputs that spend segwit outputs. An input can have both <tt>PSBT_IN_NON_WITNESS_UTXO</tt> and <tt>PSBT_IN_WITNESS_UTXO</tt>. <ref>'''Why can both UTXO types be provided?''' Many wallets began requiring the full previous transaction (i.e. <tt>PSBT_IN_NON_WITNESS_UTXO</tt>) for segwit inputs when PSBT was already in use. In order to be compatible with software which were expecting <tt>PSBT_IN_WITNESS_UTXO</tt>, both UTXO types must be allowed.</ref>\n|\n|\n| 0, 2\n| 174\n|-\n| Witness UTXO\n| <tt>PSBT_IN_WITNESS_UTXO = 0x01</tt>\n| None\n| No key data\n| <tt><64-bit little endian int amount> <compact size uint scriptPubKeylen> <bytes scriptPubKey></tt>\n| The entire transaction output in network serialization which the current input spends from. This should only be present for inputs which spend segwit outputs, including P2SH embedded ones. An input can have both <tt>PSBT_IN_NON_WITNESS_UTXO</tt> and <tt>PSBT_IN_WITNESS_UTXO</tt>\n|\n|\n| 0, 2\n| 174\n|-\n| Partial Signature\n| <tt>PSBT_IN_PARTIAL_SIG = 0x02</tt>\n| <tt><bytes pubkey></tt>\n| The public key which corresponds to this signature.\n| <tt><bytes signature></tt>\n| The signature as would be pushed to the stack from a scriptSig or witness. The signature should be a valid ECDSA signature corresponding to the pubkey that would return true when verified and not a value that would return false or be invalid otherwise (such as a NULLDUMMY).\n|\n|\n| 0, 2\n| 174\n|-\n| Sighash Type\n| <tt>PSBT_IN_SIGHASH_TYPE = 0x03</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint sighash type></tt>\n| The 32-bit unsigned integer specifying the sighash type to be used for this input. Signatures for this input must use the sighash type, finalizers must fail to finalize inputs which have signatures that do not match the specified sighash type. Signers who cannot produce signatures with the sighash type must not provide a signature.\n|\n|\n| 0, 2\n| 174\n|-\n| Redeem Script\n| <tt>PSBT_IN_REDEEM_SCRIPT = 0x04</tt>\n| None\n| No key data\n| <tt><bytes redeemScript></tt>\n| The redeemScript for this input if it has one.\n|\n|\n| 0, 2\n| 174\n|-\n| Witness Script\n| <tt>PSBT_IN_WITNESS_SCRIPT = 0x05</tt>\n| None\n| No key data\n| <tt><bytes witnessScript></tt>\n| The witnessScript for this input if it has one.\n|\n|\n| 0, 2\n| 174\n|-\n| BIP 32 Derivation Path\n| <tt>PSBT_IN_BIP32_DERIVATION = 0x06</tt>\n| <tt><bytes pubkey></tt>\n| The public key\n| <tt><4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| The master key fingerprint as defined by BIP 32 concatenated with the derivation path of the public key. The derivation path is represented as 32 bit unsigned integer indexes concatenated with each other. Public keys are those that will be needed to sign this input.\n|\n|\n| 0, 2\n| 174\n|-\n| Finalized scriptSig\n| <tt>PSBT_IN_FINAL_SCRIPTSIG = 0x07</tt>\n| None\n| No key data\n| <tt><bytes scriptSig></tt>\n| The Finalized scriptSig contains a fully constructed scriptSig with signatures and any other scripts necessary for the input to pass validation.\n|\n|\n| 0, 2\n| 174\n|-\n| Finalized scriptWitness\n| <tt>PSBT_IN_FINAL_SCRIPTWITNESS = 0x08</tt>\n| None\n| No key data\n| <tt><bytes scriptWitness></tt>\n| The Finalized scriptWitness contains a fully constructed scriptWitness with signatures and any other scripts necessary for the input to pass validation.\n|\n|\n| 0, 2\n| 174\n|-\n| Proof-of-reserves commitment\n| <tt>PSBT_IN_POR_COMMITMENT = 0x09</tt>\n| None\n| No key data\n| <tt><bytes porCommitment></tt>\n| The UTF-8 encoded commitment message string for the proof-of-reserves.  See [[bip-0127.mediawiki|BIP 127]] for more information.\n|\n|\n| 0, 2\n| [[bip-0127.mediawiki|127]]\n|-\n| RIPEMD160 preimage\n| <tt>PSBT_IN_RIPEMD160 = 0x0a</tt>\n| <tt><20-byte hash></tt>\n| The resulting hash of the preimage\n| <tt><bytes preimage></tt>\n| The hash preimage, encoded as a byte vector, which must equal the key when run through the <tt>RIPEMD160</tt> algorithm\n|\n|\n| 0, 2\n| 174\n|-\n| SHA256 preimage\n| <tt>PSBT_IN_SHA256 = 0x0b</tt>\n| <tt><32-byte hash></tt>\n| The resulting hash of the preimage\n| <tt><bytes preimage></tt>\n| The hash preimage, encoded as a byte vector, which must equal the key when run through the <tt>SHA256</tt> algorithm\n|\n|\n| 0, 2\n| 174\n|-\n| HASH160 preimage\n| <tt>PSBT_IN_HASH160 = 0x0c</tt>\n| <tt><20-byte hash></tt>\n| The resulting hash of the preimage\n| <tt><bytes preimage></tt>\n| The hash preimage, encoded as a byte vector, which must equal the key when run through the <tt>SHA256</tt> algorithm followed by the <tt>RIPEMD160</tt> algorithm\n|\n|\n| 0, 2\n| 174\n|-\n| HASH256 preimage\n| <tt>PSBT_IN_HASH256 = 0x0d</tt>\n| <tt><32-byte hash></tt>\n| The resulting hash of the preimage\n| <tt><bytes preimage></tt>\n| The hash preimage, encoded as a byte vector, which must equal the key when run through the <tt>SHA256</tt> algorithm twice\n|\n|\n| 0, 2\n| 174\n|-\n| Previous TXID\n| <tt>PSBT_IN_PREVIOUS_TXID = 0x0e</tt>\n| None\n| No key data\n| <tt><32 byte txid></tt>\n| 32 byte txid of the previous transaction whose output at PSBT_IN_OUTPUT_INDEX is being spent.\n| 2\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Spent Output Index\n| <tt>PSBT_IN_OUTPUT_INDEX = 0x0f</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint index></tt>\n| 32 bit little endian integer representing the index of the output being spent in the transaction with the txid of PSBT_IN_PREVIOUS_TXID.\n| 2\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Sequence Number\n| <tt>PSBT_IN_SEQUENCE = 0x10</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint sequence></tt>\n| The 32 bit unsigned little endian integer for the sequence number of this input. If omitted, the sequence number is assumed to be the final sequence number (0xffffffff).\n|\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Required Time-based Locktime\n| <tt>PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x11</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint locktime></tt>\n| 32 bit unsigned little endian integer greater than or equal to 500000000 representing the minimum Unix timestamp that this input requires to be set as the transaction's lock time.\n|\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Required Height-based Locktime\n| <tt>PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x12</tt>\n| None\n| No key data\n| <tt><32-bit uint locktime></tt>\n| 32 bit unsigned little endian integer less than 500000000 representing the minimum block height that this input requires to be set as the transaction's lock time.\n|\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Taproot Key Spend Signature\n| <tt>PSBT_IN_TAP_KEY_SIG = 0x13</tt>\n| None\n| No key data\n| <tt><64 or 65 byte signature></tt>\n| The 64 or 65 byte Schnorr signature for key path spending a Taproot output. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Script Spend Signature\n| <tt>PSBT_IN_TAP_SCRIPT_SIG = 0x14</tt>\n| <tt><32 byte xonlypubkey> <leafhash></tt>\n| A 32 byte X-only public key involved in a leaf script concatenated with the 32 byte hash of the leaf it is part of.\n| <tt><64 or 65 byte signature></tt>\n| The 64 or 65 byte Schnorr signature for this pubkey and leaf combination. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Leaf Script\n| <tt>PSBT_IN_TAP_LEAF_SCRIPT = 0x15</tt>\n| <tt><bytes control block></tt>\n| The control block for this leaf as specified in BIP 341. The control block contains the merkle tree path to this leaf.\n| <tt><bytes script> <8-bit uint leaf version></tt>\n| The script for this leaf as would be provided in the witness stack followed by the single byte leaf version. Note that the leaves included in this field should be those that the signers of this input are expected to be able to sign for. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Key BIP 32 Derivation Path\n| <tt>PSBT_IN_TAP_BIP32_DERIVATION = 0x16</tt>\n| <tt><32 byte xonlypubkey></tt>\n| A 32 byte X-only public key involved in this input. It may be the output key, the internal key, or a key present in a leaf script.\n| <tt><compact size uint number of hashes> <32 byte leaf hash>* <4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| A compact size unsigned integer representing the number of leaf hashes, followed by a list of leaf hashes, followed by the 4 byte master key fingerprint concatenated with the derivation path of the public key. The derivation path is represented as 32-bit little endian unsigned integer indexes concatenated with each other. Public keys are those needed to spend this output. The leaf hashes are of the leaves which involve this public key. The internal key does not have leaf hashes, so can be indicated with a <tt>hashes len</tt> of 0. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Internal Key\n| <tt>PSBT_IN_TAP_INTERNAL_KEY = 0x17</tt>\n| None\n| No key data\n| <tt><32 byte xonlypubkey></tt>\n| The X-only pubkey used as the internal key in this output. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Merkle Root\n| <tt>PSBT_IN_TAP_MERKLE_ROOT = 0x18</tt>\n| None\n| No key data\n| <tt><32-byte hash></tt>\n| The 32 byte Merkle root hash. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| MuSig2 Participant Public Keys\n| <tt>PSBT_IN_MUSIG2_PARTICIPANT_PUBKEYS = 0x1a</tt>\n| <33 byte plain aggregate pubkey>\n| The MuSig2 aggregate plain public key from the <tt>KeyAgg</tt> algorithm. This key may or may not\nbe in the script directly (as x-only). It may instead be a parent public key from which the public keys in the\nscript were derived.\n| <tt><33 byte compressed pubkey>*</tt>\n| A list of the compressed public keys of the participants in the MuSig2 aggregate key in the order\nrequired for aggregation. If sorting was done, then the keys must be in the sorted order.\n|\n|\n| 0, 2\n| [[bip-0373.mediawiki|373]]\n|-\n| MuSig2 Public Nonce\n| <tt>PSBT_IN_MUSIG2_PUB_NONCE = 0x1b</tt>\n| <tt><33 byte compressed pubkey> <33 byte plain pubkey> <32 byte hash or omitted></tt>\n| The compressed public key of the participant providing this nonce, followed by the plain public\nkey the participant is providing the nonce for, followed by the BIP 341 tapleaf hash of\nthe Taproot leaf script that will be signed. If the aggregate key is the taproot internal key or the\ntaproot output key, then the tapleaf hash must be omitted. The plain public key must be\nthe key found in the script and not the aggregate public key that it was derived from, if it was\nderived from an aggregate key.\n| <tt><66 byte public nonce></tt>\n| The public nonce produced by the <tt>NonceGen</tt> algorithm.\n|\n|\n| 0, 2\n| [[bip-0373.mediawiki|373]]\n|-\n| MuSig2 Participant Partial Signature\n| <tt>PSBT_IN_MUSIG2_PARTIAL_SIG = 0x1c</tt>\n| <tt><33 byte compressed pubkey> <33 byte plain pubkey> <32 byte hash or omitted></tt>\n| The compressed public key of the participant providing this partial signature, followed by the\nplain public key the participant is providing the signature for, followed by the BIP 341 tapleaf hash\nof the Taproot leaf script that will be signed. If the aggregate key is the taproot internal key or\nthe taproot output key, then the tapleaf hash must be omitted. Note that the plain public key must\nbe the key found in the script and not the aggregate public key that it was derived from, if it was\nderived from an aggregate key.\n| <tt><32 byte partial signature></tt>\n| The partial signature produced by the <tt>Sign</tt> algorithm.\n|\n|\n| 0, 2\n| [[bip-0373.mediawiki|373]]\n|-\n| Silent Payment Input ECDH Share\n| <tt>PSBT_IN_SP_ECDH_SHARE = 0x1d</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this ECDH share is for.\n| <tt><33 byte share></tt>\n| An ECDH share for a scan key. The ECDH shared is computed with ''a * B_scan'', where ''a'' is the private key of the corresponding prevout public key, and ''B_scan'' is the scan key of a recipient.\n|\n| 0\n| 2\n| [[bip-0375.mediawiki|375]]\n|-\n| Silent Payment Input DLEQ Proof\n| <tt>PSBT_IN_SP_DLEQ = 0x1e</tt>\n| <tt><33 byte scan key></tt>\n| The scan key that this proof covers.\n| <tt><64-byte proof></tt>\n| A BIP374 DLEQ proof computed for the matching ECDH share.\n|\n| 0\n| 2\n| [[bip-0375.mediawiki|375]]\n|-\n| Proprietary Use Type\n| <tt>PSBT_IN_PROPRIETARY = 0xFC</tt>\n| <tt><compact size uint identifier length> <bytes identifier> <compact size uint subtype> <bytes subkeydata></tt>\n| Compact size unsigned integer of the length of the identifier, followed by identifier prefix, followed by a compact size unsigned integer subtype, followed by the key data itself.\n| <tt><bytes data></tt>\n| Any value data as defined by the proprietary type user.\n|\n|\n| 0, 2\n| 174\n|}\n\nThe currently defined per-output <ref>'''Why do we need per-output data?''' Per-output data allows signers\nto verify that the outputs are going to the intended recipient. The output data can also be use by signers to\ndetermine which outputs are change outputs and verify that the change is returning to the correct place.</ref> types are defined as follows:\n\n{|\n! Name\n! <tt><keytype></tt>\n! <tt><keydata></tt>\n! <tt><keydata></tt> Description\n! <tt><valuedata></tt>\n! <tt><valuedata></tt> Description\n! Versions Requiring Inclusion\n! Versions Requiring Exclusion\n! Versions Allowing Inclusion\n! Parent BIP\n|-\n| Redeem Script\n| <tt>PSBT_OUT_REDEEM_SCRIPT = 0x00</tt>\n| None\n| No key data\n| <tt><bytes redeemScript></tt>\n| The redeemScript for this output if it has one.\n|\n|\n| 0, 2\n| 174\n|-\n| Witness Script\n| <tt>PSBT_OUT_WITNESS_SCRIPT = 0x01</tt>\n| None\n| No key data\n| <tt><bytes witnessScript></tt>\n| The witnessScript for this output if it has one.\n|\n|\n| 0, 2\n| 174\n|-\n| BIP 32 Derivation Path\n| <tt>PSBT_OUT_BIP32_DERIVATION = 0x02</tt>\n| <tt><bytes public key></tt>\n| The public key\n| <tt><4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| The master key fingerprint concatenated with the derivation path of the public key. The derivation path is represented as 32-bit little endian unsigned integer indexes concatenated with each other. Public keys are those needed to spend this output.\n|\n|\n| 0, 2\n| 174\n|-\n| Output Amount\n| <tt>PSBT_OUT_AMOUNT = 0x03</tt>\n| None\n| No key data\n| <tt><64-bit int amount></tt>\n| 64 bit signed little endian integer representing the output's amount in satoshis.\n| 2\n| 0\n| 2\n| [[bip-0370.mediawiki|370]]\n|-\n| Output Script\n| <tt>PSBT_OUT_SCRIPT = 0x04</tt>\n| None\n| No key data\n| <tt><bytes script></tt>\n| The script for this output, also known as the scriptPubKey. Must be omitted in PSBTv0. Must be provided in PSBTv2 if not sending to a BIP352 silent payment address, otherwise may be omitted.\n|\n| 0\n| 2\n| [[bip-0370.mediawiki|370]], [[bip-0375.mediawiki|375]]\n|-\n| Taproot Internal Key\n| <tt>PSBT_OUT_TAP_INTERNAL_KEY = 0x05</tt>\n| None\n| No key data\n| <tt><32 byte xonlypubkey></tt>\n| The X-only pubkey used as the internal key in this output.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Tree\n| <tt>PSBT_OUT_TAP_TREE = 0x06</tt>\n| None\n| No key data\n| <tt>{<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*</tt>\n| One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree, allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that the tree is correctly reconstructed. Each tuple is an 8-bit unsigned integer representing the depth in the Taproot tree for this script, an 8-bit unsigned integer representing the leaf version, the length of the script as a compact size unsigned integer, and the script itself.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| Taproot Key BIP 32 Derivation Path\n| <tt>PSBT_OUT_TAP_BIP32_DERIVATION = 0x07</tt>\n| <tt><32 byte xonlypubkey></tt>\n| A 32 byte X-only public key involved in this output. It may be the output key, the internal key, or a key present in a leaf script.\n| <tt><compact size uint number of hashes> <32 byte leaf hash>* <4 byte fingerprint> <32-bit little endian uint path element>*</tt>\n| A compact size unsigned integer representing the number of leaf hashes, followed by a list of leaf hashes, followed by the 4 byte master key fingerprint concatenated with the derivation path of the public key. The derivation path is represented as 32-bit little endian unsigned integer indexes concatenated with each other. Public keys are those needed to spend this output. The leaf hashes are of the leaves which involve this public key. The internal key does not have leaf hashes, so can be indicated with a <tt>hashes len</tt> of 0. Finalizers should remove this field after <tt>PSBT_IN_FINAL_SCRIPTWITNESS</tt> is constructed.\n|\n|\n| 0, 2\n| [[bip-0371.mediawiki|371]]\n|-\n| MuSig2 Participant Public Keys\n| <tt>PSBT_OUT_MUSIG2_PARTICIPANT_PUBKEYS = 0x08</tt>\n| <33 byte plain aggregate pubkey>\n| The MuSig2 aggregate plain public key from the <tt>KeyAgg</tt> algorithm. This key may or may not\nbe in the script directly. It may instead be a parent public key from which the public keys in the\nscript were derived.\n| <tt><33 byte compressed pubkey>*</tt>\n| A list of the compressed public keys of the participants in the MuSig2 aggregate key in the order\nrequired for aggregation. If sorting was done, then the keys must be in the sorted order.\n|\n|\n| 0, 2\n| [[bip-0373.mediawiki|373]]\n|-\n| Silent Payment Data\n| <tt>PSBT_OUT_SP_V0_INFO = 0x09</tt>\n| None\n| No key data\n| <tt><33 byte scan key> <33 byte spend key></tt>\n| The scan and spend public keys from the silent payments address.\n|\n| 0\n| 2\n| [[bip-0375.mediawiki|375]]\n|-\n| Silent Payment Label\n| <tt>PSBT_OUT_SP_V0_LABEL = 0x0a</tt>\n| None\n| No key data\n| <tt><32-bit little endian uint label></tt>\n| The label to use to compute the spend key of the silent payments address to verify change.\n|\n| 0\n| 2\n| [[bip-0375.mediawiki|375]]\n|-\n| BIP 353 DNSSEC proof\n| <tt>PSBT_OUT_DNSSEC_PROOF = 0x35</tt>\n| None\n| No key data\n| <tt><1-byte-length-prefixed BIP 353 human-readable name><RFC 9102-formatted AuthenticationChain DNSSEC Proof></tt>\n| A BIP 353 human-readable name (without the \u20bf prefix), prefixed by a 1-byte length.\nFollowed by an [[https://www.rfc-editor.org/rfc/rfc9102.html#name-dnssec-authentication-chain|RFC 9102 DNSSEC <tt>AuthenticationChain</tt>]] (i.e. a series of DNS Resource Records in no particular order) providing a DNSSEC proof to a BIP 353 DNS TXT record.\n|\n|\n| 0, 2\n| [[bip-0353.mediawiki|353]]\n|-\n| Proprietary Use Type\n| <tt>PSBT_OUT_PROPRIETARY = 0xFC</tt>\n| <tt><compact size uint identifier length> <bytes identifier> <compact size uint subtype> <bytes subkeydata></tt>\n| Compact size unsigned integer of the length of the identifier, followed by identifier prefix, followed by a compact size unsigned integer subtype, followed by the key data itself.\n| <tt><bytes data></tt>\n| Any value data as defined by the proprietary type user.\n|\n|\n| 0, 2\n| 174\n|}\n\nTypes can be skipped when they are unnecessary. For example, if an input is a witness\ninput, then it should not have a Non-Witness UTXO key-value pair.\n\nIf the signer encounters key-value pairs that it does not understand, it must\npass those key-value pairs through when re-serializing the transaction.\n\nAll keys must have the data that they specify. If any key or value does not match the\nspecified format for that type, the PSBT must be considered invalid. For example, any\nkey that has no data except for the type specifier must only have the type specifier in\nthe key.\n\n===Handling Duplicated Keys===\n\nKeys within each scope should never be duplicated; all keys in the format are unique. PSBTs containing duplicate keys are invalid. However implementers\nwill still need to handle events where keys are duplicated when combining transactions with duplicated fields. In this event, the software may choose\nwhichever value it wishes.<ref>'''Why can the values be arbitrarily chosen?''' When there are duplicated keys, the values that can be chosen will either be\nvalid or invalid. If the values are invalid, a signer would simply produce an invalid signature and the final transaction itself would be invalid. If the\nvalues are valid, then it does not matter which is chosen as either way the transaction is still valid.</ref>\n\n===Proprietary Use Type===\n\nFor all global, per-input, and per-output maps, the type <tt>0xFC</tt> is reserved for proprietary use.\nThe proprietary use type requires keys that follow the type with a compact size unsigned integer representing the length of the string identifier, followed by the string identifier, then a subtype, and finally any key data.\n\nThe identifier can be any variable length string that software can use to identify whether the particular data in the proprietary type can be used by it.\nIt can also be the empty string although this is not recommended.\n\nThe subtype is defined by the proprietary type user and can mean whatever they want it to mean.\nThe subtype must also be a compact size unsigned integer in the same form as the normal types.\nThe key data and value data are defined by the proprietary type user.\n\nThe proprietary use type is for private use by individuals and organizations who wish to use PSBT in their processes.\nIt is useful when there are additional data that they need attached to a PSBT but such data are not useful or available for the general public.\nThe proprietary use type is not to be used by any public specification and there is no expectation that any publicly available software be able to understand any specific meanings of it and the subtypes.\nThis type must be used for internal processes only.\n\n==Version 0==\n\nPartially Signed Bitcoin Transactions version 0 is the first version of the PSBT format.\nVersion 0 PSBTs must either omit PSBT_GLOBAL_VERSION or include it and set it to 0.\nVersion 0 PSBTs must include PSBT_GLOBAL_UNSIGNED_TX, if omitted, the PSBT is invalid.\n\n==Roles==\n\nUsing the transaction format involves many different roles. Multiple roles can be handled by a single entity, but each role is specialized in what it should be capable of doing.\n\n===Creator===\n\nThe Creator creates a new PSBT. It must create an unsigned transaction and place it in the PSBT.\nThe Creator must create empty input and output fields.\n\n===Updater===\n\nThe Updater must only accept a PSBT.\nThe Updater adds information to the PSBT that it has access to. If it has the UTXO for an input, it should add it to the PSBT.\nThe Updater should also add redeemScripts, witnessScripts, and BIP 32 derivation paths to the input and output data if it knows them.\n\nA single entity is likely to be both a Creator and Updater.\n\n===Signer===\n\nThe Signer must only accept a PSBT.\nThe Signer must only use the UTXOs provided in the PSBT to produce signatures for inputs.\nBefore signing a non-witness input, the Signer must verify that the TXID of the non-witness UTXO matches the TXID specified in the unsigned transaction.\nBefore signing a witness input, the Signer must verify that the witnessScript (if provided) matches the hash specified in the UTXO or the redeemScript, and the redeemScript (if provided) matches the hash in the UTXO.\nThe Signer may choose to fail to sign a segwit input if a non-witness UTXO is not provided. <ref>'''Why would non-witness UTXOs be provided for segwit inputs?''' The sighash algorithm for Segwit specified in BIP 143 is known to have an issue where an attacker could trick a user to sending Bitcoin to fees if they are able to convince the user to sign a malicious transaction multiple times. This is possible because the amounts in <tt>PSBT_IN_WITNESS_UTXO</tt> of other segwit inputs can be modified without effecting the signature for a particular input. In order to prevent this kind of attack, many wallets are requiring that the full previous transaction (i.e. <tt>PSBT_IN_NON_WITNESS_UTXO</tt>) be provided to ensure that the amounts of other inputs are not being tampered with.</ref>\nThe Signer should not need any additional data sources, as all necessary information is provided in the PSBT format.\nThe Signer must only add data to a PSBT.\nAny signatures created by the Signer must be added as a \"Partial Signature\" key-value pair for the respective input it relates to.\nIf a Signer cannot sign a transaction, it must not add a Partial Signature.\n\nThe Signer can additionally compute the addresses and values being sent, and the transaction fee,  optionally showing this data to the user as a confirmation of intent and the consequences of signing the PSBT.\n\nSigners do not need to sign for all possible input types. For example, a signer may choose to only sign Segwit inputs.\n\nA single entity is likely to be both a Signer and an Updater as it can update a PSBT with necessary information prior to signing it.\n\n====Data Signers Check For====\n\nFor a Signer to only produce valid signatures for what it expects to sign, it must check that the following conditions are true:\n\n* If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n* If a witness UTXO is provided, no non-witness signature may be created\n* If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n* If a witnessScript is provided, the scriptPubKey or the redeemScript must be for that witnessScript\n* If a sighash type is provided, the signer must check that the sighash is acceptable. If unacceptable, they must fail.\n* If a sighash type is not provided, the signer should sign using SIGHASH_ALL, but may use any sighash type they wish.\n\n=====Simple Signer Algorithm=====\n\nA simple signer can use the following algorithm to determine what and how to sign\n\n<pre>\nsign_witness(script_code, i):\n    for key, sighash_type in psbt.inputs[i].items:\n        if sighash_type == None:\n            sighash_type = SIGHASH_ALL\n        if IsMine(key) and IsAcceptable(sighash_type):\n            sign(witness_sighash(script_code, i, input))\n\nsign_non_witness(script_code, i):\n    for key, sighash_type in psbt.inputs[i].items:\n        if sighash_type == None:\n            sighash_type = SIGHASH_ALL\n        if IsMine(key) and IsAcceptable(sighash_type):\n            sign(non_witness_sighash(script_code, i, input))\n\nfor input, i in enumerate(psbt.inputs):\n    if witness_utxo.exists:\n        if redeemScript.exists:\n            assert(witness_utxo.scriptPubKey == P2SH(redeemScript))\n            script = redeemScript\n        else:\n            script = witness_utxo.scriptPubKey\n        if IsP2WPKH(script):\n            sign_witness(P2PKH(script[2:22]), i)\n        else if IsP2WSH(script):\n            assert(script == P2WSH(witnessScript))\n            sign_witness(witnessScript, i)\n    else if non_witness_utxo.exists:\n        assert(sha256d(non_witness_utxo) == psbt.tx.input[i].prevout.hash)\n        if redeemScript.exists:\n            assert(non_witness_utxo.vout[psbt.tx.input[i].prevout.n].scriptPubKey == P2SH(redeemScript))\n            sign_non_witness(redeemScript, i)\n        else:\n            sign_non_witness(non_witness_utxo.vout[psbt.tx.input[i].prevout.n].scriptPubKey, i)\n    else:\n        assert False\n</pre>\n\n====Change Detection====\n\nSigners may wish to display the inputs and outputs to users for extra verification.\nIn such displays, signers may wish to identify which outputs are change outputs in order to omit them to avoid additional user confusion.\nIn order to detect change, a signer can use the BIP 32 derivation paths provided in inputs and outputs as well as the extended public keys provided globally.\n\nFor a single key output, a signer can observe whether the master fingerprint for the public key for that output belongs to itself.\nIf it does, it can then derive the public key at the specified derivation path and check whether that key is the one present in that output.\n\nFor outputs involving multiple keys, a signer can first examine the inputs that it is signing.\nIt should determine the general pattern of the script and internally produce a representation of the policy that the script represents.\nSuch a policy can include things like how many keys are present, what order they are in, how many signers are necessary, which signers are required, etc.\nThe signer can then use the BIP 32 derivation paths for each of the pubkeys to find which global extended public key is the one that can derive that particular public key.\nTo do so, the signer would extract the derivation path to the highest hardened index and use that to lookup the public key with that index and master fingerprint.\nThe signer would construct this script policy with extended public keys for all of the inputs and outputs.\nChange outputs would then be identified as being the outputs which have the same script policy as the inputs that are being signed.\n\n===Combiner===\n\nThe Combiner can accept 1 or many PSBTs.\nThe Combiner must merge them into one PSBT (if possible), or fail.\nThe resulting PSBT must contain all of the key-value pairs from each of the PSBTs.\nThe Combiner must remove any duplicate key-value pairs, in accordance with the specification. It can pick arbitrarily when conflicts occur.\nA Combiner must not combine two different PSBTs. PSBTs can be uniquely identified by <tt>0x00</tt> global transaction typed key-value pair.\nFor every type that a Combiner understands, it may refuse to combine PSBTs if it detects that there will be inconsistencies or conflicts for that type in the combined PSBT.\n\nThe Combiner does not need to know how to interpret scripts in order to combine PSBTs. It can do so without understanding scripts or the network serialization format.\n\nIn general, the result of a Combiner combining two PSBTs from independent participants A and B should be functionally equivalent to a result obtained from processing the original PSBT by A and then B in a sequence.\nOr, for participants performing fA(psbt) and fB(psbt): Combine(fA(psbt), fB(psbt)) == fA(fB(psbt)) == fB(fA(psbt))\n\n===Input Finalizer===\n\nThe Input Finalizer must only accept a PSBT.\nFor each input, the Input Finalizer determines if the input has enough data to pass validation. If it does, it must construct the <tt>0x07</tt> Finalized scriptSig and <tt>0x08</tt> Finalized scriptWitness and place them into the input key-value map.\nIf scriptSig is empty for an input, <tt>0x07</tt> should remain unset rather than assigned an empty array.\nLikewise, if no scriptWitness exists for an input, <tt>0x08</tt> should remain unset rather than assigned an empty array.\nAll other data except the UTXO and unknown fields in the input key-value map should be cleared from the PSBT. The UTXO should be kept to allow Transaction Extractors to verify the final network serialized transaction.\n\n===Transaction Extractor===\n\nThe Transaction Extractor must only accept a PSBT.\nIt checks whether all inputs have complete scriptSigs and scriptWitnesses by checking for the presence of <tt>0x07</tt> Finalized scriptSig and <tt>0x08</tt> Finalized scriptWitness typed records. If they do, the Transaction Extractor should construct complete scriptSigs and scriptWitnesses and encode them into network serialized transactions. Otherwise the Extractor must not modify the PSBT.\nThe Extractor should produce a fully valid, network serialized transaction if all inputs are complete.\n\nThe Transaction Extractor does not need to know how to interpret scripts in order to extract the network serialized transaction. However it may be able to in order to validate the network serialized transaction at the same time.\n\nA single entity is likely to be both a Transaction Extractor and an Input Finalizer.\n\n==Encoding==\n\nA PSBT can be represented in two ways: in binary (as a file) or as a Base64 string using the encoding described in [https://tools.ietf.org/html/rfc4648#section-4 RFC4648].\n\nBinary PSBT files should use the <tt>.psbt</tt> file extension.\nA MIME type name will be added to this document once one has been registered.\n\n==Extensibility==\n\nThe Partially Signed Transaction format can be extended in the future by adding\nnew types for key-value pairs. Backwards compatibility will still be maintained as those new\ntypes will be ignored and passed-through by signers which do not know about them.\n\n===Version Numbers===\n\nThe Version number field exists only as a safeguard in the event that a backwards incompatible change is introduced to PSBT.\nIf a parser encounters a version number it does not recognize, it should exit immediately as this indicates that the PSBT will contain types that it does not know about and cannot be ignored.\nCurrent PSBTs are Version 0. Any PSBT that does not have the version field is version 0.\nIt is not expected that any backwards incompatible change will be introduced to PSBT, so it is not expected that the version field will ever actually be seen.\n\nUpdaters and combiners that need to add a version number to a PSBT should use the highest version number required.\nFor example, if a combiner sees two PSBTs for the same transaction, one with version 0, and the other with version 1, then it should combine them and produce a PSBT with version 1.\nIf an updater is updating a PSBT and needs to add a field that is only available in version 1, then it should set the PSBT version number to 1 unless a version higher than that is already specified.\n\n===Procedure For New Fields===\n\nNew fields should first be proposed on the bitcoin-dev mailing list.\nIf a field requires significant description as to its usage, it should be accompanied by a separate BIP.\nThe field must be added to the field listing tables in the Specification section.\nAlthough some PSBT version 0 implementations encode types as uint8_t rather than compact size,\nit is still safe to add >0xFD fields to PSBT 0, because these old parsers ignore\nunknown fields, and <keytype> is prefixed by its length.\n\n===Procedure For New Versions===\n\nNew PSBT versions must be described in a separate BIP.\nThe BIP may reference this BIP and any components of PSBT version 0 that are retained in the new version.\nAny new fields described in the new version must be added to the field listing tables in the Specification section.\n\n==Compatibility==\n\nThis transaction format is designed so that it is unable to be properly unserialized\nby normal transaction unserializers. Likewise, a normal transaction will not be\nable to be unserialized by an unserializer for the PSBT format.\n\n==Examples==\n\n===Manual CoinJoin Workflow===\n\n<img src=\"bip-0174/coinjoin-workflow.svg\" align=\"middle\"></img>\n\n===2-of-3 Multisig Workflow===\n\n<img src=\"bip-0174/multisig-workflow.svg\" align=\"middle\"></img>\n\n==Test Vectors==\n\nThe following are invalid PSBTs:\n\n* Case: Network transaction, not PSBT format\n** Bytes in Hex: <pre>0200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf6000000006a473044022070b2245123e6bf474d60c5b50c043d4c691a5d2435f09a34a7662a9dc251790a022001329ca9dacf280bdf30740ec0390422422c81cb45839457aeb76fc12edd95b3012102657d118d3357b8e0f4c2cd46db7b39f6d9c38d9a70abcb9b2de5dc8dbfe4ce31feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300</pre>\n** Base64 String: <pre>AgAAAAEmgXE3Ht/yhek3re6ks3t4AAwFZsuzrWRkFxPKQhcb9gAAAABqRzBEAiBwsiRRI+a/R01gxbUMBD1MaRpdJDXwmjSnZiqdwlF5CgIgATKcqdrPKAvfMHQOwDkEIkIsgctFg5RXrrdvwS7dlbMBIQJlfRGNM1e44PTCzUbbezn22cONmnCry5st5dyNv+TOMf7///8C09/1BQAAAAAZdqkU0MWZA8W6woaHYOkP1SGkZlqnZSCIrADh9QUAAAAAF6kUNUXm4zuDLEcFDyTT7rk8nAOUi8eHsy4TAA==</pre>\n\n* Case: PSBT missing outputs\n** Bytes in Hex: <pre>70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab30000000000</pre>\n** Base64 String: <pre>cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAA==</pre>\n\n* Case: PSBT where one input has a filled scriptSig in the unsigned tx\n** Bytes in Hex: <pre>70736274ff0100fd0a010200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be4000000006a47304402204759661797c01b036b25928948686218347d89864b719e1f7fcf57d1e511658702205309eabf56aa4d8891ffd111fdf1336f3a29da866d7f8486d75546ceedaf93190121035cdc61fc7ba971c0b501a646a2a83b102cb43881217ca682dc86e2d73fa88292feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac00000000000001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787010416001485d13537f2e265405a34dbafa9e3dda01fb82308000000</pre>\n** Base64 String: <pre>cHNidP8BAP0KAQIAAAACqwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QAAAAAakcwRAIgR1lmF5fAGwNrJZKJSGhiGDR9iYZLcZ4ff89X0eURZYcCIFMJ6r9Wqk2Ikf/REf3xM286KdqGbX+EhtdVRs7tr5MZASEDXNxh/HupccC1AaZGoqg7ECy0OIEhfKaC3Ibi1z+ogpL+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAABASAA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHhwEEFgAUhdE1N/LiZUBaNNuvqePdoB+4IwgAAAA=</pre>\n\n* Case: PSBT where inputs and outputs are provided but without an unsigned tx\n** Bytes in Hex: <pre>70736274ff000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab30000000000</pre>\n** Base64 String: <pre>cHNidP8AAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAA==</pre>\n\n* Case: PSBT with duplicate keys in an input\n** Bytes in Hex: <pre>70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab30000000001003f0200000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff010000000000000000036a010000000000000000</pre>\n** Base64 String: <pre>cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAQA/AgAAAAH//////////////////////////////////////////wAAAAAA/////wEAAAAAAAAAAANqAQAAAAAAAAAA</pre>\n\n* Case: PSBT with invalid global transaction typed key\n** Bytes in Hex: <pre>70736274ff020001550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000000010120955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a010104220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d5681010547522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8CAAFVAgAAAAEnmiMjpd+1H8RfIg+liw/BPh4zQnkqhdfjbNYzO1y8OQAAAAAA/////wGgWuoLAAAAABl2qRT/6cAGEJfMO2NvLLBGD6T8Qn0rRYisAAAAAAABASCVXuoLAAAAABepFGNFIA9o0YnhrcDfHE0W6o8UwNvrhyICA7E0HMunaDtq9PEjjNbpfnFn1Wn6xH8eSNR1QYRDVb1GRjBDAiAEJLWO/6qmlOFVnqXJO7/UqJBkIkBVzfBwtncUaUQtBwIfXI6w/qZRbWC4rLM61k7eYOh4W/s6qUuZvfhhUduamgEBBCIAIHcf0YrUWWZt1J89Vk49vEL0yEd042CtoWgWqO1IjVaBAQVHUiEDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUYhA95V0eHayAXj+KWMH7+blMAvPbqv4Sf+/KSZXyb4IIO9Uq4iBgOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RhC0prpnAAAAgAAAAIAEAACAIgYD3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg70QtKa6ZwAAAIAAAACABQAAgAAA</pre>\n\n* Case: PSBT with invalid input witness utxo typed key\n** Bytes in Hex: <pre>70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac000000000002010020955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a010104220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d5681010547522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAIBACCVXuoLAAAAABepFGNFIA9o0YnhrcDfHE0W6o8UwNvrhyICA7E0HMunaDtq9PEjjNbpfnFn1Wn6xH8eSNR1QYRDVb1GRjBDAiAEJLWO/6qmlOFVnqXJO7/UqJBkIkBVzfBwtncUaUQtBwIfXI6w/qZRbWC4rLM61k7eYOh4W/s6qUuZvfhhUduamgEBBCIAIHcf0YrUWWZt1J89Vk49vEL0yEd042CtoWgWqO1IjVaBAQVHUiEDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUYhA95V0eHayAXj+KWMH7+blMAvPbqv4Sf+/KSZXyb4IIO9Uq4iBgOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RhC0prpnAAAAgAAAAIAEAACAIgYD3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg70QtKa6ZwAAAIAAAACABQAAgAAA</pre>\n\n* Case: PSBT with invalid pubkey length for input partial signature typed key\n** Bytes in Hex: <pre>70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000000010120955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87210203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd46304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a010104220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d5681010547522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAEBIJVe6gsAAAAAF6kUY0UgD2jRieGtwN8cTRbqjxTA2+uHIQIDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUYwQwIgBCS1jv+qppThVZ6lyTu/1KiQZCJAVc3wcLZ3FGlELQcCH1yOsP6mUW1guKyzOtZO3mDoeFv7OqlLmb34YVHbmpoBAQQiACB3H9GK1FlmbdSfPVZOPbxC9MhHdONgraFoFqjtSI1WgQEFR1IhA7E0HMunaDtq9PEjjNbpfnFn1Wn6xH8eSNR1QYRDVb1GIQPeVdHh2sgF4/iljB+/m5TALz26r+En/vykmV8m+CCDvVKuIgYDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUYQtKa6ZwAAAIAAAACABAAAgCIGA95V0eHayAXj+KWMH7+blMAvPbqv4Sf+/KSZXyb4IIO9ELSmumcAAACAAAAAgAUAAIAAAA==</pre>\n\n* Case: PSBT with invalid redeemscript typed key\n** Bytes in Hex: <pre>70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000000010120955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a01020400220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d5681010547522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAEBIJVe6gsAAAAAF6kUY0UgD2jRieGtwN8cTRbqjxTA2+uHIgIDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUZGMEMCIAQktY7/qqaU4VWepck7v9SokGQiQFXN8HC2dxRpRC0HAh9cjrD+plFtYLisszrWTt5g6Hhb+zqpS5m9+GFR25qaAQIEACIAIHcf0YrUWWZt1J89Vk49vEL0yEd042CtoWgWqO1IjVaBAQVHUiEDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUYhA95V0eHayAXj+KWMH7+blMAvPbqv4Sf+/KSZXyb4IIO9Uq4iBgOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RhC0prpnAAAAgAAAAIAEAACAIgYD3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg70QtKa6ZwAAAIAAAACABQAAgAAA</pre>\n\n* Case: PSBT with invalid witnessscript typed key\n** Bytes in Hex: <pre>70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000000010120955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a010104220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d568102050047522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAEBIJVe6gsAAAAAF6kUY0UgD2jRieGtwN8cTRbqjxTA2+uHIgIDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUZGMEMCIAQktY7/qqaU4VWepck7v9SokGQiQFXN8HC2dxRpRC0HAh9cjrD+plFtYLisszrWTt5g6Hhb+zqpS5m9+GFR25qaAQEEIgAgdx/RitRZZm3Unz1WTj28QvTIR3TjYK2haBao7UiNVoECBQBHUiEDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUYhA95V0eHayAXj+KWMH7+blMAvPbqv4Sf+/KSZXyb4IIO9Uq4iBgOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RhC0prpnAAAAgAAAAIAEAACAIgYD3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg70QtKa6ZwAAAIAAAACABQAAgAAA</pre>\n\n* Case: PSBT with invalid pubkey in input BIP 32 derivation paths typed key\n** Bytes in Hex: <pre>70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000000010120955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a010104220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d5681010547522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae210603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd10b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAEBIJVe6gsAAAAAF6kUY0UgD2jRieGtwN8cTRbqjxTA2+uHIgIDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUZGMEMCIAQktY7/qqaU4VWepck7v9SokGQiQFXN8HC2dxRpRC0HAh9cjrD+plFtYLisszrWTt5g6Hhb+zqpS5m9+GFR25qaAQEEIgAgdx/RitRZZm3Unz1WTj28QvTIR3TjYK2haBao7UiNVoEBBUdSIQOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RiED3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg71SriEGA7E0HMunaDtq9PEjjNbpfnFn1Wn6xH8eSNR1QYRDVb0QtKa6ZwAAAIAAAACABAAAgCIGA95V0eHayAXj+KWMH7+blMAvPbqv4Sf+/KSZXyb4IIO9ELSmumcAAACAAAAAgAUAAIAAAA==</pre>\n\n* Case: PSBT with invalid non-witness utxo typed key\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f0000000000020000bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000000107da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae0001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8870107232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b20289030108da0400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAIAALsCAAAAAarXOTEBi9JfhK5AC2iEi+CdtwbqwqwYKYur7nGrZW+LAAAAAEhHMEQCIFj2/HxqM+GzFUjUgcgmwBW9MBNarULNZ3kNq2bSrSQ7AiBKHO0mBMZzW2OT5bQWkd14sA8MWUL7n3UYVvqpOBV9ugH+////AoDw+gIAAAAAF6kUD7lGNCFpa4LIM68kHHjBfdveSTSH0PIKJwEAAAAXqRQpynT4oI+BmZQoGFyXtdhS5AY/YYdlAAAAAQfaAEcwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMAUgwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gFHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4AAQEgAMLrCwAAAAAXqRS39fr0Dj1ApaRZsds1NfK3L6kh6IcBByMiACCMI1MXN0O1ld+0oHtyuo5C43l9p06H/n2ddJfjsgKJAwEI2gQARzBEAiBi63pVYQenxz9FrEq1od3fb3B1+xJ1lpp/OD7/94S8sgIgDAXbt0cNvy8IVX3TVscyXB7TCRPpls04QJRdsSIo2l8BRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\n* Case: PSBT with invalid final scriptsig typed key\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000020700da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae0001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8870107232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b20289030108da0400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAACBwDaAEcwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMAUgwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gFHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4AAQEgAMLrCwAAAAAXqRS39fr0Dj1ApaRZsds1NfK3L6kh6IcBByMiACCMI1MXN0O1ld+0oHtyuo5C43l9p06H/n2ddJfjsgKJAwEI2gQARzBEAiBi63pVYQenxz9FrEq1od3fb3B1+xJ1lpp/OD7/94S8sgIgDAXbt0cNvy8IVX3TVscyXB7TCRPpls04QJRdsSIo2l8BRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\n* Case: PSBT with invalid final script witness typed key\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000000107da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae0001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8870107232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903020800da0400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABB9oARzBEAiB0AYrUGACXuHMyPAAVcgs2hMyBI4kQSOfbzZtVrWecmQIgc9Npt0Dj61Pc76M4I8gHBRTKVafdlUTxV8FnkTJhEYwBSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAUdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSrgABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEHIyIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAggA2gQARzBEAiBi63pVYQenxz9FrEq1od3fb3B1+xJ1lpp/OD7/94S8sgIgDAXbt0cNvy8IVX3TVscyXB7TCRPpls04QJRdsSIo2l8BRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\n* Case: PSBT with invalid pubkey in output BIP 32 derivation paths typed key\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000000107da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae0001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8870107232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b20289030108da0400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00210203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca58710d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABB9oARzBEAiB0AYrUGACXuHMyPAAVcgs2hMyBI4kQSOfbzZtVrWecmQIgc9Npt0Dj61Pc76M4I8gHBRTKVafdlUTxV8FnkTJhEYwBSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAUdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSrgABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEHIyIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQjaBABHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwFHMEQCIGX0W6WZi1mif/4ae+0BavHx+Q1Us6qPdFCqX1aiUQO9AiB/ckcDrR7blmgLKEtW1P/LiPf7dZ6rvgiqMPKbhROD0gFHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4AIQIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1PtnuylhxDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA</pre>\n\n* Case: PSBT with invalid input sighash type typed key\n** Bytes in Hex: <pre>70736274ff0100730200000001301ae986e516a1ec8ac5b4bc6573d32f83b465e23ad76167d68b38e730b4dbdb0000000000ffffffff02747b01000000000017a91403aa17ae882b5d0d54b25d63104e4ffece7b9ea2876043993b0000000017a914b921b1ba6f722e4bfa83b6557a3139986a42ec8387000000000001011f00ca9a3b00000000160014d2d94b64ae08587eefc8eeb187c601e939f9037c0203000100000000010016001462e9e982fff34dd8239610316b090cd2a3b747cb000100220020876bad832f1d168015ed41232a9ea65a1815d9ef13c0ef8759f64b5b2b278a65010125512103b7ce23a01c5b4bf00a642537cdfabb315b668332867478ef51309d2bd57f8a8751ae00</pre>\n** Base64 String: <pre>cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wCAwABAAAAAAEAFgAUYunpgv/zTdgjlhAxawkM0qO3R8sAAQAiACCHa62DLx0WgBXtQSMqnqZaGBXZ7xPA74dZ9ktbKyeKZQEBJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnSvVf4qHUa4A</pre>\n\n* Case: PSBT with invalid output redeemScript typed key\n** Bytes in Hex: <pre>70736274ff0100730200000001301ae986e516a1ec8ac5b4bc6573d32f83b465e23ad76167d68b38e730b4dbdb0000000000ffffffff02747b01000000000017a91403aa17ae882b5d0d54b25d63104e4ffece7b9ea2876043993b0000000017a914b921b1ba6f722e4bfa83b6557a3139986a42ec8387000000000001011f00ca9a3b00000000160014d2d94b64ae08587eefc8eeb187c601e939f9037c0002000016001462e9e982fff34dd8239610316b090cd2a3b747cb000100220020876bad832f1d168015ed41232a9ea65a1815d9ef13c0ef8759f64b5b2b278a65010125512103b7ce23a01c5b4bf00a642537cdfabb315b668332867478ef51309d2bd57f8a8751ae00</pre>\n** Base64 String: <pre>cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wAAgAAFgAUYunpgv/zTdgjlhAxawkM0qO3R8sAAQAiACCHa62DLx0WgBXtQSMqnqZaGBXZ7xPA74dZ9ktbKyeKZQEBJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnSvVf4qHUa4A</pre>\n\n* Case: PSBT with invalid output witnessScript typed key\n** Bytes in Hex: <pre>70736274ff0100730200000001301ae986e516a1ec8ac5b4bc6573d32f83b465e23ad76167d68b38e730b4dbdb0000000000ffffffff02747b01000000000017a91403aa17ae882b5d0d54b25d63104e4ffece7b9ea2876043993b0000000017a914b921b1ba6f722e4bfa83b6557a3139986a42ec8387000000000001011f00ca9a3b00000000160014d2d94b64ae08587eefc8eeb187c601e939f9037c00010016001462e9e982fff34dd8239610316b090cd2a3b747cb000100220020876bad832f1d168015ed41232a9ea65a1815d9ef13c0ef8759f64b5b2b278a6521010025512103b7ce23a01c5b4bf00a642537cdfabb315b668332867478ef51309d06d57f8a8751ae00</pre>\n** Base64 String: <pre>cHNidP8BAHMCAAAAATAa6YblFqHsisW0vGVz0y+DtGXiOtdhZ9aLOOcwtNvbAAAAAAD/////AnR7AQAAAAAAF6kUA6oXrogrXQ1Usl1jEE5P/s57nqKHYEOZOwAAAAAXqRS5IbG6b3IuS/qDtlV6MTmYakLsg4cAAAAAAAEBHwDKmjsAAAAAFgAU0tlLZK4IWH7vyO6xh8YB6Tn5A3wAAQAWABRi6emC//NN2COWEDFrCQzSo7dHywABACIAIIdrrYMvHRaAFe1BIyqeploYFdnvE8Dvh1n2S1srJ4plIQEAJVEhA7fOI6AcW0vwCmQlN836uzFbZoMyhnR471EwnQbVf4qHUa4A</pre>\n\n* Case: PSBT with unsigned tx serialized with witness serialization format\n** Bytes in Hex: <pre>70736274ff01007802000000000101268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc78700b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab300000000000000</pre>\n** Base64 String: <pre>cHNidP8BAHgCAAAAAAEBJoFxNx7f8oXpN63upLN7eAAMBWbLs61kZBcTykIXG/YAAAAAAP7///8C09/1BQAAAAAZdqkU0MWZA8W6woaHYOkP1SGkZlqnZSCIrADh9QUAAAAAF6kUNUXm4zuDLEcFDyTT7rk8nAOUi8eHALMuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAAAA</pre>\n\n* Case: PSBT with an invalid value data due to its size being not the stated size\n** Bytes in Hex: <pre>70736274ff0100337401ff0700010000000100ff01000a73317428ff0000000001ff010301000001000000000000000076010000004100090000000000</pre>\n** Base64 String: <pre>cHNidP8BADN0Af8HAAEAAAABAP8BAApzMXQo/wAAAAAB/wEDAQAAAQAAAAAAAAAAdgEAAABBAAkAAAAAAA==</pre>\n\nThe following are valid PSBTs:\n\n* Case: PSBT with one P2PKH input. Outputs are empty\n** Bytes in Hex: <pre>70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab300000000000000</pre>\n** Base64 String: <pre>cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAAAA</pre>\n\n* Case: PSBT with one P2PKH input and one P2SH-P2WPKH input. First input is signed and finalized. Outputs are empty\n** Bytes in Hex: <pre>70736274ff0100a00200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40000000000feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac000000000001076a47304402204759661797c01b036b25928948686218347d89864b719e1f7fcf57d1e511658702205309eabf56aa4d8891ffd111fdf1336f3a29da866d7f8486d75546ceedaf93190121035cdc61fc7ba971c0b501a646a2a83b102cb43881217ca682dc86e2d73fa882920001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787010416001485d13537f2e265405a34dbafa9e3dda01fb82308000000</pre>\n** Base64 String: <pre>cHNidP8BAKACAAAAAqsJSaCMWvfEm4IS9Bfi8Vqz9cM9zxU4IagTn4d6W3vkAAAAAAD+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAEHakcwRAIgR1lmF5fAGwNrJZKJSGhiGDR9iYZLcZ4ff89X0eURZYcCIFMJ6r9Wqk2Ikf/REf3xM286KdqGbX+EhtdVRs7tr5MZASEDXNxh/HupccC1AaZGoqg7ECy0OIEhfKaC3Ibi1z+ogpIAAQEgAOH1BQAAAAAXqRQ1RebjO4MsRwUPJNPuuTycA5SLx4cBBBYAFIXRNTfy4mVAWjTbr6nj3aAfuCMIAAAA</pre>\n\n* Case: PSBT with one P2PKH input which has a non-final scriptSig and has a sighash type specified. Outputs are empty\n** Bytes in Hex: <pre>70736274ff0100750200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf60000000000feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000100fda5010100000000010289a3c71eab4d20e0371bbba4cc698fa295c9463afa2e397f8533ccb62f9567e50100000017160014be18d152a9b012039daf3da7de4f53349eecb985ffffffff86f8aa43a71dff1448893a530a7237ef6b4608bbb2dd2d0171e63aec6a4890b40100000017160014fe3e9ef1a745e974d902c4355943abcb34bd5353ffffffff0200c2eb0b000000001976a91485cff1097fd9e008bb34af709c62197b38978a4888ac72fef84e2c00000017a914339725ba21efd62ac753a9bcd067d6c7a6a39d05870247304402202712be22e0270f394f568311dc7ca9a68970b8025fdd3b240229f07f8a5f3a240220018b38d7dcd314e734c9276bd6fb40f673325bc4baa144c800d2f2f02db2765c012103d2e15674941bad4a996372cb87e1856d3652606d98562fe39c5e9e7e413f210502483045022100d12b852d85dcd961d2f5f4ab660654df6eedcc794c0c33ce5cc309ffb5fce58d022067338a8e0e1725c197fb1a88af59f51e44e4255b20167c8684031c05d1f2592a01210223b72beef0965d10be0778efecd61fcac6f79a4ea169393380734464f84f2ab30000000001030401000000000000</pre>\n** Base64 String: <pre>cHNidP8BAHUCAAAAASaBcTce3/KF6Tet7qSze3gADAVmy7OtZGQXE8pCFxv2AAAAAAD+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQD9pQEBAAAAAAECiaPHHqtNIOA3G7ukzGmPopXJRjr6Ljl/hTPMti+VZ+UBAAAAFxYAFL4Y0VKpsBIDna89p95PUzSe7LmF/////4b4qkOnHf8USIk6UwpyN+9rRgi7st0tAXHmOuxqSJC0AQAAABcWABT+Pp7xp0XpdNkCxDVZQ6vLNL1TU/////8CAMLrCwAAAAAZdqkUhc/xCX/Z4Ai7NK9wnGIZeziXikiIrHL++E4sAAAAF6kUM5cluiHv1irHU6m80GfWx6ajnQWHAkcwRAIgJxK+IuAnDzlPVoMR3HyppolwuAJf3TskAinwf4pfOiQCIAGLONfc0xTnNMkna9b7QPZzMlvEuqFEyADS8vAtsnZcASED0uFWdJQbrUqZY3LLh+GFbTZSYG2YVi/jnF6efkE/IQUCSDBFAiEA0SuFLYXc2WHS9fSrZgZU327tzHlMDDPOXMMJ/7X85Y0CIGczio4OFyXBl/saiK9Z9R5E5CVbIBZ8hoQDHAXR8lkqASECI7cr7vCWXRC+B3jv7NYfysb3mk6haTkzgHNEZPhPKrMAAAAAAQMEAQAAAAAAAA==</pre>\n\n* Case: PSBT with one P2PKH input and one P2SH-P2WPKH input both with non-final scriptSigs. P2SH-P2WPKH input's redeemScript is available. Outputs filled.\n** Bytes in Hex: <pre>70736274ff0100a00200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40000000000feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac00000000000100df0200000001268171371edff285e937adeea4b37b78000c0566cbb3ad64641713ca42171bf6000000006a473044022070b2245123e6bf474d60c5b50c043d4c691a5d2435f09a34a7662a9dc251790a022001329ca9dacf280bdf30740ec0390422422c81cb45839457aeb76fc12edd95b3012102657d118d3357b8e0f4c2cd46db7b39f6d9c38d9a70abcb9b2de5dc8dbfe4ce31feffffff02d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e13000001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787010416001485d13537f2e265405a34dbafa9e3dda01fb8230800220202ead596687ca806043edc3de116cdf29d5e9257c196cd055cf698c8d02bf24e9910b4a6ba670000008000000080020000800022020394f62be9df19952c5587768aeb7698061ad2c4a25c894f47d8c162b4d7213d0510b4a6ba6700000080010000800200008000</pre>\n** Base64 String: <pre>cHNidP8BAKACAAAAAqsJSaCMWvfEm4IS9Bfi8Vqz9cM9zxU4IagTn4d6W3vkAAAAAAD+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAEA3wIAAAABJoFxNx7f8oXpN63upLN7eAAMBWbLs61kZBcTykIXG/YAAAAAakcwRAIgcLIkUSPmv0dNYMW1DAQ9TGkaXSQ18Jo0p2YqncJReQoCIAEynKnazygL3zB0DsA5BCJCLIHLRYOUV663b8Eu3ZWzASECZX0RjTNXuOD0ws1G23s59tnDjZpwq8ubLeXcjb/kzjH+////AtPf9QUAAAAAGXapFNDFmQPFusKGh2DpD9UhpGZap2UgiKwA4fUFAAAAABepFDVF5uM7gyxHBQ8k0+65PJwDlIvHh7MuEwAAAQEgAOH1BQAAAAAXqRQ1RebjO4MsRwUPJNPuuTycA5SLx4cBBBYAFIXRNTfy4mVAWjTbr6nj3aAfuCMIACICAurVlmh8qAYEPtw94RbN8p1eklfBls0FXPaYyNAr8k6ZELSmumcAAACAAAAAgAIAAIAAIgIDlPYr6d8ZlSxVh3aK63aYBhrSxKJciU9H2MFitNchPQUQtKa6ZwAAAIABAACAAgAAgAA=</pre>\n\n* Case: PSBT with one P2SH-P2WSH input of a 2-of-2 multisig, redeemScript, witnessScript, and keypaths are available. Contains one signature.\n** Bytes in Hex: <pre>70736274ff0100550200000001279a2323a5dfb51fc45f220fa58b0fc13e1e3342792a85d7e36cd6333b5cbc390000000000ffffffff01a05aea0b000000001976a914ffe9c0061097cc3b636f2cb0460fa4fc427d2b4588ac0000000000010120955eea0b0000000017a9146345200f68d189e1adc0df1c4d16ea8f14c0dbeb87220203b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4646304302200424b58effaaa694e1559ea5c93bbfd4a89064224055cdf070b6771469442d07021f5c8eb0fea6516d60b8acb33ad64ede60e8785bfb3aa94b99bdf86151db9a9a010104220020771fd18ad459666dd49f3d564e3dbc42f4c84774e360ada16816a8ed488d5681010547522103b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd462103de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd52ae220603b1341ccba7683b6af4f1238cd6e97e7167d569fac47f1e48d47541844355bd4610b4a6ba67000000800000008004000080220603de55d1e1dac805e3f8a58c1fbf9b94c02f3dbaafe127fefca4995f26f82083bd10b4a6ba670000008000000080050000800000</pre>\n** Base64 String: <pre>cHNidP8BAFUCAAAAASeaIyOl37UfxF8iD6WLD8E+HjNCeSqF1+Ns1jM7XLw5AAAAAAD/////AaBa6gsAAAAAGXapFP/pwAYQl8w7Y28ssEYPpPxCfStFiKwAAAAAAAEBIJVe6gsAAAAAF6kUY0UgD2jRieGtwN8cTRbqjxTA2+uHIgIDsTQcy6doO2r08SOM1ul+cWfVafrEfx5I1HVBhENVvUZGMEMCIAQktY7/qqaU4VWepck7v9SokGQiQFXN8HC2dxRpRC0HAh9cjrD+plFtYLisszrWTt5g6Hhb+zqpS5m9+GFR25qaAQEEIgAgdx/RitRZZm3Unz1WTj28QvTIR3TjYK2haBao7UiNVoEBBUdSIQOxNBzLp2g7avTxI4zW6X5xZ9Vp+sR/HkjUdUGEQ1W9RiED3lXR4drIBeP4pYwfv5uUwC89uq/hJ/78pJlfJvggg71SriIGA7E0HMunaDtq9PEjjNbpfnFn1Wn6xH8eSNR1QYRDVb1GELSmumcAAACAAAAAgAQAAIAiBgPeVdHh2sgF4/iljB+/m5TALz26r+En/vykmV8m+CCDvRC0prpnAAAAgAAAAIAFAACAAAA=</pre>\n\n* Case: PSBT with one P2WSH input of a 2-of-2 multisig. witnessScript, keypaths, and global xpubs are available. Contains no signatures. Outputs filled.\n** Bytes in Hex: <pre>70736274ff01005202000000019dfc6628c26c5899fe1bd3dc338665bfd55d7ada10f6220973df2d386dec12760100000000ffffffff01f03dcd1d000000001600147b3a00bfdc14d27795c2b74901d09da6ef133579000000004f01043587cf02da3fd0088000000097048b1ad0445b1ec8275517727c87b4e4ebc18a203ffa0f94c01566bd38e9000351b743887ee1d40dc32a6043724f2d6459b3b5a4d73daec8fbae0472f3bc43e20cd90c6a4fae000080000000804f01043587cf02da3fd00880000001b90452427139cd78c2cff2444be353cd58605e3e513285e528b407fae3f6173503d30a5e97c8adbc557dac2ad9a7e39c1722ebac69e668b6f2667cc1d671c83cab0cd90c6a4fae000080010000800001012b0065cd1d000000002200202c5486126c4978079a814e13715d65f36459e4d6ccaded266d0508645bafa6320105475221029da12cdb5b235692b91536afefe5c91c3ab9473d8e43b533836ab456299c88712103372b34234ed7cf9c1fea5d05d441557927be9542b162eb02e1ab2ce80224c00b52ae2206029da12cdb5b235692b91536afefe5c91c3ab9473d8e43b533836ab456299c887110d90c6a4fae0000800000008000000000220603372b34234ed7cf9c1fea5d05d441557927be9542b162eb02e1ab2ce80224c00b10d90c6a4fae0000800100008000000000002202039eff1f547a1d5f92dfa2ba7af6ac971a4bd03ba4a734b03156a256b8ad3a1ef910ede45cc500000080000000800100008000</pre>\n** Base64 String: <pre>cHNidP8BAFICAAAAAZ38ZijCbFiZ/hvT3DOGZb/VXXraEPYiCXPfLTht7BJ2AQAAAAD/////AfA9zR0AAAAAFgAUezoAv9wU0neVwrdJAdCdpu8TNXkAAAAATwEENYfPAto/0AiAAAAAlwSLGtBEWx7IJ1UXcnyHtOTrwYogP/oPlMAVZr046QADUbdDiH7h1A3DKmBDck8tZFmztaTXPa7I+64EcvO8Q+IM2QxqT64AAIAAAACATwEENYfPAto/0AiAAAABuQRSQnE5zXjCz/JES+NTzVhgXj5RMoXlKLQH+uP2FzUD0wpel8itvFV9rCrZp+OcFyLrrGnmaLbyZnzB1nHIPKsM2QxqT64AAIABAACAAAEBKwBlzR0AAAAAIgAgLFSGEmxJeAeagU4TcV1l82RZ5NbMre0mbQUIZFuvpjIBBUdSIQKdoSzbWyNWkrkVNq/v5ckcOrlHPY5DtTODarRWKZyIcSEDNys0I07Xz5wf6l0F1EFVeSe+lUKxYusC4ass6AIkwAtSriIGAp2hLNtbI1aSuRU2r+/lyRw6uUc9jkO1M4NqtFYpnIhxENkMak+uAACAAAAAgAAAAAAiBgM3KzQjTtfPnB/qXQXUQVV5J76VQrFi6wLhqyzoAiTACxDZDGpPrgAAgAEAAIAAAAAAACICA57/H1R6HV+S36K6evaslxpL0DukpzSwMVaiVritOh75EO3kXMUAAACAAAAAgAEAAIAA</pre>\n\n* Case: PSBT with unknown types in the inputs.\n** Bytes in Hex: <pre>70736274ff01003f0200000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff010000000000000000036a010000000000000af00102030405060708090f0102030405060708090a0b0c0d0e0f0000</pre>\n** Base64 String: <pre>cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAACvABAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAAA=</pre>\n\n* Case: PSBT with `PSBT_GLOBAL_XPUB`.\n** Bytes in Hex: <pre>70736274ff01009d0100000002710ea76ab45c5cb6438e607e59cc037626981805ae9e0dfd9089012abb0be5350100000000ffffffff190994d6a8b3c8c82ccbcfb2fba4106aa06639b872a8d447465c0d42588d6d670000000000ffffffff0200e1f505000000001976a914b6bc2c0ee5655a843d79afedd0ccc3f7dd64340988ac605af405000000001600141188ef8e4ce0449eaac8fb141cbf5a1176e6a088000000004f010488b21e039e530cac800000003dbc8a5c9769f031b17e77fea1518603221a18fd18f2b9a54c6c8c1ac75cbc3502f230584b155d1c7f1cd45120a653c48d650b431b67c5b2c13f27d7142037c1691027569c503100008000000080000000800001011f00e1f5050000000016001433b982f91b28f160c920b4ab95e58ce50dda3a4a220203309680f33c7de38ea6a47cd4ecd66f1f5a49747c6ffb8808ed09039243e3ad5c47304402202d704ced830c56a909344bd742b6852dccd103e963bae92d38e75254d2bb424502202d86c437195df46c0ceda084f2a291c3da2d64070f76bf9b90b195e7ef28f77201220603309680f33c7de38ea6a47cd4ecd66f1f5a49747c6ffb8808ed09039243e3ad5c1827569c5031000080000000800000008000000000010000000001011f00e1f50500000000160014388fb944307eb77ef45197d0b0b245e079f011de220202c777161f73d0b7c72b9ee7bde650293d13f095bc7656ad1f525da5fd2e10b11047304402204cb1fb5f869c942e0e26100576125439179ae88dca8a9dc3ba08f7953988faa60220521f49ca791c27d70e273c9b14616985909361e25be274ea200d7e08827e514d01220602c777161f73d0b7c72b9ee7bde650293d13f095bc7656ad1f525da5fd2e10b1101827569c5031000080000000800000008000000000000000000000220202d20ca502ee289686d21815bd43a80637b0698e1fbcdbe4caed445f6c1a0a90ef1827569c50310000800000008000000080000000000400000000</pre>\n** Base64 String: <pre>cHNidP8BAJ0BAAAAAnEOp2q0XFy2Q45gflnMA3YmmBgFrp4N/ZCJASq7C+U1AQAAAAD/////GQmU1qizyMgsy8+y+6QQaqBmObhyqNRHRlwNQliNbWcAAAAAAP////8CAOH1BQAAAAAZdqkUtrwsDuVlWoQ9ea/t0MzD991kNAmIrGBa9AUAAAAAFgAUEYjvjkzgRJ6qyPsUHL9aEXbmoIgAAAAATwEEiLIeA55TDKyAAAAAPbyKXJdp8DGxfnf+oVGGAyIaGP0Y8rmlTGyMGsdcvDUC8jBYSxVdHH8c1FEgplPEjWULQxtnxbLBPyfXFCA3wWkQJ1acUDEAAIAAAACAAAAAgAABAR8A4fUFAAAAABYAFDO5gvkbKPFgySC0q5XljOUN2jpKIgIDMJaA8zx9446mpHzU7NZvH1pJdHxv+4gI7QkDkkPjrVxHMEQCIC1wTO2DDFapCTRL10K2hS3M0QPpY7rpLTjnUlTSu0JFAiAthsQ3GV30bAztoITyopHD2i1kBw92v5uQsZXn7yj3cgEiBgMwloDzPH3jjqakfNTs1m8fWkl0fG/7iAjtCQOSQ+OtXBgnVpxQMQAAgAAAAIAAAACAAAAAAAEAAAAAAQEfAOH1BQAAAAAWABQ4j7lEMH63fvRRl9CwskXgefAR3iICAsd3Fh9z0LfHK57nveZQKT0T8JW8dlatH1Jdpf0uELEQRzBEAiBMsftfhpyULg4mEAV2ElQ5F5rojcqKncO6CPeVOYj6pgIgUh9JynkcJ9cOJzybFGFphZCTYeJb4nTqIA1+CIJ+UU0BIgYCx3cWH3PQt8crnue95lApPRPwlbx2Vq0fUl2l/S4QsRAYJ1acUDEAAIAAAACAAAAAgAAAAAAAAAAAAAAiAgLSDKUC7iiWhtIYFb1DqAY3sGmOH7zb5MrtRF9sGgqQ7xgnVpxQMQAAgAAAAIAAAACAAAAAAAQAAAAA</pre>\n\n* Case: PSBT with global unsigned tx that has 0 inputs and 0 outputs\n** Bytes in Hex: <pre>70736274ff01000a0000000000000000000000</pre>\n** Base64 String: <pre>cHNidP8BAAoAAAAAAAAAAAAAAA==</pre>\n\n* Case: PSBT with 0 inputs\n** Bytes in Hex: <pre>70736274ff01004c020000000002d3dff505000000001976a914d0c59903c5bac2868760e90fd521a4665aa7652088ac00e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787b32e1300000000</pre>\n** Base64 String: <pre>cHNidP8BAEwCAAAAAALT3/UFAAAAABl2qRTQxZkDxbrChodg6Q/VIaRmWqdlIIisAOH1BQAAAAAXqRQ1RebjO4MsRwUPJNPuuTycA5SLx4ezLhMAAAAA</pre>\n\nFails Signer checks\n\n* Case: A Witness UTXO is provided for a non-witness input\n** Bytes in Hex: <pre>70736274ff0100a00200000002ab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40000000000feffffffab0949a08c5af7c49b8212f417e2f15ab3f5c33dcf153821a8139f877a5b7be40100000000feffffff02603bea0b000000001976a914768a40bbd740cbe81d988e71de2a4d5c71396b1d88ac8e240000000000001976a9146f4620b553fa095e721b9ee0efe9fa039cca459788ac0000000000010122d3dff505000000001976a914d48ed3110b94014cb114bd32d6f4d066dc74256b88ac0001012000e1f5050000000017a9143545e6e33b832c47050f24d3eeb93c9c03948bc787010416001485d13537f2e265405a34dbafa9e3dda01fb8230800220202ead596687ca806043edc3de116cdf29d5e9257c196cd055cf698c8d02bf24e9910b4a6ba670000008000000080020000800022020394f62be9df19952c5587768aeb7698061ad2c4a25c894f47d8c162b4d7213d0510b4a6ba6700000080010000800200008000</pre>\n** Base64 String: <pre>cHNidP8BAKACAAAAAqsJSaCMWvfEm4IS9Bfi8Vqz9cM9zxU4IagTn4d6W3vkAAAAAAD+////qwlJoIxa98SbghL0F+LxWrP1wz3PFTghqBOfh3pbe+QBAAAAAP7///8CYDvqCwAAAAAZdqkUdopAu9dAy+gdmI5x3ipNXHE5ax2IrI4kAAAAAAAAGXapFG9GILVT+glechue4O/p+gOcykWXiKwAAAAAAAEBItPf9QUAAAAAGXapFNSO0xELlAFMsRS9Mtb00GbcdCVriKwAAQEgAOH1BQAAAAAXqRQ1RebjO4MsRwUPJNPuuTycA5SLx4cBBBYAFIXRNTfy4mVAWjTbr6nj3aAfuCMIACICAurVlmh8qAYEPtw94RbN8p1eklfBls0FXPaYyNAr8k6ZELSmumcAAACAAAAAgAIAAIAAIgIDlPYr6d8ZlSxVh3aK63aYBhrSxKJciU9H2MFitNchPQUQtKa6ZwAAAIABAACAAgAAgAA=</pre>\n\n* Case: redeemScript with non-witness UTXO does not match the scriptPubKey\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000220202dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d7483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752af2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8872202023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e73473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d2010103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU210gwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gEBAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq8iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohyICAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBAQMEAQAAAAEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\n* Case: redeemScript with witness UTXO does not match the scriptPubKey\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000220202dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d7483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8872202023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e73473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d2010103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028900010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU210gwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gEBAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohyICAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBAQMEAQAAAAEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQABBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\n* Case: witnessScript with witness UTXO does not match the redeemScript\n** Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000220202dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d7483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8872202023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e73473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d2010103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ad2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n** Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU210gwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gEBAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohyICAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBAQMEAQAAAAEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSrSIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\nThe private keys in the tests below are derived from the following master private key:\n\n* Extended Private Key: <pre>tprv8ZgxMBicQKsPd9TeAdPADNnSyH9SSUUbTVeFszDE23Ki6TBB5nCefAdHkK8Fm3qMQR6sHwA56zqRmKmxnHk37JkiFzvncDqoKmPWubu7hDF</pre>\n** Seed: <pre>cUkG8i1RFfWGWy5ziR11zJ5V4U4W3viSFCfyJmZnvQaUsd1xuF3T</pre>\n\nA creator creating a PSBT for a transaction which creates the following outputs:\n\n* scriptPubKey: <tt>0014d85c2b71d0060b09c9886aeb815e50991dda124d</tt>, Amount: <tt>1.49990000</tt>\n* scriptPubKey: <tt>001400aea9a2e5f0f876a588df5546e8742d1d87008f</tt>, Amount: <tt>1.00000000</tt>\n\nand spends the following inputs:\n\n* TXID: <tt>75ddabb27b8845f5247975c8a5ba7c6f336c4570708ebe230caf6db5217ae858</tt>, Index: <tt>0</tt>\n* TXID: <tt>1dea7cd05979072a3578cab271c02244ea8a090bbb46aa680a65ecd027048d83</tt>, Index: <tt>1</tt>\n\nmust create this PSBT:\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f000000000000000000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAAAAAA=</pre>\n\nGiven the above PSBT, an updater with only the following:\n\n* Redeem Scripts:\n** <tt>5221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae</tt>\n** <tt>00208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903</tt>\n* Witness Scripts:\n** <tt>522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae</tt>\n* Previous Transactions:\n** <pre>0200000000010158e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7501000000171600145f275f436b09a8cc9a2eb2a2f528485c68a56323feffffff02d8231f1b0100000017a914aed962d6654f9a2b36608eb9d64d2b260db4f1118700c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88702483045022100a22edcc6e5bc511af4cc4ae0de0fcd75c7e04d8c1c3a8aa9d820ed4b967384ec02200642963597b9b1bc22c75e9f3e117284a962188bf5e8a74c895089046a20ad770121035509a48eb623e10aace8bfd0212fdb8a8e5af3c94b0b133b95e114cab89e4f7965000000</pre>\n** <pre>0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000</pre>\n* Public Keys\n** Key: <tt>029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f</tt>, Derivation Path: <tt>m/0'/0'/0'</tt>\n** Key: <tt>02dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d7</tt>, Derivation Path: <tt>m/0'/0'/1'</tt>\n** Key: <tt>03089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc</tt>, Derivation Path: <tt>m/0'/0'/2'</tt>\n** Key: <tt>023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e73</tt>, Derivation Path: <tt>m/0'/0'/3'</tt>\n** Key: <tt>03a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca58771</tt>, Derivation Path: <tt>m/0'/0'/4'</tt>\n** Key: <tt>027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b50051096</tt>, Derivation Path: <tt>m/0'/0'/5'</tt>\n\nMust create this PSBT:\n\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88701042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHAQQiACCMI1MXN0O1ld+0oHtyuo5C43l9p06H/n2ddJfjsgKJAwEFR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuIgYCOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnMQ2QxqTwAAAIAAAACAAwAAgCIGAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcENkMak8AAACAAAAAgAIAAIAAIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==</pre>\n\nAn updater which adds SIGHASH_ALL to the above PSBT must create this PSBT:\n\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8870103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEDBAEAAAABBCIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQVHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4iBgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8OcxDZDGpPAAAAgAAAAIADAACAIgYDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwQ2QxqTwAAAIAAAACAAgAAgAAiAgOppMN/WZbTqiXbrGtXCvBlA5RJKUJGCzVHU+2e7KWHcRDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA</pre>\n\nGiven the above updated PSBT, a signer that supports SIGHASH_ALL for P2PKH and P2WPKH spends and uses RFC6979 for nonce generation and has the following keys:\n* <tt>cP53pDbR5WtAD8dYAW9hhTjuvvTVaEiQBdrz9XPrgLBeRFiyCbQr</tt> (<tt>m/0'/0'/0'</tt>)\n* <tt>cR6SXDoyfQrcp4piaiHE97Rsgta9mNhGTen9XeonVgwsh4iSgw6d</tt> (<tt>m/0'/0'/2'</tt>)\nmust create this PSBT:\n\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000002202029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e887220203089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f010103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgf0cwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMAQEDBAEAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHIgIDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtxHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwEBAwQBAAAAAQQiACCMI1MXN0O1ld+0oHtyuo5C43l9p06H/n2ddJfjsgKJAwEFR1IhAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcIQI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc1KuIgYCOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnMQ2QxqTwAAAIAAAACAAwAAgCIGAwidwQx6xttU+RMpr2FzM9s4jOrQwjH3IzedG5kDCwLcENkMak8AAACAAAAAgAIAAIAAIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==</pre>\n\nGiven the above updated PSBT, a signer with the following keys:\n* <tt>cT7J9YpCwY3AVRFSjN6ukeEeWY6mhpbJPxRaDaP5QTdygQRxP9Au</tt> (<tt>m/0'/0'/1'</tt>)\n* <tt>cNBc3SWUip9PPm1GjRoLEJT6T41iNzCYtD7qro84FMnM5zEqeJsE</tt> (<tt>m/0'/0'/3'</tt>)\nmust create this PSBT:\n\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000220202dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d7483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8872202023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e73473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d2010103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU210gwRQIhAPYQOLMI3B2oZaNIUnRvAVdyk0IIxtJEVDk82ZvfIhd3AiAFbmdaZ1ptCgK4WxTl4pB02KJam1dgvqKBb2YZEKAG6gEBAwQBAAAAAQRHUiEClYO/Oa4KYJdHrRma3dY0+mEIVZ1sXNObTCGD8auW4H8hAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXUq4iBgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfxDZDGpPAAAAgAAAAIAAAACAIgYC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtcQ2QxqTwAAAIAAAACAAQAAgAABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohyICAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zRzBEAiBl9FulmYtZon/+GnvtAWrx8fkNVLOqj3RQql9WolEDvQIgf3JHA60e25ZoCyhLVtT/y4j3+3Weq74IqjDym4UTg9IBAQMEAQAAAAEEIgAgjCNTFzdDtZXftKB7crqOQuN5fadOh/59nXSX47ICiQMBBUdSIQMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3CECOt2QTz1tz1nduQaw3uI1Kbf/ue1Q5ehhUZJoYCIfDnNSriIGAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zENkMak8AAACAAAAAgAMAAIAiBgMIncEMesbbVPkTKa9hczPbOIzq0MIx9yM3nRuZAwsC3BDZDGpPAAAAgAAAAIACAACAACICA6mkw39ZltOqJdusa1cK8GUDlEkpQkYLNUdT7Z7spYdxENkMak8AAACAAAAAgAQAAIAAIgICf2OZdX0u/1WhNq0CxoSxg4tlVuXxtrNCgqlLa1AFEJYQ2QxqTwAAAIAAAACABQAAgAA=</pre>\n\nGiven both of the above PSBTs, a combiner must create this PSBT:\n\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000002202029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01220202dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d7483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01010304010000000104475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae2206029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f10d90c6a4f000000800000008000000080220602dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d710d90c6a4f0000008000000080010000800001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e887220203089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f012202023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e73473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d2010103040100000001042200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903010547522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae2206023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7310d90c6a4f000000800000008003000080220603089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc10d90c6a4f00000080000000800200008000220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAAiAgKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgf0cwRAIgdAGK1BgAl7hzMjwAFXILNoTMgSOJEEjn282bVa1nnJkCIHPTabdA4+tT3O+jOCPIBwUUylWn3ZVE8VfBZ5EyYRGMASICAtq2H/SaFNtqfQKwzR+7ePxLGDErW05U2uTbovv+9TbXSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAQEDBAEAAAABBEdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSriIGApWDvzmuCmCXR60Zmt3WNPphCFWdbFzTm0whg/GrluB/ENkMak8AAACAAAAAgAAAAIAiBgLath/0mhTban0CsM0fu3j8SxgxK1tOVNrk26L7/vU21xDZDGpPAAAAgAAAAIABAACAAAEBIADC6wsAAAAAF6kUt/X69A49QKWkWbHbNTXyty+pIeiHIgIDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtxHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwEiAgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8Oc0cwRAIgZfRbpZmLWaJ//hp77QFq8fH5DVSzqo90UKpfVqJRA70CIH9yRwOtHtuWaAsoS1bU/8uI9/t1nqu+CKow8puFE4PSAQEDBAEAAAABBCIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQVHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4iBgI63ZBPPW3PWd25BrDe4jUpt/+57VDl6GFRkmhgIh8OcxDZDGpPAAAAgAAAAIADAACAIgYDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwQ2QxqTwAAAIAAAACAAgAAgAAiAgOppMN/WZbTqiXbrGtXCvBlA5RJKUJGCzVHU+2e7KWHcRDZDGpPAAAAgAAAAIAEAACAACICAn9jmXV9Lv9VoTatAsaEsYOLZVbl8bazQoKpS2tQBRCWENkMak8AAACAAAAAgAUAAIAA</pre>\n\nGiven the above PSBT, an input finalizer must create this PSBT:\n\n* Bytes in Hex: <pre>70736274ff01009a020000000258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd750000000000ffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d0100000000ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f00000000000100bb0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f6187650000000107da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752ae0001012000c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e8870107232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b20289030108da0400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00220203a9a4c37f5996d3aa25dbac6b570af0650394492942460b354753ed9eeca5877110d90c6a4f000000800000008004000080002202027f6399757d2eff55a136ad02c684b1838b6556e5f1b6b34282a94b6b5005109610d90c6a4f00000080000000800500008000</pre>\n* Base64 String: <pre>cHNidP8BAJoCAAAAAljoeiG1ba8MI76OcHBFbDNvfLqlyHV5JPVFiHuyq911AAAAAAD/////g40EJ9DsZQpoqka7CwmK6kQiwHGyyng1Kgd5WdB86h0BAAAAAP////8CcKrwCAAAAAAWABTYXCtx0AYLCcmIauuBXlCZHdoSTQDh9QUAAAAAFgAUAK6pouXw+HaliN9VRuh0LR2HAI8AAAAAAAEAuwIAAAABqtc5MQGL0l+ErkALaISL4J23BurCrBgpi6vucatlb4sAAAAASEcwRAIgWPb8fGoz4bMVSNSByCbAFb0wE1qtQs1neQ2rZtKtJDsCIEoc7SYExnNbY5PltBaR3XiwDwxZQvufdRhW+qk4FX26Af7///8CgPD6AgAAAAAXqRQPuUY0IWlrgsgzryQceMF9295JNIfQ8gonAQAAABepFCnKdPigj4GZlCgYXJe12FLkBj9hh2UAAAABB9oARzBEAiB0AYrUGACXuHMyPAAVcgs2hMyBI4kQSOfbzZtVrWecmQIgc9Npt0Dj61Pc76M4I8gHBRTKVafdlUTxV8FnkTJhEYwBSDBFAiEA9hA4swjcHahlo0hSdG8BV3KTQgjG0kRUOTzZm98iF3cCIAVuZ1pnWm0KArhbFOXikHTYolqbV2C+ooFvZhkQoAbqAUdSIQKVg785rgpgl0etGZrd1jT6YQhVnWxc05tMIYPxq5bgfyEC2rYf9JoU22p9ArDNH7t4/EsYMStbTlTa5Nui+/71NtdSrgABASAAwusLAAAAABepFLf1+vQOPUClpFmx2zU18rcvqSHohwEHIyIAIIwjUxc3Q7WV37Sge3K6jkLjeX2nTof+fZ10l+OyAokDAQjaBABHMEQCIGLrelVhB6fHP0WsSrWh3d9vcHX7EnWWmn84Pv/3hLyyAiAMBdu3Rw2/LwhVfdNWxzJcHtMJE+mWzThAlF2xIijaXwFHMEQCIGX0W6WZi1mif/4ae+0BavHx+Q1Us6qPdFCqX1aiUQO9AiB/ckcDrR7blmgLKEtW1P/LiPf7dZ6rvgiqMPKbhROD0gFHUiEDCJ3BDHrG21T5EymvYXMz2ziM6tDCMfcjN50bmQMLAtwhAjrdkE89bc9Z3bkGsN7iNSm3/7ntUOXoYVGSaGAiHw5zUq4AIgIDqaTDf1mW06ol26xrVwrwZQOUSSlCRgs1R1Ptnuylh3EQ2QxqTwAAAIAAAACABAAAgAAiAgJ/Y5l1fS7/VaE2rQLGhLGDi2VW5fG2s0KCqUtrUAUQlhDZDGpPAAAAgAAAAIAFAACAAA==</pre>\n\nGiven the above PSBT, a transaction extractor must create this Bitcoin transaction:\n\n* Bytes in Hex: <pre>0200000000010258e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7500000000da00473044022074018ad4180097b873323c0015720b3684cc8123891048e7dbcd9b55ad679c99022073d369b740e3eb53dcefa33823c8070514ca55a7dd9544f157c167913261118c01483045022100f61038b308dc1da865a34852746f015772934208c6d24454393cd99bdf2217770220056e675a675a6d0a02b85b14e5e29074d8a25a9b5760bea2816f661910a006ea01475221029583bf39ae0a609747ad199addd634fa6108559d6c5cd39b4c2183f1ab96e07f2102dab61ff49a14db6a7d02b0cd1fbb78fc4b18312b5b4e54dae4dba2fbfef536d752aeffffffff838d0427d0ec650a68aa46bb0b098aea4422c071b2ca78352a077959d07cea1d01000000232200208c2353173743b595dfb4a07b72ba8e42e3797da74e87fe7d9d7497e3b2028903ffffffff0270aaf00800000000160014d85c2b71d0060b09c9886aeb815e50991dda124d00e1f5050000000016001400aea9a2e5f0f876a588df5546e8742d1d87008f000400473044022062eb7a556107a7c73f45ac4ab5a1dddf6f7075fb1275969a7f383efff784bcb202200c05dbb7470dbf2f08557dd356c7325c1ed30913e996cd3840945db12228da5f01473044022065f45ba5998b59a27ffe1a7bed016af1f1f90d54b3aa8f7450aa5f56a25103bd02207f724703ad1edb96680b284b56d4ffcb88f7fb759eabbe08aa30f29b851383d20147522103089dc10c7ac6db54f91329af617333db388cead0c231f723379d1b99030b02dc21023add904f3d6dcf59ddb906b0dee23529b7ffb9ed50e5e86151926860221f0e7352ae00000000</pre>\n\nGiven these two PSBTs with unknown key-value pairs:\n* Bytes in Hex: <pre>70736274ff01003f0200000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff010000000000000000036a0100000000000af00102030405060708090f0102030405060708090a0b0c0d0e0f000af00102030405060708090f0102030405060708090a0b0c0d0e0f000af00102030405060708090f0102030405060708090a0b0c0d0e0f00</pre>\n** Base64 String: <pre>cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAK8AECAwQFBgcICQ8BAgMEBQYHCAkKCwwNDg8ACvABAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PAArwAQIDBAUGBwgJDwECAwQFBgcICQoLDA0ODwA=</pre>\n\n* Bytes in Hex: <pre>70736274ff01003f0200000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff010000000000000000036a0100000000000af00102030405060708100f0102030405060708090a0b0c0d0e0f000af00102030405060708100f0102030405060708090a0b0c0d0e0f000af00102030405060708100f0102030405060708090a0b0c0d0e0f00</pre>\n** Base64 String: <pre>cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAK8AECAwQFBgcIEA8BAgMEBQYHCAkKCwwNDg8ACvABAgMEBQYHCBAPAQIDBAUGBwgJCgsMDQ4PAArwAQIDBAUGBwgQDwECAwQFBgcICQoLDA0ODwA=</pre>\n\nA combiner which orders keys lexicographically must produce the following PSBT:\n\n* Bytes in Hex: <pre>70736274ff01003f0200000001ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff010000000000000000036a0100000000000af00102030405060708090f0102030405060708090a0b0c0d0e0f0af00102030405060708100f0102030405060708090a0b0c0d0e0f000af00102030405060708090f0102030405060708090a0b0c0d0e0f0af00102030405060708100f0102030405060708090a0b0c0d0e0f000af00102030405060708090f0102030405060708090a0b0c0d0e0f0af00102030405060708100f0102030405060708090a0b0c0d0e0f00</pre>\n* Base64 String: <pre>cHNidP8BAD8CAAAAAf//////////////////////////////////////////AAAAAAD/////AQAAAAAAAAAAA2oBAAAAAAAK8AECAwQFBgcICQ8BAgMEBQYHCAkKCwwNDg8K8AECAwQFBgcIEA8BAgMEBQYHCAkKCwwNDg8ACvABAgMEBQYHCAkPAQIDBAUGBwgJCgsMDQ4PCvABAgMEBQYHCBAPAQIDBAUGBwgJCgsMDQ4PAArwAQIDBAUGBwgJDwECAwQFBgcICQoLDA0ODwrwAQIDBAUGBwgQDwECAwQFBgcICQoLDA0ODwA=</pre>\n\n==Rationale==\n\n<references/>\n\n==Reference implementation==\n\nThe reference implementation of the PSBT format is available at https://github.com/achow101/bitcoin/tree/psbt.\n\n==Acknowledgements==\n\nSpecial thanks to Pieter Wuille for suggesting that such a transaction format should be made\nand for coming up with the name and abbreviation of PSBT.\n\nThanks to Pieter Wuille, Gregory Maxwell, Jonathan Underwood, Daniel Cousens and those who commented on the bitcoin-dev mailing list for additional comments\nand suggestions for improving this proposal.\n", "content_length": 138484}
{"bip_number": 173, "filename": "bip-0173.mediawiki", "content": "<pre>\n  BIP: 173\n  Layer: Applications\n  Title: Base32 address format for native v0-16 witness outputs\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Greg Maxwell <greg@xiph.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0173\n  Status: Final\n  Type: Informational\n  Created: 2017-03-20\n  License: BSD-2-Clause\n  Replaces: 142\n  Superseded-By: 350\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a checksummed base32 format, \"Bech32\", and a standard for native segregated witness output addresses using it.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nFor most of its history, Bitcoin has relied on base58 addresses with a\ntruncated double-SHA256 checksum. They were part of the original\nsoftware and their scope was extended in\n[https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki BIP13]\nfor Pay-to-script-hash\n([https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki P2SH]).\nHowever, both the character set and the checksum algorithm have limitations:\n* Base58 needs a lot of space in QR codes, as it cannot use the ''alphanumeric mode''.\n* The mixed case in base58 makes it inconvenient to reliably write down, type on mobile keyboards, or read out loud.\n* The double SHA256 checksum is slow and has no error-detection guarantees.\n* Most of the research on error-detecting codes only applies to character-set sizes that are a [https://en.wikipedia.org/wiki/Prime_power prime power], which 58 is not.\n* Base58 decoding is complicated and relatively slow.\n\nIncluded in the Segregated Witness proposal are a new class of outputs\n(witness programs, see\n[https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141]),\nand two instances of it (\"P2WPKH\" and \"P2WSH\", see\n[https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki BIP143]).\nTheir functionality is available indirectly to older clients by embedding in P2SH\noutputs, but for optimal efficiency and security it is best to use it\ndirectly. In this document we propose a new address format for native\nwitness outputs (current and future versions).\n\nThis replaces\n[https://github.com/bitcoin/bips/blob/master/bip-0142.mediawiki BIP142],\nand was previously discussed\n[https://bitcoincore.org/logs/2016-05-zurich-meeting-notes.html#base32 here] (summarized\n[https://bitcoincore.org/en/meetings/2016/05/20/#error-correcting-codes-for-future-address-types here]).\n\n===Examples===\n\nAll examples use public key\n<tt>0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</tt>.\nThe P2WSH examples use <tt>key OP_CHECKSIG</tt> as script.\n\n* Mainnet P2WPKH: <tt>bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4</tt>\n* Testnet P2WPKH: <tt>tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx</tt>\n* Mainnet P2WSH: <tt>bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3</tt>\n* Testnet P2WSH: <tt>tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7</tt>\n\n==Specification==\n\nWe first describe the general checksummed base32<ref>'''Why use base32 at all?''' The lack of mixed case makes it more\nefficient to read out loud or to put into QR codes. It does come with a 15% length\nincrease, but that does not matter when copy-pasting addresses.</ref> format called\n''Bech32'' and then define Segregated Witness addresses using it.\n\n===Bech32===\n\nA Bech32<ref>'''Why call it Bech32?''' \"Bech\" contains the characters BCH (the error\ndetection algorithm used) and sounds a bit like \"base\".</ref> string is at most 90 characters long and consists of:\n* The '''human-readable part''', which is intended to convey the type of data, or anything else that is relevant to the reader. This part MUST contain 1 to 83 US-ASCII characters, with each character having a value in the range [33-126]. HRP validity may be further restricted by specific applications.\n* The '''separator''', which is always \"1\". In case \"1\" is allowed inside the human-readable part, the last one in the string is the separator<ref>'''Why include a separator in addresses?''' That way the human-readable\npart is unambiguously separated from the data part, avoiding potential\ncollisions with other human-readable parts that share a prefix. It also\nallows us to avoid having character-set restrictions on the human-readable part. The\nseparator is ''1'' because using a non-alphanumeric character would\ncomplicate copy-pasting of addresses (with no double-click selection in\nseveral applications). Therefore an alphanumeric character outside the normal character set\nwas chosen.</ref>.\n* The '''data part''', which is at least 6 characters long and only consists of alphanumeric characters excluding \"1\", \"b\", \"i\", and \"o\"<ref>'''Why not use an existing character set like [http://www.faqs.org/rfcs/rfc3548.html RFC3548] or [https://philzimmermann.com/docs/human-oriented-base-32-encoding.txt z-base-32]'''?\nThe character set is chosen to minimize ambiguity according to\n[https://hissa.nist.gov/~black/GTLD/ this] visual similarity data, and\nthe ordering is chosen to minimize the number of pairs of similar\ncharacters (according to the same data) that differ in more than 1 bit.\nAs the checksum is chosen to maximize detection capabilities for low\nnumbers of bit errors, this choice improves its performance under some\nerror models.</ref>.\n\n\n{| class=\"wikitable\"\n|-\n!\n!0\n!1\n!2\n!3\n!4\n!5\n!6\n!7\n|-\n!+0\n|q||p||z||r||y||9||x||8\n|-\n!+8\n|g||f||2||t||v||d||w||0\n|-\n!+16\n|s||3||j||n||5||4||k||h\n|-\n!+24\n|c||e||6||m||u||a||7||l\n|}\n\n\n'''Checksum'''\n\nThe last six characters of the data part form a checksum and contain no\ninformation. Valid strings MUST pass the criteria for validity specified\nby the Python3 code snippet below. The function\n<tt>bech32_verify_checksum</tt> must return true when its arguments are:\n* <tt>hrp</tt>: the human-readable part as a string\n* <tt>data</tt>: the data part as a list of integers representing the characters after conversion using the table above\n\n<pre>\ndef bech32_polymod(values):\n  GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]\n  chk = 1\n  for v in values:\n    b = (chk >> 25)\n    chk = (chk & 0x1ffffff) << 5 ^ v\n    for i in range(5):\n      chk ^= GEN[i] if ((b >> i) & 1) else 0\n  return chk\n\ndef bech32_hrp_expand(s):\n  return [ord(x) >> 5 for x in s] + [0] + [ord(x) & 31 for x in s]\n\ndef bech32_verify_checksum(hrp, data):\n  return bech32_polymod(bech32_hrp_expand(hrp) + data) == 1\n</pre>\n\nThis implements a [https://en.wikipedia.org/wiki/BCH_code BCH code] that\nguarantees detection of '''any error affecting at most 4 characters'''\nand has less than a 1 in 10<sup>9</sup> chance of failing to detect more\nerrors. More details about the properties can be found in the\nChecksum Design appendix. The human-readable part is processed by first\nfeeding the higher bits of each character's US-ASCII value into the\nchecksum calculation followed by a zero and then the lower bits of each<ref>'''Why are the high bits of the human-readable part processed first?'''\nThis results in the actually checksummed data being ''[high hrp] 0 [low hrp] [data]''. This means that under the assumption that errors to the\nhuman readable part only change the low 5 bits (like changing an alphabetical character into another), errors are restricted to the ''[low hrp] [data]''\npart, which is at most 89 characters, and thus all error detection properties (see appendix) remain applicable.</ref>.\n\nTo construct a valid checksum given the human-readable part and (non-checksum) values of the data-part characters, the code below can be used:\n\n<pre>\ndef bech32_create_checksum(hrp, data):\n  values = bech32_hrp_expand(hrp) + data\n  polymod = bech32_polymod(values + [0,0,0,0,0,0]) ^ 1\n  return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]\n</pre>\n\n'''Error correction'''\n\nOne of the properties of these BCH codes is that they can be used for\nerror correction. An unfortunate side effect of error correction is that\nit erodes error detection: correction changes invalid inputs into valid\ninputs, but if more than a few errors were made then the valid input may\nnot be the correct input. Use of an incorrect but valid input can cause\nfunds to be lost irrecoverably. Because of this, implementations SHOULD\nNOT implement correction beyond potentially suggesting to the user where\nin the string an error might be found, without suggesting the correction\nto make.\n\n'''Uppercase/lowercase'''\n\nThe lowercase form is used when determining a character's value for checksum purposes.\n\nEncoders MUST always output an all lowercase Bech32 string.\nIf an uppercase version of the encoding result is desired, (e.g.- for presentation purposes, or QR code use),\nthen an uppercasing procedure can be performed external to the encoding process.\n\nDecoders MUST NOT accept strings where some characters are uppercase and some are lowercase (such strings are referred to as mixed case strings).\n\nFor presentation, lowercase is usually preferable, but inside QR codes uppercase SHOULD be used, as those permit the use of\n''[http://www.thonky.com/qr-code-tutorial/alphanumeric-mode-encoding alphanumeric mode]'', which is 45% more compact than the normal\n''[http://www.thonky.com/qr-code-tutorial/byte-mode-encoding byte mode]''.\n\n===Segwit address format===\n\nA segwit address<ref>'''Why not make an address format that is generic for all scriptPubKeys?'''\nThat would lead to confusion about addresses for\nexisting scriptPubKey types. Furthermore, if addresses that do not have a one-to-one mapping with scriptPubKeys (such as ECDH-based\naddresses) are ever introduced, having a fully generic old address type available would\npermit reinterpreting the resulting scriptPubKeys using the old address\nformat, with lost funds as a result if bitcoins are sent to them.</ref> is a Bech32 encoding of:\n\n* The human-readable part \"bc\"<ref>'''Why use 'bc' as human-readable part and not 'btc'?''' 'bc' is shorter.</ref> for mainnet, and \"tb\"<ref>'''Why use 'tb' as human-readable part for testnet?''' It was chosen to\nbe of the same length as the mainnet counterpart (to simplify\nimplementations' assumptions about lengths), but still be visually\ndistinct.</ref> for testnet.\n* The data-part values:\n** 1 character (representing 5 bits of data): the witness version\n** A conversion of the 2-to-40-byte witness program (as defined by [https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141]) to base32:\n*** Start with the bits of the witness program, most significant bit per byte first.\n*** Re-arrange those bits into groups of 5, and pad with zeroes at the end if needed.\n*** Translate those bits to characters using the table above.\n\n'''Decoding'''\n\nSoftware interpreting a segwit address:\n* MUST verify that the human-readable part is \"bc\" for mainnet and \"tb\" for testnet.\n* MUST verify that the first decoded data value (the witness version) is between 0 and 16, inclusive.\n* Convert the rest of the data to bytes:\n** Translate the values to 5 bits, most significant bit first.\n** Re-arrange those bits into groups of 8 bits. Any incomplete group at the end MUST be 4 bits or less, MUST be all zeroes, and is discarded.\n** There MUST be between 2 and 40 groups, which are interpreted as the bytes of the witness program.\n\nDecoders SHOULD enforce known-length restrictions on witness programs.\nFor example, BIP141 specifies ''If the version byte is 0, but the witness\nprogram is neither 20 nor 32 bytes, the script must fail.''\n\nAs a result of the previous rules, addresses are always between 14 and 74 characters long, and their length modulo 8 cannot be 0, 3, or 5.\nVersion 0 witness addresses are always 42 or 62 characters, but implementations MUST allow the use of any version.\n\nImplementations should take special care when converting the address to a\nscriptPubkey, where witness version ''n'' is stored as ''OP_n''. OP_0 is\nencoded as 0x00, but OP_1 through OP_16 are encoded as 0x51 though 0x60\n(81 to 96 in decimal). If a bech32 address is converted to an incorrect\nscriptPubKey the result will likely be either unspendable or insecure.\n\n===Compatibility===\n\nOnly new software will be able to use these addresses, and only for\nreceivers with segwit-enabled new software. In all other cases, P2SH or\nP2PKH addresses can be used.\n\n==Rationale==\n\n<references />\n\n==Reference implementations==\n\n* Reference encoder and decoder:\n** [https://github.com/sipa/bech32/tree/master/ref/c For C]\n** [https://github.com/sipa/bech32/tree/master/ref/c++ For C++]\n** [https://github.com/sipa/bech32/tree/master/ref/javascript For JavaScript]\n** [https://github.com/sipa/bech32/tree/master/ref/go For Go]\n** [https://github.com/sipa/bech32/tree/master/ref/python For Python]\n** [https://github.com/sipa/bech32/tree/master/ref/haskell For Haskell]\n** [https://github.com/sipa/bech32/tree/master/ref/ruby For Ruby]\n** [https://github.com/sipa/bech32/tree/master/ref/rust For Rust]\n\n* Fancy decoder that localizes errors:\n** [https://github.com/sipa/bech32/tree/master/ecc/javascript For JavaScript] ([http://bitcoin.sipa.be/bech32/demo/demo.html demo website])\n\n==Registered Human-readable Prefixes==\n\nSatoshiLabs maintains a full list of registered human-readable parts for other cryptocurrencies:\n\n[https://github.com/satoshilabs/slips/blob/master/slip-0173.md SLIP-0173 : Registered human-readable parts for BIP-0173]\n\n==Appendices==\n\n===Test vectors===\n\nThe following strings are valid Bech32:\n* <tt>A12UEL5L</tt>\n* <tt>a12uel5l</tt>\n* <tt>an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs</tt>\n* <tt>abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw</tt>\n* <tt>11qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqc8247j</tt>\n* <tt>split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w</tt>\n* <tt>?1ezyfcl</tt> WARNING: During conversion to US-ASCII some encoders may set unmappable characters to a valid US-ASCII character, such as '?'. For example:\n\n<pre>\n>>> bech32_encode('\\x80'.encode('ascii', 'replace').decode('ascii'), [])\n'?1ezyfcl'\n</pre>\n\nThe following string are not valid Bech32 (with reason for invalidity):\n* 0x20 + <tt>1nwldj5</tt>: HRP character out of range\n* 0x7F + <tt>1axkwrx</tt>: HRP character out of range\n* 0x80 + <tt>1eym55h</tt>: HRP character out of range\n* <tt>an84characterslonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1569pvx</tt>: overall max length exceeded\n* <tt>pzry9x0s0muk</tt>: No separator character\n* <tt>1pzry9x0s0muk</tt>: Empty HRP\n* <tt>x1b4n0q5v</tt>: Invalid data character\n* <tt>li1dgmt3</tt>: Too short checksum\n* <tt>de1lg7wt</tt> + 0xFF: Invalid character in checksum\n* <tt>A1G7SGD8</tt>: checksum calculated with uppercase form of HRP\n* <tt>10a06t8</tt>: empty HRP\n* <tt>1qzzfhee</tt>: empty HRP\n\nThe following list gives valid segwit addresses and the scriptPubKey that they\ntranslate to in hex.\n* <tt>BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4</tt>: <tt>0014751e76e8199196d454941c45d1b3a323f1433bd6</tt>\n* <tt>tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sl5k7</tt>: <tt>00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262</tt>\n* <tt>bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx</tt>: <tt>5128751e76e8199196d454941c45d1b3a323f1433bd6751e76e8199196d454941c45d1b3a323f1433bd6</tt>\n* <tt>BC1SW50QA3JX3S</tt>: <tt>6002751e</tt>\n* <tt>bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj</tt>: <tt>5210751e76e8199196d454941c45d1b3a323</tt>\n* <tt>tb1qqqqqp399et2xygdj5xreqhjjvcmzhxw4aywxecjdzew6hylgvsesrxh6hy</tt>: <tt>0020000000c4a5cad46221b2a187905e5266362b99d5e91c6ce24d165dab93e86433</tt>\n\nThe following list gives invalid segwit addresses and the reason for\ntheir invalidity.\n* <tt>tc1qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty</tt>: Invalid human-readable part\n* <tt>bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5</tt>: Invalid checksum\n* <tt>BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2</tt>: Invalid witness version\n* <tt>bc1rw5uspcuh</tt>: Invalid program length\n* <tt>bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90</tt>: Invalid program length\n* <tt>BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P</tt>: Invalid program length for witness version 0 (per BIP141)\n* <tt>tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3q0sL5k7</tt>: Mixed case\n* <tt>bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du</tt>: zero padding of more than 4 bits\n* <tt>tb1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv</tt>: Non-zero padding in 8-to-5 conversion\n* <tt>bc1gmk9yu</tt>: Empty data section\n\n===Checksum design===\n\n'''Design choices'''\n\nBCH codes can be constructed over any prime-power alphabet and can be chosen to have a good trade-off between\nsize and error-detection capabilities. While most work around BCH codes uses a binary alphabet, that is not a requirement.\nThis makes them more appropriate for our use case than [https://en.wikipedia.org/wiki/Cyclic_redundancy_check CRC codes]. Unlike\n[https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction Reed-Solomon codes],\nthey are not restricted in length to one less than the alphabet size. While they also support efficient error correction,\nthe implementation of just error detection is very simple.\n\nWe pick 6 checksum characters as a trade-off between length of the addresses and the error-detection capabilities, as 6\ncharacters is the lowest number sufficient for a random failure chance below 1 per billion. For the length of data\nwe're interested in protecting (up to 71 bytes for a potential future 40-byte witness\nprogram), BCH codes can be constructed that guarantee detecting up to 4 errors.\n\n'''Selected properties'''\n\nMany of these codes perform badly when dealing with more errors than they are designed to detect, but not all.\nFor that reason, we consider codes that are designed to detect only 3 errors as well as 4 errors,\nand analyse how well they perform in practice.\n\nThe specific code chosen here is the result\nof:\n* Starting with an exhaustive list of 159605 BCH codes designed to detect 3 or 4 errors up to length 93, 151, 165, 341, 1023, and 1057.\n* From those, requiring the detection of 4 errors up to length 71, resulting in 28825 remaining codes.\n* From those, choosing the codes with the best worst-case window for 5-character errors, resulting in 310 remaining codes.\n* From those, picking the code with the lowest chance for not detecting small numbers of ''bit'' errors.\n\nAs a naive search would require over 6.5 * 10<sup>19</sup> checksum evaluations, a collision-search approach was used for\nanalysis. The code can be found [https://github.com/sipa/ezbase32/ here].\n\n'''Properties'''\n\nThe following table summarizes the chances for detection failure (as\nmultiples of 1 in 10<sup>9</sup>).\n\n{| class=\"wikitable\"\n|-\n!colspan=\"2\" | Window length\n!colspan=\"6\" | Number of wrong characters\n|-\n!Length\n!Description\n!\u22644\n!5\n!6\n!7\n!8\n!\u22659\n|-\n| 8 || Longest detecting 6 errors || colspan=\"3\" | 0 || 1.127 || 0.909 || n/a\n|-\n| 18 || Longest detecting 5 errors || colspan=\"2\" | 0 || 0.965 || 0.929 || 0.932 || 0.931\n|-\n| 19 || Worst case for 6 errors || 0 || 0.093 || 0.972 || 0.928 || colspan=\"2\" | 0.931\n|-\n| 39 ||  Length for a P2WPKH address || 0 || 0.756 || 0.935 || 0.932 || colspan=\"2\" | 0.931\n|-\n| 59 || Length for a P2WSH address || 0 || 0.805 || 0.933 || colspan=\"3\" | 0.931\n|-\n| 71 || Length for a 40-byte program address || 0 || 0.830 || 0.934 || colspan=\"3\" | 0.931\n|-\n| 89 || Longest detecting 4 errors || 0 || 0.867 || 0.933 || colspan=\"3\" | 0.931\n|}\nThis means that when 5 changed characters occur randomly distributed in\nthe 39 characters of a P2WPKH address, there is a chance of\n''0.756 per billion'' that it will go undetected. When those 5 changes\noccur randomly within a 19-character window, that chance goes down to\n''0.093 per billion''. As the number of errors goes up, the chance\nconverges towards ''1 in 2<sup>30</sup>'' = ''0.931 per billion''.\n\nEven though the chosen code performs reasonably well up to 1023 characters,\nother designs are preferable for lengths above 89 characters (excluding the\nseparator).\n\n==Acknowledgements==\n\nThis document is inspired by the [https://rusty.ozlabs.org/?p=578 address proposal] by Rusty Russell, the\n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-February/004402.html base32] proposal by Mark Friedenbach, and had input from Luke Dashjr,\nJohnson Lau, Eric Lombrozo, Peter Todd, and various other reviewers.\n\n==Disclosures (added 2024)==\n\nDue to an oversight in the design of bech32, this checksum scheme is not always\nrobust against\n[[https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb|the insertion\nand deletion of fewer than 5 consecutive characters]]. Due to this weakness,\n[[bip-0350.mediawiki|BIP-350]] proposes using the scheme described in this BIP\nonly for Native Segwit v0 outputs.\n", "content_length": 20786}
{"bip_number": 172, "filename": "bip-0172.mediawiki", "content": "<pre>\n  BIP: 172\n  Layer: Applications\n  Title: Define Bitcoin Subunits as Satoshis\n  Author: OceanSlim <oceanslim@gmx.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0172\n  Status: Draft\n  Type: Informational\n  Created: 2025-05-01\n  License: BSD-2-Clause\n</pre>\n\n== Abstract ==\n\nThis BIP proposes to formally define and standardize Bitcoin's smallest indivisible unit (1/100,000,000 of a bitcoin) as \"satoshi\" (singular) or \"satoshis\" (plural), with \"sats\" as the standard abbreviated form. This standardization aims to improve clarity in communication, user interfaces, documentation, and development across the Bitcoin ecosystem.\n\n== Motivation ==\n\nAs Bitcoin adoption grows, the need for a clear, standardized terminology for its subunits becomes increasingly important. Currently, there are various terms used to refer to Bitcoin's smallest unit (1/100,000,000 BTC), including \"satoshi\", \"satoshis\", \"sat\", \"sats\" and sometimes simply expressed as decimal values of bitcoin (0.00000001 BTC).\n\nThis lack of standardization can lead to:\n\n# Confusion for newcomers to the Bitcoin ecosystem\n# Inconsistent user experiences across different applications and services\n# Ambiguity in technical documentation and discussions\n# Potential errors in development and implementation of Bitcoin-related software\n\nBy formally establishing \"satoshi\"/\"satoshis\" as the standard term with \"sats\" as the recognized abbreviation, we can improve clarity and consistency throughout the ecosystem.\n\n== Specification ==\n\nThis BIP formally defines:\n\n# The term \"satoshi\" (singular) or \"satoshis\" (plural) shall be the standard term for 1/100,000,000 of a bitcoin (0.00000001 BTC).\n# The abbreviation \"sat\" (singular) or \"sats\" (plural) shall be the standard short form for \"satoshi\"/\"satoshis\".\n# The relationship between units shall be expressed as:\n#* 1 bitcoin (BTC) = 100,000,000 satoshis\n#* 1 satoshi = 0.00000001 bitcoin\n# The terms \"satoshi\" and \"sats\" are not proper nouns when referring to the unit of currency and should not be capitalized except at the beginning of sentences or in titles.\n# Bitcoin-related applications, services, documentation, and communications are encouraged to use these standardized terms to promote consistency across the ecosystem.\n\n== Accessibility Considerations ==\n\nTo ensure clarity and inclusiveness in user interfaces and assistive technologies, the following recommendations apply:\n\n# Pronunciation:\n#* The abbreviation \"sat\" should be pronounced as /s\u00e6t/, and \"sats\" (plural) should be pronounced as /s\u00e6ts/ (rhyming with \"cats\") by screen readers and voice assistants. \n#* \"Satoshi\" (singular) is pronounced /s\u0259\u02c8to\u028a\u0283i/. \"Satoshis\" (plural) is pronounced /s\u0259\u02c8to\u028a\u0283iz/.\n\n# Singular vs. Plural: Preserve correct pluralization when reading amounts:\n#* \"1 sat\" should be read as \"one satoshi\" (/w\u028cn s\u0259\u02c8to\u028a\u0283i/)\n#* \"100 sats\" should be read as \"one hundred satoshis\" (/w\u028cn \u02c8h\u028cndr\u0259d s\u0259\u02c8to\u028a\u0283iz/)\n\n# Readable Formats:\n#* Prefer full terms in accessibility modes (e.g., \"satoshis\" instead of \"sats\")\n#* Group digits to assist parsing (e.g., \"12,345\" instead of \"12345\")\n\n# Contextual Labels:\n#* Interfaces should use clear alt-text or aria-labels such as: alt=\"Transaction fee: 14 satoshis per virtual byte\"\n#* This enables screen readers and other assistive technologies to accurately interpret and communicate the content\n\n== Rationale ==\n\nSatoshi Nakamoto, the creator of Bitcoin, established that one bitcoin would be divisible to eight decimal places, creating 100,000,000 units per bitcoin. The community has organically adopted the term \"satoshi\" to refer to this smallest unit.\n\nAs Bitcoin's value has increased, expressing smaller values in fractional bitcoins has become increasingly unwieldy (e.g., 0.00000546 BTC). Using satoshis as the unit of account for smaller values (e.g., 546 sats) is more intuitive and less error-prone for humans.\n\nThe term \"satoshi\" and its abbreviation \"sats\" have already gained widespread adoption within the Bitcoin community. This BIP seeks to formalize this existing convention rather than introduce new terminology.\n\n=== Analogous to Traditional Currency Systems ===\n\nThe proposed bitcoin/satoshi (or BTC/sat) standard follows the established pattern of major world currencies, which typically have a primary unit and a smaller subunit. Most notably, the United States dollar\u2014the world's primary reserve currency\u2014uses dollars and cents in a two-tier denomination system. This familiar dollars/cents model has proven effective and intuitive for everyday transactions across different scales.\nThe bitcoin/satoshi system mirrors this approach while accounting for Bitcoin's higher divisibility requirements. Furthermore, the phonetic similarity between \"sat\" and \"cent\" creates an intuitive bridge for newcomers to understand Bitcoin's smallest unit, making the learning curve less steep for those familiar with traditional currency systems. This natural familiarity leverages existing mental models of how currency denominations work.\n\n=== Comparison with Alternative Approaches ===\n\nTwo notable proposals related to Bitcoin denomination have been put forward:\n\nOur proposal represents a minimally disruptive approach to standardization, formalizing existing common practice rather than introducing new terms (BIP-176) or redefining existing ones (BIP-177).\n\n==== BIP-176: Bits Denomination ====\n\nBIP-176 proposes using \"bits\" as a standard term for 100 satoshis (or 0.000001 BTC). While this proposal has merit for creating a middle-ground denomination that avoids small decimal places when bitcoin's value is high, our approach differs in that it:\n\n* Formalizes existing widely adopted terminology rather than introducing or prioritizing a different unit\n* Focuses on the fundamental base unit that cannot be subdivided further within the Bitcoin protocol\n* Maintains the simplicity of a two-tier system (bitcoin and satoshi) rather than adding a third tier\n\n==== BIP-177: Redefine Bitcoin's Base Unit ====\n\nBIP-177 takes a more radical approach by proposing to redefine the term \"bitcoin\" to refer to what is currently called a \"satoshi\" (1/100,000,000 of the current bitcoin). While this proposal aims to eliminate decimal points and simplify mental calculations, our approach differs in that it:\n\n* Preserves the established meaning of \"bitcoin\" which has global recognition and avoids potentially confusing redefinition\n* Maintains compatibility with existing systems, documentation, and user understanding\n* Achieves similar clarity benefits through standardization without requiring a fundamental redefinition of terms\n\n== Backwards Compatibility ==\n\nThis proposal does not affect the technical operation of Bitcoin or its protocol. It is purely a standardization of terminology for human communication and user interfaces.\n\nExisting applications that use other terms or conventions can continue to operate but are encouraged to adopt the standardized terms to improve overall ecosystem clarity.\n\n== Copyright ==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n== Reference Implementation ==\n\nNot applicable as this is an Informational BIP that standardizes terminology rather than implementing technical changes.\n\n== Examples ==\n\nBefore standardization, various formats might be used:\n* 0.00000100 BTC\n* 100 satoshi\n* 100 satoshis\n* 100 sat\n* 100 sats\n\nAfter standardization, the preferred formats would be:\n* 100 satoshis (formal)\n* 100 sats (abbreviated)\n\n== Acknowledgements ==\n\nThanks to the entire Bitcoin community who has organically adopted the terms \"satoshi\" and \"sats\" over the years. If anyone can point to early references of the term being used in this way please leave a comment so we can amend this BIP to acknowledge it. \n\n== References ==\n\n# Satoshi Nakamoto. \"Bitcoin: A Peer-to-Peer Electronic Cash System\" (2008)\n# BIP-176: Bits Denomination (Jimmy Song)\n\n== Glossary ==\n\n* BTC: The current universal ticker symbol for bitcoin, the cryptocurrency. \n* Satoshi: The smallest unit of bitcoin, equal to 0.00000001 BTC.\n* Sats: Abbreviation for \"satoshis\".", "content_length": 8105}
{"bip_number": 171, "filename": "bip-0171.mediawiki", "content": "<pre>\n  BIP: 171\n  Layer: Applications\n  Title: Currency/exchange rate information API\n  Author: Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0171\n  Status: Rejected\n  Type: Standards Track\n  Created: 2017-03-04\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nA common interface for requesting currency exchange rate information from a server.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Specification==\n\nFour requests are defined, which are all made by a GET request to a common URI with parameters encoded in application/x-www-form-urlencoded format.\nAll matching parameters may be specified with multiple comma-separated values, which are to be interpreted as \"any of these\".\nEach result is always in JSON format, with a line-feed (never a carriage-return) separating multiple results.\n\nAuthentication for subscription-based services MAY be supported using standard HTTP authentication.\nIt is recommended to use TLS (HTTPS) and/or Linked Data Signatures, so that MITM attackers cannot deceive the client.\n\nTo be BIP 171 compatible, servers MUST support at least one currency-pair compared to XBT.\nAll inquiries for bitcoin amounts MUST be specified in XBT, even if the presentation to the end user is in another unit.\n(FIXME: or should this be satoshis?)\n\nCurrency-pair tokens are arbitrary Strings no longer than 255 characters, which may include any ASCII [https://tools.ietf.org/html/rfc3986#section-2.3 RFC 3986 unreserved characters] (ie, alphanumerics and the hyphen, underscore, period, and tilde symbols).\n\nCurrency code(s) used herein are defined as such:\n\n* All ISO 4217 codes are valid currency codes.\n* XBT is defined as 100000000 satoshis (commonly known as 1 BTC).\n* Strings longer than 3 characters may be used for currencies without an applicable code. (If a shorter code is desired despite this, it may be padded with space(s) to the left until it is 4 characters. Software MAY strip these spaces.)\n\nRate is defined as the amount of quote-currency to be exchanged for one unit of the base-currency.\nIn other words, <code>1 baseCurrency = rate quoteCurrency</code>.\n\n===Enumerating supported currency-pair tokens===\n\nParameters:\n\n* ''mode'' - Always \"list\" for this request.\n* ''quote'' - If provided, the server MAY limit the results to only currency-pairs describing a currency with the given currency code(s).\n* ''base'' - If provided, the server MAY limit the results to only currency-pairs describing currency rates compared to the given currency code(s).\n* ''locale'' - If provided, the server MAY limit the results to only currency-pairs supporting the given Unicode CLDR locale(s).\n\nEach currency-pair will receive a separate result, a JSON Object, with the following information:\n\n* ''cp'' - The currency-pair token.\n* ''quote'' - The currency code for the quote currency.\n* ''base'' - The currency code for the base currency.\n* ''locale'' - If provided, a String with the applicable Unicode CLDR locale.\n* ''desc'' - Optional description. For example, it could be \"Based on Florida BTM prices.\" or any other short String that provides information useful to the user. SHOULD be shorter than 45 characters.\n* ''signature'' - Optional. May be used for Linked Data Signatures.\n\nExample:\n\n    Request: http://api.example.tld/?mode=list&quote=USD&base=XBT&locale=en_US,en_GB\n    Result:\n      {\"cp\":\"XBTUSD-ver4\", \"quote\":\"USD\", \"base\": \"XBT\", \"locale\": \"en_US\", \"desc\": \"Smoothed averages\"}\n      {\"cp\":\"2\", \"quote\":\"USD\", \"base\": \"XBT\", \"locale\": \"en_US\", \"desc\": \"Updated per-trade\"}\n      {\"cp\":\"XBTUSD-european\", \"quote\":\"USD\", \"base\": \"XBT\", \"locale\": \"en_GB\"}\n\n===Currency-pair information===\n\nParameters:\n\n* ''mode'' - Always \"info\" for this request.\n* ''cp'' - Currency pair(s) for which information is requested.\n\nEach currency-pair will receive a separate result, a JSON Object, with the following information:\n\n* ''cp'' - The currency-pair token.\n* ''quote'' - The currency code for the quote currency.\n* ''base'' - The currency code for the base currency.\n* ''locale'' - If provided, a String with the applicable Unicode CLDR locale.\n* ''desc'' - Optional description. For example, it could be \"Based on Florida BTM prices.\" or any other short String that provides information useful to the user. SHOULD be shorter than 45 characters.\n* ''longdesc'' - Optional description, but may be longer and include newlines.\n* ''symbol'' - An Array of prefix and suffix for the quote currency. Each may be either a fixed String, an Array of two Strings (negative and positive), or null. Any positive or negative symbols must be included in this prefix/suffix; it MUST NOT be implied otherwise.\n* ''digits'' - The type of digits to use for the quote currency's numbers. \"arabic\" should be used for common 0-9 digits.\n* ''grouping'' - An Array alternating between Numbers representing a series of digits, and Strings used as delimiters. If terminated by a zero, the final grouping is to be repeated continually. For example, the common US locale thousands grouping would be <code>[3, \",\", 0]</code>\n* ''fraction_sep'' - A String to be placed between whole numbers and a fractional amount.\n* ''fraction_digits'' - Array of absolute minimum (even for whole numbers) number of fractional digits, minimum fractional digits when a fraction exists, and maximum number of fractional digits when absolute precision is not demanded (below which is to be rounded in an implementation-dependent manner).\n* ''minpoll'' - A Number of seconds indicating a minimum time between polls to the server. Clients should be prudent about not polling too often, even if this number is low.\n* ''longpoll'' - If provided and true, indicates longpolling is supported by the server.\n* ''history'' - If provided, indicates the server has historical records going back no earlier than the POSIX timestamp provided as a value.\n* ''archive'' - If provided, indicates the server no longer has current rates, and has no historical rates more recent than the POSIX timestamp provided as a value.\n* ''signature'' - Optional. May be used for Linked Data Signatures.\n\nExample:\n\n    Request: http://api.example.tld/?mode=info&cp=XBTUSD-ver4,2\n    Result:\n      {\"cp\":\"XBTUSD-ver4\", \"quote\":\"USD\", \"base\": \"XBT\", \"locale\": \"en_US\", \"desc\": \"Smoothed averages\", \"longdesc\": \"USD price quotes as compared to Bitcoin value\\n\\nRecommended for casual usage\", \"symbol\": [[\"-$\", \"$\"], null], \"digits\": \"arabic\", \"grouping\": [3, \",\", 0], \"fraction_sep\": \".\", \"fraction_digits\": [0, 2, 2], \"minpoll\": 300, \"longpoll\": true, \"history\": 1457231416}\n      {\"cp\":\"2\", \"quote\":\"USD\", \"base\": \"XBT\", \"locale\": \"en_US\", \"desc\": \"Updated per-trade\", \"longdesc\": \"Maximum precision USD price quotes as compared to Bitcoin value\", \"symbol\": [[\"-$\", \"$\"], null], \"digits\": \"arabic\", \"grouping\": [3, \",\", 0], \"fraction_sep\": \".\", \"fraction_digits\": [0, 2, 2], \"minpoll\": 3600, \"longpoll\": false, \"history\": 1467458333.1225}\n\n===Current exchange rate===\n\nParameters:\n\n* ''mode'' - Always \"rate\" for this request.\n* ''cp'' - Currency pair(s) for which rate is requested.\n* ''type'' - Type of exchange rate data being requested. May be \"high\", \"low\", \"average\", \"typical\", or any other arbitrary name. If omitted, the server may provide any rates it deems appropriate.\n* ''minrate'', ''maxrate'' - If specified, indicates this request is a longpoll. The server should not send a response until the rate(s) fall below or above (respectively) the provided value.\n* ''nonce'' - If specified, the server SHOULD return it in each result.\n\nEach currency-pair receives a separate result (a JSON Object) with all requested rate types:\n\n* ''cp'' - The currency-pair token.\n* ''time'' - The time (as a POSIX timestamp) the rate information is applicable to (should be approximately the request time).\n* ''rates'' - A JSON Object with each rate type provided as a key, and a Number as the value specifying the rate.\n* ''nonce'' - Only if the request specified a nonce, the server SHOULD include it here as a JSON String.\n* ''signature'' - Optional. May be used for Linked Data Signatures.\n\nExample:\n\n    Request: http://api.example.tld/?mode=rate&cp=XBTUSD-ver4,2&type=typical,high\n    Result:\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488767410.5463133, \"rates\": {\"typical\": 1349.332215, \"high\": 1351.2}}\n      {\"cp\":\"2\", \"time\": 1488767410, \"rates\": {\"typical\": 1350.111332}}\n\n===Historical exchange rates===\n\nParameters:\n\n* ''mode'' - Always \"history\" for this request.\n* ''cp'' - Currency pair(s) for which rate is requested.\n* ''type'' - Type of exchange rate data being requested. May be \"high\", \"low\", \"average\", \"typical\", or any other arbitrary name. If omitted, the server may provide any rates it deems appropriate.\n* ''from'' - POSIX timestamp the results should begin with.\n* ''to'' - POSIX timestamp the results should end with. If omitted, the present time shall be used.\n* ''nearest'' - If provided and true, indicates that only the nearest timestamp to \"from\" must be returned, and a range is not desired. (\"to\" should be omitted in this case.)\n* ''ratedelta'', ''timedelta'' - If specified, the server may omit data where the rate or time has not changed since the last provided rate and time. If both are provided, either a significant rate change OR time change should trigger a new record in the results.\n\nA result is provided for each currency-pair and timestamp record, in the same format as the current exchange rate request.\nRecords MUST be provided in chronological order, but only within the scope of the applicable currency-pair (ie, it is okay to send the full history for one currency-pair, and then the full history for the next; or to intermix them out of any given order).\n\nIf there is no exact record for the times specified by \"from\" and/or \"to\", a single record before \"from\" and/or after \"to\" should also be included.\nThis is not necessary when only the nearest record is requested, or when \"to\" is omitted (ie, ending at the most recent record).\n\nExample:\n\n    Request: http://api.example.tld/?mode=history&cp=XBTUSD-ver4,2&type=typical&ratedelta=0.1&timedelta=10&from=1488759998&to=1488760090\n    Result:\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760000, \"rates\": {\"typical\": 1300}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760010, \"rates\": {\"typical\": 1301.1}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760020, \"rates\": {\"typical\": 1320}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760030, \"rates\": {\"typical\": 1305}}\n      {\"cp\":\"2\", \"time\": 1488760000.1, \"rates\": {\"typical\": 1300}}\n      {\"cp\":\"2\", \"time\": 1488760010.2, \"rates\": {\"typical\": 1301.1}}\n      {\"cp\":\"2\", \"time\": 1488760020.2, \"rates\": {\"typical\": 1320.111332}}\n      {\"cp\":\"2\", \"time\": 1488760031, \"rates\": {\"typical\": 1305.222311}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760040, \"rates\": {\"typical\": 1303.33}}\n      {\"cp\":\"2\", \"time\": 1488760042, \"rates\": {\"typical\": 1303.33}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760050, \"rates\": {\"typical\": 1305}}\n      {\"cp\":\"2\", \"time\": 1488760052, \"rates\": {\"typical\": 1307}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760060, \"rates\": {\"typical\": 1309}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760072, \"rates\": {\"typical\": 1308}}\n      {\"cp\":\"2\", \"time\": 1488760062, \"rates\": {\"typical\": 1309.55555555}}\n      {\"cp\":\"2\", \"time\": 1488760072, \"rates\": {\"typical\": 1308}}\n      {\"cp\":\"XBTUSD-ver4\", \"time\": 1488760082, \"rates\": {\"typical\": 1309}}\n      {\"cp\":\"2\", \"time\": 1488760082, \"rates\": {\"typical\": 1309.1}}\n\n==Motivation==\n\nEnd users often desire to see fiat currency information in their Bitcoin wallet software.\nDue to the nature of Bitcoin, there is inherently no authoritative source for exchange rates.\nThere are many independent providers of such information, but they all use different formats for providing it, so wallet software is currently forced to implement dedicated code for each provider.\n\nBy providing a standard interface for retrieving this information, wallets (and other software) and service providers can implement it once, and become immediately interoperable with all other compatible implementations.\n\n==Rationale==\n\nWhy are multiple results separated by a line-feed rather than using a JSON Array?\n\n* Clients ought to cache historical data, and using a line-feed format allows them to simply append to a cache file.\n* Parsing JSON typically requires the entire data parsed together as a single memory object. Using simple lines to separate results, however, allows parsing a single result at a time.\n\nWhat if long descriptions require line and paragraph breaks?\n\n* Clients should word-wrap long lines, and JSON escapes newlines as \"\\n\" which can be used doubly (\"\\n\\n\") for paragraph breaks.\n\n==Backwards compatibility==\n\nWhile this new standard is adopted, software and providers can continue to use and provide their current formats until they are no longer needed.\n\n==Reference implementation==\n\nTODO\n\n==See also==\n\n* [https://w3c-dvcg.github.io/ld-signatures/ Draft W3c Linked Data Signatures specification]\n", "content_length": 13038}
{"bip_number": 159, "filename": "bip-0159.mediawiki", "content": "<pre>\n  BIP: 159\n  Layer: Peer Services\n  Title: NODE_NETWORK_LIMITED service bit\n  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0159\n  Status: Final\n  Type: Standards Track\n  Created: 2017-05-11\n  License: BSD-2-Clause\n</pre>\n\n== Abstract ==\n\nDefine a service bit that allows pruned peers to signal their limited services.\n\n==Motivation==\n\nPruned peers can offer the same services as traditional peers, except that of serving all historical blocks.\nBitcoin right now only offers the <code>NODE_NETWORK</code> service bit to indicate that a peer can serve\nall historical blocks.\n# Pruned peers can relay blocks, headers, transactions, and addresses, but they only guarantee serving a minimum number of historical blocks; thus, they should have a way to announce their service(s)\n# Peers no longer in initial block download should consider connecting some of their outbound connections to pruned peers, to allow other peers to bootstrap from non-pruned peers\n\n== Specification ==\n\n=== New service bit ===\n\nThis BIP proposes a new service bit\n\n{|class=\"wikitable\"\n|-\n| NODE_NETWORK_LIMITED || bit 10 (0x400) || If signaled, the peer <I>MUST</I> be capable of serving at least the last 288 blocks (~2 days).\n|}\n\nPruned/limited peers <I>MUST NOT</I> set a service bit that signals serving the complete block chain (e.g., <code>NODE_NETWORK</code>). Rationale: nodes that signal serving the complete block chain may also signal <code>NODE_NETWORK_LIMITED</code>.\n\nA safety buffer of 144 blocks to handle chain reorganizations <I>SHOULD</I> be taken into account when connecting to a peer signaling the <code>NODE_NETWORK_LIMITED</code> service bit.\n\n=== Address relay ===\n\nFull nodes following this BIP <I>SHOULD</I> relay address/services (<code>addr</code> message) from peers they would connect to (including peers signaling <code>NODE_NETWORK_LIMITED</code>).\n\n=== Counter-measures for peer fingerprinting ===\n\nPeers may have different prune depths (depending on their configuration, disk space, etc.), which can result in a fingerprinting weakness (finding the prune depth through getdata requests).\n\nPruned nodes should therefore avoid leaking the prune depth and <I>SHOULD NOT</I> serve blocks deeper than the signaled <code>NODE_NETWORK_LIMITED</code> threshold of 288 blocks.\n\n=== Risks ===\n\nPruned peers following this BIP may consume more outbound bandwidth.\n\nLight clients (and such) who are not checking the <code>nServiceFlags</code> (service bits) from a relayed <code>addr</code>-message may unwittingly connect to a pruned peer and ask for (filtered) blocks at a depth below the peer\u2019s pruned depth. Light clients should therefore check the service bits and either (1) connect to peers signaling <code>NODE_NETWORK_LIMITED</code> that preferably do not also signal serving the full block chain, if they only require (filtered) blocks around the tip, or (2) connect to peers signaling serving the full block chain if they need data older than the latest 288 blocks. Light clients obtaining peer IPs through DNS seeds should use the DNS filtering option.\n\n== Compatibility ==\n\nThis proposal is backward compatible.\n\n== Reference implementation ==\n\n* https://github.com/bitcoin/bitcoin/pull/11740 (signaling)\n* https://github.com/bitcoin/bitcoin/pull/10387 (connection and relay)\n\n== Copyright ==\n\nThis BIP is licensed under the 2-clause BSD license.\n", "content_length": 3464}
{"bip_number": 158, "filename": "bip-0158.mediawiki", "content": "<pre>\n  BIP: 158\n  Layer: Peer Services\n  Title: Compact Block Filters for Light Clients\n  Author: Olaoluwa Osuntokun <laolu32@gmail.com>\n          Alex Akselrod <alex@akselrod.org>\n  Comments-Summary: None yet\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0158\n  Status: Final\n  Type: Standards Track\n  Created: 2017-05-24\n  License: CC0-1.0\n  Requires: 157\n</pre>\n\n\n== Abstract ==\n\nThis BIP describes a structure for compact filters on block data, for use in the\nBIP 157 light client protocol<ref>bip-0157.mediawiki</ref>. The filter\nconstruction proposed is an alternative to Bloom filters, as used in BIP 37,\nthat minimizes filter size by using Golomb-Rice coding for compression. This\ndocument specifies one initial filter type based on this construction that\nenables basic wallets and applications with more advanced smart contracts.\n\n== Motivation ==\n\n[[bip-0157.mediawiki|BIP 157]] defines a light client protocol based on\ndeterministic filters of block content. The filters are designed to\nminimize the expected bandwidth consumed by light clients, downloading filters\nand full blocks. This document defines the initial filter type ''basic''\nthat is designed to reduce the filter size for regular wallets.\n\n== Definitions ==\n\n<code>[]byte</code> represents a vector of bytes.\n\n<code>[N]byte</code> represents a fixed-size byte array with length N.\n\n''CompactSize'' is a compact encoding of unsigned integers used in the Bitcoin\nP2P protocol.\n\n''Bit streams'' are readable and writable streams of individual bits. The\nfollowing functions are used in the pseudocode in this document:\n* <code>new_bit_stream</code> instantiates a new writable bit stream\n* <code>new_bit_stream(vector)</code> instantiates a new bit stream reading data from <code>vector</code>\n* <code>write_bit(stream, b)</code> appends the bit <code>b</code> to the end of the stream\n* <code>read_bit(stream)</code> reads the next available bit from the stream\n* <code>write_bits_big_endian(stream, n, k)</code> appends the <code>k</code> least significant bits of integer <code>n</code> to the end of the stream in big-endian bit order\n* <code>read_bits_big_endian(stream, k)</code> reads the next available <code>k</code> bits from the stream and interprets them as the least significant bits of a big-endian integer\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n\"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be\ninterpreted as described in RFC 2119.\n\n== Specification ==\n\n=== Golomb-Coded Sets ===\n\nFor each block, compact filters are derived containing sets of items associated\nwith the block (eg. addresses sent to, outpoints spent, etc.). A set of such\ndata objects is compressed into a probabilistic structure called a\n''Golomb-coded set'' (GCS), which matches all items in the set with probability\n1, and matches other items with probability <code>1/M</code> for some\ninteger parameter <code>M</code>. The encoding is also parameterized by\n<code>P</code>, the bit length of the remainder code. Each filter defined\nspecifies values for <code>P</code> and <code>M</code>.\n\nAt a high level, a GCS is constructed from a set of <code>N</code> items by:\n# hashing all items to 64-bit integers in the range <code>[0, N * M)</code>\n# sorting the hashed values in ascending order\n# computing the differences between each value and the previous one\n# writing the differences sequentially, compressed with Golomb-Rice coding\n\nThe following sections describe each step in greater detail.\n\n==== Hashing Data Objects ====\n\nThe first step in the filter construction is hashing the variable-sized raw\nitems in the set to the range <code>[0, F)</code>, where <code>F = N *\nM</code>. Customarily, <code>M</code> is set to <code>2^P</code>. However, if\none is able to select both Parameters independently, then more optimal values\ncan be\nselected<ref>https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845</ref>.\nSet membership queries against the hash outputs will have a false positive rate\nof <code>1 / M</code>. To avoid integer overflow, the number of items <code>N</code>\nMUST be <2^32 and <code>M</code> MUST be <2^32.\n\nThe items are first passed through the pseudorandom function ''SipHash'', which\ntakes a 128-bit key <code>k</code> and a variable-sized byte vector and produces\na uniformly random 64-bit output. Implementations of this BIP MUST use the\nSipHash parameters <code>c = 2</code> and <code>d = 4</code>.\n\nThe 64-bit SipHash outputs are then mapped uniformly over the desired range by\nmultiplying with F and taking the top 64 bits of the 128-bit result. This\nalgorithm is a faster alternative to modulo reduction, as it avoids the\nexpensive division\noperation<ref>https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/</ref>.\nNote that care must be taken when implementing this reduction to ensure the\nupper 64 bits of the integer multiplication are not truncated; certain\narchitectures and high level languages may require code that decomposes the\n64-bit multiplication into four 32-bit multiplications and recombines into the\nresult.\n\n<pre>\nhash_to_range(item: []byte, F: uint64, k: [16]byte) -> uint64:\n    return (siphash(k, item) * F) >> 64\n\nhashed_set_construct(raw_items: [][]byte, k: [16]byte, M: uint) -> []uint64:\n    let N = len(raw_items)\n    let F = N * M\n\n    let set_items = []\n\n    for item in raw_items:\n        let set_value = hash_to_range(item, F, k)\n        set_items.append(set_value)\n\n    return set_items\n</pre>\n\n==== Golomb-Rice Coding ====\n\nInstead of writing the items in the hashed set directly to the filter, greater\ncompression is achieved by only writing the differences between successive\nitems in sorted order. Since the items are distributed uniformly, it can be\nshown that the differences resemble a geometric\ndistribution<ref>https://en.wikipedia.org/wiki/Geometric_distribution</ref>.\n''Golomb-Rice''\n''coding''<ref>https://en.wikipedia.org/wiki/Golomb_coding#Rice_coding</ref>\nis a technique that optimally compresses geometrically distributed values.\n\nWith Golomb-Rice, a value is split into a quotient and remainder modulo\n<code>2^P</code>, which are encoded separately. The quotient <code>q</code> is\nencoded as ''unary'', with a string of <code>q</code> 1's followed by one 0. The\nremainder <code>r</code> is represented in big-endian by P bits. For example,\nthis is a table of Golomb-Rice coded values using <code>P=2</code>:\n\n{| class=\"wikitable\"\n! n !! (q, r) !! c\n|-\n| 0 || (0, 0) || <code>0 00</code>\n|-\n| 1 || (0, 1) || <code>0 01</code>\n|-\n| 2 || (0, 2) || <code>0 10</code>\n|-\n| 3 || (0, 3) || <code>0 11</code>\n|-\n| 4 || (1, 0) || <code>10 00</code>\n|-\n| 5 || (1, 1) || <code>10 01</code>\n|-\n| 6 || (1, 2) || <code>10 10</code>\n|-\n| 7 || (1, 3) || <code>10 11</code>\n|-\n| 8 || (2, 0) || <code>110 00</code>\n|-\n| 9 || (2, 1) || <code>110 01</code>\n|}\n\n<pre>\ngolomb_encode(stream, x: uint64, P: uint):\n    let q = x >> P\n\n    while q > 0:\n        write_bit(stream, 1)\n        q--\n    write_bit(stream, 0)\n\n    write_bits_big_endian(stream, x, P)\n\ngolomb_decode(stream, P: uint) -> uint64:\n    let q = 0\n    while read_bit(stream) == 1:\n        q++\n\n    let r = read_bits_big_endian(stream, P)\n\n    let x = (q << P) + r\n    return x\n</pre>\n\n==== Set Construction ====\n\nA GCS is constructed from four parameters:\n* <code>L</code>, a vector of <code>N</code> raw items\n* <code>P</code>, the bit parameter of the Golomb-Rice coding\n* <code>M</code>, the inverse of the target false positive rate\n* <code>k</code>, the 128-bit key used to randomize the SipHash outputs\n\nThe result is a byte vector with a minimum size of <code>N * (P + 1)</code>\nbits.\n\nThe raw items in <code>L</code> are first hashed to 64-bit unsigned integers as\nspecified above and sorted. The differences between consecutive values,\nhereafter referred to as ''deltas'', are encoded sequentially to a bit stream\nwith Golomb-Rice coding. Finally, the bit stream is padded with 0's to the\nnearest byte boundary and serialized to the output byte vector.\n\n<pre>\nconstruct_gcs(L: [][]byte, P: uint, k: [16]byte, M: uint) -> []byte:\n    let set_items = hashed_set_construct(L, k, M)\n\n    set_items.sort()\n\n    let output_stream = new_bit_stream()\n\n    let last_value = 0\n    for item in set_items:\n        let delta = item - last_value\n        golomb_encode(output_stream, delta, P)\n        last_value = item\n\n    return output_stream.bytes()\n</pre>\n\n==== Set Querying/Decompression ====\n\nTo check membership of an item in a compressed GCS, one must reconstruct the\nhashed set members from the encoded deltas. The procedure to do so is the\nreverse of the compression: deltas are decoded one by one and added to a\ncumulative sum. Each intermediate sum represents a hashed value in the original\nset. The queried item is hashed in the same way as the set members and compared\nagainst the reconstructed values. Note that querying does not require the entire\ndecompressed set be held in memory at once.\n\n<pre>\ngcs_match(key: [16]byte, compressed_set: []byte, target: []byte, P: uint, N: uint, M: uint) -> bool:\n    let F = N * M\n    let target_hash = hash_to_range(target, F, k)\n\n    stream = new_bit_stream(compressed_set)\n\n    let last_value = 0\n\n    loop N times:\n        let delta = golomb_decode(stream, P)\n        let set_item = last_value + delta\n\n        if set_item == target_hash:\n            return true\n\n        // Since the values in the set are sorted, terminate the search once\n        // the decoded value exceeds the target.\n        if set_item > target_hash:\n            break\n\n        last_value = set_item\n\n    return false\n</pre>\n\nSome applications may need to check for set intersection instead of membership\nof a single item. This can be performed far more efficiently than checking each\nitem individually by leveraging the sorted structure of the compressed GCS.\nFirst the query elements are all hashed and sorted, then compared in order\nagainst the decompressed GCS contents. See\n[[#golomb-coded-set-multi-match|Appendix B]] for pseudocode.\n\n=== Block Filters ===\n\nThis BIP defines one initial filter type:\n* Basic (<code>0x00</code>)\n** <code>M = 784931</code>\n** <code>P = 19</code>\n\n==== Contents ====\n\nThe basic filter is designed to contain everything that a light client needs to\nsync a regular Bitcoin wallet. A basic filter MUST contain exactly the\nfollowing items for each transaction in a block:\n* The previous output script (the script being spent) for each input, except for the coinbase transaction.\n* The scriptPubKey of each output, aside from all <code>OP_RETURN</code> output scripts.\n\nAny \"nil\" items MUST NOT be included into the final set of filter elements.\n\nWe exclude all outputs that start with <code>OP_RETURN</code> in order to allow\nfilters to easily be committed to in the future via a soft-fork. A likely area\nfor future commitments is an additional <code>OP_RETURN</code> output in the\ncoinbase transaction similar to the current witness commitment\n<ref>https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki</ref>. By\nexcluding all <code>OP_RETURN</code> outputs we avoid a circular dependency\nbetween the commitment, and the item being committed to.\n\n==== Construction ====\n\nThe basic type is constructed as Golomb-coded sets with the following\nparameters.\n\nThe parameter <code>P</code> MUST be set to <code>19</code>, and the parameter\n<code>M</code> MUST be set to <code>784931</code>. Analysis has shown that if\none is able to select <code>P</code> and <code>M</code> independently, then\nsetting <code>M=1.497137 * 2^P</code> is close to optimal\n<ref>https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845</ref>.\n\nEmpirical analysis also shows that these parameters minimize the bandwidth\nutilized, considering both the expected number of blocks downloaded due to false\npositives and the size of the filters themselves.\n\nThe parameter <code>k</code> MUST be set to the first 16 bytes of the hash\n(in standard little-endian representation) of the block for which the filter is\nconstructed. This ensures the key is deterministic while still varying from\nblock to block.\n\nSince the value <code>N</code> is required to decode a GCS, a serialized GCS\nincludes it as a prefix, written as a <code>CompactSize</code>. Thus, the\ncomplete serialization of a filter is:\n* <code>N</code>, encoded as a <code>CompactSize</code>\n* The bytes of the compressed filter itself\n\nA zero element filter MUST be written as one byte containing zeroes.\n\n==== Signaling ====\n\nThis BIP allocates a new service bit:\n\n{| class=\"wikitable\"\n|-\n| NODE_COMPACT_FILTERS\n| style=\"white-space: nowrap;\" | <code>1 << 6</code>\n| If enabled, the node MUST respond to all BIP 157 messages for filter type <code>0x00</code>\n|}\n\n== Compatibility ==\n\nThis block filter construction is not incompatible with existing software,\nthough it requires implementation of the new filters.\n\n== Acknowledgments ==\n\nWe would like to thank bfd (from the bitcoin-dev mailing list) for bringing the\nbasis of this BIP to our attention, Greg Maxwell for pointing us in the\ndirection of Golomb-Rice coding and fast range optimization, Pieter Wullie for\nhis analysis of optimal GCS parameters, and Pedro\nMartelletto for writing the initial indexing code for <code>btcd</code>.\n\nWe would also like to thank Dave Collins, JJ Jeffrey, and Eric Lombrozo for\nuseful discussions.\n\n== Reference Implementation ==\n\nLight client: [https://github.com/lightninglabs/neutrino]\n\nFull-node indexing: https://github.com/Roasbeef/btcd/tree/segwit-cbf\n\nGolomb-Rice Coded sets: https://github.com/btcsuite/btcd/tree/master/btcutil/gcs\n\n== Appendix A: Alternatives ==\n\nA number of alternative set encodings were considered before Golomb-coded\nsets were settled upon. In this appendix section, we'll list a few of the\nalternatives along with our rationale for not pursuing them.\n\n==== Bloom Filters ====\n\nBloom Filters are perhaps the best known probabilistic data structure for\ntesting set membership, and were introduced into the Bitcoin protocol with BIP\n37. The size of a Bloom filter is larger than the expected size of a GCS with\nthe same false positive rate, which is the main reason the option was rejected.\n\n==== Cryptographic Accumulators ====\n\nCryptographic\naccumulators<ref>https://en.wikipedia.org/wiki/Accumulator_(cryptography)</ref>\nare a cryptographic data structures that enable (amongst other operations) a one\nway membership test. One advantage of accumulators are that they are constant\nsize, independent of the number of elements inserted into the accumulator.\nHowever, current constructions of cryptographic accumulators require an initial\ntrusted set up. Additionally, accumulators based on the Strong-RSA Assumption\nrequire mapping set items to prime representatives in the associated group which\ncan be preemptively expensive.\n\n==== Matrix Based Probabilistic Set Data Structures ====\n\nThere exist data structures based on matrix solving which are even more space\nefficient compared to Bloom\nfilters<ref>https://arxiv.org/pdf/0804.1845.pdf</ref>. We instead opted for our\nGCS-based filters as they have a much lower implementation complexity and are\neasier to understand.\n\n== Appendix B: Pseudocode ==\n\n=== Golomb-Coded Set Multi-Match ===\n\n<pre>\ngcs_match_any(key: [16]byte, compressed_set: []byte, targets: [][]byte, P: uint, N: uint, M: uint) -> bool:\n    let F = N * M\n\n    // Map targets to the same range as the set hashes.\n    let target_hashes = []\n    for target in targets:\n        let target_hash = hash_to_range(target, F, k)\n        target_hashes.append(target_hash)\n\n    // Sort targets so matching can be checked in linear time.\n    target_hashes.sort()\n\n    stream = new_bit_stream(compressed_set)\n\n    let value = 0\n    let target_idx = 0\n    let target_val = target_hashes[target_idx]\n\n    loop N times:\n        let delta = golomb_decode(stream, P)\n        value += delta\n\n        inner loop:\n            if target_val == value:\n                return true\n\n            // Move on to the next set value.\n            else if target_val > value:\n                break inner loop\n\n            // Move on to the next target value.\n            else if target_val < value:\n                target_idx++\n\n                // If there are no targets left, then there are no matches.\n                if target_idx == len(targets):\n                    break outer loop\n\n                target_val = target_hashes[target_idx]\n\n    return false\n</pre>\n\n== Appendix C: Test Vectors ==\n\nTest vectors for basic block filters on five testnet blocks, including the filters and filter headers, can be found [[bip-0158/testnet-19.json|here]]. The code to generate them can be found [[bip-0158/gentestvectors.go|here]].\n\n== References ==\n\n<references/>\n\n== Copyright ==\n\nThis document is licensed under the  Creative Commons CC0 1.0 Universal license.\n", "content_length": 16866}
{"bip_number": 157, "filename": "bip-0157.mediawiki", "content": "<pre>\n  BIP: 157\n  Layer: Peer Services\n  Title: Client Side Block Filtering\n  Author: Olaoluwa Osuntokun <laolu32@gmail.com>\n          Alex Akselrod <alex@akselrod.org>\n          Jim Posen <jimpo@coinbase.com>\n  Comments-Summary: None yet\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0157\n  Status: Final\n  Type: Standards Track\n  Created: 2017-05-24\n  License: CC0-1.0\n  Requires: 158\n</pre>\n\n\n== Abstract ==\n\nThis BIP describes a new light client protocol in Bitcoin that improves upon\ncurrently available options. The standard light client protocol in use today,\ndefined in BIP\n37<ref>https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki</ref>, has\nknown flaws that weaken the security and privacy of clients and allow\ndenial-of-service attack vectors on full\nnodes<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html</ref>.\nThe new protocol overcomes these issues by allowing light clients to obtain\ncompact probabilistic filters of block content from full nodes and download full\nblocks if the filter matches relevant data.\n\nNew P2P messages empower light clients to securely sync the blockchain without\nrelying on a trusted source. This BIP also defines a filter header, which serves\nas a commitment to all filters for previous blocks and provides the ability to\nefficiently detect malicious or faulty peers serving invalid filters. The\nresulting protocol guarantees that light clients with at least one honest peer\nare able to identify the correct block filters.\n\n== Motivation ==\n\nBitcoin light clients allow applications to read relevant transactions from the\nblockchain without incurring the full cost of downloading and validating all\ndata. Such applications seek to simultaneously minimize the trust in peers and\nthe amount of bandwidth, storage space, and computation required. They achieve\nthis by downloading all block headers, verifying the proofs of work, and\nfollowing the longest proof-of-work chain. Since block headers are a fixed\n80-bytes and are generated every 10 minutes on average, the bandwidth required\nto sync the block headers is minimal. Light clients then download only the\nblockchain data relevant to them directly from peers and validate inclusion in\nthe header chain. Though clients do not check the validity of all blocks in the\nlongest proof-of-work chain, they rely on miner incentives for security.\n\nBIP 37 is currently the most widely used light client execution mode for\nBitcoin. With BIP 37, a client sends a Bloom filter it wants to watch to a full\nnode peer, then receives notifications for each new transaction or block that\nmatches the filter. The client then requests relevant transactions from the peer\nalong with Merkle proofs of inclusion in the blocks containing them, which are\nverified against the block headers. The Bloom filters match data such as client\naddresses and unspent outputs, and the filter size must be carefully tuned to\nbalance the false positive rate with the amount of information leaked to peer. It\nhas been shown, however, that most implementations available offer virtually\n''zero privacy'' to wallets and other\napplications<ref>https://eprint.iacr.org/2014/763.pdf</ref><ref>https://jonasnick.github.io/blog/2015/02/12/privacy-in-bitcoinj/</ref>.\nAdditionally, malicious full nodes serving light clients can omit critical data\nwith little risk of detection, which is unacceptable for some applications\n(such as Lightning Network clients) that must respond to certain on-chain\nevents. Finally, honest nodes servicing BIP 37 light clients may incur\nsignificant I/O and CPU resource usage due to maliciously crafted Bloom filters,\ncreating a denial-of-service (DoS) vector and disincentizing node operators from\nsupporting the\nprotocol<ref>https://github.com/bitcoin/bips/blob/master/bip-0111.mediawiki</ref>.\n\nThe alternative detailed in this document can be seen as the opposite of BIP 37:\ninstead of the client sending a filter to a full node peer, full nodes generate\ndeterministic filters on block data that are served to the client. A light\nclient can then download an entire block if the filter matches the data it is\nwatching for. Since filters are deterministic, they only need to be constructed\nonce and stored on disk, whenever a new block is connected to the chain. This\nkeeps the computation required to serve filters minimal, and eliminates the I/O\nasymmetry that makes BIP 37 enabled nodes vulnerable. Clients also get better\nassurance of seeing all relevant transactions because they can check the\nvalidity of filters received from peers more easily than they can check\ncompleteness of filtered blocks. Finally, client privacy is improved because\nblocks can be downloaded from ''any source'', so that no one peer gets complete\ninformation on the data required by a client. Extremely privacy conscious light\nclients may opt to anonymously fetch blocks using advanced techniques such a\nPrivate Information\nRetrieval<ref>https://en.wikipedia.org/wiki/Private_information_retrieval</ref>.\n\n== Definitions ==\n\n<code>[]byte</code> represents a vector of bytes.\n\n<code>[N]byte</code> represents a fixed-size byte array with length N.\n\n''CompactSize'' is a compact encoding of unsigned integers used in the Bitcoin\nP2P protocol.\n\n''double-SHA256'' is a hash algorithm defined by two invocations of SHA-256:\n<code>double-SHA256(x) = SHA256(SHA256(x))</code>.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n\"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be\ninterpreted as described in RFC 2119.\n\n== Specification ==\n\n=== Filter Types ===\n\nFor the sake of future extensibility and reducing filter sizes, there are\nmultiple ''filter types'' that determine which data is included in a block\nfilter as well as the method of filter construction/querying. In this model,\nfull nodes generate one filter per block per filter type supported.\n\nEach type is identified by a one byte code, and specifies the contents and\nserialization format of the filter. A full node MAY signal support for\nparticular filter types using service bits. The initial filter types are defined\nseparately in [[bip-0158.mediawiki|BIP 158]], and one service bit is allocated\nto signal support for them.\n\n=== Filter Headers ===\n\nThis proposal draws inspiration from the headers-first mechanism that Bitcoin\nnodes use to sync the block\nchain<ref>https://bitcoin.org/en/developer-guide#headers-first</ref>. Similar to\nhow block headers have a Merkle commitment to all transaction data in the block,\nwe define filter headers that have commitments to the block filters. Also like\nblock headers, filter headers each have a commitment to the preceding one.\nBefore downloading the block filters themselves, a light client can download all\nfilter headers for the current block chain and use them to verify the\nauthenticity of the filters. If the filter header chains differ between multiple\npeers, the client can identify the point where they diverge, then download the\nfull block and compute the correct filter, thus identifying which peer is\nfaulty.\n\nThe canonical hash of a block filter is the double-SHA256 of the serialized\nfilter. Filter headers are 32-byte hashes derived for each block filter. They\nare computed as the double-SHA256 of the concatenation of the filter hash with\nthe previous filter header. The previous filter header used to calculate that of\nthe genesis block is defined to be the 32-byte array of 0's.\n\n=== New Messages ===\n\n==== getcfilters ====\n<code>getcfilters</code> is used to request the compact filters of a particular\ntype for a particular range of blocks. The message contains the following\nfields:\n\n{| class=\"wikitable\"\n! Field Name\n! Data Type\n! Byte Size\n! Description\n|-\n| FilterType\n| byte\n| 1\n| Filter type for which headers are requested\n|-\n| StartHeight\n| uint32\n| 4\n| The height of the first block in the requested range\n|-\n| StopHash\n| [32]byte\n| 32\n| The hash of the last block in the requested range\n|}\n\n# Nodes SHOULD NOT send <code>getcfilters</code> unless the peer has signaled support for this filter type. Nodes receiving <code>getcfilters</code> with an unsupported filter type SHOULD NOT respond.\n# StopHash MUST be known to belong to a block accepted by the receiving peer. This is the case if the peer had previously sent a <code>headers</code> or <code>inv</code> message with that block or any descendents. A node that receives <code>getcfilters</code> with an unknown StopHash SHOULD NOT respond.\n# The height of the block with hash StopHash MUST be greater than or equal to StartHeight, and the difference MUST be strictly less than 1000.\n# The receiving node MUST respond to valid requests by sending one <code>cfilter</code> message for each block in the requested range, sequentially in order by block height.\n\n==== cfilter ====\n<code>cfilter</code> is sent in response to <code>getcfilters</code>, one for\neach block in the requested range. The message contains the following fields:\n\n{| class=\"wikitable\"\n! Field Name\n! Data Type\n! Byte Size\n! Description\n|-\n| FilterType\n| byte\n| 1\n| Byte identifying the type of filter being returned\n|-\n| BlockHash\n| [32]byte\n| 32\n| Block hash of the Bitcoin block for which the filter is being returned\n|-\n| NumFilterBytes\n| CompactSize\n| 1-5\n| A variable length integer representing the size of the filter in the following field\n|-\n| FilterBytes\n| []byte\n| NumFilterBytes\n| The serialized compact filter for this block\n|}\n\n# The FilterType SHOULD match the field in the <code>getcfilters</code> request, and BlockHash must correspond to a block that is an ancestor of StopHash with height greater than or equal to StartHeight.\n\n==== getcfheaders ====\n<code>getcfheaders</code> is used to request verifiable filter headers for a\nrange of blocks. The message contains the following fields:\n\n{| class=\"wikitable\"\n! Field Name\n! Data Type\n! Byte Size\n! Description\n|-\n| FilterType\n| byte\n| 1\n| Filter type for which headers are requested\n|-\n| StartHeight\n| uint32\n| 4\n| The height of the first block in the requested range\n|-\n| StopHash\n| [32]byte\n| 32\n| The hash of the last block in the requested range\n|}\n\n# Nodes SHOULD NOT send <code>getcfheaders</code> unless the peer has signaled support for this filter type. Nodes receiving <code>getcfheaders</code> with an unsupported filter type SHOULD NOT respond.\n# StopHash MUST be known to belong to a block accepted by the receiving peer. This is the case if the peer had previously sent a <code>headers</code> or <code>inv</code> message with that block or any descendents. A node that receives <code>getcfheaders</code> with an unknown StopHash SHOULD NOT respond.\n# The height of the block with hash StopHash MUST be greater than or equal to StartHeight, and the difference MUST be strictly less than 2,000.\n\n==== cfheaders ====\n<code>cfheaders</code> is sent in response to <code>getcfheaders</code>. Instead\nof including the filter headers themselves, the response includes one filter\nheader and a sequence of filter hashes, from which the headers can be derived.\nThis has the benefit that the client can verify the binding links between the\nheaders. The message contains the following fields:\n\n{| class=\"wikitable\"\n! Field Name\n! Data Type\n! Byte Size\n! Description\n|-\n| FilterType\n| byte\n| 1\n| Filter type for which hashes are requested\n|-\n| StopHash\n| [32]byte\n| 32\n| The hash of the last block in the requested range\n|-\n| PreviousFilterHeader\n| [32]byte\n| 32\n| The filter header preceding the first block in the requested range\n|-\n| FilterHashesLength\n| CompactSize\n| 1-3\n| The length of the following vector of filter hashes\n|-\n| FilterHashes\n| [][32]byte\n| FilterHashesLength * 32\n| The filter hashes for each block in the requested range\n|}\n\n# The FilterType and StopHash SHOULD match the fields in the <code>getcfheaders</code> request.\n# FilterHashesLength MUST NOT be greater than 2,000.\n# FilterHashes MUST have one entry for each block on the chain terminating with tip StopHash, starting with the block at height StartHeight. The entries MUST be the filter hashes of the given type for each block in that range, in ascending order by height.\n# PreviousFilterHeader MUST be set to the previous filter header of first block in the requested range.\n\n==== getcfcheckpt ====\n<code>getcfcheckpt</code> is used to request filter headers at evenly spaced\nintervals over a range of blocks. Clients may use filter hashes from\n<code>getcfheaders</code> to connect these checkpoints, as is described in the\n[[#client-operation|Client Operation]] section below. The\n<code>getcfcheckpt</code> message contains the following fields:\n\n{| class=\"wikitable\"\n! Field Name\n! Data Type\n! Byte Size\n! Description\n|-\n| FilterType\n| byte\n| 1\n| Filter type for which headers are requested\n|-\n| StopHash\n| [32]byte\n| 32\n| The hash of the last block in the chain that headers are requested for\n|}\n\n# Nodes SHOULD NOT send <code>getcfcheckpt</code> unless the peer has signaled support for this filter type. Nodes receiving <code>getcfcheckpt</code> with an unsupported filter type SHOULD NOT respond.\n# StopHash MUST be known to belong to a block accepted by the receiving peer. This is the case if the peer had previously sent a <code>headers</code> or <code>inv</code> message with any descendent blocks. A node that receives <code>getcfcheckpt</code> with an unknown StopHash SHOULD NOT respond.\n\n==== cfcheckpt ====\n<code>cfcheckpt</code> is sent in response to <code>getcfcheckpt</code>. The\nfilter headers included are the set of all filter headers on the requested chain\nwhere the height is a positive multiple of 1,000. The message contains the\nfollowing fields:\n\n{| class=\"wikitable\"\n! Field Name\n! Data Type\n! Byte Size\n! Description\n|-\n| FilterType\n| byte\n| 1\n| Filter type for which headers are requested\n|-\n| StopHash\n| [32]byte\n| 32\n| The hash of the last block in the chain that headers are requested for\n|-\n| FilterHeadersLength\n| CompactSize\n| 1-3\n| The length of the following vector of filter headers\n|-\n| FilterHeaders\n| [][32]byte\n| FilterHeadersLength * 32\n| The filter headers at intervals of 1,000\n|}\n\n# The FilterType and StopHash SHOULD match the fields in the <code>getcfcheckpt</code> request.\n# FilterHeaders MUST have exactly one entry for each block on the chain terminating in StopHash, where the block height is a multiple of 1,000 greater than 0. The entries MUST be the filter headers of the given type for each such block, in ascending order by height.\n\n=== Node Operation ===\n\nFull nodes MAY opt to support this BIP and generate filters for any of the\nspecified filter types. Such nodes SHOULD treat the filters as an additional\nindex of the blockchain. For each new block that is connected to the main chain,\nnodes SHOULD generate filters for all supported types and persist them. Nodes\nthat are missing filters and are already synced with the blockchain SHOULD\nreindex the chain upon start-up, constructing filters for each block from\ngenesis to the current tip. They also SHOULD keep every checkpoint header in\nmemory, so that <code>getcfcheckpt</code> requests do not result in many\nrandom-access disk reads.\n\nNodes SHOULD NOT generate filters dynamically on request, as malicious peers may\nbe able to perform DoS attacks by requesting small filters derived from large\nblocks. This would require an asymmetrical amount of I/O on the node to compute\nand serve, similar to attacks against BIP 37 enabled nodes noted in BIP 111.\n\nNodes MAY prune block data after generating and storing all filters for a block.\n\n=== Client Operation ===\n\nThis section provides recommendations for light clients to download filters with\nmaximal security.\n\nClients SHOULD first sync the entire block header chain from peers using the\nstandard headers-first syncing mechanism before downloading any block filters or\nfilter headers. Clients configured with trusted checkpoints MAY only sync\nheaders started from the last checkpoint. Clients SHOULD disconnect any outbound\npeers whose best chain has significantly less work than the known longest\nproof-of-work chain.\n\nOnce a client's block headers are in sync, it SHOULD download and verify filter\nheaders for all blocks and filter types that it might later download. The client\nSHOULD send <code>getcfheaders</code> messages to peers and derive and store the\nfilter headers for each block. The client MAY first fetch headers at evenly\nspaced intervals of 1,000 by sending <code>getcfcheckpt</code>. The header\ncheckpoints allow the client to download filter headers for different intervals\nfrom multiple peers in parallel, verifying each range of 1,000 headers against\nthe checkpoints.\n\nUnless securely connected to a trusted peer that is serving filter headers, the\nclient SHOULD connect to multiple outbound peers that support each filter type\nto mitigate the risk of downloading incorrect headers. If the client receives\nconflicting filter headers from different peers for any block and filter type,\nit SHOULD interrogate them to determine which is faulty. The client SHOULD use\n<code>getcfheaders</code> and/or <code>getcfcheckpt</code> to first identify\nthe first filter headers that the peers disagree on. The client then SHOULD\ndownload the full block from any peer and derive the correct filter and filter\nheader. The client SHOULD ban any peers that sent a filter header that does not\nmatch the computed one.\n\nOnce the client has downloaded and verified all filter headers needed, ''and''\nno outbound peers have sent conflicting headers, the client can download the\nactual block filters it needs. The client MAY backfill filter headers before the\nfirst verified one at this point if it only downloaded them starting at a later\npoint. Clients SHOULD persist the verified filter headers for the last 100 blocks in\nthe chain (or whatever finality depth is desired), to compare against headers\nreceived from new peers after restart. They MAY store more filter headers to\navoid redownloading them if a rescan is later necessary.\n\nStarting from the first block in the desired range, the client now MAY download\nthe filters. The client SHOULD test that each filter links to its corresponding\nfilter header and ban peers that send incorrect filters. The client MAY download\nmultiple filters at once to increase throughput, though it SHOULD test the\nfilters sequentially. The client MAY check if a filter is empty before\nrequesting it by checking if the filter header commits to the hash of the empty\nfilter, saving a round trip if that is the case.\n\nEach time a new valid block header is received, the client SHOULD request the\ncorresponding filter headers from all eligible peers. If two peers send\nconflicting filter headers, the client should interrogate them as described\nabove and ban any peers that send an invalid header.\n\nIf a client is fetching full blocks from the P2P network, they SHOULD be downloaded\nfrom outbound peers at random to mitigate privacy loss due to transaction\nintersection analysis. Note that blocks may be downloaded from peers that do not\nsupport this BIP.\n\n== Rationale ==\n\nThe filter headers and checkpoints messages are defined to help clients identify\nthe correct filter for a block when connected to peers sending conflicting\ninformation. An alternative solution is to require Bitcoin blocks to include\ncommitments to derived block filters, so light clients can verify authenticity\ngiven block headers and some additional witness data. This would require a\nnetwork-wide change to the Bitcoin consensus rules, however, whereas this\ndocument proposes a solution purely at the P2P layer.\n\nThe constant interval of 1,000 blocks between checkpoints was chosen so that,\ngiven the current chain height and rate of growth, the size of a\n<code>cfcheckpt</code> message is not drastically different from a\n<code>cfheaders</code> message between two checkpoints. Also, 1,000 is a nice\nround number, at least to those of us who think in decimal.\n\n== Compatibility ==\n\nThis light client mode is not compatible with current node deployments and\nrequires support for the new P2P messages. The node implementation of this\nproposal is not incompatible with the current P2P network rules (ie. doesn't\naffect network topology of full nodes). Light clients may adopt protocols based\non this as an alternative to the existing BIP 37. Adoption of this BIP may\nresult in reduced network support for BIP 37.\n\n== Acknowledgments ==\n\nWe would like to thank bfd (from the bitcoin-dev mailing list) for bringing the\nbasis of this BIP to our attention, Joseph Poon for suggesting the filter header\nchain scheme, and Pedro Martelletto for writing the initial indexing code for\n<code>btcd</code>.\n\nWe would also like to thank Dave Collins, JJ Jeffrey, Eric Lombrozo, and Matt\nCorallo for useful discussions.\n\n== Reference Implementation ==\n\nLight client: [https://github.com/lightninglabs/neutrino]\n\nFull-node indexing: https://github.com/Roasbeef/btcd/tree/segwit-cbf\n\nGolomb-Rice Coded sets: https://github.com/Roasbeef/btcutil/tree/gcs/gcs\n\n== References ==\n\n<references/>\n\n== Copyright ==\n\nThis document is licensed under the  Creative Commons CC0 1.0 Universal license.\n", "content_length": 21145}
{"bip_number": 156, "filename": "bip-0156.mediawiki", "content": "<pre>\n  BIP: 156\n  Layer: Peer Services\n  Title: Dandelion - Privacy Enhancing Routing\n  Author: Brad Denby <bdenby@cmu.edu>\n          Andrew Miller <soc1024@illinois.edu>\n          Giulia Fanti <gfanti@andrew.cmu.edu>\n          Surya Bakshi <sbakshi3@illinois.edu>\n          Shaileshh Bojja Venkatakrishnan <shaileshh.bv@gmail.com>\n          Pramod Viswanath <pramodv@illinois.edu>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0156\n  Status: Rejected\n  Type: Standards Track\n  Created: 2017-06-09\n  License: CC0-1.0\n</pre>\n\n==Abstract==\n\nBitcoin's transaction spreading protocol is vulnerable to deanonymization\nattacks. Dandelion is a transaction routing mechanism that provides formal\nanonymity guarantees against these attacks. When a node generates a transaction\nwithout Dandelion, it transmits that transaction to its peers with independent,\nexponential delays. This approach, known as diffusion in academia, allows\nnetwork adversaries to link transactions to IP addresses.\n\nDandelion mitigates this class of attacks by sending transactions over a\nrandomly selected path before diffusion. Transactions travel along this path\nduring the \"stem phase\" and are then diffused during the \"fluff phase\" (hence\nDandelion). We have shown that this routing protocol provides near-optimal\nanonymity guarantees among schemes that do not introduce additional encryption\nmechanisms.\n\n==Motivation==\n\nTransaction diffusion in Bitcoin is vulnerable to deanonymization attacks.\nBecause transactions are sent to peers with independent, exponential delays,\nmessages spread through the network in a statistically symmetric manner. This\npattern allows colluding spy nodes to infer the transaction source. Breaking\nthis symmetry prevents the attack. However, we have shown that an adversary with\nknowledge of the network topology can launch a much more effective \"fingerprint\"\nattack if the symmetry breaking is not done properly.\n\nConsider a botnet-style adversary with access to the P2P graph. Botnets of size\ncomparable to the Bitcoin P2P network are common and cheap, and these\nadversaries can learn the network structure with probe messages. We have shown\nthat such an adversary can achieve total deanonymization of the entire network\nafter observing less than ten transactions per node.\n\nDandelion is a practical, lightweight privacy solution that provides the Bitcoin\nnetwork formal anonymity guarantees. While other privacy solutions aim to\nprotect individual users, Dandelion protects anonymity by limiting the\ncapability of adversaries to deanonymize the entire network.\n\n==How Dandelion Works==\n\nDandelion enhances user privacy by sending transactions through an anonymity\nphase before diffusing them throughout the network. At a high level, Dandelion\nenhances privacy by (i) breaking the symmetry of diffusion and (ii) mixing\ntransactions by forwarding messages from different sources along the same path.\n\nDandelion routing can be conceptualized in three phases. First, a privacy graph\nis constructed. In practice, this privacy graph is constructed in a fully\ndecentralized manner and is a subgraph of the existing Bitcoin P2P network.\nNext, transactions are forwarded along this privacy graph during the \"stem\nphase.\" Finally, messages are broadcast to the network during the \"fluff phase\"\nusing the typical method of diffusion.\n\n[[File:bip-0156/1-dandelion.png|framed|center|alt=An illustration of Dandelion routing|Figure 1]]\nFigure 1\n\nIn order to select the privacy graph in a decentralized manner, each node\nselects a subset of its outbound peers to be Dandelion destinations. Dandelion\ntransactions (transactions in their stem phase) that arrive at this node via\ninbound connections are forwarded to these Dandelion destinations.\n\nIn an ideal setting, we have found that a Hamiltonian circuit provides\nnear-optimal privacy guarantees. However, constructing a Hamiltonian circuit\nthrough the Bitcoin P2P network in a decentralized, trustless manner is not\nfeasible. Thus, we recommend that each node select two Dandelion destinations\nuniformly at random without replacement from its list of outbound peers. Our\ntests have shown that this method provides comparable privacy with increased\nrobustness.\n\nDuring stem phase routing, there is a question of how to route messages in order\nto protect privacy. For example, if two Dandelion transactions arrive at a node\nfrom different inbound peers, to which Dandelion destination(s) should these\ntransactions be sent? We have found that some choices are much better than\nothers.\n\nConsider the case in which each Dandelion transaction is forwarded to a\nDandelion destination selected uniformly at random. This approach results in a\nfingerprint attack allowing network-level botnet adversaries to achieve total\ndeanonymization of the P2P network after observing less than ten transactions\nper node.\n\n[[File:bip-0156/2-attack.png|framed|center|alt=An illustration of a fingerprint attack|Figure 2]]\nFigure 2\n\nDuring a fingerprint attack, a botnet-style adversary with knowledge of the\ngraph structure first simulates transaction propagation. This offline step lets\nthe adversary generate fingerprints for each network node. During the online\nattack, the adversary collects transactions at its spy nodes and matches these\nobservations to the simulated fingerprints. Our simulations have shown that this\nattack results in devastating, network-wide deanonymization.\n\n[[File:bip-0156/3-attack-plot.png|framed|center|alt=A plot illustrating total deanonymization|Figure 3]]\nFigure 3\n\nTo avoid this issue, we suggest \"per-inbound-edge\" routing. Each inbound peer is\nassigned a particular Dandelion destination. Each Dandelion transaction that\narrives via this peer is forwarded to the same Dandelion destination.\nPer-inbound-edge routing breaks the described attack by blocking an adversary's\nability to construct useful fingerprints. Fingerprints arise when routing\ndecisions are made independently per transaction at each node. In this case, two\ntransactions from the same node generally take different paths through the\nnetwork. Crucially, this results in multiple, unique data points that are\naggregated to match with a fingerprint.\n\nDandelion ensures that two transactions from the same node take the same network\npath, limiting adversaries to the far-left of the graph in Figure 3. In other\nwords, adversary knowledge is limited to the case of one observed message rather\nthan a rich profile of multiple transaction paths. Dandelion also breaks the\nsymmetry of diffusion, making the source of the transaction difficult to infer.\n\n[[File:bip-0156/4-dandelion-plot.png|framed|center|alt=A plot illustrating limited deanonymization|Figure 4]]\nFigure 4\n\nAfter a transaction has traveled along a Dandelion stem for a random number of\nhops, it transitions into the fluff phase of routing. The transaction is shared\nwith the network through the existing process of diffusion. In practice, this\nfluff mechanism is enforced by a weighted coin flip at each node. If the random\nvalue is below some threshold, the Dandelion transaction is transformed into a\ntypical transaction. In our testing, we have chosen a probability of ten percent\nthat a given Dandelion transaction enters fluff phase when leaving a given node.\nThis value strikes a good balance between stem path length and transaction\nspreading latency.\n\nNote that Dandelion's expected precision guarantees are a population-level\nmetric, whereas the expected recall guarantees can be interpreted as an\nindividual-level metric. Expected recall is equivalent to the probability that\nan adversary associates a single transaction with a given source. These\nguarantees are probabilistic. They do not address scenarios in which a node has\nbeen eclipsed by other nodes, or when a node is specifically targeted by an\nISP-like adversary. Individuals who are concerned about targeted deanonymization\nshould still use Tor.\n\nAt a high level, Dandelion is like an \"anonymity inoculation\" for the public at\nlarge - including users who are not aware of Bitcoin's privacy issues. Higher\nadoption leads to greater benefits, even for users who do not use Tor. Early\nadopters of Dandelion still receive privacy benefits. In the worst case when no\nneighbors support Dandelion, transactions make at least one hop before\ndiffusing. Note that any solution based only on routing cannot be perfectly\nanonymous due to the fundamental lower bounds on precision and recall shown in\nthe original Dandelion paper. Dandelion provides near-optimal anonymity\nguarantees among such solutions.\n\n==Specification==\n\nDandelion can be specified with a handful of features: Dandelion transaction\nsupport, Dandelion routing data and logic, periodic Dandelion route shuffling,\nmemory pool logic, the fluff mechanism, transaction embargoes, and Dandelion\ntransaction logic. Specification details are summarized below.\n\n===Dandelion transaction support===\n\nDuring the stem phase, transactions are \"Dandelion transactions.\" When a\nDandelion transaction enters fluff phase, it becomes a typical Bitcoin\ntransaction. Dandelion transactions and typical transactions differ only in\ntheir <code>NetMsgType</code>.\n\nDandelion (stem phase) transactions MUST be differentiable from typical Bitcoin\ntransactions.\n\n===Dandelion routing data and logic===\n\nDandelion routing during the stem phase requires notions of inbound peers,\noutbound peers, Dandelion destinations, and Dandelion routes. Inbound peers\nconsist of all currently connected peers that initiated the peer connection.\nOutbound peers consist of all currently connected peers that were connected to\nby this node. Dandelion destinations are a subset of outbound peers. The number\nof Dandelion destinations is limited by the\n<code>DANDELION_MAX_DESTINATIONS</code> parameter. In the reference\nimplementation, this parameter is set to two. Our tests have shown that this\nvalue provides both privacy and robustness (see the reference paper for more\ndetails on the parameter tradeoffs). Dandelion routes are a map of inbound peers\nto Dandelion destinations. Every inbound peer is mapped to a Dandelion\ndestination.\n\nNote that a Dandelion node may choose a different\n<code>DANDELION_MAX_DESTINATIONS</code> parameter without splitting from the\nprivacy graph. When mapping inbound connections to outbound connections for\nDandelion routes, we implement the following routing logic. First, select a set\nof Dandelion destinations from the set of outbound peers. This set of Dandelion\ndestinations is of size less than or equal to\n<code>DANDELION_MAX_DESTINATIONS</code>. For each inbound connection, first\nidentify the subset of Dandelion destinations with the least number of routes.\nFor example, some subset of Dandelion destinations may be affiliated with zero\nroutes while all other Dandelion destinations are affiliated with one or more\nroutes. From this subset, select one Dandelion destination uniformly at random.\nEstablish a Dandelion route from the inbound connection to this Dandelion\ndestination.\n\nFor a given Dandelion routing epoch, two distinct Dandelion destinations SHOULD\nbe selected uniformly at random from the set of outbound connections. All\nDandelion transactions that arrive via a given inbound connection MUST be\ntransmitted to the same Dandelion destination. When choosing a Dandelion\ndestination for a given inbound connection, the destination MUST be selected\nuniformly at random from the set of Dandelion destinations with the least number\nof inbound connections mapped to them.\n\n===Periodic Dandelion route shuffling===\n\nThe map of Dandelion routes is cleared and reconstructed every ten minutes on\naverage. We have chosen the value of ten minutes heuristically in order to make\nprivacy graph learning difficult for adversaries. Note that a Dandelion node may\nchoose a different average shuffle time without splitting from the privacy\ngraph.\n\nDandelion routes MUST be cleared and reconstructed at random intervals.\nDandelion routes SHOULD be cleared and reconstructed every ten minutes on\naverage.\n\n===Memory pool logic===\n\nDandelion transactions are segregated from typical transactions. The\n<code>mempool</code> remains unchanged. Another instance of the\n<code>CTxMemPool</code> class, called the <code>stempool</code>, is used for\nDandelion transactions. Information flows from <code>mempool</code> to\n<code>stempool</code> in order to ensure proper transaction propagation.\nInformation does not flow from <code>stempool</code> to <code>mempool</code>,\nexcept when a Dandelion transaction fluffs into a typical transaction.\n\nWhen a Dandelion transaction arrives, the transaction MUST be added to the\nstempool and MUST NOT be added to the mempool. When a typical Bitcoin\ntransaction arrives, the transaction MUST be added to the mempool and MUST be\nadded to the stempool. When a Dandelion transaction fluffs, the transaction MUST\nbe added to the mempool.\n\n===The fluff mechanism===\n\nWhen relaying a Dandelion transaction along a Dandelion route, there is a 10%\nchance that the Dandelion transaction becomes a typical Bitcoin transaction and\nis therefore relayed via diffusion. In our testing, this value strikes a good\nbalance between stem path length and transaction spreading latency. Note that a\nDandelion node may choose a different chance of fluffing without splitting from\nthe privacy graph.\n\nWhen a node prepares to transmit a Dandelion transaction, the node MUST flip a\nbiased coin. If the outcome is \"Dandelion transaction,\" then the node MUST\ntransmit the transaction to the appropriate Dandelion destination. Otherwise,\nthe node MUST convert the Dandelion transaction into a typical Bitcoin\ntransaction. A Dandelion transaction SHOULD fluff into a typical Bitcoin\ntransaction with a 10% probability.\n\n===Transaction embargoes===\n\nDuring the stem phase, transactions are relayed along a single path. If any node\nin this path were to receive the Dandelion transaction and go offline, then the\ntransaction would cease to propagate. To increase robustness, every node that\nforwards a Dandelion transaction initializes a timer at the time of reception.\nIf the Dandelion transaction does not appear in the memory pool by the time the\ntimer expires, then the transaction enters fluff phase and is forwarded via\ndiffusion.\n\nWhen a Dandelion transaction arrives, the node MUST set an embargo timer for a\nrandom time in the future. If the Dandelion transaction arrives as a typical\nBitcoin transaction, the node MUST cancel the timer. If the timer expires before\nthe Dandelion transaction is observed as a typical Bitcoin transaction, then the\nnode MUST fluff the Dandelion transaction.\n\n===Dandelion transaction logic===\n\nThe following cases define a node's behavior when receiving network packets\nreferencing Dandelion transactions.\n* Receive INV for Dandelion TX: If the peer is inbound and the Dandelion transaction has not been received from this peer, then reply with GETDATA.\n* Receive GETDATA for Dandelion TX: If the peer is not inbound and the Dandelion transaction has been advertised to this peer, then reply with the Dandelion transaction.\n* Receive Dandelion TX: If the peer is inbound, then relay the Dandelion TX to the appropriate Dandelion destination.\n\n==Implementation==\n\nA reference implementation is available at the following URL:\nhttps://github.com/dandelion-org/bitcoin/tree/dandelion-feature-commits\n\nAll features have been compressed into a single commit at the following URL:\nhttps://github.com/dandelion-org/bitcoin/tree/dandelion\n\n==Compatibility==\n\nDandelion does not conflict with existing versions of Bitcoin. A Bitcoin node\nthat supports Dandelion appears no differently to Bitcoin nodes running older\nsoftware versions. Bitcoin nodes that support Dandelion can identify feature\nsupport through a probe message. Obviously, older nodes are not capable of\nDandelion routing. If a Bitcoin node supporting Dandelion has no peers that also\nsupport Dandelion, then its behavior naturally decays to that of a Bitcoin node\nwithout Dandelion support due to the Dandelion transaction embargoes.\n\n==Acknowledgements==\n\nWe would like to thank the Bitcoin Core developers and Gregory Maxwell in\nparticular for their insightful comments, which helped to inform this\nimplementation and some of the follow-up work we conducted. We would also like\nto thank the Mimblewimble development community for coining the term \"stempool,\"\nwhich we happily adopted for this implementation.\n\n==References==\n\n# An Analysis of Anonymity in Bitcoin Using P2P Network Traffic http://fc14.ifca.ai/papers/fc14_submission_71.pdf\n# Deanonymisation of clients in Bitcoin P2P network https://arxiv.org/abs/1405.7418\n# Discovering Bitcoin\u2019s Public Topology and Influential Nodes https://cs.umd.edu/projects/coinscope/coinscope.pdf\n# (Sigmetrics 2017) Dandelion: Redesigning the Bitcoin Network for Anonymity https://arxiv.org/abs/1701.04439\n# (Sigmetrics 2018) Dandelion++: Lightweight Cryptocurrency Networking with Formal Anonymity Guarantees https://arxiv.org/pdf/1805.11060.pdf\n\n==Copyright==\n\nTo the extent possible under law, the author(s) have dedicated all copyright and\nrelated and neighboring rights to this work to the public domain worldwide. This\nwork is distributed without any warranty.\n\nYou should have received a copy of the CC0 Public Domain Dedication with this\nwork. If not, see https://creativecommons.org/publicdomain/zero/1.0/ .\n", "content_length": 17388}
{"bip_number": 155, "filename": "bip-0155.mediawiki", "content": "<pre>\n  BIP: 155\n  Layer: Peer Services\n  Title: addrv2 message\n  Author: Wladimir J. van der Laan <laanwj@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0155\n  Status: Final\n  Type: Standards Track\n  Created: 2019-02-27\n  License: BSD-2-Clause\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a new P2P message to gossip longer node addresses over the P2P network.\nThis is required to support new-generation Onion addresses, I2P, and potentially other networks\nthat have longer endpoint addresses than fit in the 128 bits of the current <code>addr</code> message.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nTor v3 hidden services are part of the stable release of Tor since version 0.3.2.9. They have\nvarious advantages compared to the old hidden services, among which are better encryption and privacy\n<ref>[https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt Tor Rendezvous Specification - Version 3]</ref>.\nThese services have 256 bit addresses and thus do not fit in the existing <code>addr</code> message, which encapsulates onion addresses in OnionCat IPv6 addresses.\n\nOther transport-layer protocols such as I2P have always used longer\naddresses. This change would make it possible to gossip such addresses over the\nP2P network, so that other peers can connect to them.\n\n==Specification==\n\n<blockquote>\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n\"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be\ninterpreted as described in RFC 2119<ref>[https://tools.ietf.org/html/rfc2119 RFC 2119]</ref>.\n</blockquote>\n\nThe <code>addrv2</code> message is defined as a message where <code>pchCommand == \"addrv2\"</code>.\nIt is serialized in the standard encoding for P2P messages.\nIts format is similar to the current <code>addr</code> message format, with the difference that the\nfixed 16-byte IP address is replaced by a network ID and a variable-length address, and the services format has been changed to [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer CompactSize].\n\nThis means that the message contains a serialized <code>std::vector</code> of the following structure:\n\n{| class=\"wikitable\" style=\"width: auto; text-align: center; font-size: smaller; table-layout: fixed;\"\n!Type\n!Name\n!Description\n|-\n| <code>uint32_t</code>\n| <code>time</code>\n| Time that this node was last seen as connected to the network. A time in Unix epoch time format.\n|-\n| <code>CompactSize</code>\n| <code>services</code>\n| Service bits. A bit field that is 64 bits wide, encoded in [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer CompactSize].\n|-\n| <code>uint8_t</code>\n| <code>networkID</code>\n| Network identifier. An 8-bit value that specifies which network is addressed.\n|-\n| <code>std::vector<uint8_t></code>\n| <code>addr</code>\n| Network address. The interpretation depends on networkID.\n|-\n| <code>uint16_t</code>\n| <code>port</code>\n| Network port. If not relevant for the network this MUST be 0.\n|}\n\nOne message can contain up to 1,000 addresses. Clients SHOULD reject messages with more addresses.\n\nField <code>addr</code> has a variable length, with a maximum of 512 bytes (4096 bits).\nClients SHOULD reject messages with longer addresses, irrespective of the network ID.\n\nThe list of reserved network IDs is as follows:\n\n{| class=\"wikitable\" style=\"width: auto; text-align: center; font-size: smaller; table-layout: fixed;\"\n!Network ID\n!Enumeration\n!Address length (bytes)\n!Description\n|-\n| <code>0x01</code>\n| <code>IPV4</code>\n| 4\n| IPv4 address (globally routed internet)\n|-\n| <code>0x02</code>\n| <code>IPV6</code>\n| 16\n| IPv6 address (globally routed internet)\n|-\n| <code>0x03</code>\n| <code>TORV2</code>\n| 10\n| Tor v2 hidden service address (no longer used<ref name=\"torv2\">Tor v2 is no longer operational; clients MUST NOT gossip or relay Tor v2 addresses and MUST ignore them on receive</ref>)\n|-\n| <code>0x04</code>\n| <code>TORV3</code>\n| 32\n| Tor v3 hidden service address\n|-\n| <code>0x05</code>\n| <code>I2P</code>\n| 32\n| I2P overlay network address\n|-\n| <code>0x06</code>\n| <code>CJDNS</code>\n| 16\n| Cjdns overlay network address\n|-\n| <code>0x07</code>\n| <code>YGGDRASIL</code>\n| 16\n| Yggdrasil overlay network address\n|}\n\nClients are RECOMMENDED to gossip addresses from all known networks even if they are currently not connected to some of them. That could help multi-homed nodes and make it more difficult for an observer to tell which networks a node is connected to.\n\nClients SHOULD NOT gossip addresses from unknown networks because they have no means to validate those addresses and so can be tricked to gossip invalid addresses.\n\nFurther network ID numbers MUST be reserved in a new BIP document.\n\nClients SHOULD reject messages that contain addresses that have a different length than specified in this table for a specific network ID, as these are meaningless.\n\nSee the appendices for the address encodings to be used for the various networks.\n\n==Signaling support and compatibility==\n\nIntroduce a new message type <code>sendaddrv2</code>. Sending such a message indicates that a node can understand and prefers to receive <code>addrv2</code> messages instead of <code>addr</code> messages. I.e. \"Send me addrv2\". Sending or not sending this message does not imply any preference with respect to receiving unrequested address messages.\n\nThe <code>sendaddrv2</code> message MUST only be sent in response to the <code>version</code> message from a peer and prior to sending the <code>verack</code> message.\n\nFor older peers, that did not emit <code>sendaddrv2</code>, keep sending the legacy <code>addr</code> message, ignoring addresses with the newly introduced address types.\n\n==Reference implementation==\n\nThe reference implementation is available at (to be done)\n\n==Acknowledgements==\n\n- Jonas Schnelli: change <code>services</code> field to [https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer CompactSize], to make the message more compact in the likely case instead of always using 8 bytes.\n\n- Gregory Maxwell: various suggestions regarding extensibility\n\n==Appendix A: Tor v2 address encoding (no longer used <ref name=\"torv2\" />)==\n\nThe new message introduces a separate network ID for <code>TORV2</code>.\n\nClients MUST send Tor hidden service addresses with this network ID, with the 80-bit hidden service ID in the address field. This is the same as the representation in the legacy <code>addr</code> message, minus the 6 byte prefix of the OnionCat wrapping.\n\nClients SHOULD ignore OnionCat (<code>fd87:d87e:eb43::/48</code>) addresses on receive if they come with the <code>IPV6</code> network ID.\n\n==Appendix B: Tor v3 address encoding==\n\nAccording to the spec <ref>[https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt Tor Rendezvous Specification - Version 3: Encoding onion addresses]</ref>, next-gen <code>.onion</code> addresses are encoded as follows:\n<pre>\nonion_address = base32(PUBKEY | CHECKSUM | VERSION) + \".onion\"\n CHECKSUM = H(\".onion checksum\" | PUBKEY | VERSION)[:2]\n\n where:\n   - PUBKEY is the 32 bytes ed25519 master pubkey of the hidden service\n   - VERSION is a one byte version field (default value '\\x03')\n   - \".onion checksum\" is a constant string\n   - CHECKSUM is truncated to two bytes before inserting it in onion_address\n   - H() is the SHA3-256 cryptographic hash function\n</pre>\n\nTor v3 addresses MUST be sent with the <code>TORV3</code> network ID, with the 32-byte PUBKEY part in the address field. As VERSION will always be '\\x03' in the case of v3 addresses, this is enough to reconstruct the onion address.\n\n==Appendix C: I2P address encoding==\n\nLike Tor, I2P naming uses a base32-encoded address format<ref>[https://geti2p.net/en/docs/naming#base32 I2P: Naming and address book]</ref>.\n\nI2P uses 52 characters (256 bits) to represent the full SHA-256 hash, followed by <code>.b32.i2p</code>.\n\nI2P addresses MUST be sent with the <code>I2P</code> network ID, with the decoded SHA-256 hash as address field.\n\n==Appendix D: Cjdns address encoding==\n\nCjdns addresses are simply IPv6 addresses in the <code>fc00::/8</code> range<ref>[https://github.com/cjdelisle/cjdns/blob/6e46fa41f5647d6b414612d9d63626b0b952746b/doc/Whitepaper.md#pulling-it-all-together Cjdns whitepaper: Pulling It All Together]</ref>. They MUST be sent with the <code>CJDNS</code> network ID.\n\n==Appendix E: Yggdrasil address encoding==\n\nYggdrasil addresses are simply IPv6 addresses in the <code>0200::/7</code> range<ref>[https://yggdrasil-network.github.io/faq.html#will-yggdrasil-conflict-with-my-network-routing Yggdrasil FAQ]</ref>. They MUST be sent with the <code>YGGDRASIL</code> network ID.\n\n== Changelog ==\n\n* 2.0.0 (2025-10-01):\n** Add note that Tor v2 is no longer operational.\n* 1.0.0 (2019-02-27):\n** Initial version\n\n==References==\n\n<references/>\n", "content_length": 8980}
{"bip_number": 154, "filename": "bip-0154.mediawiki", "content": "<pre>\n  BIP: 154\n  Layer: Peer Services\n  Title: Rate Limiting via peer specified challenges\n  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0154\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2017-04-12\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nAn anti-DoS system which provides additional service for peers which perform proof of work.\n\n==Definitions==\n\n* '''POW''' : a proof of work using some arbitrary algorithm, such as SHA256\n* '''challenge''' : a problem in the form of a POW specification and other data\n* '''solution''' : a set of inputs which solve a given challenge\n* '''free connection slot''' : an inbound connection slot that does not require POW\n* '''POW connection slot''' : an inbound connection slot that requires POW\n* '''SPH''' : Special Purpose Hardware, such as an ASIC chip\n* '''GPH''' : General Purpose Hardware, such as a desktop computer\n* '''Work''' : A measurement of optimized average resources (clock cycles, memory, ...) required to perform a single attempt at solving a given POW algorithm on GPH\n\n==Motivation==\n\nThe Bitcoin network has a maximum number of inbound and outbound connections (125).\nIt is trivial and relatively cheap to flood the network with connections via dummy\nnodes. Such an attack would result in (1) nodes evicting some other nodes in order to\nfacilitate the new connection, and (2) nodes' ability to connect to each other being\nseverely hampered. In this state, the network is vulnerable to e.g. a Sybil attack.\n\nWhile the network is under pressure as in the above case, nodes could allow incoming\nconnections anyway by requiring that the incoming peer performs some form of proof\nof work, to prove that they are not simply spamming the network. This would severely\nramp up the costs of a Sybil attack, as the attacker would now have to perform proof\nof work for each node, beyond the free slots.\n\nHowever, using the \"standard\" double-SHA256 POW algorithm in use by Bitcoin nodes to\ngenerate blocks means attackers can use special-purpose hardware to greatly accelerate\nthe POW solving process. To counter this, the proof weight would have to be raised,\nbut this would mean standard nodes would need to solve unacceptably costly challenges\nfor simple operation. Therefore, a different proof of work which is arguably less\nsensitive to special-purpose hardware implementations is introduced. As this is not\nconsensus sensitive, additional POW algorithms may be added in the future.\n\n==Specification==\n\nA peer that supports Proof of Work Rate Limiting defines two maximums:\n\n* max connections, from which the maximum inbound connections is calculated as <code>nMaxConnections - (nMaxOutbound + nMaxFeeler)</code>\n* POW connection slots, which define how many of the above inbound connections require a POW challenge\n\nThe peer must interpret two new network peer message types, <code>challenge</code> and <code>solution</code>.\n\nIn addition, the network handshake sequence must be altered slightly to facilitate the exchange of challenges and/or solutions:\n* when a node connects, it may send a <code>solution</code> message prior to the <code>version</code>\n* if it does, and\n** the solution satisfies the local node, it is given a connection, but if\n** the solution does not satisfy the local node (unknown, wrong, ...), a new <code>challenge</code> is sent and the connection is closed\n* if it does not, and it is marked as needing to do POW, a <code>challenge</code> is sent and the connection is closed\n\nThis means nodes will be disconnected after receiving the challenge. It is then up to the individual nodes whether they\nsolve the challenge and reconnect, or discard it and find a different peer (or wait for the peer to have an open free slot).\n\n===POW Identifiers===\n\nThere are two POW identifiers currently. When a new identifier is introduced, it should be added with an increment of 1\nto the last identifier in the list. When an identifier is deprecated, its status should be changed to <code>Deprecated</code> but it should\nretain its place in the list indefinitely.\n\n{|class=\"wikitable\"\n! ID !! Algorithm Name !! Work !! Param size !! Solution size !! Provably Secure !! SPH Resistance !! Status\n|-\n| 1 || sha256 || 11k cycles || 11+ bytes || 0, 4 or 8 bytes || Yes || Low || Active\n|-\n| 2 || cuckoo-cycle || ss 28: 150G cycles / ~48M RAM || 6+ bytes || 168 bytes || No || High || Active\n|}\n\n====sha256====\n\nProperties:\n\n{|class=\"wikitable\"\n! Property !! Value\n|-\n| Solution probability || <code>sum((1/2)^i*(1-targetBE[i]))</code>\n|}\n\nChallenge format:\n\n{|class=\"wikitable\"\n! Range !! Field Name !! Data Type !! Description\n|-\n| 0 || config_length || varint || Length of configuration part; always 9\n|-\n| 1..4 || target || uint32 || Difficulty target, in the form of a compact size (like nBits in blocks).\n|-\n| 5 || nonce_size || uint8 || Size of nonce in bytes; must be 0 (no nonce), 4 (uint32) or 8 (uint64)\n|-\n| 6..9 || nonce_offset || uint32 || Location of nonce value in target\n|-\n| 10.. || payload_length || varint || Length of the input data\n|-\n| .. || payload || byte array || Input data\n|}\n\nSolution format:\n\n{|class=\"wikitable\"\n! Range !! Field Name !! Data Type !! Description\n|-\n| 0.. || nonce || uint32/64, or data || Nonce value that satisfies challenge; for zero-byte nonces, this is variable data that is appended to the challenge payload before hashing\n|}\n\nNote: SHA256 works in two \"modes\".\n# One is where the task is to insert a nonce into an existing data block so that the hash of the data block matches a given target; this is the conventional block proof of work behavior.\n# The other is where the whole or parts of the data chunk are given as input (a \"big nonce\"). In this case, the internal nonce size is zero bytes, and the task is simply to check whether the hash of the data matches the target. If it does not, there is no way to find a solution except by getting different input from the generator (a successor algorithm). This mode is used when SHA256 is a predecessor to another algorithm.\n\nAdditional notes:\n\n* The initial nonce value (when present) for finding a suitable digest should be randomized, or a challenger may deliberately pick a challenge with \"poor\" outcomes to fool a node into spending more than predicted time solving.\n\n====cuckoo-cycle====\n\nProperties:\n\n{|class=\"wikitable\"\n! Property !! Value\n|-\n| Solution probability || <code>~1.0</code> for sizeshift=28, proofsize-min:-max=12:228\n|}\n\nChallenge format:\n\n{|class=\"wikitable\"\n! Range !! Field Name !! Data Type !! Description\n|-\n| 0 || config_length || varint || Length of configuration part; always 5\n|-\n| 1 || sizeshift || uint8 || Size shift; must be equal to 28, but may be variable in the future\n|-\n| 2..3 || proofsize-min || uint16 || Minimum number of edges in cycle; must be even and greater than or equal to 12 (recommended: 12)\n|-\n| 4..5 || proofsize-max || uint16 || Maximum number of edges in cycle; must be even, greater than or equal to proofsize-min, and smaller than or equal to 254 (recommended: 228)\n|-\n| 6 || payload_length || varint || Length of the input data; must be 76, but may be variable in the future\n|-\n| 7.. || payload || byte array || Input data\n|}\n\nSolution format:\n\n{|class=\"wikitable\"\n! Range !! Field Name !! Data Type !! Description\n|-\n| 0..3 || nonce || uint32 || Nonce which is appended to challenge payload to form solution graph\n|-\n| 4..171 || edges || uint32 array || 42 values which identify each of the 42 edges in the cycle\n|}\n\nAdditional notes:\n\n* The initial nonce value used for finding a graph with a suitable solution should be randomized, or a challenger may deliberately pick a challenge with \"poor\" outcomes to fool a node into spending more than predicted time solving.\n* Further information on the recommended challenge parameters can be found here: https://web.archive.org/web/20230207054058/http://bc-2.jp/cuckoo-profile.pdf\n\n===Purpose Identifiers===\n\nThere is only one Purpose Identifier currently. In the future, more Purpose Identifiers could be added for at-DoS-risk operations,\nsuch as bloom filters. When a new identifier is introduced, it should be added with an increment of 1 to the last identifier in the\nlist. When an identifier is deprecated, its status should be changed to <code>Deprecated</code> but it should retain its place in\nthe list indefinitely.\n\n{|class=\"wikitable\"\n! ID !! Purpose Name !! Description !! Status\n|-\n| 1 || connect || Establish peer to peer connection || Active\n|}\n\n===Challenges===\n\nChallenges consist of one or several chained POW identifiers with accompanying parameters, as well as indicators for the purpose of the challenge,\nand a signature that lets the node verify the challenge authenticity.\n\nAfter creating a challenge, the node signs it, delivers it to the peer, then discards it.\nWhen a node provides a solution to a challenge, the node verifies the signature and adds the challenge hash to a list of solved\nchallenges along with its expiration time. This list is pruned on each insertion, removing any expired challenges.\n\nIf nodes needed to keep track of unsolved challenges, an attacker could hypothetically swarm a node, causing a DoS by having it generate so many\nchallenges that it runs out of memory and crashes.\nBy signing and discarding challenges, a node only has to retain challenges that were solved, and which have not yet expired, effectively DoS-\nprotecting the node via the challenges themselves.\n\n===The <code>challenge</code> message type===\n\nA challenge consists of four parts: the POW specification, a purpose identifier, an expiration date, and a signature.\nThe POW specification contains a list of tuples containing a POW identifier and corresponding POW parameters.\n\n* Each POW identifier specifies a POW algorithm (see POW Identifiers)\n* The POW parameters define the inputs and requirements of the POW algorithm\n* The purpose identifier specifies the purpose of the challenge (see Purpose Identifiers)\n* The expiration date is a UNIX timestamp indicating when the challenge expires\n* The signed content should contain a signature of the hash <code>SHA256(SHA256(pow-count || pow-id || pow-params || ... || purpose-id || expiration))</code>, i.e. the hash of the entire challenge except for the signature length and data.\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Description\n|-\n| 1 byte || pow-count || uint8 || Number of POW algorithms in the range [1..255]\n|-\n| 4 bytes || pow-id || uint32 || The POW algorithm to solve the problem with\n|-\n| ? || pow-params  || ? || The POW parameters and payload\n|-\n| ... || ...  || ... || pow-id and pow-params for algorithms 2 and beyond\n|-\n| 4 bytes || purpose-id  || uint32 || The purpose of the challenge\n|-\n| 8 bytes || expiration  || int64 || Expiration UNIX timestamp\n|-\n| ? || sign-len  || varint || The length of the signature\n|-\n| ? || sign  || byte array || The signature data\n|}\n\nFor POW specifications with a pow-count > 1, the output of the succeeding POW algorithm will be appended to the input of the predecessor for all POW algorithms except the last one.\nNormally mid-layer (all but the last) POW algorithms have a zero-length input. Example implementing sha256(cuckoo-cycle):\n\n{|class=\"wikitable\"\n! Range !! Field Name !! Value !! Comment\n|-\n| 0 || pow-count || 2 || Two POW algorithms\n|-\n| 1..4 || pow-id || 1 || sha256\n|-\n| 5 || pow-params (config_length) || 9 ||\n|-\n| 6..9 || pow-params (target) || 0x207fffff || Resulting hash must be <= the compact hash 0x207fffff*\n|-\n| 10 || pow-params (nonce_size) || 0 || No nonce\n|-\n| 11..14 || pow-params (nonce_offset) || 0 || --\n|-\n| 15..18 || pow-params (payload_length) || 0 || 0 byte input (turns into 32 byte input from successor)\n|-\n| 19..22 || pow-id || 2 || cuckoo-cycle\n|-\n| 23 || pow-params (config_length) || 8 ||\n|-\n| 24 || pow-params (sizeshift) || 28\n|-\n| 25..26 || pow-params (proofsize-min) || 12 ||\n|-\n| 27..28 || pow-params (proofsize-max) || 228 ||\n|-\n| 29 || pow-params (payload_length) || 76 || 76 byte input\n|-\n| 30..105 || pow-params || (random data) || A randomized challenge of 76 bytes\n|-\n| 106..109 || purpose-id || 1 || Purpose is a peer-to-peer connection\n|-\n| 110..117 || expiration || 1491285696 || Expiration is April 4 2017, 15:01:36 (JST)\n|-\n| 118 || sign-len || 71 || 71 byte signature\n|-\n| 119..189 || sign || (signature) || Signature of above challenge\n|}\n\n(* Compact 0x207fffff = 0x7fffff0000000000000000000000000000000000000000000000000000000000.)\n\nThe above should be interpreted as SHA256(cuckoo-cycle(random data || nonce)) < 0x7fffff0000000000000000000000000000000000000000000000000000000000.\n* Run cuckoo-cycle on random data || nonce; increment nonce until solution is found, then\n** Run SHA256 on 32 byte digest from above; if less than 0x7fffff0000000000000000000000000000000000000000000000000000000000,\n*** Mark solved.\n* Otherwise loop back and increase nonce and continue finding solutions\n\n===The <code>solution</code> message type===\n\nA solution consists of two parts: the entire challenge, and solution parameters:\n* The challenge must match the given challenge up to and including the signature bytes\n* The solution parameters must form a valid solution to each POW step in the challenge\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Description\n|-\n| 1 byte || pow-count || uint8 || Number of POW algorithms in the range [1..255]\n|-\n| 4 bytes || pow-id || uint32 || The POW algorithm used to solve the problem\n|-\n| ? || pow-params  || ? || The input to the POW solver for the above algorithm\n|-\n| ... || ...  || ... || pow-id and pow-params for algorithms 2 and beyond\n|-\n| 4 bytes || purpose-id  || uint32 || The purpose of the challenge\n|-\n| 8 bytes || expiration  || int64 || Expiration UNIX timestamp\n|-\n| ? || sign-len  || varint || The length of the signature\n|-\n| ? || sign  || byte array || The signature data\n|-\n| ? || solution  || ? || The solution to the challenge\n|}\n\nNote that the solution contains the parameters for the last algorithm only.\nFor each algorithm except the last one, the input is derived from the output of the successor.\nExample solution:\n\n{|class=\"wikitable\"\n! Range !! Name !! Value !! Description\n|-\n| 0 || length || 4 || The input to the innermost POW is 4 bytes in length\n|-\n| 1..4 || nonce32 || 0x12345 || The nonce used as input is 0x12345\n|}\n\nThe above example will provide a single nonce for the inner POW. For the SHA256(SHA256(challenge data || nonce32)) case, the solution would\nclaim that SHA256(SHA256(challenge data || 0x00012345)) solves the challenge.\n\n==Signing and Verifying Challenges==\n\nBelow is a suggestion for how to sign a challenge. The implementation generates a new, random key-pair at launch and uses that\nto sign all challenges until the node is shutdown.\n\n===Signing a Challenge===\n\n# (first time) Create a new random key-pair <code>key</code> and <code>pubkey</code> and keep these around until shutdown\n# (second+ time) Fetch <code>key</code> created above\n# Create a double-SHA256 <code>sighash</code> of the challenge in serialized form up until and including the expiration bytes\n# Create a signature <code>sign</code> of <code>sighash</code> using <code>key</code>\n# Append <code>varint(len(sign))</code> and <code>sign</code> to challenge\n\n===Verifying a Challenge===\n\n# Fetch <code>pubkey</code> and declare failure if not defined (that means we never issued a challenge)\n# Create a double-SHA256 <code>sighash</code> of the challenge provided with the solution up until and including the expiration bytes\n# Verify <code>sighash</code> is not known, and add it to known hashes along with its expiration date for pruning purposes\n# Set <code>sign</code> to the signature included in the challenge\n# Verify the signature <code>sign</code> using <code>pubkey</code> and <code>sighash</code>\n# Check that the solution solves the challenge\n\nNote that a list of known hashes should be kept and pruned of expired challenges on verification. Otherwise nodes may reuse the same\nsolution repeatedly up until its expiration.\n\n==Difficulty and Cost==\n\n===Estimating Challenge Cost===\n\nNodes need to be able to make a judgement call on whether solving a given challenge is worth their efforts. If a challenge is expected to take\nso much time that it would expire before being solved (on average), it should be immediately discarded. Beyond this, a threshold should be\nestablished for nodes based on their \"value\" to the node, which is inversely proportional to the current number of connections as a function\nof uptime, with arbitrary modifiers (a whitelisted node or a node added via -addnode has a much higher threshold).\n\nIt is hard to obtain an accurate value for <code>cycles_per_second</code>, and as such a fixed value of 1700000000=1.7e9 may be used.\n\nGiven a threshold <code>t</code>, calculate the estimated work required to solve the challenge as follows:\n# Define <code>p(alg)</code> as the probability that an attempt at finding a solution given the algorithm <code>alg</code> succeeds\n# Define <code>w(alg)</code> as the work parameter of the algorithm <code>alg</code>.\n# Let <code>Wc \u2190 0, Wm \u2190 1, Wi \u2190 1</code>\n# For each proof of work <code>pow</code> in the POW specification:\n## Let <code>p \u2190 p(pow)</code>, <code>w \u2190 w(pow)</code>\n## Update <code>Wc \u2190 Wc + w_cycles</code>, <code>Wi \u2190 Wi * 1/p</code>, <code>Wm \u2190 Wm + w_ram</code>\n# Let <code>eta \u2190 (Wc * Wi) / cycles_per_second</code>\n# If <code>date() + eta >= expiration</code>, discard challenge\n# If <code>eta > t</code>, discard challenge\n\nExample: <code>SHA256(cuckoo-cycle(...)) < 0x7fffff0000000000000000000000000000000000000000000000000000000000</code>\n# <code>p(cuckoo-cycle) = 1</code>, <code>p(sha256, 0x7fffff000...) ~= (1/2)^1 = 1/2</code>\n# <code>w(cuckoo-cycle) = (1.5e11 cycles, 5e7 ram)</code>, <code>w(sha256, 0x7fffff000...) = (11e3 cycles)</code>\n# <code>Wc = 0, Wm = 1, Wi = 1</code>\n## <code>p = p(cuckoo-cycle) = 1, w = w(cuckoo-cycle) = (1.5e11 cycles, 5e7 ram)</code>\n## <code>Wc = 0 + 1.5e11 = 1.5e11</code>, <code>Wi = 1 * 1 = 1</code>, <code>Wm = 1 + 5e7 = 5e7</code>\n## <code>p = p(sha256) = 1/2, w = w(sha256) = (11e3 cycles)</code>\n## <code>Wc = 1.5e11 + 11e3 ~= 1.5e11, Wi = 1 * 2 = 2, Wm = 5e7 + 0 = 5e7</code>\n# <code>eta = (1.5e11 * 2) / cycles_per_second</code> = <code>7.5e10 / 1.7e9</code> = 44.1 seconds</code>\n\nTODO: Determine how memory impacts threshold.\n\nTo avoid other nodes dropping our challenges due to early expiration, we use a fairly generous expiration based on the pressure value\n<pre>\nexpiration = date() + 600 * (1 + pressure)\n</pre>\nwhich means the expiration is 10 minutes for the weakest challenge, and gradually rises to 20 minutes for the hardest one.\n\n===Establishing Difficulty Parameters===\n\nThe difficulty setting for the network should change based on connection slot availability. The amount of pressure\non the network in the sense of connection slot availability is proportional to the number of established connections\nover the number of total available connections. This can be locally approximated by a node to the number of\nlocal connections compared to the local connection maximum.\n\nIn other words, the network pressure can be approximated by any node as <code>connections / max</code> and the difficulty\ncan be based on e.g. <code>(connections - free) / pow_slots</code>.\n\nThe challenge difficulty parameters can be set based on this, where 0.0 means \"low pressure\" and 1.0 means\n\"maximum pressure\". The <code>GetPressure</code> method below gives 0.0 at 67 connections (for a 50 POW slot set up), and hits the 1.0 mark at <code>(nMaxConnections - nMaxOutbound - nMaxFeeler)</code>, incrementing by 0.02 for each new connection:\n<pre>\nint nMaxInbound = nMaxConnections - (nMaxOutbound + nMaxFeeler + nPOWConnectionSlots);\nreturn ((double)GetNodeCount(CONNECTIONS_ALL) - nMaxInbound) / nPOWConnectionSlots;\n</pre>\n\nAn example of difficulty for a SHA256(Cuckoo-Cycle) specification would be based on a desired probability of a random SHA256 digest matching a given target:\n<pre>\nprob_target = 1 / (1 + pressure^2 * 15)\n</pre>\nThis would result in probability targets according to the table below, for varying pressures (where the pressure is in the range [0..1]):\n\n{|class=\"wikitable\"\n! pressure !! prob_target !! solution time sha256(cc)\n|-\n| 0.0 || 1.00 || 00:45\n|-\n| 0.1 || 0.87 || 00:51\n|-\n| 0.2 || 0.63 || 01:11\n|-\n| 0.3 || 0.43 || 01:45\n|-\n| 0.4 || 0.29 || 02:32\n|-\n| 0.5 || 0.21 || 03:32\n|-\n| 0.6 || 0.16 || 04:46\n|-\n| 0.7 || 0.12 || 06:13\n|-\n| 0.8 || 0.09 || 07:54\n|-\n| 0.9 || 0.08 || 09:48\n|-\n| 1.0 || 0.06 || 11:55\n|-\n|}\n\n==Cuckoo Cycle==\n\nCuckoo Cycle[1] is a \"graph-theoretic proof-of-work system, based on finding small cycles or other structures in large random graphs.\"\n\nIt is memory hard, which greatly increases the complexity and cost of producing dedicated (special purpose) hardware, an ideal property for an anti-DoS system.\n\nThe implementation specifics of the algorithm are beyond the scope of this BIP, but the github repository[2] has several reference implementations in various languages.\n\n==Compatibility==\n\nThis proposal is backward compatible. Non-supporting peers will ignore the <code>challenge</code> message\nand be disconnected, as if they hit the peer connection limit as normal.\n\n==Reference implementation==\n\nhttps://github.com/kallewoof/bitcoin/pull/2 (https://github.com/kallewoof/bitcoin/tree/pow-connection-slots)\n\n==References==\n\n* [1] Cuckoo Cycle https://github.com/tromp/cuckoo/blob/master/doc/cuckoo.pdf?raw=true\n* [2] Cuckoo Cycle github https://github.com/tromp/cuckoo\n\n==Test vectors==\n\n===Cuckoo-Cycle===\n\nCuckoo Cycle header (76 bytes):\n<pre>\n00..1f   68a639cb 3deab5b6 23054d60 e7856037 8afa0f31 4f08dec1 6cc4ec4f d9bef1ff\n20..3f   468af883 c6c9c3d5 4260087a 046d12a0 7cc3988f 9ff2957a 384de8ed db75b037\n40..4b   798d1073 214b7ea6 954f1b3a\n</pre>\n\nExample solution nonce: 0 (<code>00000000</code>)\n\nSolution edges (16 number of 32-bit unsigned integers, read horizontally from top left):\n\n<pre>\n550b1100 0fc89a00 45034401 ddfce701 08da0e02 6ccc5703 06fe8404 1d3f8504\n559e3e05 d41a9905 17075206 97cfa006 59e50d07 7bd71f07 13fe2607 14493007\n</pre>\n\n===SHA256(Cuckoo-Cycle)===\n\nSHA256 target: <code>0x205fffff</code>\n\nCuckoo Cycle header (76 bytes, same as above):\n<pre>\n00..1f   68a639cb 3deab5b6 23054d60 e7856037 8afa0f31 4f08dec1 6cc4ec4f d9bef1ff\n20..3f   468af883 c6c9c3d5 4260087a 046d12a0 7cc3988f 9ff2957a 384de8ed db75b037\n40..4b   798d1073 214b7ea6 954f1b3a\n</pre>\n\nExample solution nonce: 0 (<code>00000000</code>)\n\nSHA256 input (cuckoo-cycle nonce + solution):\n\n<pre>\n00000000\n550b1100 0fc89a00 45034401 ddfce701 08da0e02 6ccc5703 06fe8404 1d3f8504\n559e3e05 d41a9905 17075206 97cfa006 59e50d07 7bd71f07 13fe2607 14493007\n</pre>\n\nSHA256 hash: <code>262c8558c7c589b19b3d513abf5fcb15162745473e603f0146889ceff750bcc3</code>\n\nMust be less than: <code>5fffff0000000000000000000000000000000000000000000000000000000000</code>\n\n===Serialized challenge example===\n\n<pre>\n020100000009ffff5f2000000000000002000000051c0c00e4004c68a639cb3deab5b623054d60e7\n8560378afa0f314f08dec16cc4ec4fd9bef1ff468af883c6c9c3d54260087a046d12a07cc3988f9f\nf2957a384de8eddb75b037798d1073214b7ea6954f1b3a01000000a49d0659000000004730450221\n0095fc5fafe2032097c4d12a8901401cda297aad614e16f23ec42d4b78955856c002206ab7ada4ac\n8f6fa9d5bd7cd06f9ba89587a28e14cea14e7f8f8d5ab851541791\n</pre>\n\n{|class=\"wikitable\"\n! Hex !! Description\n|-\n| <code>0x02</code> || Two proofs of work\n|-\n| <code>0x01000000</code> || Proof of work ID = 1 (SHA256)\n|-\n| <code>0x09</code> || Config is 9 bytes\n|-\n| <code>0xffff5f20</code> || SHA256: Compact target = 0x205fffff\n|-\n| <code>0x00</code> || SHA256: Nonce size is 0 bytes\n|-\n| <code>0x00000000</code> || SHA256: Nonce offset is 0\n|-\n| <code>0x00</code> || Payload is 0 bytes\n|-\n| <code>0x02000000</code> || Proof of work ID = 2 (cuckoo-cycle)\n|-\n| <code>0x05</code> || Config is 5 bytes\n|-\n| <code>0x1c</code> || Size shift is 28\n|-\n| <code>0x0c00</code> || Proof size min is 12\n|-\n| <code>0xe400</code> || Proof size max is 228\n|-\n| <code>0x4c</code> || Payload is 76 bytes\n|-\n| <code>0x68a639cb3deab5b623054d60e7856037</code> || Payload\n|-\n| <code>0x8afa0f314f08dec16cc4ec4fd9bef1ff</code>\n|-\n| <code>0x468af883c6c9c3d54260087a046d12a0</code>\n|-\n| <code>0x7cc3988f9ff2957a384de8eddb75b037</code>\n|-\n| <code>0x798d1073214b7ea6954f1b3a</code>\n|-\n| <code>0x01000000</code> || Purpose ID = 1 (PURPOSE_CONNECT)\n|-\n| <code>0xa49d065900000000</code> || UNIX timestamp 1493605796\n|-\n| <code>0x47</code> || 71 byte signature\n|-\n| <code>0x304502210095fc5fafe2032097c4d12a</code> || Signature data\n|-\n| <code>0x8901401cda297aad614e16f23ec42d4b</code>\n|-\n| <code>0x78955856c002206ab7ada4ac8f6fa9d5</code>\n|-\n| <code>0xbd7cd06f9ba89587a28e14cea14e7f8f</code>\n|-\n| <code>0x8d5ab851541791</code>\n|}\n\n===Serialized solution example===\n\n<pre>\n020100000009ffff5f2000000000000002000000051c0c00e4004c68a639cb3deab5b623054d60e7\n8560378afa0f314f08dec16cc4ec4fd9bef1ff468af883c6c9c3d54260087a046d12a07cc3988f9f\nf2957a384de8eddb75b037798d1073214b7ea6954f1b3a01000000a49d0659000000004730450221\n0095fc5fafe2032097c4d12a8901401cda297aad614e16f23ec42d4b78955856c002206ab7ada4ac\n8f6fa9d5bd7cd06f9ba89587a28e14cea14e7f8f8d5ab8515417914400000000550b11000fc89a00\n45034401ddfce70108da0e026ccc570306fe84041d3f8504559e3e05d41a99051707520697cfa006\n59e50d077bd71f0713fe260714493007\n</pre>\n\nNote that the first 187 bytes are identical to the challenge above.\n\n{|class=\"wikitable\"\n! Hex !! Description\n|-\n| <code>0x0201..1791</code> || Challenge\n|-\n| <code>0x44</code> || Solution is 68 bytes long\n|-\n| <code>0x00000000</code> || The cuckoo cycle nonce is 0\n|-\n| <code>0x550b11000fc89a0045034401ddfce701</code> || Cycle edges 0..3\n|-\n| <code>0x08da0e026ccc570306fe84041d3f8504</code> || Cycle edges 4..7\n|-\n| <code>0x559e3e05d41a99051707520697cfa006</code> || Cycle edges 8..11\n|-\n| <code>0x59e50d077bd71f0713fe260714493007</code> || Cycle edges 12..15\n|}\n\n===Cuckoo-Cycle Example 2===\n\nCuckoo Cycle header (76 bytes):\n<pre>\n00..1f   3c1e3ee5 c799b7e9 92bcccbb 8985979d cb8dd229 b8d0db06 e677d00b b3a43c88\n20..3f   ef8596a7 7cbd1dda 23b0a0b8 4bdf6084 d7aa28dd bd5e91b5 11b3578c baf92707\n40..4b   c940b051 a0759b3f 80c5fb65\n</pre>\n\nExample solution nonce: 4 (<code>04000000</code>)\n\nSolution edges (22 number of 32-bit unsigned integers, read horizontally from top left):\n\n<pre>\n5a013700 7074ce00 e3dbeb00 e88f7901 06d71d02 984d3d02 091b5002 378a8e02\n90a6d202 b3c67003 757cb703 44d9cf03 297f2004 8e76a604 67e44a05 7b077405\n634f8405 23e88c05 0d887606 109d3e07 c4bdcd07 3db2d407\n</pre>\n\n===SHA256(Cuckoo-Cycle)===\n\nSHA256 target: <code>0x2021642c</code>\n\nCuckoo Cycle header (76 bytes, same as above):\n<pre>\n00..1f   3c1e3ee5 c799b7e9 92bcccbb 8985979d cb8dd229 b8d0db06 e677d00b b3a43c88\n20..3f   ef8596a7 7cbd1dda 23b0a0b8 4bdf6084 d7aa28dd bd5e91b5 11b3578c baf92707\n40..4b   c940b051 a0759b3f 80c5fb65\n</pre>\n\nExample solution nonce: 4 (<code>04000000</code>)\n\nSHA256 input (cuckoo-cycle nonce + solution):\n\n<pre>\n04000000\n5a013700 7074ce00 e3dbeb00 e88f7901 06d71d02 984d3d02 091b5002 378a8e02\n90a6d202 b3c67003 757cb703 44d9cf03 297f2004 8e76a604 67e44a05 7b077405\n634f8405 23e88c05 0d887606 109d3e07 c4bdcd07 3db2d407\n</pre>\n\nSHA256 hash: <code>08210561257e26776135ec1cb92cfe17f46803613c0bdc02043e5545b18556ce</code>\n\nMust be less than: <code>21642c0000000000000000000000000000000000000000000000000000000000</code>\n\n===Serialized challenge example===\n\n<pre>\n0201000000092c64212000000000000002000000051c0c00e4004c3c1e3ee5c799b7e992bcccbb89\n85979dcb8dd229b8d0db06e677d00bb3a43c88ef8596a77cbd1dda23b0a0b84bdf6084d7aa28ddbd\n5e91b511b3578cbaf92707c940b051a0759b3f80c5fb650100000024aa0659000000004630440220\n0edfb5c4812a31d84cbbd4b24e631795435a0d16b57d37ef773735b8a87caa8a0220631d0b78b7f1\nd29c9e54a76f3457ff1a2ee19490ff027c528a896f4bf6aff577\n</pre>\n\n{|class=\"wikitable\"\n! Hex !! Description\n|-\n| <code>0x02</code> || Two proofs of work\n|-\n| <code>0x01000000</code> || Proof of work ID = 1 (SHA256)\n|-\n| <code>0x09</code> || Config is 9 bytes\n|-\n| <code>0x2c642120</code> || SHA256: Compact target = 0x2021642c\n|-\n| <code>0x00</code> || SHA256: Nonce size is 0 bytes\n|-\n| <code>0x00000000</code> || SHA256: Nonce offset is 0\n|-\n| <code>0x00</code> || Payload is 0 bytes\n|-\n| <code>0x02000000</code> || Proof of work ID = 2 (cuckoo-cycle)\n|-\n| <code>0x05</code> || Config is 5 bytes\n|-\n| <code>0x1c</code> || Size shift is 28\n|-\n| <code>0x0c00</code> || Proof size min is 12\n|-\n| <code>0xe400</code> || Proof size max is 228\n|-\n| <code>0x4c</code> || Payload is 76 bytes\n|-\n| <code>0x3c1e3ee5c799b7e992bcccbb8985979d</code> || Payload\n|-\n| <code>0xcb8dd229b8d0db06e677d00bb3a43c88</code>\n|-\n| <code>0xef8596a77cbd1dda23b0a0b84bdf6084</code>\n|-\n| <code>0xd7aa28ddbd5e91b511b3578cbaf92707</code>\n|-\n| <code>0xc940b051a0759b3f80c5fb65</code>\n|-\n| <code>0x01000000</code> || Purpose ID = 1 (PURPOSE_CONNECT)\n|-\n| <code>0x24aa065900000000</code> || UNIX timestamp 1493608996\n|-\n| <code>0x46</code> || 70 byte signature\n|-\n| <code>0x304402200edfb5c4812a31d84cbbd4b2</code> || Signature data\n|-\n| <code>0x4e631795435a0d16b57d37ef773735b8</code>\n|-\n| <code>0xa87caa8a0220631d0b78b7f1d29c9e54</code>\n|-\n| <code>0xa76f3457ff1a2ee19490ff027c528a89</code>\n|-\n| <code>0x6f4bf6aff577</code>\n|}\n\n===Serialized solution example===\n\n<pre>\n0201000000092c64212000000000000002000000051c0c00e4004c3c1e3ee5c799b7e992bcccbb89\n85979dcb8dd229b8d0db06e677d00bb3a43c88ef8596a77cbd1dda23b0a0b84bdf6084d7aa28ddbd\n5e91b511b3578cbaf92707c940b051a0759b3f80c5fb650100000024aa0659000000004630440220\n0edfb5c4812a31d84cbbd4b24e631795435a0d16b57d37ef773735b8a87caa8a0220631d0b78b7f1\nd29c9e54a76f3457ff1a2ee19490ff027c528a896f4bf6aff5775c040000005a0137007074ce00e3\ndbeb00e88f790106d71d02984d3d02091b5002378a8e0290a6d202b3c67003757cb70344d9cf0329\n7f20048e76a60467e44a057b077405634f840523e88c050d887606109d3e07c4bdcd073db2d407\n</pre>\n\nNote that the first 186 bytes are identical to the challenge above.\n\n{|class=\"wikitable\"\n! Hex !! Description\n|-\n| <code>0x0201..f577</code> || Challenge\n|-\n| <code>0x5c</code> || Solution is 92 bytes long\n|-\n| <code>0x04000000</code> || The cuckoo cycle nonce is 4\n|-\n| <code>0x5a0137007074ce00e3dbeb00e88f7901</code> || Cycle edges 0..3\n|-\n| <code>0x06d71d02984d3d02091b5002378a8e02</code> || Cycle edges 4..7\n|-\n| <code>0x90a6d202b3c67003757cb70344d9cf03</code> || Cycle edges 8..11\n|-\n| <code>0x297f20048e76a60467e44a057b077405</code> || Cycle edges 12..15\n|-\n| <code>0x634f840523e88c050d887606109d3e07</code> || Cycle edges 16..19\n|-\n| <code>0xc4bdcd073db2d407</code> || Cycle edges 20..21\n|}\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n", "content_length": 30696}
{"bip_number": 152, "filename": "bip-0152.mediawiki", "content": "<pre>\n  BIP: 152\n  Layer: Peer Services\n  Title: Compact Block Relay\n  Author: Matt Corallo <bip152@bluematt.me>\n  Comments-Summary: Unanimously Recommended for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0152\n  Status: Final\n  Type: Standards Track\n  Created: 2016-04-27\n  License: PD\n</pre>\n\n==Abstract==\n\nCompact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n==Motivation==\n\nHistorically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n\nThus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n\nWhile the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n\n==Specification for version 1==\n\n===Intended Protocol Flow===\n<img src=bip-0152/protocol-flow.png></img>\n\nThe protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Notes|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a <code>sendcmpct</code> message. In this mode, peers send new block announcements with the short transaction IDs already (via a <code>cmpctblock</code> message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a <code>getblocktxn</code>/<code>blocktxn</code> roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n\nThe \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a <code>sendcmpct</code> message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK <code>getdata</code> request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a <code>getblocktxn</code>/<code>blocktxn</code> roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n\n===New data structures===\nSeveral new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions.\n\nFor the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes. Only CompactSize encodings which are minimally-encoded (ie the shortest length possible) are used by this spec. Any other CompactSize encodings are left with undefined behavior.\n\nSeveral uses of CompactSize below are \"differentially encoded\". For these, instead of using raw indexes, the number encoded is the difference between the current index and the previous index, minus one. For example, a first index of 0 implies a real index of 0, a second index of 0 thereafter refers to a real index of 1, etc.\n\n====PrefilledTransaction====\nA PrefilledTransaction structure is used in HeaderAndShortIDs to provide a list of a few transactions explicitly.\n\n{|\n|Field Name||Type||Size||Encoding||Purpose\n|-\n|index||CompactSize||1, 3 bytes||Compact Size, differentially encoded since the last PrefilledTransaction in a list||The index into the block at which this transaction is\n|-\n|tx||Transaction||variable||As encoded in \"tx\" messages sent in response to getdata MSG_TX||The transaction which is in the block at index index.\n|}\n\n====HeaderAndShortIDs====\nA HeaderAndShortIDs structure is used to relay a block header, the short transactions IDs used for matching already-available transactions, and a select few transactions which we expect a peer may be missing.\n\n{|\n|Field Name||Type||Size||Encoding||Purpose\n|-\n|header||Block header||80 bytes||First 80 bytes of the block as defined by the encoding used by \"block\" messages||The header of the block being provided\n|-\n|nonce||uint64_t||8 bytes||Little Endian||A nonce for use in short transaction ID calculations\n|-\n|shortids_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of short transaction IDs in shortids (ie block tx count - prefilledtxn_length)\n|-\n|shortids||List of 6-byte integers||6*shortids_length bytes||Little Endian||The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\n|-\n|prefilledtxn_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of prefilled transactions in prefilledtxn (ie block tx count - shortids_length)\n|-\n|prefilledtxn||List of PrefilledTransactions||variable size*prefilledtxn_length||As defined by PrefilledTransaction definition, above||Used to provide the coinbase transaction and a select few which we expect a peer may be missing\n|}\n\n====BlockTransactionsRequest====\nA BlockTransactionsRequest structure is used to list transaction indexes in a block being requested.\n\n{|\n|Field Name||Type||Size||Encoding||Purpose\n|-\n|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being requested are in\n|-\n|indexes_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of transactions being requested\n|-\n|indexes||List of CompactSizes||1 or 3 bytes*indexes_length||Differentially encoded||The indexes of the transactions being requested in the block\n|}\n\n====BlockTransactions====\nA BlockTransactions structure is used to provide some of the transactions in a block, as requested.\n\n{|\n|Field Name||Type||Size||Encoding||Purpose\n|-\n|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being provided are in\n|-\n|transactions_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of transactions provided\n|-\n|transactions||List of Transactions||variable||As encoded in \"tx\" messages in response to getdata MSG_TX||The transactions provided\n|}\n\n====Short transaction IDs====\nShort transaction IDs are used to represent a transaction without sending a full 256-bit hash. They are calculated by:\n# single-SHA256 hashing the block header with the nonce appended (in little-endian)\n# Running SipHash-2-4 with the input being the transaction ID and the keys (k0/k1) set to the first two little-endian 64-bit integers from the above hash, respectively.\n# Dropping the 2 most significant bytes from the SipHash output to make it 6 bytes.\n\n===New messages===\nA new inv type (MSG_CMPCT_BLOCK == 4) and several new protocol messages are added: sendcmpct, cmpctblock, getblocktxn, and blocktxn.\n\n====sendcmpct====\n# The sendcmpct message is defined as a message containing a 1-byte integer followed by a 8-byte integer where pchCommand == \"sendcmpct\".\n# The first integer SHALL be interpreted as a boolean (and MUST have a value of either 1 or 0)\n# The second integer SHALL be interpreted as a little-endian version number. Nodes sending a sendcmpct message MUST currently set this value to 1.\n# Upon receipt of a \"sendcmpct\" message with the first and second integers set to 1, the node SHOULD announce new blocks by sending a cmpctblock message.\n# Upon receipt of a \"sendcmpct\" message with the first integer set to 0, the node SHOULD NOT announce new blocks by sending a cmpctblock message, but SHOULD announce new blocks by sending invs or headers, as defined by BIP130.\n# Upon receipt of a \"sendcmpct\" message with the second integer set to something other than 1, nodes MUST treat the peer as if they had not received the message (as it indicates the peer will provide an unexpected encoding in cmpctblock, and/or other, messages). This allows future versions to send duplicate sendcmpct messages with different versions as a part of a version handshake for future versions. See Protocol Versioning section, below, for more info on the specifics of the version-negotiation mechanics.\n# Nodes SHOULD check for a protocol version of >= 70014 before sending sendcmpct messages.\n# Nodes MUST NOT send a request for a MSG_CMPCT_BLOCK object to a peer before having received a sendcmpct message from that peer.\n# Nodes MUST NOT request a MSG_CMPCT_BLOCK object before having sent all sendcmpct messages to that peer which they intend to send, as the peer cannot know what version protocol to use in the response.\n\n====MSG_CMPCT_BLOCK====\n# getdata messages may now contain requests for MSG_CMPCT_BLOCK objects.\n# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object with the hash of a block which was recently announced and is close to the tip of the best chain of the receiver and after having sent the requesting peer a sendcmpct message, nodes MUST respond with a cmpctblock message containing appropriate data representing the block being requested.\n# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object for which a cmpctblock message is not sent in response, a block message containing the requested block in non-compact form MUST be sent.\n# MSG_CMPCT_BLOCK inv objects MUST NOT appear anywhere except for in getdata messages.\n\n====cmpctblock====\n# The cmpctblock message is defined as a message containing a serialized HeaderAndShortIDs message and pchCommand == \"cmpctblock\".\n# Upon receipt of a cmpctblock message after sending a sendcmpct message, nodes SHOULD calculate the short transaction ID for each unconfirmed transaction they have available (ie in their mempool) and compare each to each short transaction ID in the cmpctblock message.\n# After finding already-available transactions, nodes which do not have all transactions available to reconstruct the full block SHOULD request the missing transactions using a getblocktxn message.\n# A node MUST NOT send a cmpctblock message unless they are able to respond to a getblocktxn message which requests every transaction in the block.\n# A node MUST NOT send a cmpctblock message without having validated that the header properly commits to each transaction in the block, and properly builds on top of the existing, fully-validated chain with a valid proof-of-work either as a part of the current most-work valid chain, or building directly on top of it. A node MAY send a cmpctblock before validating that each transaction in the block validly spends existing UTXO set entries.\n\n====getblocktxn====\n# The getblocktxn message is defined as a message containing a serialized BlockTransactionsRequest message and pchCommand == \"getblocktxn\".\n# Upon receipt of a properly-formatted getblocktxn message, nodes which recently provided the sender of such a message a cmpctblock for the block hash identified in this message MUST respond with either an appropriate blocktxn message, or a full block message. A blocktxn response MUST contain exactly and only each transaction which is present in the appropriate block at the index specified in the getblocktxn indexes list, in the order requested.\n\n====blocktxn====\n# The blocktxn message is defined as a message containing a serialized BlockTransactions message and pchCommand == \"blocktxn\".\n# Upon receipt of a properly-formatted requested blocktxn message, nodes SHOULD attempt to reconstruct the full block by:\n## Taking the prefilledtxn transactions from the original cmpctblock and placing them in the marked positions.\n## For each short transaction ID from the original cmpctblock, in order, find the corresponding transaction either from the blocktxn message or from other sources and place it in the first available position in the block.\n# Once the block has been reconstructed, it shall be processed as normal, keeping in mind that short transaction IDs are expected to occasionally collide, and that nodes MUST NOT be penalized for such collisions, wherever they appear.\n\n==Protocol Versioning==\n# The protocol version negotiation allows two nodes to agree on the versions of compact blocks which they will exchange. As it is only in a single field, it does not allow a node to support a specific version in only one direction (sending or receiving).\n# Upon connection establishment, a node SHOULD send a burst of sendcmpct messages containing every version of compact block encodings for which they are willing to support sending cmpctblock and blocktxn messages, and receiving getblocktxn messages. These messages SHOULD be ordered in the order of the priority which the node wishes to receive cmpctblock/blocktxn messages, with the highest-priority version sendcmpct message sent first.\n# The encoding version used to send a cmpctblock or blocktxn message or to receive a getblocktxn message MUST be the second integer (version number) in the first sendcmpct message received for which a sendcmpct message with the same version number was sent.\n# Nodes MUST NOT send a sendcmpct message which contains a version number other than the version number which has been negotiated for receiving cmpctblock/blocktxn messages after sending a request for a MSG_CMPCT_BLOCK object, sending a cmpctblock, getblocktxn, blocktxn, or pong message.\n# As a node must send all sendcmpct messages which contain a novel version announcement before any other compact block-related messages, it is possible to determine which version of compact blocks will be used for each object received. It is, however, not possible to know which version will be used to encode the response to a request for a compact block object before any MSG_CMPCT_BLOCK-containing getdata, cmpctblock, getblocktxn, blocktxn, or ping/pong messages have been exchanged.\n# Thus, if a node wishes to determine exactly which version of compact blocks will be used before requesting a compact block object, it must send all of its sendcmpct version announcements, followed by a ping, and wait for the pong response to ensure it has received all sendcmpctblock version announcement messages from the remote peer. Nodes can, obviously, however, determine that the version used will be at least a certain version (in their priority order) after having received a sendcmpct message from the remote peer containing that version as the second integer.\n\n===Sample Version Implementation===\n# By way of example, an implementation of the above protocol might look like the following.\n# Upon exchanging version/verack messages, a node immediately sends its list of sendcmpct announcements to the other side, with the version which it wants to receive sent first.\n# Upon receiving the first sendcmpct announcement with a protocol version which is understood from the remote peer, a node will \"lock in\" the compact block encoding version which will be used to encode compact blocks to that peer.\n# The node then sets the current receive-protocol-version in use on the connection to that version, and uses it to decode new compact block messages.\n# Upon receiving subsequent sendcmpct announcements with a protocol version which is understood from the remote peer (ie a version which has been announced using a sendcmpct in the other direction), a node will check if that protocol version is higher-receive-priority than the current receive-protocol-version in use on the connection, and switch to that version for decoding new compact block messages received.\n# A node might wish to keep a flag for each peer which indicates compact block version negotiation is complete, which can be set upon receiving any compact block-related, or pong message.\n# The above implementation requires only a compile-time list of supported versions in some static priority order, two version fields per peer, and an optional negotiation-complete boolean per-peer.\n\n==Specification for version 2==\nCompact blocks version 2 is almost identical to version 1, but supports segregated witness transactions (BIP 141 and BIP 144). The changes are:\n\n# The second integer (version number) inside sendcmpct is 2 instead of 1 (see Protocol Versioning section, above).\n# Transactions inside cmpctblock messages (both those used as direct announcement and those in response to getdata) and in blocktxn should include witness data, using the same format as responses to getdata MSG_WITNESS_TX, specified in BIP144.\n# Short transaction IDs sent to us in cmpctblock messages, and sent by us in getblocktxn messages, are computed using the same process as in version 1, but using the wtxid as defined in BIP 141 instead of the txid. Note that, though a node normally SHOULD, if a node does not include (ie must then include the short ID for) the coinbase transaction, it must be computed by encoding the transaction in witness format as defined by BIP 141.\n# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object for which a cmpctblock message is not sent in response, the block message containing the requested block in non-compact form MUST be encoded with witnesses (as is sent in reply to a MSG_WITNESS_BLOCK getdata) if the protocol version used to encode the cmpctblock message would have been 2, and encoded without witnesses (as is sent in response to a MSG_BLOCK getdata) if the protocol version used to encode the cmpctblock message would have been 1.\n\n==Implementation Notes==\n# For nodes which have sufficient inbound bandwidth, sending a sendcmpct message with the first integer set to 1 to up to 3 peers is RECOMMENDED. If possible, it is RECOMMENDED that those peers be selected based on their past performance in providing blocks quickly (eg the three peers which provided the highest number of the recent N blocks the quickest), allowing nodes to receive blocks which come from those peers in only 0.5*RTT.\n\n# Nodes MUST NOT send such sendcmpct messages to more than three peers, as it encourages wasting outbound bandwidth across the network.\n\n# All nodes SHOULD send a sendcmpct message to all appropriate peers. This will reduce their outbound bandwidth usage by allowing their peers to request compact blocks instead of full blocks.\n\n# Nodes with limited inbound bandwidth SHOULD request blocks using MSG_CMPCT_BLOCK/getblocktxn requests, when possible. While this increases worst-case message round-trips, it is expected to reduce overall transfer latency as TCP is more likely to exhibit poor throughput on low-bandwidth nodes.\n\n# Nodes sending cmpctblock messages SHOULD limit prefilledtxn to 10KB of transactions. When in doubt, nodes SHOULD only include the coinbase transaction in prefilledtxn.\n\n# Nodes MAY pick one nonce per block they wish to send, and only build a cmpctblock message once for all peers which they wish to send a given block to. Nodes SHOULD NOT use the same nonce across multiple different blocks.\n\n# Nodes MAY impose additional requirements on when they announce new blocks by sending cmpctblock messages. For example, nodes with limited outbound bandwidth MAY choose to announce new blocks using inv/header messages (as per BIP130) to conserve outbound bandwidth.\n\n# Note that the MSG_CMPCT_BLOCK section does not require that nodes respond to MSG_CMPCT_BLOCK getdata requests for blocks which they did not recently announce. This allows nodes to calculate cmpctblock messages at announce-time instead of at request-time. Blocks which are requested with a MSG_CMPCT_BLOCK getdata, but which are not responded to with a cmpctblock message MUST be responded to with a block message, allowing nodes to request all blocks using MSG_CMPCT_BLOCK getdatas and rely on their peer to pick an appropriate response.\n\n# While the current version sends transactions with the same encodings as are used in tx messages and elsewhere in the protocol, the version field in sendcmpct is intended to allow this to change in the future. For this reason, it is recommended that the code used to decode PrefilledTransaction and BlockTransactions messages be prepared to take a different transaction encoding, if and when the version field in sendcmpct changes in a future BIP.\n\n# Any undefined behavior in this spec may cause failure to transfer block to, peer disconnection by, or self-destruction by the receiving node. A node receiving non-minimally-encoded CompactSize encodings should make a best-effort to eat the sender's cat.\n\n===Pre-Validation Relay and Consistency Considerations===\n\n# As high-bandwidth mode permits relaying of CMPCTBLOCK messages prior to full validation (requiring only that the block header is valid before relay), nodes SHOULD NOT ban a peer for announcing a new block with a CMPCTBLOCK message that is invalid, but has a valid header.  For avoidance of doubt, nodes SHOULD bump their peer-to-peer protocol version to 70015 or higher to signal that they will not ban or punish a peer for announcing compact blocks prior to full validation, and nodes SHOULD NOT announce a CMPCTBLOCK to a peer with a version number below 70015 before fully validating the block.\n\n# SPV nodes which implement this spec must consider the implications of accepting blocks which were not validated by the node which provided them. Especially SPV nodes which allow users to select a \"trusted full node\" to sync from may wish to avoid implementing this spec in high-bandwidth mode.\n\n# Note that this spec does not change the requirement that nodes only relay information about blocks which they have fully validated in response to GETDATA/GETHEADERS/GETBLOCKS/etc requests. Nodes which announce using CMPCTBLOCK message and then receive a request for associated block data SHOULD ensure that messages do not go unresponded to, and that the appropriate data is provided after the block has been validated, subject to standard message-response ordering requirements. Note that no requirement is added that the node respond to the request with the new block included in eg GETHEADERS or GETBLOCKS messages, but the node SHOULD re-announce the block using the associated announcement methods after validation has completed if it is not included in the original response. On the other hand, nodes SHOULD delay responding to GETDATA requests for the block until validation has completed, stalling all message processing for the associated peer. REJECT messages are not considered \"responses\" for the purpose of this section.\n\n# As a result of the above requirements, implementers may wish to consider the potential for the introduction of delays in responses while remote peers validate blocks, avoiding delay-causing requests where possible.\n\n==Justification==\n\n====Protocol design====\nThere have been many proposals to save wire bytes when relaying blocks. Many of them have a two-fold goal of reducing block relay time and thus rely on the use of significant processing power in order to avoid introducing additional worst-case RTTs. Because this work is not focused primarily on reducing block relay time, its design is much simpler (ie does not rely on set reconciliation protocols). Still, in testing at the time of writing, nodes are able to relay blocks without the extra getblocktxn/blocktxn RTT around 90% of the time. With a smart compact-block-announcement policy, it is thus expected that this work might allow blocks to be relayed between nodes in 0.5*RTT instead of 1.5*RTT at least 75% of the time.\n\n====Short transaction ID calculation====\n\nThere are several design goals for the Short ID calculation:\n* '''Performance''' The sender needs to compute short IDs for all block transactions, and the receiver for all mempool transactions they are being compared to. As we're easily talking about several thousand transactions, sub-microsecond processing per-transactions is needed.\n* '''Space''' cmpctblock messages are never optional in this protocol, and contain a short ID for each non-prefilled transaction in the block. Thus, the size of short IDs is directly proportional to the maximum bandwidth savings possible.\n* '''Collision resistance''' It should be hard for network participants to create transactions that cause collisions. If an attacker were able to cause such collisions, filling mempools (and, thus, blocks) with them would cause poor network propagation of new (or non-attacker, in the case of a miner) blocks.\n\nSipHash is a secure, fast, and simple 64-bit MAC designed for network traffic authentication and collision-resistant hash tables. We truncate the output from SipHash-2-4 to 48 bits (see next section) in order to minimize space. The resulting 48-bit hash is certainly not large enough to avoid intentionally created individual collisions, but by using the block hash as a key to SipHash, an attacker cannot predict what keys will be used once their transactions are actually included in a relayed block. We mix in a per-connection 64-bit nonce to obtain independent short IDs on every connection, so that even block creators cannot control where collisions occur, and random collisions only ever affect a small number of connections at any given time. The mixing is done using SHA256(block_header || nonce), which is slow compared to SipHash, but only done once per block. It also adds the ability for nodes to choose the nonce in a better than random way to minimize collisions, though that is not necessary for correct behaviour. Conversely, nodes can also abuse this ability to increase their ability to introduce collisions in the blocks they relay themselves. However, they can already cause more problems by simply refusing to relay blocks. That is inevitable, and this design only seeks to prevent network-wide misbehavior.\n\n====Random collision probability====\n\nThanks to the block-header-based SipHash keys, we can assume that the only collisions on links between honest nodes are random ones.\n\nFor each of the ''t'' block transactions, the receiver will compare its received short ID with that of a set of ''m'' mempool transactions. We assume that each of those ''t'' has a chance ''r'' to be included in that set of ''m''. If we use ''B'' bits short IDs, for each comparison between a received short ID and a mempool transaction, there is a chance of ''P = 1 - 1 / 2^B'' that a mismatch is detected as such.\n\nWhen comparing a given block transaction to the whole set of mempool transactions, there are 5 cases to distinguish:\n# The receiver has exactly one match, which is the correct one. This has chance ''r * P^(m - 1)''.\n# The receiver has no matches. This has chance ''(1 - r) * P^m''.\n# The receiver has at least two matches, one of which is correct. This has chance ''r * (1 - P^(m - 1))''.\n# The receiver has at least two matches, both of which are incorrect. This has chance ''(1 - r) * (1 - P^m - m * (1 - P) * P^(m - 1))''.\n# The receiver has exactly one match, but an incorrect one. This has chance ''(1 - r) * m * (1 - P) * P^(m - 1)''.\n\n(note that these 5 numbers always add up to 100%)\n\nIn case 1, we're good. In cases 2, 3, or 4, we request the full transaction because we know we're uncertain. Only in case 5, we fail to reconstruct. The chance that case 5 does not occur in any of the ''t'' transactions in a block is ''(1 - (1 - r) * m * (1 - P) * P^(m - 1))^t''. This expression is well approximated by ''1 - (1 - r) * m * (1 - P) * t'' = ''1 - (1 - r) * m * t / 2^B''. Thus, if we want only one in F block transmissions between honest nodes to fail under the conservative ''r = 0'' assumption, we need ''log2(F * m * t)'' bits hash functions.\n\nThis means that ''B = 48'' bits short IDs suffice for blocks with up to ''t = 10000'' transactions, mempools up to ''m = 100000'' transactions, with failure to reconstruct at most one in ''F = 281474'' blocks. Since failure to reconstruct just means we fall back to normal inv/header based relay, it isn't necessary to avoid such failure completely. It just needs to be sufficiently rare they have a lower impact than random transmission failures (for example, network disconnection, node overloaded, ...).\n\n====Separate version for segregated witness====\n\nThe changes to transaction and block relay in BIP 144 introduce separate MSG_FILTERED_ versions of messages in getdata,\nallowing a receiver to choose individually where witness data is wanted.\n\nThis method is not useful for compact blocks because `cmpctblock` blocks can be sent unsolicitedly in high-bandwidth\nmode, so we need to negotiate at least whether those should include witness data up front. There is little use for a\nvalidating node that only sometimes processes witness data, so we may as well use that negotiation for everything and\nturn it into a separate protocol version. We also need a means to distinguish different versions of the same transaction\nwith different witnesses for correct reconstruction, so this also forces us to use wtxids instead of txids for short IDs\neverywhere in that case.\n\n==Backward compatibility==\n\nOlder clients remain fully compatible and interoperable after this change.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/8068 for version 1.\nhttps://github.com/bitcoin/bitcoin/pull/8393 for version 2.\n\n==Acknowledgements==\n\nThanks to Gregory Maxwell for the initial suggestion as well as a lot of back-and-forth design and significant testing.\nThanks to Nicolas Dorier for the protocol flow diagram.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 31003}
{"bip_number": 151, "filename": "bip-0151.mediawiki", "content": "<pre>\n  BIP: 151\n  Layer: Peer Services\n  Title: Peer-to-Peer Communication Encryption\n  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n  Comments-Summary: Controversial; some recommendation, and some discouragement\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0151\n  Status: Replaced\n  Type: Standards Track\n  Created: 2016-03-23\n  License: PD\n  Superseded-By: 324\n</pre>\n\n== Abstract ==\n\nThis BIP describes an alternative way that a peer can encrypt their communication between a selective subset of remote peers.\n\n== Motivation ==\n\n\nThe Bitcoin network does not encrypt communication between peers today. This opens up security issues (eg: traffic manipulation by others) and allows for mass surveillance / analysis of bitcoin users. Mostly this is negligible because of the nature of Bitcoin's trust model, however, for SPV nodes this can have significant privacy impacts [1] and could reduce the censorship-resistance of a peer.\n\nEncrypting peer traffic will make analysis and specific user targeting much more difficult than it currently is. Today it's trivial for a network provider or any other men-in-the-middle to identify a Bitcoin user and its controlled addresses/keys (and link with his Google profile, etc.). Just created and broadcasted transactions will reveal the amount and the payee to the network provider.\n\nThis BIP also describes a way that data manipulation (blocking commands by a intercepting TCP/IP node) would be identifiable by the communicating peers.\n\nAnalyzing the type of p2p communication would still be possible because of the characteristics (size, sending-interval, etc.) of the encrypted messages.\n\nEncrypting traffic between peers is already possible with VPN, tor, stunnel, curveCP or any other encryption mechanism on a deeper OSI level, however, most mechanisms are not practical for SPV or other DHCP/NAT environment and will require significant knowhow in how to setup such a secure channel.\n\n== Specification ==\n\nA peer that supports encryption must accept encryption requests from all peers.\n\nAn independent ECDH negotiation for both communication directions is required and therefore a bidirectional communication will use two symmetric cipher keys (one per direction).\n\nBoth peers must only send encrypted messages after a successful ECDH negotiation in ''both directions''.\n\nEncryption initialization must happen before sending any other messages to the responding peer (<code>encinit</code> message after a <code>version</code> message must be ignored).\n\n=== Symmetric Encryption Cipher Keys ===\n\nThe symmetric encryption cipher keys will be calculated with ECDH/HKDF by sharing the pubkeys of an ephemeral key. Once the ECDH secret is calculated on each side, the symmetric encryption cipher keys must be derived with HKDF [2] after the following specification:\n\n1. HKDF extraction\n<code>PRK = HKDF_EXTRACT(hash=SHA256, salt=\"bitcoinecdh\", ikm=ecdh_secret|cipher-type)</code>.\n\n2. Derive Key1\n<code>K_1 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK1\", L=32)</code>\n\n3. Derive Key2\n<code>K_2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinK2\", L=32)</code>\n\nIt is important to include the cipher-type into the symmetric cipher key derivation to avoid weak-cipher-attacks.\n\n=== Session ID ===\n\nBoth sides must also calculate the 256bit session-id using <code>SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info=\"BitcoinSessionID\", L=32)</code>. The session-id can be used for linking the encryption-session to an identity check.\n\n=== The <code>encinit</code> message type ===\n\nTo request encrypted communication, the requesting peer generates an EC ephemeral-session-keypair and sends an <code>encinit</code> message to the responding peer and waits for an <code>encack</code> message. The responding node must do the same <code>encinit</code>/<code>encack</code> interaction for the opposite communication direction.\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 33bytes || ephemeral-pubkey || comp.-pubkey || The session pubkey from the requesting peer\n|-\n| 1bytes || symmetric key cipher type  || int8 || symmetric key cipher type to use\n|}\n\nPossible symmetric key ciphers types\n{|class=\"wikitable\"\n! Number !! symmetric key ciphers type\n|-\n| 0 || chacha20-poly1305@openssh.com\n|}\n\n=== ChaCha20-Poly1305 Cipher Suite ===\n\nChaCha20 is a stream cipher designed by Daniel Bernstein [3]. It operates by permuting 128 fixed bits, 128 or 256 bits of key,\na 64 bit nonce and a 64 bit counter into 64 bytes of output. This output is used as a keystream, with any unused bytes simply discarded.\n\nPoly1305, also by Daniel Bernstein [4], is a one-time Carter-Wegman MAC that computes a 128 bit integrity tag given a message and a single-use\n256 bit secret key.\n\nThe chacha20-poly1305@openssh.com specified and defined by openssh [5] combines these two primitives into an authenticated encryption mode. The construction used is based on that proposed for TLS by Adam Langley [6], but differs in the layout of data passed to the MAC and in the addition of encryption of the packet lengths.\n\n<code>K_1</code> must be used to only encrypt the payload size of the encrypted message to avoid leaking information by revealing the message size.\n\n<code>K_2</code> must be used in conjunction with poly1305 to build an AEAD.\n\nOptimized implementations of ChaCha20-Poly1305 are very fast in general, therefore it is very likely that encrypted messages require less CPU cycles per byte than the current unencrypted p2p message format. A quick analysis by Pieter Wuille of the current ''standard implementations'' has shown that SHA256 requires more CPU cycles per byte than ChaCha20 & Poly1304.\n\n=== The <code>encack</code> message type ===\n\nThe responding peer accepts the encryption request by sending an <code>encack</code> message.\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 33bytes || ephemeral-pubkey || comp.-pubkey || The session pubkey from the responding peer\n|}\n\nAt this point, the shared secret key for the symmetric key cipher must be calculated by using ECDH (own privkey x remote pub key).\nPrivate keys will never be transmitted. The shared secret can only be calculated if an attacker knows at least one private key and the remote peer's public key.\n\n* '''The <code>encinit</code>/<code>encack</code> interaction must be done from both sides.'''\n* Each communication direction uses its own secret key for the symmetric cipher.\n* The second <code>encinit</code> request (from the responding peer) must use the same symmetric cipher type.\n* All unencrypted messages before the second <code>encack</code> response (from the responding peer) must be ignored.\n* After a successful <code>encinit</code>/<code>encack</code> interaction, the \"encrypted messages structure\" must be used. Non-encrypted messages from the requesting peer must lead to a connection termination.\n\nAfter a successful <code>encinit</code>/<code>encack</code> interaction from both sides, the messages format must use the \"encrypted messages structure\". Non-encrypted messages from the requesting peer must lead to a connection termination (can be detected by the 4 byte network magic in the unencrypted message structure).\n\n=== Encrypted Messages Structure  ===\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 4 || length || uint32_t || Length of ciphertext payload in number of bytes\n|-\n| ? || ciphertext payload || ? || One or many ciphertext command & message data\n|-\n| 16 || MAC tag || ? || 128bit MAC-tag\n|}\n\nEncrypted messages do not have the 4byte network magic.\n\nThe maximum message length needs to be chosen carefully. The 4 byte length field can lead to a required message buffer of 4 GiB.\nProcessing the message before the authentication succeeds must not be done.\n\nThe 4byte sha256 checksum is no longer required because the AEAD.\n\nBoth peers need to track the message sequence number (uint32) of sent messages to the remote peer for building a 64 bit symmetric cipher IV. Sequence numbers are allowed to overflow to zero after 4294967295 (2^32-1).\n\nThe encrypted payload will result decrypted in one or many unencrypted messages:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| ? || command || varlen || ASCII string identifying the packet content, we are using varlen in the encrypted messages.\n|-\n| 4 || length || uint32_t || Length of plaintext payload\n|-\n| ? || payload || ? || The actual data\n|}\nIf more data is present, another message must be deserialized. There is no explicit amount-of-messages integer.\n\n\n=== Re-Keying ===\n\nA responding peer can inform the requesting peer over a re-keying with an <code>encack</code> message containing 33byte of zeros to indicate that all encrypted message following after this <code>encack</code> message will be encrypted with ''the next symmetric cipher key''.\n\nThe new symmetric cipher key will be calculated by <code>SHA256(SHA256(session_id || old_symmetric_cipher_key))</code>.\n\nRe-Keying interval is a peer policy with a minimum timespan of 10 seconds.\n\nThe Re-Keying must be done after every 1GB of data sent or received (recommended by RFC4253 SSH Transport).\n\n=== Risks ===\n\nThe encryption does not include an identity authentication scheme. This BIP does not cover a proposal to avoid MITM attacks during the encryption initialization.\n\nIdentity authentication will be covered in another BIP and will presume communication encryption after this BIP.\n\n== Compatibility ==\n\nThis proposal is backward compatible. Non-supporting peers will ignore the <code>encinit</code> messages.\n\n== Reference implementation ==\n\n== References ==\n\n* [1] https://e-collection.library.ethz.ch/eserv/eth:48205/eth-48205-01.pdf\n* [2] HKDF (RFC 5869) https://tools.ietf.org/html/rfc5869\n* [3] ChaCha20 https://cr.yp.to/chacha/chacha-20080128.pdf\n* [4] Poly1305 https://cr.yp.to/mac/poly1305-20050329.pdf\n* [5] https://github.com/openssh/openssh-portable/blob/05855bf2ce7d5cd0a6db18bc0b4214ed5ef7516d/PROTOCOL.chacha20poly1305\n* [6] \"ChaCha20 and Poly1305 based Cipher Suites for TLS\", Adam Langley https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03\n\n== Acknowledgements ==\n* Pieter Wuille and Gregory Maxwell for most of the ideas in this BIP.\n\n== Copyright ==\nThis work is placed in the public domain.\n\n\n", "content_length": 10326}
{"bip_number": 150, "filename": "bip-0150.mediawiki", "content": "<pre>\n  BIP: 150\n  Layer: Peer Services\n  Title: Peer Authentication\n  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n  Comments-Summary: Discouraged for implementation (one person)\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0150\n  Status: Deferred\n  Type: Standards Track\n  Created: 2016-03-23\n  License: PD\n</pre>\n\n== Abstract ==\n\nThis BIP describes a way for peers to authenticate to other peers to guarantee node ownership and/or allow peers to access additional or limited node services, without the possibility of fingerprinting.\n\n== Motivation ==\n\nWe assume peer operators want to limit the access of different node services or increase datastream priorities to a selective subset of peers. Also we assume that peers want to connect to specific peers to broadcast or filter transactions (or similar actions that reveal sensitive information) and therefore operators want to authenticate the remote peer and ensure that they have not connected to a MITM (man-in-the-middle) attacker.\n\nBenefits of peer authentication:\n* Peers can detect MITM attacks when connecting to known peers\n* Peers can allow resource hungry transaction filtering only to specific peers\n* Peers can allow access to sensitive information that can lead to node fingerprinting (fee estimation)\n* Peers can allow custom message types (private extensions) to authenticated peers\n\nA simple authentication scheme based on elliptic cryptography will allow peers to identify each other and selectively allow access to restricted services or reject the connection if the peer identity cannot be verified.\n\n== Specification ==\n\nThe authentication scheme proposed in this BIP uses ECDSA, '''secrets will never be transmitted'''.\n\n'''Authentication initialization must only happen if encrypted channels have been established (according to BIP-151 [1]).'''\n\nThe '''encryption-session-ID''' is available once channels are encrypted (according to BIP-151 [1]).\n\nThe identity-public-keys used for the authentication must be pre-shared over a different channel (mail/PGP, physical paper exchange, etc.). This BIP does not cover a \"trust on first use\" (TOFU) concept.\n\nThe authentication state must be kept until the encryption/connection terminates.\n\nOnly one authentication process is allowed per connection. Re-authentication require re-establishing the connection.\n\n=== Known-peers and authorized-peers database ===\nEach peer that supports p2p authentication must provide two user-editable \"databases\".\n\n# '''known-peers''' contains known identity-public-keys together with a network identifier (IP & port), similar to the \"known-host\" file supported by openssh.\n# '''authorized-peers''' contains authorized identity-public-keys\n\n=== Local identity key management ===\nEach peer can configure multiple identity-keys (ECC, 32 bytes). Peers should make sure that each network interface (IPv4, IPv6, tor) has its own identity-key (otherwise it would be possible to link a tor address to a IPvX address).\nThe identity-public-key(s) can be shared over a different channel with other node-operators (or non-validating clients) to grant authorized access.\n\n=== Authentication procedure ===\nAuthentication based on this BIP will require both sides to authenticate. Signatures/public-keys will only be revealed if the remote peer can prove that they already know the remote identity-public-key.\n\n# -> Requesting peer sends <code>AUTHCHALLENGE</code> (hash)\n# <- Responding peer sends <code>AUTHREPLY</code> (signature)\n# -> Requesting peer sends <code>AUTHPROPOSE</code> (hash)\n# <- Responding peer sends <code>AUTHCHALLENGE</code> (hash)\n# -> Requesting peer sends <code>AUTHREPLY</code> (signature)\n\nFor privacy reasons, dropping the connection or aborting during the authentication process must not be allowed.\n\n=== <code>AUTHCHALLENGE</code> message ===\nA peer can send an authentication challenge to see if the responding peer can produce a valid signature with the expected responding peer's identity-public-key by sending an <code>AUTHCHALLENGE</code>-message to the remote peer.\n\nThe responding peer needs to check if the hash matches the hash calculated with his own local identity-public-key. Fingerprinting the requesting peer is not possible.\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 32bytes || challenge-hash || hash || <code>hash(encryption-session-ID || challenge_type || remote-peers-expected-identity-public-key)</code>\n|}\n\n\n<code>challenge_type</code> is a single character. <code>i</code> if the <code>AUTHCHALLENGE</code>-message is the first, requesting challenge or <code>r</code> if it's the second, remote peers challenge message.\n\n=== <code>AUTHREPLY</code> message ===\nA peer must reply an <code>AUTHCHALLENGE</code>-message with an <code>AUTHREPLY</code>-message.\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 64bytes || signature || normalized comp.-signature || A signature of the encryption-session-ID done with the identity-key\n|}\n\nIf the challenge-hash from the <code>AUTHCHALLENGE</code>-message did not match the local authentication public-key, the signature must contain 64 bytes of zeros.\n\nThe requesting peer can check the responding peer's identity by checking the validity of the sent signature against with the pre-shared remote peers identity-public-key.\n\nIf the signature was invalid, the requesting peer must still proceed with the authentication by sending an <code>AUTHPROPOSE</code>-message with 32 random bytes.\n\n=== <code>AUTHPROPOSE</code> message ===\nA peer can propose authentication of the channel by sending an <code>AUTHPROPOSE</code>-message to the remote peer.\n\nIf the signature sent in <code>AUTHREPLY</code> was invalid, the peer must still send an <code>AUTHPROPOSE</code>-message containing 32 random bytes.\n\nThe <code>AUTHPROPOSE</code> message must be answered with an <code>AUTHCHALLENGE</code>-message - even if the proposed requesting-peers identity-public-key has not been found in the authorized-peers database. In case of no match, the responding <code>AUTHCHALLENGE</code>-message must contains 32 bytes of zeros.\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 32bytes || auth-propose-hash || hash || <code>hash(encryption-session-ID || \"p\" || identity-public-key)</code>\n|}\n\n== Post-Authentication Re-Keying ==\n\nAfter the second <code>AUTHREPLY</code> message (requesting peer's signature -> responding peer), both clients must re-key the symmetric encryption according to BIP151 while using '''a slightly different re-key key derivation hash'''.\n\nBoth peers re-key with <code>hash(encryption-session-ID || old_symmetric_cipher_key || requesting-peer-identity-public-key || responding-peer-identity-public-key)</code>\n\n== Identity-Addresses ==\nThe peers should display/log the identity-public-key as an identity-address to the users, which is a base58-check encoded ripemd160(sha256) hash. The purpose of this is for better visual comparison (logs, accept-dialogs).\nThe base58check identity byte is <code>0x0F</code> followed by an identity-address version number (=<code>0xFF01</code>).\n\nAn identity address would look like <code>TfG4ScDgysrSpodWD4Re5UtXmcLbY5CiUHA</code> and can be interpreted as a remote peer's fingerprint.\n\n== Compatibility ==\n\nThis proposal is backward compatible. Non-supporting peers will ignore the new <code>AUTH*</code> messages.\n\n== Example of an auth interaction ==\n\nBefore authentication (once during peer setup or upgrade)\n# Requesting peer and responding peer create each an identity-keypair (standard ECC priv/pubkey)\n# Requesting and responding peer share the identity-public-key over a different channel (mail/PGP, physical paper exchange, etc.)\n# Responding peer stores requesting peers identity-public-key in its authorized-peers database (A)\n# Requesting peer stores responding peers identity-public-key in its known-peers database together with its IP and port (B)\n\nEncryption\n# Encrypted channels must be established (according to BIP-151 [1])\n\nAuthentication\n# Requesting peer sends an <code>AUTHCHALLENGE</code> message\n  AUTHCHALLENGE:\n    [32 bytes, hash(encryption-session-ID || \"i\" || <remote-peers-expected-identity-public-key>)]\n\n# Responding peer does create the same hash <code>(encryption-session-ID || \"i\" || <remote-peers-expected-identity-public-key>)</code> with its local identity-public-key\n# If the hash does not match, response with an <code>AUTHREPLY</code> message containing 64bytes of zeros.\n# In case of a match, response with an <code>AUTHREPLY</code> message\n  AUTHREPLY:\n    [64 bytes normalized compact ECDSA signature (H)] (sig of the encryption-session-ID done with the identity-key)\n\n# Requesting peer does verify the signature with the <code>remote-peers-identity-public-key</code>\n# If the signature is invalid, requesting peer answers with an <code>AUTHREPLY</code> message containing 32 random bytes\n# In case of a valid signature, requesting peer sends an <code>AUTHPROPOSE</code> message\n  AUTHPROPOSE:\n    [32 bytes, hash(encryption-session-ID || \"p\" || <client-identity-public-key>)]\n\n# Responding peer iterates over authorized-peers database (A), hashes the identical data and looks for a match.\n# If the hash does not match, responding peer answer with an <code>AUTHCHALLENGE</code> message containing 32 bytes of zeros.\n# In case of a match, responding peer sends an <code>AUTHCHALLENGE</code> message with the hashed client public-key\n  AUTHCHALLENGE:\n    [32 bytes, hash(encryption-session-ID || \"r\" || <client-identity-public-key>)]\n# Requesting peer sends an <code>AUTHREPLY</code> message containing 64 bytes of zeros if server failed to authenticate\n# Otherwise, response with signature in the <code>AUTHREPLY</code> message\n  AUTHREPLY:\n    [64 bytes normalized compact ECDSA signature (H)] (sig of the encryption-session-ID done with the identity-key)\n# Responding peer must verify the signature and can grant access to restricted services.\n# Both peers re-key the encryption after BIP151 including the requesting-peer-identity-public-key and responding-peer-identity-public-key\n\n== Disadvantages ==\n\nThe protocol may be slow if a peer has a large authorized-peers database due to the requirement of iterating and hashing over all available authorized peer identity-public-keys.\n\n== Reference implementation ==\n\n== References ==\n\n* [1] [[bip-0151.mediawiki|BIP 151: Peer-to-Peer Communication Encryption]]\n\n== Acknowledgements ==\n* Gregory Maxwell and Pieter Wuille for most of the ideas in this BIP.\n* Bryan Bishop for editing.\n\n== Copyright ==\nThis work is placed in the public domain.\n", "content_length": 10630}
{"bip_number": 149, "filename": "bip-0149.mediawiki", "content": "<pre>\n  BIP: 149\n  Layer: Consensus (soft fork)\n  Title: Segregated Witness (second deployment)\n  Author: Shaolin Fry <shaolinfry@protonmail.ch>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0149\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2017-04-14\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies a user activated soft fork for [[bip-0141.mediawiki|BIP141]], [[bip-0143.mediawiki|BIP143]] and [[bip-0147.mediawiki|BIP147]] using versionbits with guaranteed lock-in.\n\n==Motivation==\n\nMiners have been reluctant to signal the BIP9 segwit deployment despite a large portion of the Bitcoin ecosystem who want the soft fork activated. This BIP specifies a user activated soft fork (UASF) that deploys segwit again using versionbits with guaranteed lock-in on timeout if the BIP is not already locked-in or activated by the timeout. This ensures users have sufficient time to prepare and no longer require a miner supermajority, while still allowing for an earlier miner activated soft fork (MASF).\n\n==Reference implementation==\n\nThe reference implementation will refuse to run on Bitcoin mainnet before 7 November 2017, and can only be run on testnet and regtest until then.\n\nhttps://github.com/bitcoin/bitcoin/compare/master...shaolinfry:uasegwit-flagday\n\n==Specification==\n\nThis deployment will set service bit (1<<5) as NODE_UAWITNESS.\n\n==Deployment==\n\nThis BIP should only be deployed if BIP9-segwit fails to lock-in or activate before timeout on 15 November 2017. This BIP cannot be deployed before 15 November 2017.\n\nThis BIP will be deployed by BIP8 with the name \"segwit\" and using bit 1.\n\nFor Bitcoin mainnet, the BIP8 starttime will be midnight 16 November 2017 UTC (Epoch timestamp 1510790400) and BIP8 timeout will be 4 July 2018 UTC (Epoch timestamp 1530662400).\n\nFor Bitcoin testnet, segwit is already activated so no deployment is specified.\n\n==Backwards Compatibility==\n\nThis deployment reuses the GBT deployment name \"segwit\" to maintain compatibility with existing mining software.\n\nThis deployment is incompatible with the BIP9-segwit deployment and should not be run concurrently with it.\n\n==Rationale==\n\nThe '''starttime''' of this BIP is after the BIP9-segwit timeout to remove compatibility issues with old nodes.\n\n==References==\n\n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/014234.html Mailing list discussion]\n\n[[bip-0008.mediawiki|BIP8]]\n\n[[bip-0009.mediawiki|BIP9]]\n\n[[bip-0141.mediawiki|BIP141]]\n\n[[bip-0143.mediawiki|BIP143]]\n\n[[bip-0147.mediawiki|BIP147]]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n", "content_length": 2720}
{"bip_number": 148, "filename": "bip-0148.mediawiki", "content": "<pre>\n  BIP: 148\n  Layer: Consensus (soft fork)\n  Title: Mandatory activation of segwit deployment\n  Author: Shaolin Fry <shaolinfry@protonmail.ch>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0148\n  Status: Final\n  Type: Standards Track\n  Created: 2017-03-12\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies a BIP16 like soft fork flag day activation of the segregated witness BIP9 deployment known as \"segwit\".\n\n==Definitions==\n\n\"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment using bit 1, between November 15th 2016 and November 15th 2017 to activate BIP141, BIP143 and BIP147.\n\n==Motivation==\n\nSegwit increases the blocksize, fixes transaction malleability, and makes scripting easier to upgrade as well as bringing many other [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n\nIt is hoped that miners will respond to this BIP by activating segwit early, before this BIP takes effect. Otherwise this BIP will cause the mandatory activation of the existing segwit deployment before the end of midnight November 15th 2017.\n\n==Specification==\n\nAll times are specified according to median past time.\n\nThis BIP will be active between midnight August 1st 2017 (epoch time 1501545600) and midnight November 15th 2017 (epoch time 1510704000) if the existing segwit deployment is not locked-in or activated before epoch time 1501545600. This BIP will cease to be active when segwit is locked-in.\n\nWhile this BIP is active, all blocks must set the nVersion header top 3 bits to 001 together with bit field (1<<1) (according to the existing segwit deployment). Blocks that do not signal as required will be rejected.\n\n=== Reference implementation ===\n\n<pre>\n// Check if Segregated Witness is Locked In\nbool IsWitnessLockedIn(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n{\n    LOCK(cs_main);\n    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_LOCKED_IN);\n}\n\n// BIP148 mandatory segwit signalling.\nint64_t nMedianTimePast = pindex->GetMedianTimePast();\nif ( (nMedianTimePast >= 1501545600) &&  // Tue 01 Aug 2017 00:00:00 UTC\n     (nMedianTimePast <= 1510704000) &&  // Wed 15 Nov 2017 00:00:00 UTC\n     (!IsWitnessLockedIn(pindex->pprev, chainparams.GetConsensus()) &&  // Segwit is not locked in\n      !IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) )   // and is not active.\n{\n    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n    bool fSegbit = (pindex->nVersion & VersionBitsMask(chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT)) != 0;\n    if (!(fVersionBits && fSegbit)) {\n        return state.DoS(0, error(\"ConnectBlock(): relayed block must signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n    }\n}\n</pre>\n\nhttps://github.com/bitcoin/bitcoin/compare/master...shaolinfry:bip-segwit-flagday\n\n==Backwards Compatibility==\n\nThis deployment is compatible with the existing \"segwit\" bit 1 deployment scheduled between midnight November 15th, 2016 and midnight November 15th, 2017.\n\n==Rationale==\n\nHistorically, the P2SH soft fork (BIP16) was activated using a predetermined flag day where nodes began enforcing the new rules. P2SH was successfully activated with relatively few issues\n\nBy orphaning non-signalling blocks during the last month of the BIP9 bit 1 \"segwit\" deployment, this BIP can cause the existing \"segwit\" deployment to activate without needing to release a new deployment.\n\n==References==\n\n*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html Mailing list discussion]\n*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283 P2SH flag day activation]\n*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for Version 0 Witness Program]]\n*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n\n", "content_length": 4337}
{"bip_number": 147, "filename": "bip-0147.mediawiki", "content": "<pre>\n  BIP: 147\n  Layer: Consensus (soft fork)\n  Title: Dealing with dummy stack element malleability\n  Author: Johnson Lau <jl2012@xbt.hk>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0147\n  Status: Final\n  Type: Standards Track\n  Created: 2016-09-02\n  License: PD\n</pre>\n\n==Abstract==\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules to fix a malleability vector in the extra stack element consumed by <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code>.\n\n\n==Motivation==\n\nSignature malleability refers to the ability of any relay node on the network to transform the signature in transactions, with no access to the relevant private keys required. For non-segregated witness transactions, signature malleability will change the <code>txid</code> and invalidate any unconfirmed child transactions. Although the <code>txid</code> of segregated witness ([https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141]) transactions is not third party malleable, this malleability vector will change the <code>wtxid</code> and may reduce the efficiency of compact block relay ([https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki BIP152]).\n\nA design flaw in <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> causes them to consume an extra stack element (\"dummy element\") after signature validation. The dummy element is not inspected in any manner, and could be replaced by any value without invalidating the script. This document specifies a new rule to fix this signature malleability.\n\n\n==Specification==\n\nTo fix the dummy element malleability, a new consensus rule (\"<code>NULLDUMMY</code>\") is deployed to require that the dummy element MUST be the empty byte array. Anything else makes the script evaluate to false immediately. The <code>NULLDUMMY</code> rule applies to <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> in pre-segregated scripts, and also pay-to-witness-script-hash scripts described in BIP141.\n\n\n==Deployment==\n\nThis BIP will be deployed by \"version bits\" [https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki BIP9] using the same parameters for BIP141 and BIP143, with the name \"segwit\" and using bit 1.\n\nFor Bitcoin mainnet, the BIP9 starttime is midnight 15 November 2016 UTC (Epoch timestamp 1479168000) and BIP9 timeout is midnight 15 November 2017 UTC (Epoch timestamp 1510704000).\n\nFor Bitcoin testnet, the BIP9 starttime is midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout is midnight 1 May 2017 UTC (Epoch timestamp 1493596800).\n\n\n==Compatibility==\n\nThe reference client has produced compatible signatures from the beginning, and the <code>NULLDUMMY</code> rule has been enforced as relay policy by the reference client since v0.10.0. There has been no transactions violating the requirement being added to the chain since at least August 2015.\n\nFor all scriptPubKey types in actual use, non-compliant signatures can trivially be converted into compliant ones, so there is no loss of functionality by this requirement. Users MUST pay extra attention to this new rule when designing exotic scripts.\n\n\n==Implementation==\n\nAn implementation for the reference client is available at https://github.com/bitcoin/bitcoin/pull/8636\n\n\n==Acknowledgements==\n\nPeter Todd is the original author of NULLDUMMY. This document is extracted from the previous [https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki BIP62] proposal, which was composed by Pieter Wuille and had input from various people.\n\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 3692}
{"bip_number": 146, "filename": "bip-0146.mediawiki", "content": "<pre>\n  BIP: 146\n  Layer: Consensus (soft fork)\n  Title: Dealing with signature encoding malleability\n  Author: Johnson Lau <jl2012@xbt.hk>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0146\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2016-08-16\n  License: PD\n</pre>\n\n==Abstract==\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules to fix signature malleability related to ECDSA signature encoding.\n\n\n==Motivation==\n\nSignature malleability refers to the ability of any relay node on the network to transform the signature in transactions, with no access to the relevant private keys required. For non-segregated witness transactions, signature malleability will change the <code>txid</code> and invalidate any unconfirmed child transactions. Although the <code>txid</code> of segregated witness ([https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141]) transactions is not third party malleable, this malleability vector will change the <code>wtxid</code> and may reduce the efficiency of compact block relay ([https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki BIP152]).\n\nSince the enforcement of Strict DER signatures ([https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki BIP66]), there are 2 remaining known sources of malleability in ECDSA signatures:\n\n# '''Inherent ECDSA signature malleability''': ECDSA signatures are inherently malleable as taking the negative of the number S inside (modulo the curve order) does not invalidate it.\n\n# '''Malleability of failing signature''': If a signature failed to validate in <code>OP_CHECKSIG</code> or <code>OP_CHECKMULTISIG</code>, a <code>FALSE</code> would be returned to the stack and the script evaluation would continue. The failing signature may take any value, as long as it follows all the rules described in BIP66.\n\nThis document specifies new rules to fix the aforesaid signature malleability.\n\n\n==Specification==\n\nTo fix signature encoding malleability, the following new rules are applied to pre-segregated witness and segregated witness scripts:\n\n\n===LOW_S===\n\nWe require that the S value inside ECDSA signatures is at most the curve order divided by 2 (essentially restricting this value to its lower half range). Every signature passed to <code>OP_CHECKSIG</code><ref>Including pay-to-witness-public-key-hash (P2WPKH) described in BIP141</ref>, <code>OP_CHECKSIGVERIFY</code>, <code>OP_CHECKMULTISIG</code>, or <code>OP_CHECKMULTISIGVERIFY</code>, to which ECDSA verification is applied, MUST use a S value between <code>0x1</code> and <code>0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0</code> (inclusive) with strict DER encoding (see [https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki BIP66]).\n\nIf a signature passing to ECDSA verification does not pass the Low S value check and is not an empty byte array, the entire script evaluates to false immediately.\n\nA high S value in signature could be trivially replaced by <code>S' = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S</code>.\n\n\n===NULLFAIL===\n\nIf an <code>OP_CHECKSIG</code> is trying to return a <code>FALSE</code> value to the stack, we require that the relevant signature must be an empty byte array.\n\nIf an <code>OP_CHECKMULTISIG</code> is trying to return a <code>FALSE</code> value to the stack, we require that all signatures passing to this <code>OP_CHECKMULTISIG</code> must be empty byte arrays, even the processing of some signatures might have been skipped due to early termination of the signature verification.\n\nOtherwise, the entire script evaluates to false immediately.\n\n\n==Examples==\n\nThe following examples are the combined results of the LOW_S and NULLFAIL rules.<ref>Please note that due to implementation details in reference client v0.13.1, some signatures with S value higher than the half curve order might pass the LOW_S test. However, such signatures are certainly invalid, and will fail later due to NULLFAIL test.</ref>\n\nNotation:\n\n  CO       : curve order = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141\n  HCO      : half curve order = CO / 2 = 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0\n  P1, P2   : valid, serialized, public keys\n  S1L, S2L : valid low S value signatures using respective keys P1 and P2 (1 \u2264 S \u2264 HCO)\n  S1H, S2H : signatures with high S value (otherwise valid) using respective keys P1 and P2 (HCO < S < CO)\n  F        : any BIP66-compliant non-empty byte array but not a valid signature\n\nThese scripts will return a <code>TRUE</code> to the stack as before:\n\n  S1L P1 CHECKSIG\n  0 S1L S2L 2 P1 P2 2 CHECKMULTISIG\n\nThese scripts will return a <code>FALSE</code> to the stack as before:\n\n  0 P1 CHECKSIG\n  0 0 0 2 P1 P2 2 CHECKMULTISIG\n\nThese previously <code>TRUE</code> scripts will fail immediately under the new rules:\n\n  S1H P1 CHECKSIG\n  0 S1H S2L 2 P1 P2 2 CHECKMULTISIG\n  0 S1L S2H 2 P1 P2 2 CHECKMULTISIG\n  0 S1H S2H 2 P1 P2 2 CHECKMULTISIG\n\nThese previously <code>FALSE</code> scripts will fail immediately under the new rules:\n\n  F P1 CHECKSIG\n  0 S2L S1L 2 P1 P2 2 CHECKMULTISIG\n  0 S1L F   2 P1 P2 2 CHECKMULTISIG\n  0 F   S2L 2 P1 P2 2 CHECKMULTISIG\n  0 S1L 0   2 P1 P2 2 CHECKMULTISIG\n  0 0   S2L 2 P1 P2 2 CHECKMULTISIG\n  0 F   0   2 P1 P2 2 CHECKMULTISIG\n  0 0   F   2 P1 P2 2 CHECKMULTISIG\n\n\n==Deployment==\n\nThis BIP will be deployed by \"version bits\" [https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki BIP9]. Details TBD.\n\nFor Bitcoin mainnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).\n\nFor Bitcoin testnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).\n\n\n==Compatibility==\n\nThe reference client has produced LOW_S compatible signatures since v0.9.0, and the LOW_S rule has been enforced as relay policy by the reference client since v0.11.1. As of August 2016, very few transactions violating the requirement are being added to the chain. For all scriptPubKey types in actual use, non-compliant signatures can trivially be converted into compliant ones, so there is no loss of functionality by these requirements.\n\nScripts with failing <code>OP_CHECKSIG</code> or <code>OP_CHECKMULTISIG</code> rarely happen on the chain. The NULLFAIL rule has been enforced as relay policy by the reference client since v0.13.1.\n\nUsers MUST pay extra attention to these new rules when designing exotic scripts.\n\n\n==Implementation==\n\nImplementations for the reference client is available at:\n\nhttps://github.com/bitcoin/bitcoin/blob/35fe0393f216aa6020fc929272118eade5628636/src/script/interpreter.cpp#L185\n\nand\n\nhttps://github.com/bitcoin/bitcoin/pull/8634\n\n\n==Footnotes==\n\n<references />\n\n\n==Acknowledgements==\n\nThis document is extracted from the previous [https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki BIP62] proposal which had input from various people.\n\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 7221}
{"bip_number": 145, "filename": "bip-0145.mediawiki", "content": "<pre>\n  BIP: 145\n  Layer: API/RPC\n  Title: getblocktemplate Updates for Segregated Witness\n  Author: Luke Dashjr <luke+bip22@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0145\n  Status: Final\n  Type: Standards Track\n  Created: 2016-01-30\n  License: BSD-2-Clause\n           OPL\n</pre>\n\n==Abstract==\n\nThis BIP describes modifications to the getblocktemplate JSON-RPC call ([[bip-0022.mediawiki|BIP 22]]) to support segregated witness as defined by [[bip-0141.mediawiki|BIP 141]].\n\n==Specification==\n\n===Block Template===\n\nThe template Object is revised to include a new key:\n\n{| class=\"wikitable\"\n!colspan=4| template\n|-\n! Key !! Required !! Type !! Description\n|-\n| weightlimit || No || Number || total weight allowed in blocks\n|}\n\nThe '!' rule prefix MUST be enabled on the \"segwit\" rule for templates including transactions with witness data.\nIn particular, note that even if the client's \"rules\" list lacks \"segwit\", server MAY support old miners by producing a witness-free template and omitting the '!' rule prefix for \"segwit\" in the template's \"rules\" list.\nIf the GBT server does not support producing witness-free templates after its activation, it must also use the '!' rule prefix in the \"vbavailable\" list prior to activation.\n\n====Transactions Object Format====\n\nThe Objects listed in the response's \"transactions\" key is revised to include these keys:\n\n{| class=\"wikitable\"\n!colspan=3|template \"transactions\" element\n|-\n! Key !! Type !! Description\n|-\n| txid || String || transaction id encoded in hexadecimal; required for transactions with witness data\n|-\n| weight || Number || numeric weight of the transaction, as counted for purposes of the block's weightlimit; if key is not present, weight is unknown and clients MUST NOT assume it is zero, although they MAY choose to calculate it themselves\n|-\n| hash || String || reversed hash of complete transaction (with witness data included) encoded in hexadecimal\n|}\n\nTransactions with witness data may only be included if the template's \"rules\" list (see [[bip-0009.mediawiki#getblocktemplate_changes|BIP 9]]) includes \"segwit\".\n\n===Sigops===\n\nFor templates with \"segwit\" enabled as a rule, the \"sigoplimit\" and \"sigops\" keys must use the new values as calculated in [[bip-0141.mediawiki#Sigops|BIP 141]].\n\n===Block Assembly with Witness Transactions===\n\nWhen block assembly is done without witness transactions, no changes are made by this BIP, and it should be assembled as previously.\n\nWhen witness transactions are included in the block, the primary merkle root MUST be calculated with those transactions' \"txid\" field instead of \"hash\". A secondary merkle root MUST be calculated as per [[bip-0141.mediawiki#Commitment_structure|BIP 141's commitment structure specification]] to be inserted into the generation (coinbase) transaction.\n\nServers MUST NOT include a commitment in the \"coinbasetxn\" key on the template. Clients MUST insert the commitment as an additional output at the end of the final generation (coinbase) transaction. Only if the template includes a \"mutable\" key (see [[bip-0023.mediawiki#Mutations|BIP 23 Mutations]]) including \"generation\", the client MAY in that case place the commitment output in any position it chooses, provided that no later output matches the commitment pattern.\n\n==Motivation==\n\nSegregated witness substantially changes the structure of blocks, so the previous getblocktemplate specification is no longer sufficient.\nIt additionally also adds a new way of counting resource limits, and so GBT must be extended to convey this information correctly as well.\n\n==Rationale==\n\nWhy doesn't \"weightlimit\" simply redefine the existing \"sizelimit\"?\n* \"sizelimit\" is already enforced by clients by counting the sum of bytes in transactions' \"data\" keys.\n* Servers may wish to limit the overall size of a block, independently from the \"weight\" of the block.\n\nWhy is \"sigoplimit\" redefined instead of a new \"sigopweightlimit\" being added?\n* The old limit was already arbitrarily defined, and could not be counted by clients on their own anyway. The concept of \"sigop weight\" is merely a change in the arbitrary formula used.\n\nWhy is \"sigoplimit\" divided by 4?\n* To resemble the previous values. (FIXME: is this a good reason? maybe we shouldn't divide it?)\n\nWhy is the witness commitment required to be added to the end of the generation transaction rather than anywhere else?\n* Servers which do not allow modification of the generation outputs ought to be checking this as part of the validity of submissions. By requiring a specific placement, they can simply strip the commitment and do a byte-for-byte comparison of the outputs. Placing it at the end avoids the possibility of a later output matching the pattern and overriding it.\n\nWhy shouldn't the server simply add the commitment upfront in the \"coinbasetxn\", and simply send the client stripped transaction data?\n* It would become impossible for servers to specify only \"coinbasevalue\", since clients would no longer have the information required to construct the commitment.\n* getblocktemplate is intended to be a *decentralised* mining protocol, and allowing clients to be blinded to the content of the block works contrary to that purpose.\n* BIP 23's \"transactions\" mutations allow the client to modify the transaction-set on their own, which is impossible without the complete transaction data.\n\n==Reference Implementation==\n\n* [https://github.com/bitcoin/libblkmaker/tree/segwit libblkmaker]\n* [https://github.com/luke-jr/eloipool/tree/segwit Eloipool]\n* [https://github.com/bitcoin/bitcoin/pull/7404/files Bitcoin Core]\n\n==See Also==\n* [[bip-0009.mediawiki|BIP 9: Version bits with timeout and delay]]\n* [[bip-0022.mediawiki|BIP 22: getblocktemplate - Fundamentals]]\n* [[bip-0023.mediawiki|BIP 23: getblocktemplate - Pooled Mining]]\n* [[bip-0141.mediawiki|BIP 141: Segregated Witness (Consensus layer)]]\n\n==Copyright==\n\nThis BIP is dual-licensed under the Open Publication License and BSD 2-clause license.\n", "content_length": 6041}
{"bip_number": 144, "filename": "bip-0144.mediawiki", "content": "<pre>\n  BIP: 144\n  Layer: Peer Services\n  Title: Segregated Witness (Peer Services)\n  Author: Eric Lombrozo <elombrozo@gmail.com>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0144\n  Status: Final\n  Type: Standards Track\n  Created: 2016-01-08\n  License: PD\n</pre>\n\n==Abstract==\nThis BIP defines new messages and serialization formats for propagation of transactions and blocks committing to segregated witness structures.\n\n==Motivation==\nIn addition to defining witness structures and requiring commitments in future blocks ([https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141] - Consensus segwit BIP), new mechanisms must be defined to allow peers to advertise support for segregated witness and to relay the witness structures and request them from other peers without breaking compatibility with older nodes.\n\n==Specification==\n\n=== Serialization ===\nA new serialization format for tx messages is added to the peer-to-peer protocol.\n\nThe serialization has the following structure:\n\n{| class=\"wikitable\" style=\"width: auto; text-align: center; font-size: smaller; table-layout: fixed;\"\n!Field Size\n!Name\n!Type\n!Description\n|-\n| 4\n| version\n| int32_t\n| Transaction data format version\n|-\n| 1\n| marker\n| char\n| Must be zero\n|-\n| 1\n| flag\n| char\n| Must be nonzero\n|-\n| 1+\n| txin_count\n| var_int\n| Number of transaction inputs\n|-\n| 41+\n| txins\n| txin[]\n| A list of one or more transaction inputs\n|-\n| 1+\n| txout_count\n| var_int\n| Number of transaction outputs\n|-\n| 9+\n| txouts\n| txouts[]\n| A list of one or more transaction outputs\n|-\n| 1+\n| script_witnesses\n| script_witnesses[]\n| The witness structure as a serialized byte array\n|-\n| 4\n| lock_time\n| uint32_t\n| The block number or timestamp until which the transaction is locked\n|}\n\nParsers supporting this BIP will be able to distinguish between the old serialization format (without the witness) and this one. The marker byte is set to zero so that this structure will never parse as a valid transaction in a parser that does not support this BIP. If parsing were to succeed, such a transaction would contain no inputs and a single output.\n\nIf the witness is empty, the old serialization format must be used.\n\nCurrently, the only witness objects type supported are script witnesses which consist of a stack of byte arrays. It is encoded as a var_int item count followed by each item encoded as a var_int length followed by a string of bytes. Each txin has its own script witness. The number of script witnesses is not explicitly encoded as it is implied by txin_count. Empty script witnesses are encoded as a zero byte. The order of the script witnesses follows the same order as the associated txins.\n\n* '''Rationale for not having an independent message type with its own serialization''': this would require separate \"tx\" and \"block\" messages, and all RPC calls operating on raw transactions would need to be duplicated, or need inefficient or nondeterministic guesswork to know which type is to be used.\n\n* '''Rationale for not using just a single 0x00 byte as marker''': that would lead to empty transactions (no inputs, no outputs, which are used in some tests) to be interpreted as new serialized data.\n\n* '''Rationale for the 0x01 flag byte in between''': this will allow us to easily add more extra non-committed data to transactions (like txouts being spent, ...). It can be interpreted as a bitvector.\n\n=== Handshake ===\nA node will signal that it can provide witnesses using the following service bit\n\n    NODE_WITNESS = (1 << 3)\n\t\n\n=== Hashes ===\nTransaction hashes used in the transaction merkle tree and txin outpoints are always computed using the old non-witness\nserialization.\n\nSupport for a new hash including the witness data is added that is\ncomputed from the new witness serialization. (Note that transactions\nwith an empty witness always use the old serialization,\nand therefore, they have witness hash equal to normal hash.)\n\n<img src=bip-0144/witnesstx.png></img>\n\n=== Relay ===\nNew inv types MSG_WITNESS_TX (0x40000001, or (1<<30)+MSG_TX) and MSG_WITNESS_BLOCK (0x40000002, or (1<<30)+MSG_BLOCK) are added, only\nfor use in getdata. Inventory messages themselves still use just MSG_TX and MSG_BLOCK,\nsimilar to MSG_FILTERED_BLOCK. A further inv type MSG_FILTERED_WITNESS_BLOCK (0x40000003, or (1<<30)+MSG_FILTERED_BLOCK) is reserved for future use.\n\n* '''Rationale for not advertizing witnessness in invs''': we don't always use invs anymore (with 'sendheaders' BIP 130), plus it's not useful: implicitly, every transaction and block have a witness, old ones just have empty ones.\n\nMSG_WITNESS_TX getdata requests should use the non-witness serialized hash. The peer shall respond with a tx message, and if the witness structure is nonempty, the witness serialization shall be used.\n\nMSG_WITNESS_BLOCK requests will return a block message with transactions that have a witness using witness serialization.\n\n== Credits ==\nSpecial thanks to Gregory Maxwell for originating many of the ideas in this BIP and Luke-Jr for figuring out how to deploy this as a soft fork.\n\n== Reference Implementation ==\nhttps://github.com/bitcoin/bitcoin/pull/8149\n\n== Copyright ==\nThis document is placed in the public domain.\n", "content_length": 5308}
{"bip_number": 143, "filename": "bip-0143.mediawiki", "content": "<pre>\n  BIP: 143\n  Layer: Consensus (soft fork)\n  Title: Transaction Signature Verification for Version 0 Witness Program\n  Author: Johnson Lau <jl2012@xbt.hk>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0143\n  Status: Final\n  Type: Standards Track\n  Created: 2016-01-03\n  License: PD\n</pre>\n\n== Abstract ==\nThis proposal defines a new transaction digest algorithm for signature verification in version 0 witness program, in order to minimize redundant data hashing in verification, and to cover the input value by the signature.\n\n== Motivation ==\nThere are 4 ECDSA signature verification codes in the original Bitcoin script system: <code>CHECKSIG</code>, <code>CHECKSIGVERIFY</code>, <code>CHECKMULTISIG</code>, <code>CHECKMULTISIGVERIFY</code> (\u201csigops\u201d). According to the sighash type (<code>ALL</code>, <code>NONE</code>, <code>SINGLE</code>, <code>ANYONECANPAY</code>), a transaction digest is generated with a double SHA256 of a serialized subset of the transaction, and the signature is verified against this digest with a given public key. The detailed procedure is described in a Bitcoin Wiki article. <ref name=wiki>[https://en.bitcoin.it/wiki/OP_CHECKSIG]</ref>\n\nUnfortunately, there are at least 2 weaknesses in the original SignatureHash transaction digest algorithm:\n\n* For the verification of each signature, the amount of data hashing is proportional to the size of the transaction. Therefore, data hashing grows in O(n<sup>2</sup>) as the number of sigops in a transaction increases. While a 1 MB block would normally take 2 seconds to verify with an average computer in 2015, a 1MB transaction with 5569 sigops may take 25 seconds to verify. This could be fixed by optimizing the digest algorithm by introducing some reusable \u201cmidstate\u201d, so the time complexity becomes O(n). <ref>[https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2292 CVE-2013-2292]</ref><ref>[https://bitcointalk.org/?topic=140078 New Bitcoin vulnerability: A transaction that takes at least 3 minutes to verify]</ref><ref>[http://rusty.ozlabs.org/?p=522 The Megatransaction: Why Does It Take 25 Seconds?]</ref>\n* The algorithm does not involve the amount of Bitcoin being spent by the input. This is usually not a problem for online network nodes as they could request for the specified transaction to acquire the output value. For an offline transaction signing device (\"cold wallet\"), however, the unknowing of input amount makes it impossible to calculate the exact amount being spent and the transaction fee. To cope with this problem a cold wallet must also acquire the full transaction being spent, which could be a big obstacle in the implementation of lightweight, air-gapped wallet. By including the input value of part of the transaction digest, a cold wallet may safely sign a transaction by learning the value from an untrusted source. In the case that a wrong value is provided and signed, the signature would be invalid and no funding might be lost. <ref>[https://bitcointalk.org/index.php?topic=181734.0 SIGHASH_WITHINPUTVALUE: Super-lightweight HW wallets and offline data]</ref>\n\nDeploying the aforementioned fixes in the original script system is not a simple task. That would be either a hardfork, or a softfork for new sigops without the ability to remove or insert stack items. However, the introduction of segregated witness softfork offers an opportunity to define a different set of script semantics without disrupting the original system, as the unupgraded nodes would always consider such a transaction output is spendable by arbitrary signature or no signature at all. <ref>[https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141: Segregated Witness (Consensus layer)]</ref>\n\n== Specification ==\nA new transaction digest algorithm is defined, but only applicable to sigops in version 0 witness program:\n  Double SHA256 of the serialization of:\n     1. nVersion of the transaction (4-byte little endian)\n     2. hashPrevouts (32-byte hash)\n     3. hashSequence (32-byte hash)\n     4. outpoint (32-byte hash + 4-byte little endian)\n     5. scriptCode of the input (serialized as scripts inside CTxOuts)\n     6. value of the output spent by this input (8-byte little endian)\n     7. nSequence of the input (4-byte little endian)\n     8. hashOutputs (32-byte hash)\n     9. nLocktime of the transaction (4-byte little endian)\n    10. sighash type of the signature (4-byte little endian)\n\nSemantics of the original sighash types remain unchanged, except the following:\n# The way of serialization is changed;\n# All sighash types commit to the amount being spent by the signed input;\n# <code>FindAndDelete</code> of the signature is not applied to the <code>scriptCode</code>;\n# <code>OP_CODESEPARATOR</code>(s) after the last executed <code>OP_CODESEPARATOR</code> are not removed from the <code>scriptCode</code> (the last executed <code>OP_CODESEPARATOR</code> and any script before it are always removed);\n# <code>SINGLE</code> does not commit to the input index. When <code>ANYONECANPAY</code> is not set, the semantics are unchanged since <code>hashPrevouts</code> and <code>outpoint</code> together implicitly commit to the input index. When <code>SINGLE</code> is used with <code>ANYONECANPAY</code>, omission of the index commitment allows permutation of the input-output pairs, as long as each pair is located at an equivalent index.\n\nThe items 1, 4, 7, 9, 10 have the same meaning as the original algorithm. <ref name=wiki></ref>\n\nThe item 5:\n*For <code>P2WPKH</code> witness program, the <code>scriptCode</code> is <code>0x1976a914{20-byte-pubkey-hash}88ac</code>.\n*For <code>P2WSH</code> witness program,\n**if the <code>witnessScript</code> does not contain any <code>OP_CODESEPARATOR</code>, the <code>scriptCode</code> is the <code>witnessScript</code> serialized as scripts inside <code>CTxOut</code>.\n**if the <code>witnessScript</code> contains any <code>OP_CODESEPARATOR</code>, the <code>scriptCode</code> is the <code>witnessScript</code> but removing everything up to and including the last executed <code>OP_CODESEPARATOR</code> before the signature checking opcode being executed, serialized as scripts inside <code>CTxOut</code>. (The exact semantics is demonstrated in the examples below)\n\nThe item 6 is a 8-byte value of the amount of bitcoin spent in this input.\n\n<code>hashPrevouts</code>:\n*If the <code>ANYONECANPAY</code> flag is not set, <code>hashPrevouts</code> is the double SHA256 of the serialization of all input outpoints;\n*Otherwise, <code>hashPrevouts</code> is a <code>uint256</code> of <code>0x0000......0000</code>.\n\n<code>hashSequence</code>:\n*If none of the <code>ANYONECANPAY</code>, <code>SINGLE</code>, <code>NONE</code> sighash type is set, <code>hashSequence</code> is the double SHA256 of the serialization of <code>nSequence</code> of all inputs;\n*Otherwise, <code>hashSequence</code> is a <code>uint256</code> of <code>0x0000......0000</code>.\n\n<code>hashOutputs</code>:\n*If the sighash type is neither <code>SINGLE</code> nor <code>NONE</code>, <code>hashOutputs</code> is the double SHA256 of the serialization of all output amount (8-byte little endian) with <code>scriptPubKey</code> (serialized as scripts inside CTxOuts);\n*If sighash type is <code>SINGLE</code> and the input index is smaller than the number of outputs, <code>hashOutputs</code> is the double SHA256 of the output amount with <code>scriptPubKey</code> of the same index as the input;\n*Otherwise, <code>hashOutputs</code> is a <code>uint256</code> of <code>0x0000......0000</code>.<ref>In the original algorithm, a <code>uint256</code> of <code>0x0000......0001</code> is committed if the input index for a <code>SINGLE</code> signature is greater than or equal to the number of outputs. In this BIP a <code>0x0000......0000</code> is committed, without changing the semantics.</ref>\n\nThe <code>hashPrevouts</code>, <code>hashSequence</code>, and <code>hashOutputs</code> calculated in an earlier verification may be reused in other inputs of the same transaction, so that the time complexity of the whole hashing process reduces from O(n<sup>2</sup>) to O(n).\n\nRefer to the reference implementation, reproduced below, for the precise algorithm:\n\n<source lang=\"cpp\">\n  uint256 hashPrevouts;\n  uint256 hashSequence;\n  uint256 hashOutputs;\n\n  if (!(nHashType & SIGHASH_ANYONECANPAY)) {\n      CHashWriter ss(SER_GETHASH, 0);\n      for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n          ss << txTo.vin[n].prevout;\n      }\n      hashPrevouts = ss.GetHash();\n  }\n\n  if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n      CHashWriter ss(SER_GETHASH, 0);\n      for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n          ss << txTo.vin[n].nSequence;\n      }\n      hashSequence = ss.GetHash();\n  }\n\n  if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n      CHashWriter ss(SER_GETHASH, 0);\n      for (unsigned int n = 0; n < txTo.vout.size(); n++) {\n          ss << txTo.vout[n];\n      }\n      hashOutputs = ss.GetHash();\n  } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {\n      CHashWriter ss(SER_GETHASH, 0);\n      ss << txTo.vout[nIn];\n      hashOutputs = ss.GetHash();\n  }\n\n  CHashWriter ss(SER_GETHASH, 0);\n  // Version\n  ss << txTo.nVersion;\n  // Input prevouts/nSequence (none/all, depending on flags)\n  ss << hashPrevouts;\n  ss << hashSequence;\n  // The input being signed (replacing the scriptSig with scriptCode + amount)\n  // The prevout may already be contained in hashPrevout, and the nSequence\n  // may already be contained in hashSequence.\n  ss << txTo.vin[nIn].prevout;\n  ss << static_cast<const CScriptBase&>(scriptCode);\n  ss << amount;\n  ss << txTo.vin[nIn].nSequence;\n  // Outputs (none/one/all, depending on flags)\n  ss << hashOutputs;\n  // Locktime\n  ss << txTo.nLockTime;\n  // Sighash type\n  ss << nHashType;\n\n  return ss.GetHash();\n</source>\n\n== Restrictions on public key type ==\nAs a default policy, only compressed public keys are accepted in <code>P2WPKH</code> and <code>P2WSH</code>. Each public key passed to a sigop inside version 0 witness program must be a compressed key: the first byte MUST be either <code>0x02</code> or <code>0x03</code>, and the size MUST be 33 bytes. Transactions that break this rule will not be relayed or mined by default.\n\nSince this policy is preparation for a future softfork proposal, to avoid potential future funds loss, users MUST NOT use uncompressed keys in version 0 witness programs.\n\n== Example ==\n\nTo ensure consistency in consensus-critical behaviour, developers should test their implementations against all the tests below. More tests related to this proposal could be found under https://github.com/bitcoin/bitcoin/tree/master/src/test/data .\n\n=== Native P2WPKH ===\n\n  The following is an unsigned transaction:\n    0100000002fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f0000000000eeffffffef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a0100000000ffffffff02202cb206000000001976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac9093510d000000001976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac11000000\n\n    nVersion:  01000000\n    txin:      02 fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f 00000000 00 eeffffff\n                  ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a 01000000 00 ffffffff\n    txout:     02 202cb20600000000 1976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac\n                  9093510d00000000 1976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac\n    nLockTime: 11000000\n\n  The first input comes from an ordinary P2PK:\n    scriptPubKey : 2103c9f4836b9a4f77fc0d81f7bcb01b7f1b35916864b9476c241ce9fc198bd25432ac value: 6.25\n    private key  : bbc27228ddcb9209d7fd6f36b02f7dfa6252af40bb2f1cbc7a557da8027ff866\n\n  The second input comes from a P2WPKH witness program:\n    scriptPubKey : 00141d0f172a0ecb48aee1be1f2687d2963ae33f71a1, value: 6\n    private key  : 619c335025c7f4012e556c2a58b2506e30b8511b53ade95ea316fd8c3286feb9\n    public key   : 025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee6357\n\n  To sign it with a nHashType of 1 (SIGHASH_ALL):\n\n  hashPrevouts:\n    dSHA256(fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f00000000ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a01000000)\n  = 96b827c8483d4e9b96712b6713a7b68d6e8003a781feba36c31143470b4efd37\n\n  hashSequence:\n    dSHA256(eeffffffffffffff)\n  = 52b0a642eea2fb7ae638c36f6252b6750293dbe574a806984b8e4d8548339a3b\n\n  hashOutputs:\n    dSHA256(202cb206000000001976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac9093510d000000001976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac)\n  = 863ef3e1a92afbfdb97f31ad0fc7683ee943e9abcf2501590ff8f6551f47e5e5\n\n  hash preimage: 0100000096b827c8483d4e9b96712b6713a7b68d6e8003a781feba36c31143470b4efd3752b0a642eea2fb7ae638c36f6252b6750293dbe574a806984b8e4d8548339a3bef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a010000001976a9141d0f172a0ecb48aee1be1f2687d2963ae33f71a188ac0046c32300000000ffffffff863ef3e1a92afbfdb97f31ad0fc7683ee943e9abcf2501590ff8f6551f47e5e51100000001000000\n\n    nVersion:     01000000\n    hashPrevouts: 96b827c8483d4e9b96712b6713a7b68d6e8003a781feba36c31143470b4efd37\n    hashSequence: 52b0a642eea2fb7ae638c36f6252b6750293dbe574a806984b8e4d8548339a3b\n    outpoint:     ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a01000000\n    scriptCode:   1976a9141d0f172a0ecb48aee1be1f2687d2963ae33f71a188ac\n    amount:       0046c32300000000\n    nSequence:    ffffffff\n    hashOutputs:  863ef3e1a92afbfdb97f31ad0fc7683ee943e9abcf2501590ff8f6551f47e5e5\n    nLockTime:    11000000\n    nHashType:    01000000\n\n  sigHash:      c37af31116d1b27caf68aae9e3ac82f1477929014d5b917657d0eb49478cb670\n  signature:    304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee01\n\n  The serialized signed transaction is: 01000000000102fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f00000000494830450221008b9d1dc26ba6a9cb62127b02742fa9d754cd3bebf337f7a55d114c8e5cdd30be022040529b194ba3f9281a99f2b1c0a19c0489bc22ede944ccf4ecbab4cc618ef3ed01eeffffffef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a0100000000ffffffff02202cb206000000001976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac9093510d000000001976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac000247304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee0121025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee635711000000\n\n    nVersion:  01000000\n    marker:    00\n    flag:      01\n    txin:      02 fff7f7881a8099afa6940d42d1e7f6362bec38171ea3edf433541db4e4ad969f 00000000 494830450221008b9d1dc26ba6a9cb62127b02742fa9d754cd3bebf337f7a55d114c8e5cdd30be022040529b194ba3f9281a99f2b1c0a19c0489bc22ede944ccf4ecbab4cc618ef3ed01 eeffffff\n                  ef51e1b804cc89d182d279655c3aa89e815b1b309fe287d9b2b55d57b90ec68a 01000000 00 ffffffff\n    txout:     02 202cb20600000000 1976a9148280b37df378db99f66f85c95a783a76ac7a6d5988ac\n                  9093510d00000000 1976a9143bde42dbee7e4dbe6a21b2d50ce2f0167faa815988ac\n    witness    00\n               02 47304402203609e17b84f6a7d30c80bfa610b5b4542f32a8a0d5447a12fb1366d7f01cc44a0220573a954c4518331561406f90300e8f3358f51928d43c212a8caed02de67eebee01 21025476c2e83188368da1ff3e292e7acafcdb3566bb0ad253f62fc70f07aeee6357\n    nLockTime: 11000000\n\n=== P2SH-P2WPKH ===\n\n\n  The following is an unsigned transaction: 0100000001db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a54770100000000feffffff02b8b4eb0b000000001976a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac0008af2f000000001976a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac92040000\n\n    nVersion:  01000000\n    txin:      01 db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477 01000000 00 feffffff\n    txout:     02 b8b4eb0b00000000 1976a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac\n                  0008af2f00000000 1976a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac\n    nLockTime: 92040000\n\n  The input comes from a P2SH-P2WPKH witness program:\n    scriptPubKey : a9144733f37cf4db86fbc2efed2500b4f4e49f31202387, value: 10\n    redeemScript : 001479091972186c449eb1ded22b78e40d009bdf0089\n    private key  : eb696a065ef48a2192da5b28b694f87544b30fae8327c4510137a922f32c6dcf\n    public key   : 03ad1d8e89212f0b92c74d23bb710c00662ad1470198ac48c43f7d6f93a2a26873\n\n  To sign it with a nHashType of 1 (SIGHASH_ALL):\n\n  hashPrevouts:\n    dSHA256(db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a547701000000)\n  = b0287b4a252ac05af83d2dcef00ba313af78a3e9c329afa216eb3aa2a7b4613a\n\n  hashSequence:\n    dSHA256(feffffff)\n  = 18606b350cd8bf565266bc352f0caddcf01e8fa789dd8a15386327cf8cabe198\n\n  hashOutputs:\n    dSHA256(b8b4eb0b000000001976a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac0008af2f000000001976a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac)\n  = de984f44532e2173ca0d64314fcefe6d30da6f8cf27bafa706da61df8a226c83\n\n  hash preimage: 01000000b0287b4a252ac05af83d2dcef00ba313af78a3e9c329afa216eb3aa2a7b4613a18606b350cd8bf565266bc352f0caddcf01e8fa789dd8a15386327cf8cabe198db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477010000001976a91479091972186c449eb1ded22b78e40d009bdf008988ac00ca9a3b00000000feffffffde984f44532e2173ca0d64314fcefe6d30da6f8cf27bafa706da61df8a226c839204000001000000\n\n    nVersion:     01000000\n    hashPrevouts: b0287b4a252ac05af83d2dcef00ba313af78a3e9c329afa216eb3aa2a7b4613a\n    hashSequence: 18606b350cd8bf565266bc352f0caddcf01e8fa789dd8a15386327cf8cabe198\n    outpoint:     db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a547701000000\n    scriptCode:   1976a91479091972186c449eb1ded22b78e40d009bdf008988ac\n    amount:       00ca9a3b00000000\n    nSequence:    feffffff\n    hashOutputs:  de984f44532e2173ca0d64314fcefe6d30da6f8cf27bafa706da61df8a226c83\n    nLockTime:    92040000\n    nHashType:    01000000\n\n  sigHash:      64f3b0f4dd2bb3aa1ce8566d220cc74dda9df97d8490cc81d89d735c92e59fb6\n  signature:    3044022047ac8e878352d3ebbde1c94ce3a10d057c24175747116f8288e5d794d12d482f0220217f36a485cae903c713331d877c1f64677e3622ad4010726870540656fe9dcb01\n\n  The serialized signed transaction is: 01000000000101db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477010000001716001479091972186c449eb1ded22b78e40d009bdf0089feffffff02b8b4eb0b000000001976a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac0008af2f000000001976a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac02473044022047ac8e878352d3ebbde1c94ce3a10d057c24175747116f8288e5d794d12d482f0220217f36a485cae903c713331d877c1f64677e3622ad4010726870540656fe9dcb012103ad1d8e89212f0b92c74d23bb710c00662ad1470198ac48c43f7d6f93a2a2687392040000\n    nVersion:  01000000\n    marker:    00\n    flag:      01\n    txin:      01 db6b1b20aa0fd7b23880be2ecbd4a98130974cf4748fb66092ac4d3ceb1a5477 01000000 1716001479091972186c449eb1ded22b78e40d009bdf0089 feffffff\n    txout:     02 b8b4eb0b00000000 1976a914a457b684d7f0d539a46a45bbc043f35b59d0d96388ac\n                  0008af2f00000000 1976a914fd270b1ee6abcaea97fea7ad0402e8bd8ad6d77c88ac\n    witness    02 473044022047ac8e878352d3ebbde1c94ce3a10d057c24175747116f8288e5d794d12d482f0220217f36a485cae903c713331d877c1f64677e3622ad4010726870540656fe9dcb01 2103ad1d8e89212f0b92c74d23bb710c00662ad1470198ac48c43f7d6f93a2a26873\n    nLockTime: 92040000\n\n=== Native P2WSH ===\n\nThis example shows how <code>OP_CODESEPARATOR</code> and out-of-range <code>SIGHASH_SINGLE</code> are processed:\n\n\n\n  The following is an unsigned transaction:\n    0100000002fe3dc9208094f3ffd12645477b3dc56f60ec4fa8e6f5d67c565d1c6b9216b36e0000000000ffffffff0815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f80000000000ffffffff0100f2052a010000001976a914a30741f8145e5acadf23f751864167f32e0963f788ac00000000\n\n    nVersion:  01000000\n    txin:      02 fe3dc9208094f3ffd12645477b3dc56f60ec4fa8e6f5d67c565d1c6b9216b36e 00000000 00 ffffffff\n                  0815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f8 00000000 00 ffffffff\n    txout:     01 00f2052a01000000 1976a914a30741f8145e5acadf23f751864167f32e0963f788ac\n    nLockTime: 00000000\n\n  The first input comes from an ordinary P2PK:\n    scriptPubKey: 21036d5c20fa14fb2f635474c1dc4ef5909d4568e5569b79fc94d3448486e14685f8ac value: 1.5625\n    private key:  b8f28a772fccbf9b4f58a4f027e07dc2e35e7cd80529975e292ea34f84c4580c\n    signature:    304402200af4e47c9b9629dbecc21f73af989bdaa911f7e6f6c2e9394588a3aa68f81e9902204f3fcf6ade7e5abb1295b6774c8e0abd94ae62217367096bc02ee5e435b67da201 (SIGHASH_ALL)\n\n  The second input comes from a native P2WSH witness program:\n    scriptPubKey : 00205d1b56b63d714eebe542309525f484b7e9d6f686b3781b6f61ef925d66d6f6a0, value: 49\n    witnessScript: 21026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880aeadab210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac\n                   <026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880ae> CHECKSIGVERIFY CODESEPARATOR <0255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465> CHECKSIG\n\n  To sign it with a nHashType of 3 (SIGHASH_SINGLE):\n\n  hashPrevouts:\n    dSHA256(fe3dc9208094f3ffd12645477b3dc56f60ec4fa8e6f5d67c565d1c6b9216b36e000000000815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f800000000)\n  = ef546acf4a020de3898d1b8956176bb507e6211b5ed3619cd08b6ea7e2a09d41\n\n    nVersion:     01000000\n    hashPrevouts: ef546acf4a020de3898d1b8956176bb507e6211b5ed3619cd08b6ea7e2a09d41\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     0815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f800000000\n    scriptCode:   (see below)\n    amount:       0011102401000000\n    nSequence:    ffffffff\n    hashOutputs:  0000000000000000000000000000000000000000000000000000000000000000 (this is the second input but there is only one output)\n    nLockTime:    00000000\n    nHashType:    03000000\n\n  scriptCode:  4721026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880aeadab210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac\n                                                                                       ^^\n               (please note that the not-yet-executed OP_CODESEPARATOR is not removed from the scriptCode)\n  preimage:    01000000ef546acf4a020de3898d1b8956176bb507e6211b5ed3619cd08b6ea7e2a09d4100000000000000000000000000000000000000000000000000000000000000000815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f8000000004721026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880aeadab210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac0011102401000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000003000000\n  sigHash:     82dde6e4f1e94d02c2b7ad03d2115d691f48d064e9d52f58194a6637e4194391\n  public key:  026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880ae\n  private key: 8e02b539b1500aa7c81cf3fed177448a546f19d2be416c0c61ff28e577d8d0cd\n  signature:   3044022027dc95ad6b740fe5129e7e62a75dd00f291a2aeb1200b84b09d9e3789406b6c002201a9ecd315dd6a0e632ab20bbb98948bc0c6fb204f2c286963bb48517a7058e2703\n\n  scriptCode:  23210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac\n               (everything up to the last executed OP_CODESEPARATOR, including that OP_CODESEPARATOR, are removed)\n  preimage:    01000000ef546acf4a020de3898d1b8956176bb507e6211b5ed3619cd08b6ea7e2a09d4100000000000000000000000000000000000000000000000000000000000000000815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f80000000023210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac0011102401000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000003000000\n  sigHash:     fef7bd749cce710c5c052bd796df1af0d935e59cea63736268bcbe2d2134fc47\n  public key:  0255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465\n  private key: 86bf2ed75935a0cbef03b89d72034bb4c189d381037a5ac121a70016db8896ec\n  signature:   304402200de66acf4527789bfda55fc5459e214fa6083f936b430a762c629656216805ac0220396f550692cd347171cbc1ef1f51e15282e837bb2b30860dc77c8f78bc8501e503\n\n  The serialized signed transaction is: 01000000000102fe3dc9208094f3ffd12645477b3dc56f60ec4fa8e6f5d67c565d1c6b9216b36e000000004847304402200af4e47c9b9629dbecc21f73af989bdaa911f7e6f6c2e9394588a3aa68f81e9902204f3fcf6ade7e5abb1295b6774c8e0abd94ae62217367096bc02ee5e435b67da201ffffffff0815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f80000000000ffffffff0100f2052a010000001976a914a30741f8145e5acadf23f751864167f32e0963f788ac000347304402200de66acf4527789bfda55fc5459e214fa6083f936b430a762c629656216805ac0220396f550692cd347171cbc1ef1f51e15282e837bb2b30860dc77c8f78bc8501e503473044022027dc95ad6b740fe5129e7e62a75dd00f291a2aeb1200b84b09d9e3789406b6c002201a9ecd315dd6a0e632ab20bbb98948bc0c6fb204f2c286963bb48517a7058e27034721026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880aeadab210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac00000000\n\n\nThis example shows how unexecuted <code>OP_CODESEPARATOR</code> is processed, and <code>SINGLE|ANYONECANPAY</code> does not commit to the input index:\n\n\n\n  The following is an unsigned transaction:\n    0100000002e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc0010000000000ffffffff80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b0000000000ffffffff0280969800000000001976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac80969800000000001976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac00000000\n\n    nVersion:  01000000\n    txin:      02 e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc001 00000000 00 ffffffff\n                  80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b 00000000 00 ffffffff\n    txout:     02 8096980000000000 1976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac\n                  8096980000000000 1976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac\n    nLockTime: 00000000\n\n  The first input comes from a native P2WSH witness program:\n    scriptPubKey: 0020ba468eea561b26301e4cf69fa34bde4ad60c81e70f059f045ca9a79931004a4d value: 0.16777215\n    witnessScript:0063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n                  0 IF CODESEPARATOR ENDIF <0392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98> CHECKSIG\n\n  The second input comes from a native P2WSH witness program:\n    scriptPubKey: 0020d9bbfbe56af7c4b7f960a70d7ea107156913d9e5a26b0a71429df5e097ca6537 value: 0.16777215\n    witnessScript:5163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n                  1 IF CODESEPARATOR ENDIF <0392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98> CHECKSIG\n\n  To sign it with a nHashType of 0x83 (SINGLE|ANYONECANPAY):\n\n    nVersion:     01000000\n    hashPrevouts: 0000000000000000000000000000000000000000000000000000000000000000\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     (see below)\n    scriptCode:   (see below)\n    amount:       ffffff0000000000\n    nSequence:    ffffffff\n    hashOutputs:  (see below)\n    nLockTime:    00000000\n    nHashType:    83000000\n\n  outpoint:    e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc00100000000\n  scriptCode:  270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n               (since the OP_CODESEPARATOR is not executed, nothing is removed from the scriptCode)\n  hashOutputs: b258eaf08c39fbe9fbac97c15c7e7adeb8df142b0df6f83e017f349c2b6fe3d2\n  preimage:    0100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc00100000000270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98acffffff0000000000ffffffffb258eaf08c39fbe9fbac97c15c7e7adeb8df142b0df6f83e017f349c2b6fe3d20000000083000000\n  sigHash:     e9071e75e25b8a1e298a72f0d2e9f4f95a0f5cdf86a533cda597eb402ed13b3a\n  public key:  0392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98\n  private key: f52b3484edd96598e02a9c89c4492e9c1e2031f471c49fd721fe68b3ce37780d\n  signature:   3045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683\n\n  outpoint:    80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b00000000\n  scriptCode:  2468210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n               (everything up to the last executed OP_CODESEPARATOR, including that OP_CODESEPARATOR, are removed)\n  hashOutputs: 91ea93dd77f702b738ebdbf3048940a98310e869a7bb8fa2c6cb3312916947ca\n  preimage:    010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b000000002468210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98acffffff0000000000ffffffff91ea93dd77f702b738ebdbf3048940a98310e869a7bb8fa2c6cb3312916947ca0000000083000000\n  sigHash:     cd72f1f1a433ee9df816857fad88d8ebd97e09a75cd481583eb841c330275e54\n  public key:  0392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98\n  private key: f52b3484edd96598e02a9c89c4492e9c1e2031f471c49fd721fe68b3ce37780d\n  signature:   30440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83\n\n  The serialized signed transaction is:\n  01000000000102e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc0010000000000ffffffff80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b0000000000ffffffff0280969800000000001976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac80969800000000001976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac02483045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac024730440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83275163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac00000000\n    nVersion:  01000000\n    marker:    00\n    flag:      01\n    txin:      02 e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc001 00000000 00 ffffffff\n                  80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b 00000000 00 ffffffff\n    txout:     02 8096980000000000 1976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac\n                  8096980000000000 1976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac\n    witness    02 483045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683 270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n               02 4730440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83 275163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n    nLockTime: 00000000\n\n  Since SINGLE|ANYONECANPAY does not commit to the input index, the signatures are still valid when the input-output pairs are swapped:\n  0100000000010280e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b0000000000ffffffffe9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc0010000000000ffffffff0280969800000000001976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac80969800000000001976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac024730440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83275163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac02483045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac00000000\n    nVersion:  01000000\n    marker:    00\n    flag:      01\n    txin:      02 80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b 00000000 00 ffffffff\n                  e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc001 00000000 00 ffffffff\n    txout:     02 8096980000000000 1976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac\n                  8096980000000000 1976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac\n    witness    02 4730440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83 275163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n               02 483045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683 270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac\n    nLockTime: 00000000\n\n=== P2SH-P2WSH ===\n\nThis example is a P2SH-P2WSH 6-of-6 multisig witness program signed with 6 different <code>SIGHASH</code> types.\n\n\n\n  The following is an unsigned transaction: 010000000136641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e0100000000ffffffff0200e9a435000000001976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688acc0832f05000000001976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac00000000\n\n    nVersion:  01000000\n    txin:      01 36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e 01000000 00 ffffffff\n    txout:     02 00e9a43500000000 1976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac\n                  c0832f0500000000 1976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac\n    nLockTime: 00000000\n\n  The input comes from a P2SH-P2WSH 6-of-6 multisig witness program:\n    scriptPubKey : a9149993a429037b5d912407a71c252019287b8d27a587, value: 9.87654321\n    redeemScript : 0020a16b5755f7f6f96dbd65f5f0d6ab9418b89af4b1f14a1bb8a09062c35f0dcb54\n    witnessScript: 56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n\n  hashPrevouts:\n    dSHA256(36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000)\n  = 74afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa0\n\n  hashSequence:\n    dSHA256(ffffffff)\n  = 3bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e70665044\n\n  hashOutputs for ALL:\n    dSHA256(00e9a435000000001976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688acc0832f05000000001976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac)\n  = bc4d309071414bed932f98832b27b4d76dad7e6c1346f487a8fdbb8eb90307cc\n\n  hashOutputs for SINGLE:\n    dSHA256(00e9a435000000001976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac)\n  = 9efe0c13a6b16c14a41b04ebe6a63f419bdacb2f8705b494a43063ca3cd4f708\n\n  hash preimage for ALL: 0100000074afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa03bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e7066504436641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56aeb168de3a00000000ffffffffbc4d309071414bed932f98832b27b4d76dad7e6c1346f487a8fdbb8eb90307cc0000000001000000\n    nVersion:     01000000\n    hashPrevouts: 74afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa0\n    hashSequence: 3bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e70665044\n    outpoint:     36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000\n    scriptCode:   cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n    amount:       b168de3a00000000\n    nSequence:    ffffffff\n    hashOutputs:  bc4d309071414bed932f98832b27b4d76dad7e6c1346f487a8fdbb8eb90307cc\n    nLockTime:    00000000\n    nHashType:    01000000\n  sigHash:      185c0be5263dce5b4bb50a047973c1b6272bfbd0103a89444597dc40b248ee7c\n  public key:   0307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba3\n  private key:  730fff80e1413068a05b57d6a58261f07551163369787f349438ea38ca80fac6\n  signature:    304402206ac44d672dac41f9b00e28f4df20c52eeb087207e8d758d76d92c6fab3b73e2b0220367750dbbe19290069cba53d096f44530e4f98acaa594810388cf7409a1870ce01\n\n  hash preimage for NONE: 0100000074afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa0000000000000000000000000000000000000000000000000000000000000000036641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56aeb168de3a00000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000002000000\n    nVersion:     01000000\n    hashPrevouts: 74afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa0\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000\n    scriptCode:   cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n    amount:       b168de3a00000000\n    nSequence:    ffffffff\n    hashOutputs:  0000000000000000000000000000000000000000000000000000000000000000\n    nLockTime:    00000000\n    nHashType:    02000000\n  sigHash:        e9733bc60ea13c95c6527066bb975a2ff29a925e80aa14c213f686cbae5d2f36\n  public key:     03b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b\n  private key:    11fa3d25a17cbc22b29c44a484ba552b5a53149d106d3d853e22fdd05a2d8bb3\n  signature:      3044022068c7946a43232757cbdf9176f009a928e1cd9a1a8c212f15c1e11ac9f2925d9002205b75f937ff2f9f3c1246e547e54f62e027f64eefa2695578cc6432cdabce271502\n\n  hash preimage for SINGLE: 0100000074afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa0000000000000000000000000000000000000000000000000000000000000000036641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56aeb168de3a00000000ffffffff9efe0c13a6b16c14a41b04ebe6a63f419bdacb2f8705b494a43063ca3cd4f7080000000003000000\n    nVersion:     01000000\n    hashPrevouts: 74afdc312af5183c4198a40ca3c1a275b485496dd3929bca388c4b5e31f7aaa0\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000\n    scriptCode:   cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n    amount:       b168de3a00000000\n    nSequence:    ffffffff\n    hashOutputs:  9efe0c13a6b16c14a41b04ebe6a63f419bdacb2f8705b494a43063ca3cd4f708\n    nLockTime:    00000000\n    nHashType:    03000000\n  sigHash:        1e1f1c303dc025bd664acb72e583e933fae4cff9148bf78c157d1e8f78530aea\n  public key:     034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a\n  private key:    77bf4141a87d55bdd7f3cd0bdccf6e9e642935fec45f2f30047be7b799120661\n  signature:      3044022059ebf56d98010a932cf8ecfec54c48e6139ed6adb0728c09cbe1e4fa0915302e022007cd986c8fa870ff5d2b3a89139c9fe7e499259875357e20fcbb15571c76795403\n\n  hash preimage for ALL|ANYONECANPAY: 010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56aeb168de3a00000000ffffffffbc4d309071414bed932f98832b27b4d76dad7e6c1346f487a8fdbb8eb90307cc0000000081000000\n    nVersion:     01000000\n    hashPrevouts: 0000000000000000000000000000000000000000000000000000000000000000\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000\n    scriptCode:   cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n    amount:       b168de3a00000000\n    nSequence:    ffffffff\n    hashOutputs:  bc4d309071414bed932f98832b27b4d76dad7e6c1346f487a8fdbb8eb90307cc\n    nLockTime:    00000000\n    nHashType:    81000000\n  sigHash:        2a67f03e63a6a422125878b40b82da593be8d4efaafe88ee528af6e5a9955c6e\n  public key:     033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f4\n  private key:    14af36970f5025ea3e8b5542c0f8ebe7763e674838d08808896b63c3351ffe49\n  signature:      3045022100fbefd94bd0a488d50b79102b5dad4ab6ced30c4069f1eaa69a4b5a763414067e02203156c6a5c9cf88f91265f5a942e96213afae16d83321c8b31bb342142a14d16381\n\n  hash preimage for NONE|ANYONECANPAY: 010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56aeb168de3a00000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000082000000\n    nVersion:     01000000\n    hashPrevouts: 0000000000000000000000000000000000000000000000000000000000000000\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000\n    scriptCode:   cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n    amount:       b168de3a00000000\n    nSequence:    ffffffff\n    hashOutputs:  0000000000000000000000000000000000000000000000000000000000000000\n    nLockTime:    00000000\n    nHashType:    82000000\n  sigHash:        781ba15f3779d5542ce8ecb5c18716733a5ee42a6f51488ec96154934e2c890a\n  public key:     03a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac16\n  private key:    fe9a95c19eef81dde2b95c1284ef39be497d128e2aa46916fb02d552485e0323\n  signature:      3045022100a5263ea0553ba89221984bd7f0b13613db16e7a70c549a86de0cc0444141a407022005c360ef0ae5a5d4f9f2f87a56c1546cc8268cab08c73501d6b3be2e1e1a8a0882\n\n  hash preimage for SINGLE|ANYONECANPAY: 010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56aeb168de3a00000000ffffffff9efe0c13a6b16c14a41b04ebe6a63f419bdacb2f8705b494a43063ca3cd4f7080000000083000000\n    nVersion:     01000000\n    hashPrevouts: 0000000000000000000000000000000000000000000000000000000000000000\n    hashSequence: 0000000000000000000000000000000000000000000000000000000000000000\n    outpoint:     36641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e01000000\n    scriptCode:   cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae\n    amount:       b168de3a00000000\n    nSequence:    ffffffff\n    hashOutputs:  9efe0c13a6b16c14a41b04ebe6a63f419bdacb2f8705b494a43063ca3cd4f708\n    nLockTime:    00000000\n    nHashType:    83000000\n  sigHash:        511e8e52ed574121fc1b654970395502128263f62662e076dc6baf05c2e6a99b\n  public key:     02d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b\n  private key:    428a7aee9f0c2af0cd19af3cf1c78149951ea528726989b2e83e4778d2c3f890\n  signature:      30440220525406a1482936d5a21888260dc165497a90a15669636d8edca6b9fe490d309c022032af0c646a34a44d1f4576bf6a4a74b67940f8faa84c7df9abe12a01a11e2b4783\n\n  The serialized signed transaction is: 0100000000010136641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e0100000023220020a16b5755f7f6f96dbd65f5f0d6ab9418b89af4b1f14a1bb8a09062c35f0dcb54ffffffff0200e9a435000000001976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688acc0832f05000000001976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac080047304402206ac44d672dac41f9b00e28f4df20c52eeb087207e8d758d76d92c6fab3b73e2b0220367750dbbe19290069cba53d096f44530e4f98acaa594810388cf7409a1870ce01473044022068c7946a43232757cbdf9176f009a928e1cd9a1a8c212f15c1e11ac9f2925d9002205b75f937ff2f9f3c1246e547e54f62e027f64eefa2695578cc6432cdabce271502473044022059ebf56d98010a932cf8ecfec54c48e6139ed6adb0728c09cbe1e4fa0915302e022007cd986c8fa870ff5d2b3a89139c9fe7e499259875357e20fcbb15571c76795403483045022100fbefd94bd0a488d50b79102b5dad4ab6ced30c4069f1eaa69a4b5a763414067e02203156c6a5c9cf88f91265f5a942e96213afae16d83321c8b31bb342142a14d16381483045022100a5263ea0553ba89221984bd7f0b13613db16e7a70c549a86de0cc0444141a407022005c360ef0ae5a5d4f9f2f87a56c1546cc8268cab08c73501d6b3be2e1e1a8a08824730440220525406a1482936d5a21888260dc165497a90a15669636d8edca6b9fe490d309c022032af0c646a34a44d1f4576bf6a4a74b67940f8faa84c7df9abe12a01a11e2b4783cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae00000000\n\n\n=== No FindAndDelete ===\n\nThese examples show that <code>FindAndDelete</code> for the signature is not applied. The transactions are generated in an unconventional way. Instead of signing using a private key, the signatures are pre-determined as part of <code>witnessScript</code>. The public keys are generated with key recovery, using the fixed signatures and the <code>sighash</code> defined in this proposal. Therefore, the private keys are unknown.\n\n\n  The following is an unsigned transaction: 010000000169c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f14c1d000000ffffffff0101000000000000000000000000\n\n    nVersion:  01000000\n    txin:      01 69c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f1 4c1d0000 00 ffffffff\n    txout:     01 0100000000000000 00\n    nLockTime: 00000000\n\n  The input comes from a P2WSH witness program:\n    scriptPubKey : 00209e1be07558ea5cc8e02ed1d80c0911048afad949affa36d5c3951e3159dbea19, value: 0.00200000\n    redeemScript : OP_CHECKSIGVERIFY <0x30450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01>\n                   ad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01\n\n  To sign it with a nHashType of 1 (SIGHASH_ALL):\n\n  hashPrevouts:\n    dSHA256(69c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f14c1d0000)\n  = b67c76d200c6ce72962d919dc107884b9d5d0e26f2aea7474b46a1904c53359f\n\n  hashSequence:\n    dSHA256(ffffffff)\n  = 3bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e70665044\n\n  hashOutputs:\n    dSHA256(010000000000000000)\n  = e5d196bfb21caca9dbd654cafb3b4dc0c4882c8927d2eb300d9539dd0b934228\n\n  hash preimage: 01000000b67c76d200c6ce72962d919dc107884b9d5d0e26f2aea7474b46a1904c53359f3bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e7066504469c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f14c1d00004aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01400d030000000000ffffffffe5d196bfb21caca9dbd654cafb3b4dc0c4882c8927d2eb300d9539dd0b9342280000000001000000\n\n    nVersion:     01000000\n    hashPrevouts: b67c76d200c6ce72962d919dc107884b9d5d0e26f2aea7474b46a1904c53359f\n    hashSequence: 3bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e70665044\n    outpoint:     69c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f14c1d0000\n    scriptCode:   4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01\n    amount:       400d030000000000\n    nSequence:    ffffffff\n    hashOutputs:  e5d196bfb21caca9dbd654cafb3b4dc0c4882c8927d2eb300d9539dd0b934228\n    nLockTime:    00000000\n    nHashType:    01000000\n\n  sigHash:      71c9cd9b2869b9c70b01b1f0360c148f42dee72297db312638df136f43311f23\n  signature:    30450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e 01\n  pubkey:       02a9781d66b61fb5a7ef00ac5ad5bc6ffc78be7b44a566e3c87870e1079368df4c\n\n  The serialized signed transaction is: 0100000000010169c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f14c1d000000ffffffff01010000000000000000034830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e012102a9781d66b61fb5a7ef00ac5ad5bc6ffc78be7b44a566e3c87870e1079368df4c4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0100000000\n\n    nVersion:  01000000\n    marker:    00\n    flag:      01\n    txin:      01 69c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f1 4c1d0000 00 ffffffff\n    txout:     01 0100000000000000 00\n    witness:   03 4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01\n                  2102a9781d66b61fb5a7ef00ac5ad5bc6ffc78be7b44a566e3c87870e1079368df4c\n                  4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01\n    nLockTime: 00000000\n\n\n\n  The following transaction is a <code>OP_CHECKMULTISIGVERIFY</code> version of the <code>FindAndDelete</code> examples: 010000000001019275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a6628964c1d000000ffffffff0101000000000000000007004830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960101022102966f109c54e85d3aee8321301136cedeb9fc710fdef58a9de8a73942f8e567c021034ffc99dd9a79dd3cb31e2ab3e0b09e0e67db41ac068c625cd1f491576016c84e9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c039596017500000000\n\n  redeemScript:  OP_2 OP_CHECKMULTISIGVERIFY <30450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01> <304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c03959601>\n  hash preimage: 0100000039283953eb1e26994dde57b7f9362a79a8c523e2f8deba943c27e826a005f1e63bb13029ce7b1f559ef5e747fcac439f1455a2ec7c5f09b72290795e706650449275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a6628964c1d00009552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175400d030000000000ffffffffe5d196bfb21caca9dbd654cafb3b4dc0c4882c8927d2eb300d9539dd0b9342280000000001000000\n  sighash:       c1628a1e7c67f14ca0c27c06e4fdeec2e6d1a73c7a91d7c046ff83e835aebb72\n  witness:       07 00\n                    4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01\n                    48304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c03959601\n                    0102\n                    2102966f109c54e85d3aee8321301136cedeb9fc710fdef58a9de8a73942f8e567c0\n                    21034ffc99dd9a79dd3cb31e2ab3e0b09e0e67db41ac068c625cd1f491576016c84e\n                    9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175\n\n\nThe new serialization format is described in BIP144 <ref>[[bip-0144.mediawiki|BIP144: Segregated Witness (Peer Services)]]</ref>\n\n== Deployment ==\n\nThis proposal is deployed with Segregated Witness softfork (BIP 141)\n\n== Backward compatibility ==\n\nAs a soft fork, older software will continue to operate without modification. Non-upgraded nodes, however, will not see nor validate the witness data and will consider all witness programs, including the redefined sigops, as anyone-can-spend scripts.\n\n== Reference Implementation ==\n\nhttps://github.com/bitcoin/bitcoin/pull/8149\n\n== References ==\n\n<references />\n\n== Copyright ==\n\nThis document is placed in the public domain.\n", "content_length": 57851}
{"bip_number": 142, "filename": "bip-0142.mediawiki", "content": "<pre>\n  BIP: 142\n  Layer: Applications\n  Title: Address Format for Segregated Witness\n  Author: Johnson Lau <jl2012@xbt.hk>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0142\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2015-12-24\n  License: PD\n</pre>\n\n== Abstract ==\n\nThis BIP describes new types of Bitcoin address to support native segregated witness transactions with 20-byte and 32-byte program.\n\n== Motivation ==\n\nTo define standard payment address for native segregated witness (segwit) transactions to promote early adoption of the more efficient transaction method.\n\n== Specification ==\n\nThe new Bitcoin address format defined is for the Pay-to-Witness-Public-Key-Hash (P2WPKH) and Pay-to-Witness-Script-Hash (P2WSH) transaction described in segregated witness soft fork (BIP141). The scriptPubKey is an OP_0 followed by a push of 20-byte-hash (P2WPKH) or 32-byte hash (P2WSH).\n\nThe new address is encoded in a way similar to existing address formats:\n\n  base58-encode:\n    [1-byte address version]\n    [1-byte witness program version]\n    [0x00]\n    [20/32-byte-hash]\n    [4-byte checksum]\n\nFor P2WPKH address, the address version is 6 (0x06) for a main-network address or 3 (0x03) for a testnet address.\n\nFor P2WSH address, the address version is 10 (0x0A) for a main-network address or 40 (0x28) for a testnet address.\n\nThe witness program version is a 1-byte value between 0 (0x00) and 16 (0x10). Only version 0 is defined in BIP141. Versions 1 to 16 are reserved for future extensions.\n\nFollowing the witness program version is a 0x00 padding to make sure that each witness program version will have a unique prefix.\n\nFollowing the padding is the program hash, 20 byte for a P2WPKH address and 32 byte for a P2WSH address.\n\nThe 4-byte checksum is the first four bytes of the double SHA256 hash of the serialization of the previous items.\n\nAll addresses generated with this scheme will have a constant length, with 36 digits for 20-byte and 53 digits for 32-byte. Different witness program versions will have a unique prefix, as shown in the following table:\n\n{|class=\"wikitable\" style=\"text-align: center;\"\n|-\n!rowspan=3 style=\"\"|Witness program version\n!colspan=4 style=\"\"|Hash size\n|-\n!colspan=2 style=\"\"|20-byte (36 characters)\n!colspan=2 style=\"\"|32-byte (53 characters)\n|-\n!Mainnet\n!Testnet\n!Mainnet\n!Testnet\n|-\n|0||p2||QW||7Xh||T7n\n|-\n|1||p4||QY||7Xq||T7w\n|-\n|2||p6||Qa||7Xz||T85\n|-\n|3||p7||Qc||7Y9||T8E\n|-\n|4||pA||Qe||7YH||T8N\n|-\n|5||pB||Qf||7YS||T8X\n|-\n|6||pD||Qh||7Ya||T8g\n|-\n|7||pF||Qj||7Yj||T8p\n|-\n|8||pG||Qm||7Yt||T8y\n|-\n|9||pJ||Qn||7Z2||T97\n|-\n|10||pL||Qp||7ZB||T9G\n|-\n|11||pN||Qr||7ZK||T9Q\n|-\n|12||pQ||Qt||7ZU||T9Z\n|-\n|13||pS||Qv||7Zc||T9i\n|-\n|14||pT||Qw||7Zm||T9r\n|-\n|15||pV||Qy||7Zv||TA1\n|-\n|16||pX||R1||7a4||TA9\n|-\n|}\n\n\n== Rationale ==\n\nBIP141 defines 2 ways of encoding a \"witness program\", a data push of 2 to 32 bytes:\n\n* A native witness program output is a scriptPubKey with a push of version byte followed by a push of witness program, and nothing else;\n* Segwit-in-P2SH is a BIP16 P2SH redeemScript with a push of version byte followed by a push of witness program, while the scriptPubKey looks like a normal P2SH output.\n\nConsidering the BIP13 P2SH address has been defined in 2012, using segwit-in-P2SH allows most existing wallets to pay a segwit-compatible wallet without any upgrade. However, this method requires more block space and is only a short-term solution to make the transition smoother. Eventually, all users are expected to use the more efficient native witness program as the primary method of payment.\n\nThe drawbacks of Bitcoin addresses have been extensively discussed in BIP13. Since then, better payment methods have been proposed or deployed, for example:\n*BIP47 Reusable Payment Codes for Hierarchical Deterministic Wallets\n*BIP63 Stealth Addresses\n*BIP70 Payment protocol\n\nHowever, none of these are as widely adopted as the suboptimal base-58 scriptPubKey template addresses, which is still a standard for the whole eco-system, from wallets, block explorers, merchants, exchanges, to end users. It is believed that the proposed P2WPKH and P2WSH address format is the easiest way for wallets and services to adopt native witness program, which is particularly important in the context of scaling the capacity of the blockchain.\n\nWhile P2WPKH address is specific for simple payment to a single public key, P2WSH address allows arbitrarily complex segwit transactions, similar to the BIP13 P2SH address.\n\n== Compatibility ==\n\nThis proposal is not backward-compatible. However, an older implementation will report the new address type as invalid, and refuse to create a transaction.\n\nThis proposal is forward-compatible with future versions of witness programs of 20 and 32 bytes.\n\n== Example ==\n\nThe following public key,\n\n    0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6\n\nwhen encoded as a P2PKH template, would become:\n\n    DUP HASH160 <010966776006953D5567439E5E39F86A0D273BEE> EQUALVERIFY CHECKSIG\n\nWith the corresponding version 1 Bitcoin address being:\n\n    16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM\n\nWhen the same public key is encoded as P2WPKH, the scriptPubKey becomes:\n\n    OP_0 <010966776006953D5567439E5E39F86A0D273BEE>\n\nUsing 0x06 as address version, followed by 0x00 as witness program version, and a 0x00 padding, the equivalent P2WPKH address is:\n\n    p2xtZoXeX5X8BP8JfFhQK2nD3emtjch7UeFm\n\n== Reference implementation ==\n\nhttps://github.com/theuni/bitcoin/commit/ede1b57058ac8efdefe61f67395affb48f2c0d80\n\n== References ==\n\n* [[bip-0013.mediawiki|BIP 13: Address Format for pay-to-script-hash]]\n* [[bip-0016.mediawiki|BIP 16: Pay to Script Hash]]\n* [[bip-0070.mediawiki|BIP 70: Payment Protocol]]\n* [[bip-0141.mediawiki|BIP 141: Segregated Witness]]\n\n== Copyright ==\nThis work is placed in the public domain.\n", "content_length": 5931}
{"bip_number": 141, "filename": "bip-0141.mediawiki", "content": "<pre>\n  BIP: 141\n  Layer: Consensus (soft fork)\n  Title: Segregated Witness (Consensus layer)\n  Author: Eric Lombrozo <elombrozo@gmail.com>\n          Johnson Lau <jl2012@xbt.hk>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0141\n  Status: Final\n  Type: Standards Track\n  Created: 2015-12-21\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n\nThe witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n\n==Motivation==\n\nThe entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n\nBy removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n\n# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was signed are no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach ([https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki BIP62]):\n#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n#* New script system could be introduced without any limitation from the existing script semantic. For example, a new transaction digest algorithm for transaction signature verification is described in [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki BIP143]\n\n==Specification==\n\n=== Transaction ID ===\n\nA new data structure, <code>witness</code>, is defined. Each transaction will have 2 IDs.\n\nDefinition of <code>txid</code> remains unchanged: the double SHA256 of the traditional serialization format:\n\n  [nVersion][txins][txouts][nLockTime]\n\nA new <code>wtxid</code> is defined: the double SHA256 of the new serialization with witness data:\n\n  [nVersion][marker][flag][txins][txouts][witness][nLockTime]\n\nFormat of <code>nVersion</code>, <code>txins</code>, <code>txouts</code>, and <code>nLockTime</code> are same as traditional serialization.\n\nThe <code>marker</code> MUST be a 1-byte zero value: <code>0x00</code>.\n\nThe <code>flag</code> MUST be a 1-byte non-zero value. Currently, <code>0x01</code> MUST be used.\n\nThe <code>witness</code> is a serialization of all witness fields of the transaction. Each txin is associated with a witness field. A witness field starts with a <code>var_int</code> to indicate the number of stack items for the txin. It is followed by stack items, with each item starts with a <code>var_int</code> to indicate the length. Witness data is NOT script.\n\nA non-witness program (defined hereinafter) txin MUST be associated with an empty witness field, represented by a <code>0x00</code>. If all txins are not witness program, a transaction's <code>wtxid</code> is equal to its <code>txid</code>.\n\n=== Commitment structure ===\n\nA new block rule is added which requires a commitment to the <code>wtxid</code>. The <code>wtxid</code> of coinbase transaction is assumed to be <code>0x0000....0000</code>.\n\nA <code>witness root hash</code> is calculated with all those <code>wtxid</code> as leaves, in a way similar to the <code>hashMerkleRoot</code> in the block header.\n\nThe commitment is recorded in a <code>scriptPubKey</code> of the coinbase transaction. It must be at least 38 bytes, with the first 6-byte of <code>0x6a24aa21a9ed</code>, that is:\n\n   1-byte - OP_RETURN (0x6a)\n   1-byte - Push the following 36 bytes (0x24)\n   4-byte - Commitment header (0xaa21a9ed)\n  32-byte - Commitment hash: Double-SHA256(witness root hash|witness reserved value)\n\n  39th byte onwards: Optional data with no consensus meaning\n\nand the coinbase's input's witness must consist of a single 32-byte array for the <code>witness reserved value</code>.\n\nIf there are more than one <code>scriptPubKey</code> matching the pattern, the one with highest output index is assumed to be the commitment.\n\nIf all transactions in a block do not have witness data, the commitment is optional.\n\n=== Witness program ===\n\nA <code>scriptPubKey</code> (or <code>redeemScript</code> as defined in BIP16/P2SH) that consists of a 1-byte push opcode (one of <code>OP_0,OP_1,OP_2,...,OP_16</code>) followed by a direct data push between 2 and 40 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\nIn more detail, this means a <code>scriptPubKey</code> or <code>redeemScript</code> which consists of (in order):\n* First, byte 0x00 (<code>OP_0</code>) or any byte between 0x51 (<code>OP_1</code>) and 0x60 (<code>OP_16</code>) inclusive (the version byte).\n* Then, a byte ''L'' between 0x02 (push of 2 bytes) and 0x28 (push of 40 bytes) inclusive.\n* Finally, ''L'' arbitrary bytes (the witness program).\n\nThere are two cases in which witness validation logic are triggered. Each case determines the location of the witness version byte and program, as well as the form of the scriptSig:\n# Triggered by a <code>scriptPubKey</code> that is exactly a push of a version byte, plus a push of a witness program. The scriptSig must be exactly empty or validation fails. (''\"native witness program\"'')\n# Triggered when a <code>scriptPubKey</code> is a P2SH script, and the BIP16 <code>redeemScript</code> pushed in the <code>scriptSig</code> is exactly a push of a version byte plus a push of a witness program. The <code>scriptSig</code> must be exactly a push of the BIP16 <code>redeemScript</code> or validation fails. (''\"P2SH witness program\"'')\n\nIf the version byte is 0, and the witness program is 20 bytes (''L = 20''):\n* It is interpreted as a pay-to-witness-public-key-hash (P2WPKH) program.\n* The witness must consist of exactly 2 items (\u2264 520 bytes each). The first one a signature, and the second one a public key.\n* The HASH160 of the public key must match the 20-byte witness program.\n* After normal script evaluation, the signature is verified against the public key with CHECKSIG operation. The verification must result in a single TRUE on the stack.\n\nIf the version byte is 0, and the witness program is 32 bytes (''L = 32''):\n* It is interpreted as a pay-to-witness-script-hash (P2WSH) program.\n* The witness must consist of an input stack to feed to the script, followed by a serialized script (<code>witnessScript</code>).\n* The <code>witnessScript</code> (\u2264 10,000 bytes) is popped off the initial witness stack. SHA256 of the <code>witnessScript</code> must match the 32-byte witness program.\n* The <code>witnessScript</code> is deserialized, and executed after normal script evaluation with the remaining witness stack (\u2264 520 bytes for each stack item).\n* The script must not fail, and result in exactly a single TRUE on the stack.\n\nIf the version byte is 0, but the witness program is neither 20 nor 32 bytes, the script must fail.<ref>For example, a scriptPubKey with OP_0 followed by a 40-byte non-zero data push will fail due to incorrect program size. However, a scriptPubKey with OP_0 followed by a 41-byte non-zero data push will pass, since it is not considered to be a witness program</ref>\n\nIf the version byte is 1 to 16, no further interpretation of the witness program or witness stack happens, and there is no size restriction for the witness stack. These versions are reserved for future extensions.<ref>For backward compatibility, for any version byte from 0 to 16, the script must fail if the witness program has a <code>CastToBool</code> value of zero. However, having a hash like this is a successful preimage attack against the hash function, and the risk is negligible.</ref>\n\n=== Other consensus critical limits ===\n\n==== Block size ====\n\nBlocks are currently limited to 1,000,000 bytes (1MB) total size. We change this restriction as follows:\n\n''Block weight'' is defined as ''Base size'' * 3 + ''Total size''. (rationale<ref>Rationale of using a single composite constraint, instead of two separate limits such as 1MB base data and 3MB witness data: Using two separate limits would make mining and fee estimation nearly impossible. Miners would need to solve a complex non-linear optimization problem to find the set of transactions that maximize fees given both constraints, and wallets would not be able to know what to pay as it depends on which of the two conditions is most constrained by the time miners try to produce blocks with their transactions in. Another problem with such an approach is freeloading. Once a set of transactions hit the base data 1MB constraint, up to 3MB extra data could be added to the witness by just minimally increasing the fee. The marginal cost for extra witness space effectively becomes zero in that case.</ref>)\n\n''Base size'' is the block size in bytes with the original transaction serialization without any witness-related data, as seen by a non-upgraded node.\n\n''Total size'' is the block size in bytes with transactions serialized as described in [[bip-0144.mediawiki|BIP144]], including base data and witness data.\n\nThe new rule is ''block weight'' \u2264 4,000,000.\n\n==== Sigops ====\n\nSigops per block is currently limited to 20,000. We change this restriction as follows:\n\nSigops in the current pubkey script, signature script, and P2SH check script are counted at 4 times their previous value.\nThe sigop limit is likewise quadrupled to \u2264 80,000.\n\nEach P2WPKH input is counted as 1 sigop. In addition, opcodes within a P2WSH <code>witnessScript</code> are counted identically as previously within the P2SH <code>redeemScript</code>. That is, CHECKSIG is counted as only 1 sigop. When preceded by OP_1 to OP_16 CHECKMULTISIG is counted as 1 to 16 sigops respectively, otherwise it is counted as 20 sigops. This rule applies to both native witness program and P2SH witness program.\n\n=== Additional definitions ===\n\nThe following definitions are not used for consensus limits, but are suggested to provide language consistent with the terminology introduced above.\n\n==== Transaction size calculations ====\n\n''Transaction weight'' is defined as ''Base transaction size'' * 3 + ''Total transaction size'' (ie. the same method as calculating ''Block weight'' from ''Base size'' and ''Total size'').\n\n''Virtual transaction size'' is defined as ''Transaction weight'' / 4 (rounded up to the next integer).\n\n''Base transaction size'' is the size of the transaction serialised with the witness data stripped.\n\n''Total transaction size'' is the transaction size in bytes serialized as described in [[bip-0144.mediawiki|BIP144]], including base data and witness data.\n\n=== New script semantics ===\n\nDespite that the script language for P2WPKH and P2WSH looks very similar to pre-segregated witness script, there are several notable differences. Users MUST NOT assume that a script spendable in pre-segregated witness system would also be spendable as a P2WPKH or P2WSH script. Before large-scale deployment in the production network, developers should test the scripts on testnet with the default relay policy turned on, and with a small amount of money after BIP141 is activated on mainnet.\n\nA major difference at consensus level is described in [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki BIP143], as a new transaction digest algorithm for signature verification in version 0 witness program.\n\nThree relay and mining policies are also included in the first release of segregated witness at reference implementation version 0.13.1. Softforks based on these policies are likely to be proposed in the near future. To avoid indefinite delay in transaction confirmation and permanent fund loss in a potential softfork, users MUST observe the new semantics carefully:\n\n# Only compressed public keys are accepted in P2WPKH and P2WSH (See [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#Restrictions_on_public_key_type BIP143])\n# The argument of OP_IF/NOTIF in P2WSH must be minimal<ref>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html</ref>\n# Signature(s) must be null vector(s) if an OP_CHECKSIG or OP_CHECKMULTISIG is failed (for both pre-segregated witness script and P2WSH. See [https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki BIP146])\n\n== Examples ==\n\n=== P2WPKH ===\n\nThe following example is a version 0 pay-to-witness-public-key-hash (P2WPKH):\n\n    witness:      <signature> <pubkey>\n    scriptSig:    (empty)\n    scriptPubKey: 0 <20-byte-key-hash>\n                  (0x0014{20-byte-key-hash})\n\nThe '0' in scriptPubKey indicates the following push is a version 0 witness program. The length of the witness program indicates that it is a P2WPKH type. The witness must consist of exactly 2 items. The HASH160 of the pubkey in witness must match the witness program.\n\nThe signature is verified as\n\n    <signature> <pubkey> CHECKSIG\n\nComparing with a traditional P2PKH output, the P2WPKH equivalent occupies 3 less bytes in the scriptPubKey, and moves the signature and public key from scriptSig to witness.\n\n=== P2WPKH nested in BIP16 P2SH ===\n\nThe following example is the same P2WPKH, but nested in a BIP16 P2SH output.\n\n    witness:      <signature> <pubkey>\n    scriptSig:    <0 <20-byte-key-hash>>\n                  (0x160014{20-byte-key-hash})\n    scriptPubKey: HASH160 <20-byte-script-hash> EQUAL\n                  (0xA914{20-byte-script-hash}87)\n\nThe only item in scriptSig is hashed with HASH160, compared against the 20-byte-script-hash in scriptPubKey, and interpreted as:\n\n    0 <20-byte-key-hash>\n\nThe public key and signature are then verified as described in the previous example.\n\nComparing with the previous example, the scriptPubKey is 1 byte bigger and the scriptSig is 23 bytes bigger. Although a nested witness program is less efficient, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.\n\n=== P2WSH ===\n\nThe following example is an 1-of-2 multi-signature version 0 pay-to-witness-script-hash (P2WSH).\n\n    witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>\n    scriptSig:    (empty)\n    scriptPubKey: 0 <32-byte-hash>\n                  (0x0020{32-byte-hash})\n\nThe '0' in scriptPubKey indicates the following push is a version 0 witness program. The length of the witness program indicates that it is a P2WSH type. The last item in the witness (the \"witnessScript\") is popped off, hashed with SHA256, compared against the 32-byte-hash in scriptPubKey, and deserialized:\n\n    1 <pubkey1> <pubkey2> 2 CHECKMULTISIG\n\nThe script is executed with the remaining data from witness:\n\n    0 <signature1> 1 <pubkey1> <pubkey2> 2 CHECKMULTISIG\n\nP2WSH allows maximum script size of 10,000 bytes, as the 520-byte push limit is bypassed.\n\nThe scriptPubKey occupies 34 bytes, as opposed to 23 bytes of BIP16 P2SH. The increased size improves security against possible collision attacks, as 2<sup>80</sup> work is not infeasible anymore (By the end of 2015, 2<sup>84</sup> hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent BIP16 P2SH output but is moved to witness.\n\n=== P2WSH nested in BIP16 P2SH ===\n\nThe following example is the same 1-of-2 multi-signature P2WSH script, but nested in a BIP16 P2SH output.\n\n    witness:      0 <signature1> <1 <pubkey1> <pubkey2> 2 CHECKMULTISIG>\n    scriptSig:    <0 <32-byte-hash>>\n                  (0x220020{32-byte-hash})\n    scriptPubKey: HASH160 <20-byte-hash> EQUAL\n                  (0xA914{20-byte-hash}87)\n\nThe only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash in scriptPubKey, and interpreted as:\n\n    0 <32-byte-hash>\n\nThe P2WSH witnessScript is then executed as described in the previous example.\n\nComparing with the previous example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig.\n\n=== Extensible commitment structure ===\n\nThe new commitment in coinbase transaction is a hash of the <code>witness root hash</code> and a <code>witness reserved value</code>. The <code>witness reserved value</code> currently has no consensus meaning, but in the future allows new commitment values for future softforks. For example, if a new consensus-critical commitment is required in the future, the commitment in coinbase becomes:\n\n  Double-SHA256(Witness root hash|Hash(new commitment|witness reserved value))\n\nFor backward compatibility, the <code>Hash(new commitment|witness reserved value)</code> will go to the coinbase witness, and the <code>witness reserved value</code> will be recorded in another location specified by the future softfork. Any number of new commitment could be added in this way.\n\nAny commitments that are not consensus-critical to Bitcoin, such as merge-mining, MUST NOT use the <code>witness reserved value</code> to preserve the ability to do upgrades of the Bitcoin consensus protocol.\n\nThe optional data space following the commitment also leaves room for metadata of future softforks, and MUST NOT be used for other purpose.\n\n=== Trust-free unconfirmed transaction dependency chain ===\n\nSegregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.\n\nTwo parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the \"funding transaction\"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the \"spending transaction\"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.\n\nSuch setups are not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.\n\nUnconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.\n\n== Future extensions ==\n\n=== Compact fraud proof for SPV nodes ===\n\nBitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.\n\nIn the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:\n\n# It is not possible to prove a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.\n# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)\n# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.\n\nExtra witness data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify:\n\n# Sum trees for transaction fee can be committed making it possible to construct short proofs that the miner does not add excessive fees to the coinbase transaction. Similar for the block size and sigop count limit.\n# Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n\nThese commitments could be included in the extensible commitment structure through a soft fork and will be transparent to nodes that do not understand such new rules.\n\n=== New script system ===\n\nSince a version byte is pushed before a witness program, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.\n\nExamples of new script systems include Schnorr signatures, which reduce the size of multisig transactions dramatically; Lamport signatures, which are quantum computing resistant; and Merklized abstract syntax trees, which allow very compact witnesses for conditional scripts with extreme complexity.\n\n=== Per-input lock-time and relative-lock-time ===\n\nCurrently there is only one nLockTime field in a transaction and all inputs must share the same value. [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP68] enables per-input relative-lock-time using the nSequence field, however, with a limited lock-time period and resolution.\n\nWith a soft fork, it is possible to introduce a separate witness structure to allow per-input lock-time and relative-lock-time, and a new script system that could sign and manipulate the new data (like [https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP65] and [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP112]).\n\n== Backward compatibility ==\n\nAs a soft fork, older software will continue to operate without modification.  Non-upgraded nodes, however, will not see nor validate the witness data and will consider all witness programs as anyone-can-spend scripts (except a few edge cases where the witness programs are equal to 0, which the script must fail). Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion. Non-upgraded nodes are strongly encouraged to upgrade in order to take advantage of the new features.\n\n'''What a non-upgraded wallet can do'''\n\n* Receiving bitcoin from non-upgraded and upgraded wallets\n* Sending bitcoin to non-upgraded and upgraded wallets with traditional P2PKH address (without any benefit of segregated witness)\n* Sending bitcoin to upgraded wallets using a P2SH address\n* Sending bitcoin to upgraded wallets using a native witness program through [https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki BIP70] payment protocol\n\n'''What a non-upgraded wallet cannot do'''\n\n* Validating segregated witness transaction. It assumes such a transaction is always valid\n\n== Deployment ==\n\nThis BIP will be deployed by \"version bits\" BIP9 with the name \"segwit\" and using bit 1.\n\nFor Bitcoin mainnet, the BIP9 starttime will be midnight 15 November 2016 UTC (Epoch timestamp 1479168000) and BIP9 timeout will be midnight 15 November 2017 UTC (Epoch timestamp 1510704000).\n\nFor Bitcoin testnet, the BIP9 starttime will be midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout will be midnight 1 May 2017 UTC (Epoch timestamp 1493596800).\n\n== Credits ==\n\nSpecial thanks to Gregory Maxwell for originating many of the ideas in this BIP and Luke-Jr for figuring out how to deploy this as a soft fork.\n\n== Footnotes ==\n\n<references />\n\n== Reference Implementation ==\n\nhttps://github.com/bitcoin/bitcoin/pull/8149\n\n== References ==\n\n*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for Version 0 Witness Program]]\n*[[bip-0144.mediawiki|BIP144 Segregated Witness (Peer Services)]]\n*[[bip-0173.mediawiki|BIP173 Base32 address format for native v0-16 witness outputs]]\n\n== Copyright ==\n\nThis document is placed in the public domain.\n", "content_length": 26407}
{"bip_number": 140, "filename": "bip-0140.mediawiki", "content": "<pre>\n  BIP: 140\n  Layer: Consensus (soft fork)\n  Title: Normalized TXID\n  Author: Christian Decker <decker.christian@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0140\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-10-14\n  License: PD\n</pre>\n\n== Abstract ==\n\nThis BIP describes the use of normalized transaction IDs (NTXIDs) in order to eliminate transaction malleability, both in the third-party modification scenario as well as the participant modification scenario. The transaction ID is normalized by removing the signature scripts from transactions before computing its hash. The normalized transaction hashes are then used during the signature creation and signature verification of dependent transactions.\n\n== Motivation ==\n\nTransaction malleability refers to the fact that transactions can be modified, either by one of the signers by re-signing the transaction or a third-party by modifying the signature representation. This is a problem since any modification to the serialized representation also changes the hash of the transaction, which is used by spending transaction to reference the funds that are being transferred. If a transaction is modified and later confirmed by ending up in the blockchain all transactions that depended on the original transaction are no longer valid, and thus orphaned.\n\nBIPs 62<ref>[[https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki|BIP 62 - Dealing with malleability]]</ref> and 66<ref>[[https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki|BIP 66 - Strict DER signatures]]</ref> alleviate the problem of third-party modification by defining a canonical representation of the signatures. However, checking the canonical representation is complex and may not eliminate all sources of third-party malleability. Furthermore, these BIPs do not address modifications by one of the signers, i.e., re-signing the transaction, because signers can produce any number of signatures due to the random parameter in ECDSA.\n\nThis proposal eliminates malleability by removing the malleable signatures from the hash used to reference the outputs spent by a transaction. The new hash used to reference an output is called the ''normalized transaction ID''. The integrity of all data that is used to reference the output is guaranteed by the signature itself, and any modification that would change the normalized transaction ID would also invalidate the signature itself.\n\nBesides eliminating transaction malleability as a source of problems it also allows the use of transaction templates. Transaction templates simplify higher level protocols and allows new uses. They allow an unsigned template transaction to be used as a basis for a sequence of transaction and only once the sequence matches the signers' expectations they provide the necessary signatures for the template to become valid, thus opting in to the sequence.\n\n== Specification ==\n\nThe use of normalized transaction IDs is introduced as a softfork. The specification is divided into three parts:\n\n* Computation of the normalized transaction ID\n* Introduction of a new extensible signature verification opcode to enable softfork deployment\n* Changes to the UTXO tracking to enable normalized transaction ID lookup\n\n=== Normalized Transaction ID computation ===\n\nIn order to calculate the normalized transaction ID, the signature script is stripped from each input of the transaction of non-coinbase transactions and each input is normalized. Stripping the signature script is achieved by setting the script's length to 0 and removing the <code>uchar[]</code> array from the <code>TxIn</code>.<ref>[[https://en.bitcoin.it/wiki/Protocol_Specification#tx|Protocol Specification: TX]]</ref>\nInputs are then normalized by replacing the hash of each previous transaction with its normalized version if available, i.e., the normalized hash of the previous transaction that created the output being spent in the current transaction. Version 1 transactions do not have a normalized transaction ID hence the non-normalized transaction ID is used for input normalization.\n\nThe normalized transaction ID is then computed as the double <code>SHA 256</code> hash of the normalized transaction matching the existing transaction ID computation. The normalized transaction ID remains unchanged even if the signatures of the transaction are replaced/malleated and describe a class of semantically identical transactions. In the following we use ''transaction instance ID'' to refer to the transaction ID computed on the transaction including signatures. Normalized transaction IDs for coinbase transactions are computed with the signature script in the coinbase input, in order to avoid hash collisions.\n\n=== OP_CHECKSIGEX ===\nThis BIP introduces a new opcode <code>OP_CHECKSIGEX</code> which replaces <code>OP_NOP4</code>. <code>OP_CHECKSIGEX</code> subsumes <code>OP_CHECKSIGVERIFY</code> and <code>OP_CHECKMULTISIGVERIFY</code>, and extends them by accepting a new <code>VERSION</code> parameter. The version parameter is a single integer pushed onto the stack before invoking <code>OP_CHECKSIGEX</code> and is used to group and evolve future versions of signature checking opcodes.\n\nWhen executed <code>OP_CHECKSIGEX</code> pops the version from the stack and then performs the signature check according to the specified version. If the verifying client does not support the specified version, i.e., the version was defined after the release of the client, the client must treat the <code>OP_CHECKSIGEX</code> as an <code>OP_NOP</code>.\n\n==== Version 1 ====\n\nThe first version of <code>OP_CHECKSIGEX</code> (<code>VERSION=1</code>) implements normalized transaction IDs and uses Schnorr signatures instead of the current ECDSA signatures.\n\nVersion 1 introduces the following new standard script format:\n\n    m {pubkey}...{pubkey} n v OP_CHECKSIGEX\n\nwith matching scriptSig format:\n\n    {signature}...{signature}\n\nThis is the standard ''m-of-n'' script defined in [https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP 11] with an additional version parameter <code>v</code> and the new opcode. Singlesig transactions are encoded as ''1-of-1'' transactions.\n\nThe existing <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code> have a bug<ref>[[https://bitcoin.org/en/developer-guide#multisig|Developer Documentation - Multisig]]</ref> that pops one argument too many from the stack. This bug is not reproduced in the implementation of OP_CHECKSIGEX, so the canonical solution of pushing a dummy value onto the stack is not necessary.\n\nThe normalization is achieved by normalizing the transaction before computing the signaturehash, i.e., the hash that is signed.\nThe transaction must be normalized by replacing all transaction IDs in the inputs by their normalized variants and stripping the signature scripts. The normalized transaction IDs are computed as described in the previous section. This normalization step is performed both when creating the signatures as well as when checking the signatures.\n\n=== Tracking Normalized Transaction IDs ===\n\nThe transaction version is bumped to 2. The new version signals to clients receiving the transaction that they should track the normalized transaction ID along with the transaction instance ID in the unspent transaction output (UTXO) set. Upon receiving a version 2 transaction the client computes the normalized transaction ID, annotates the outputs with it, and adds them into the UTXO set indexed by the transaction instance ID as before. Transactions continue using the transaction instance ID to reference the outputs, but while checking the signature they may get normalized. All network messages continue to use the transaction instance ID to reference the transaction, specifically <code>inv</code>, <code>getdata</code>, <code>tx</code> and <code>block</code> messages still use transaction instance IDs, not the normalized transaction IDs.\n\nOutputs created by version 1 transactions are not annotated with the normalized transaction ID, and when normalizing the hashes in transaction inputs referencing version 1 outputs are not modified.\n\n== Rationale ==\n\n=== Normalization ===\nNormalized transaction IDs are provably non-malleable since no data is included in the signaturehash whose integrity is not also proven in the signature, thus any modification causing the hash to change will also invalidate the signature.\nNormalized transactions are secure as they still use cryptographic hashes over all the semantic information of the transaction, i.e., the inputs, outputs and metadata, thus it is still computationally infeasible to cause a hash collision between transactions.\n\nThere are a number of advantages to using normalized transaction IDs:\n\n* Like BIP 62 and BIP 66 it solves the problem of third-parties picking transactions out of the network, modifying them and reinjecting them.\n* ''m-of-n'' multisig outputs are often used in higher level protocols<ref>[[http://www.tik.ee.ethz.ch/file/716b955c130e6c703fac336ea17b1670/duplex-micropayment-channels.pdf|A Fast and Scalable Payment Network with Bitcoin Duplex Micropayment Channels ]]</ref><ref>[[http://lightning.network/lightning-network-paper.pdf|The Bitcoin Lightning Network:\nScalable Off-Chain Instant Payments]]</ref> in which several parties sign a transaction. Without normalized transaction IDs it is trivial for one party to re-sign a transaction, hence changing the transaction hash and invalidating any transaction built on top of its outputs. Normalized transaction IDs force the ID not to change, even if a party replaces its signature.\n* Many higher level protocols build structures of transactions on top of multisig outputs that are not completely signed. This is currently not possible without one party holding a fully signed transaction and then calculating the ID. It is desirable to be able to build successive transactions without one party collecting all signatures, and thus possibly lock in funds unilaterally. Normalized transaction IDs allow the use of transaction templates, i.e., completely unsigned transactions upon which further transactions can be built, and only once every party is assured the structure matches its expectations it signs the template, thus validating the template.\n\nThe only occurrence in which transactions can still be modified unilaterally is in the case <code>SIGHASH_NONE</code>, <code>SIGHASH_SINGLE</code> or <code>SIGHASH_ANYONECANPAY</code> is used. This however is not problematic since in these cases the creator of the transaction explicitly allows modification.\n\nIn case of a transaction becoming invalid due to one of the inputs being malleated it is necessary to modify the spending transaction to reference the modified transaction ID. However, the signatures, which only use the normalized IDs, remain valid as long as the semantics of the funding transaction remain unchanged. An observer in the network may fix the transaction and reinject a corrected version.\n\nUsing version 2 for transactions is an explicit opt-in to the normalized ID tracking and a simple upgrade for existing clients. It avoids having to reprocess the entire blockchain and computing the normalized transaction IDs for existing outputs in the UTXO. This would be further complicated by having to recursively compute normalized transaction IDs down to the coinbase transactions which created the coins.\n\nTracking the normalized transaction IDs in the UTXO requires the storage of an additional hash per transaction whose outputs are not completely spent, which at 7,000,000 transactions with unspent outputs amounts to 224MB additional storage on disk.\n\nThe coinbase transactions have been checked for hash-collisions and no collisions were found except for the coinbase transactions in blocks at heights 91842 and 91880, which are known to be identical<ref>[[https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki|BIP 30 - Duplicate transactions]]</ref>, and motivated the introduction of BIP 34.<ref>[[https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki|Block v2, Height in Coinbase]]</ref> Since coinbase transactions are invalid if transmitted outside of a block it is not possible to modify them on the fly and since they only mature after being included for a long time in the blockchain they are considered safe.\n\n=== OP_CHECKSIGEX ===\n\nThe new opcode <code>OP_CHECKSIGEX</code> was introduced in order to allow the use of normalized transaction IDs as a softfork and in order to keep the number of <code>OP_NOP</code>s needed to a bare minimum, while enabling future soft-fork updates to the signing algorithms.\n\nThe additional argument containing the version can be pushed on the stack using a single byte up to version 16 (<code>OP_1</code> - <code>OP_16</code>), resulting in one byte overhead for this script type. Using the standard multisig format also for 1-of-1 transactions add an additional 2 bytes, however it also removes the bug requiring a dummy push, resulting in a single byte overhead.\nFurthermore, using Schnorr signatures instead of ECDSA brings a number of improvements that reduce the size of transactions (''m-of-m'' is the same size as ''1-of-1'') and increase verification speed (batch signature validation by summing up keys and signatures). The code is already in bitcoin/secp256k1 and can be merged in. We limited the description of this BIP to re-using BIP 11 style ''m-of-n'' scripts to keep it short, however Schnorr also allows a number of more complex applications which we defer to future BIPs.\n\nVersion 0 was intentionally skipped in order to guarantee that the top-most element before <code>OP_CHECKSIGEX</code> is non-zero. This is necessary to guarantee that non-upgraded clients, which interpret <code>OP_CHECKSIGEX</code> as <code>OP_NOP4</code>, do not end up with a zero value on top of the stack after execution, which would be interpreted as script failure.\n\n=== Impact ===\n\nThis is a softfork which replaces <code>OP_NOP4</code> with the new implementation of <code>OP_CHECKSIGEX</code>, as such the impact on the network is minimal. Wallets that do not implement this opcode will not be able to verify the validity of the scripts, however if transactions using <code>OP_CHECKSIGEX</code> are included in blocks they will accept them and track the inputs correctly. This is guaranteed since the transaction inputs still use the non-normalized transaction ID to reference the outputs to be claimed, hence non-upgraded wallets can still lookup the outputs and mark them as spent. Furthermore, clients that do not implement this BIP are unable to identify outputs using this script as their own, however upgrading and rescanning the blockchain will make them available.\n\n== See also ==\n\n* [[bip-0062.mediawiki|BIP 62: Dealing with malleability]]\n* [[bip-0066.mediawiki|BIP 66: Strict DER Signatures]]\n\n== References ==\n<references>\n\n==Copyright==\nThis document is placed in the public domain.\n", "content_length": 15041}
{"bip_number": 137, "filename": "bip-0137.mediawiki", "content": "<pre>\n  BIP: 137\n  Layer: Applications\n  Title: Signatures of Messages using Private Keys\n  Author: Christopher Gilliard <christopher.gilliard@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0137\n  Status: Final\n  Type: Standards Track\n  Created: 2019-02-16\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document describes a signature format for signing messages with Bitcoin private keys.\n\nThe specification is intended to describe the standard for signatures of messages that can be signed and verified between different clients that exist in the field today. Note: that a new signature format has been defined which has a number of advantages over this BIP, but to be backwards compatible with existing implementations this BIP will be useful. See BIP 322 [1] for full details on the new signature scheme.\n\nOne of the key problems in this area is that there are several different types of Bitcoin addresses and without introducing specific standards it is unclear which type of address format is being used. See [2]. This BIP will attempt to address these issues and define a clear and concise format for Bitcoin signatures.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nSince Bitcoin private keys can not only be used to sign Bitcoin transactions, but also any other message, it has become customary to use them to sign various messages for differing purposes. Some applications of signing messages with a Bitcoin private key are as follows: proof of funds for collateral, credit worthiness, entrance to events, airdrops, audits as well as other applications. While there was no BIP written for how to digitally sign messages with Bitcoin private keys with P2PKH addresses it is a fairly well understood process, however with the introduction of Segwit (both in the form of P2SH and bech32) addresses, it is unclear how to distinguish a P2PKH, P2SH, or bech32 address from one another. This BIP proposes a standard signature format that will allow clients to distinguish between the different address formats.\n\n==Specification==\n\n===Background on ECDSA Signatures===\n\n(For readers who already understand how ECDSA signatures work, you can skip this section as this is only intended as background information.)\nElliptic Curve Digital Signature Algorithm or ECDSA is a cryptographic algorithm used by Bitcoin to ensure that funds can only be spent by their rightful owners.\n\nA few concepts related to ECDSA:\n\n<b>private key</b>: A secret number, known only to the person that generated it. A private key is essentially a randomly generated number. In Bitcoin, someone with the private key that corresponds to funds on the block chain can spend the funds. In Bitcoin, a private key is a single unsigned 256 bit integer (32 bytes).\n\n<b>public key</b>: A number that corresponds to a private key, but does not need to be kept secret. A public key can be calculated from a private key, but not vice versa. A public key can be used to determine if a signature is genuine (in other words, produced with the proper key) without requiring the private key to be divulged. In Bitcoin, public keys are either compressed or uncompressed. Compressed public keys are 33 bytes, consisting of a prefix either 0x02 or 0x03, and a 256-bit integer called x. The older uncompressed keys are 65 bytes, consisting of constant prefix (0x04), followed by two 256-bit integers called x and y (2 * 32 bytes). The prefix of a compressed key allows for the y value to be derived from the x value.\n\n<b>signature</b>: A number that proves that a signing operation took place. A signature is mathematically generated from a hash of something to be signed, plus a private key. The signature itself is two numbers known as r and s. With the public key, a mathematical algorithm can be used on the signature to determine that it was originally produced from the hash and the private key, without needing to know the private key. Signatures are either 73, 72, or 71 bytes long, with probabilities approximately 25%, 50% and 25% respectively, although sizes even smaller than that are possible with exponentially decreasing probability. Source [3].\n\n===Conventions with signatures used in Bitcoin===\n\nBitcoin signatures have the r and s values mentioned above, and a header. The header is a single byte and the r and s are each 32 bytes so a signature's size is 65 bytes. The header is used to specify information about the signature. It can be thought of as a bitmask with each bit in this byte having a meaning. The serialization format of a Bitcoin signature is as follows:\n\n[1 byte of header data][32 bytes for r value][32 bytes for s value]\n\nThe header byte has a few components to it. First, it stores something known as the recId. This value is stored in the least significant 2 bits of the header. If the header is between a value of 31 and 34, this indicates that it is a compressed address. If the header value is between 35 and 38 inclusive, it is a p2sh segwit address. If the header value is between 39 and 42, it is a bech32 address.\n\n===Procedure for signing/verifying a signature===\n\nAs noted above the signature is composed of three components, the header, r and s values. r/s can be computed with standard ECDSA library functions. Part of the header includes something called a recId. This is part of every ECDSA signature and should be generated by the ECDSA library. The recId is a number between 0 and 3 inclusive. The header is the recId plus a constant which indicates what type of Bitcoin address this is. For P2PKH address using an uncompressed public key this value is 27. For P2PKH address using compressed public key this value is 31. For P2SH-P2WPKH this value is 35 and for P2WPKH (version 0 witness) address this value is 39. So, you have the following ranges:\n* 27-30: P2PKH uncompressed\n* 31-34: P2PKH compressed\n* 35-38: Segwit P2SH\n* 39-42: Segwit Bech32\n\nTo verify a signature, the recId is obtained by subtracting this constant from the header value.\n\n===Sample Code for processing a signature===\n\nNote: this code is a modification of the BitcoinJ code which is written in java.\n\n    public static ECKey signedMessageToKey(String message, String signatureBase64) throws SignatureException {\n        byte[] signatureEncoded;\n        try {\n            signatureEncoded = Base64.decode(signatureBase64);\n        } catch (RuntimeException e) {\n            // This is what you get back from Bouncy Castle if base64 doesn't decode :(\n            throw new SignatureException(\"Could not decode base64\", e);\n        }\n        // Parse the signature bytes into r/s and the selector value.\n        if (signatureEncoded.length < 65)\n            throw new SignatureException(\"Signature truncated, expected 65 bytes and got \" + signatureEncoded.length);\n        int header = signatureEncoded[0] & 0xFF;\n        // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n        //                  0x1D = second key with even y, 0x1E = second key with odd y\n        if (header < 27 || header > 42)\n            throw new SignatureException(\"Header byte out of range: \" + header);\n        BigInteger r = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 1, 33));\n        BigInteger s = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 33, 65));\n        ECDSASignature sig = new ECDSASignature(r, s);\n        byte[] messageBytes = formatMessageForSigning(message);\n        // Note that the C++ code doesn't actually seem to specify any character encoding. Presumably it's whatever\n        // JSON-SPIRIT hands back. Assume UTF-8 for now.\n        Sha256Hash messageHash = Sha256Hash.twiceOf(messageBytes);\n        boolean compressed = false;\n        // this section is added to support new signature types\n        if(header>= 39) // this is a bech32 signature\n        {\n            header -= 12;\n            compressed = true;\n        } // this is a segwit p2sh signature\n        else if(header >= 35)\n        {\n            header -= 8;\n            compressed = true;\n        } // this is a compressed key signature\n        else if (header >= 31) {\n            compressed = true;\n            header -= 4;\n        }\n        int recId = header - 27;\n        ECKey key = ECKey.recoverFromSignature(recId, sig, messageHash, compressed);\n        if (key == null)\n            throw new SignatureException(\"Could not recover public key from signature\");\n        return key;\n    }\n\n==Backwards Compatibility==\n\nSince this format includes P2PKH keys, it is backwards compatible, but keep in mind some software has checks for ranges of headers and will report the newer segwit header types as errors.\n\n==Implications==\n\nMessage signing is an important use case and potentially underused due to the fact that, up until now, there has not been a formal specification for how wallets can sign messages using Bitcoin private keys. Bitcoin wallets should be interoperable and use the same conventions for determining a signature's validity. This BIP can also be updated as new signature formats emerge.\n\n==Acknowledgements==\n\n* Konstantin Bay - review\n* Holly Casaletto - review\n* James Bryrer - review\n\nNote that the background on ECDSA signatures was taken from en.bitcoin.it and code sample modified from BitcoinJ.\n\n==References==\n\n[1] - https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki\n\n[2] - https://github.com/bitcoin/bitcoin/issues/10542\n\n[3] - https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm\n", "content_length": 9549}
{"bip_number": 136, "filename": "bip-0136.mediawiki", "content": "<pre>\n  BIP: 136\n  Layer: Applications\n  Title: Bech32 Encoded Tx Position References\n  Author: \u0412\u0435\u043b\u0435\u0441\u043b\u0430\u0432 <veleslav.bips@protonmail.com>\n          Jonas Schnelli <dev@jonasschnelli.ch>\n          Daniel Pape <dpape@dpape.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0136\n  Status: Draft\n  Type: Informational\n  Created: 2017-07-09\n  License: BSD-2-Clause\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\nThis document proposes a convenient, human usable encoding to refer to a '''confirmed transaction position''' within the Bitcoin blockchain--known as '''\"TxRef\"'''. The primary purpose of this encoding is to allow users to refer to a confirmed transaction (and optionally, a particular outpoint index within the transaction) in a standard, reliable, and concise way.\n\n''Please note: Unlike a transaction ID, '''\"TxID\"''', where there is a strong cryptographic link between the ID and the actual transaction, a '''TxRef''' only provides a weak link to a particular transaction. A '''TxRef''' locates an offset within a blockchain for a transaction, that may - or may not - point to an actual transaction, which in fact may change with reorganisations. We recommend that '''TxRef'''s should be not used for positions within the blockchain having a maturity less than 100 blocks.''\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [https://tools.ietf.org/html/rfc2119 RFC 2119].\n\n=== Copyright ===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n=== Motivation ===\nSince the first version of Bitcoin, '''TxID'''s have been a core part of the consensus protocol and are routinely used to identify individual transactions between users.\n\nHowever, for many use-cases they have practical limitations:\n* '''TxID'''s are expensive for full nodes to lookup (requiring either a linear scan of the blockchain, or an expensive '''TxID''' index).\n* '''TxID'''s require third-party services for SPV wallets to lookup.\n* '''TxID'''s are 64 character HEX encoded values.\n\nIt is possible to reference transactions not only by their '''TxID''', but by their location within the blockchain itself. Rather than use the 64 character '''TxID''', an encoding of the position coordinates can be made friendly for occasional human transcription. In this document, we propose a standard for doing this.\n\n=== Examples ===\n\n{| class=\"wikitable\"\n|-\n! Block # !! Transaction # !! Outpoint # !! TxRef !! TxID\n|-\n| 0 || 0 || 0 || tx1:rqqq&#8209;qqqq&#8209;qwtv&#8209;vjr || 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\n|-\n| 170 || 1 || 0 || tx1:r52q&#8209;qqpq&#8209;qpty&#8209;cfg || f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16\n|-\n| 456789 || 1234 || 1 || tx1:y29u&#8209;mqjx&#8209;ppqq&#8209;sfp2&#8209;tt || 6fb8960f70667dc9666329728a19917937896fc476dfc54a3e802e887ecb4e82\n|}\n\n== Specification ==\n\nA '''confirmed transaction position reference''', or '''TxRef''', is a reference to a particular location within the blockchain, specified by the block height and a transaction index within the block, and optionally, an outpoint index within the transaction.\n\n''Please Note: All values in this specification are encoded in little-endian format.''\n\n=== TxRef Considerations ===\nIt is possible for a '''TxRef''' to reference a transaction that doesn't really exist because:\n\n* The specified block hasn't yet been mined.\n* The transaction index is greater than the total number of transactions included within the specified block.\n* The optional outpoint index is greater than the total outpoints contained within the transaction.\n\nTherefore, implementers must be careful not to display '''TxRef'''s to users prematurely:\n\n* Applications MUST NOT display '''TxRef'''s for transactions with less than 6 confirmations.\n* Application MUST show a warning for '''TxRef'''s for transactions with less than 100 confirmations.\n** This warning SHOULD state that in the case of a large reorganisation, the '''TxRef'''s displayed may point to a different transaction, or to no transaction at all.\n\n=== TxRef Format ===\n\n'''TxRef''' MUST use the '''Bech32m'''<ref>'''Why use Bech32 Encoding for Confirmed Transaction References?''' The error detection and correction properties of this encoding format make it very attractive. We expect that it will be reasonable for software to correct a maximum of two characters; however, we haven\u2019t specified this yet.</ref> encoding as defined in [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP-0173] and later refined in [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki BIP-0350]. The Bech32m encoding consists of:\n\n==== Human-Readable Part ====\n\nThe '''HRP''' can be thought of as a label. We have chosen labels to distinguish between Main, Test, and Regtest networks:\n* Mainnet: '''\"tx\"'''.\n* Testnet: '''\"txtest\"'''.\n* Regtest: '''\"txrt\"'''.\n\n==== Separator ====\n\nThe separator is the character '''\"1\"'''.\n\n==== Data Part ====\n\nThe data part for a '''TxRef''' consists of the transaction's block height, transaction index within the block, and optionally, an outpoint index. Specific encoding details for the data are given below.\n\n''Please note: other specifications, such as [https://w3c-ccg.github.io/did-spec/ the Decentralized Identifiers spec], have implicitly encoded the information contained within the HRP elsewhere. In this case they may choose to not include the HRP as specified here.''\n\n==== Readability ====\n\nTo increase portability and readability, additional separator characters SHOULD be added to the '''TxRef''':\n\n* A Colon<ref>'''Why add a colon here?''' This allows it to conform better with W3C URN/URL standards.</ref> '''\":\"'''  added after the separator character '1'.\n* Hyphens<ref>'''Why hyphens within the TxRef?''' As '''TxRef'''s are short, we expect that they will be quoted via voice or written by hand. The inclusion of hyphens every 4 characters breaks up the string and means people don't lose their place so easily.</ref> '''\"-\"''' added after every 4 characters beyond the colon.\n\n=== Encoding ===\n\nEncoding a '''TxRef''' requires 4 or 5 pieces of data: a magic code denoting which network is being used; a version number (currently always 0); the block height of the block containing the transaction; the index of the transaction within the block; and optionally, the index of the outpoint within the transaction. Only a certain number of bits are supported for each of these values, see the following table for details.\n\n{| class=\"wikitable\"\n!\n!Description\n!Possible Data Type\n!'''# of Bits used'''\n!Values\n|-\n| style=\"background: #99DDFF; color: black; text-align : center;\" | Magic Code\n|Chain Namespacing Code\n|uint8\n| style=\"background: #99DDFF; color: black; text-align : center;\" | 5\n|'''3''': Mainnet<br>'''4''': Mainnet with Outpoint<br>'''6''': Testnet<br>'''7''': Testnet with Outpoint<br>'''0''': Regtest<br>'''1''': Regtest with Outpoint\n|-\n| style=\"background: #DDDDDD; color: black; text-align : center;\" | Version\n|For Future Use\n|uint8\n| style=\"background: #DDDDDD; color: black; text-align : center;\" | 1\n|Must be '''0'''\n|-\n| style=\"background: #EEDD88; color: black; text-align : center;\" | Block<br>Height\n|The Block Height of the Tx\n|uint32\n| style=\"background: #EEDD88; color: black; text-align : center;\" | 24\n|Block 0 to Block 16777215\n|-\n| style=\"background: #FFAABB; color: black; text-align : center;\" | Transaction<br>Index\n|The index of the Tx inside the block\n|uint16, uint32\n| style=\"background: #FFAABB; color: black; text-align : center;\" | 15\n|Tx 0 to Tx 32767\n|-\n| style=\"background: #BBCC33; color: black; text-align : center;\" | Outpoint<br>Index\n|The index of the Outpoint inside the Tx\n|uint16, uint32\n| style=\"background: #BBCC33; color: black; text-align : center;\" | 15\n|Outpoint 0 to Outpoint 32767\n|}\n\n==== Magic Notes ====\nThe magic code provides namespacing between chains:\n\n* For Mainnet the magic code is: '''0x3''', leading to an '''\"r\"''' character when encoded.\n* For Mainnet with Outpoint Encoded the magic code is: '''0x4''', leading to a '''\"y\"''' character when encoded.\n* For Testnet the magic code is: '''0x6''', leading to an '''\"x\"''' character when encoded.\n* For Testnet with Outpoint Encoded the magic code is: '''0x7''', leading to an '''\"8\"''' character when encoded.\n* For Regtest the magic code is: '''0x0''', leading to a '''\"q\"''' character when encoded.\n* For Regtest with Outpoint Encoded the magic code is: '''0x1''', leading to a '''\"p\"''' character when encoded.\n\n==== Encoding Example ====\n\nWe want to encode a '''TxRef''' that refers to Transaction #1234 of Block #456789 on the Mainnet chain. We use this data in preparation for the Bech32 encoding algorithm:\n\n{| class=\"wikitable\"\n!\n!Decimal<br>Value\n!Binary<br>Value\n!'''# of Bits<br>used'''\n!Bit Indexes and Values\n|-\n| style=\"background: #99DDFF; color: black; text-align : center;\" | Magic<br>Code\n| style=\"background: #99DDFF; color: black; text-align : center;\" | 3\n|00000011\n| style=\"background: #99DDFF; color: black; text-align : center;\" | 5\n|(mc04, mc03, mc02, mc01, mc00) = (0, 0, 0, 1, 1)\n|-\n| style=\"background: #DDDDDD; color: black; text-align : center;\" | Version\n| style=\"background: #DDDDDD; color: black; text-align : center;\" | 0\n|00000000\n| style=\"background: #DDDDDD; color: black; text-align : center;\" | 1\n|(v0) = (0)\n|-\n| style=\"background: #EEDD88; color: black; text-align : center;\" | Block<br>Height\n| style=\"background: #EEDD88; color: black; text-align : center;\" | 456789\n|00000110<br>11111000<br>01010101\n| style=\"background: #EEDD88; color: black; text-align : center;\" | 24\n|(bh23, bh22, bh21, bh20, bh19, bh18, bh17, bh16) = (0, 0, 0, 0, 0, 1, 1, 0)<br>(bh15, bh14, bh13, bh12, bh11, bh10, bh09, bh08) = (1, 1, 1, 1, 1, 0, 0, 0)<br>(bh07, bh06, bh05, bh04, bh03, bh02, bh01, bh00) = (0, 1, 0, 1, 0, 1, 0, 1)\n|-\n| style=\"background: #FFAABB; color: black; text-align : center;\" | Transaction<br>Index\n| style=\"background: #FFAABB; color: black; text-align : center;\" | 1234\n|00000100<br>11010010\n| style=\"background: #FFAABB; color: black; text-align : center;\" | 15\n|(ti14, ti13, ti12, ti11, ti10, ti09, ti08) = (0, 0, 0, 0, 1, 0, 0)<br>(ti07, ti06, ti05, ti04, ti03, ti02, ti01, ti00) = (1, 1, 0, 1, 0, 0, 1, 0)\n|}\n\nAs shown in the last column, we take the necessary bits of each binary value and copy them into nine unsigned chars illustrated in the next table. We only set the lower five bits of each unsigned char as the bech32 algorithm only uses those bits.\n\n{| class=\"wikitable\" style=\"text-align: center\"\n!\n!\n!style=\"width:2em\"|7\n!style=\"width:2em\"|6\n!style=\"width:2em\"|5\n!style=\"width:2em\"|4\n!style=\"width:2em\"|3\n!style=\"width:2em\"|2\n!style=\"width:2em\"|1\n!style=\"width:2em\"|0\n!\n!Decimal<br>Value\n!Bech32<br>Character\n|-\n| || || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[0] || Index\n|na\n|na\n|na\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc04\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc03\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc02\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc01\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc00\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|0\n|1\n|1\n|\n|3\n|r\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[1] || Index\n|na\n|na\n|na\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh03\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh02\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh01\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh00\n| style=\"background: #DDDDDD; color: black; text-align : center;\" | v0\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|1\n|0\n|1\n|0\n|\n|10\n|2\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[2] || Index\n|na\n|na\n|na\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh08\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh07\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh06\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh05\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh04\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|1\n|0\n|1\n|\n|5\n|9\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[3] || Index\n|na\n|na\n|na\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh13\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh12\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh11\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh10\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh09\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|1\n|1\n|1\n|0\n|0\n|\n|28\n|u\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[4] || Index\n|na\n|na\n|na\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh18\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh17\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh16\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh15\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh14\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|1\n|1\n|0\n|1\n|1\n|\n|27\n|m\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[5] || Index\n|na\n|na\n|na\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh23\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh22\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh21\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh20\n| style=\"background: #EEDD88; color: black; text-align : center;\" | bh19\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|\n|0\n|q\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[6] || Index\n|na\n|na\n|na\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti04\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti03\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti02\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti01\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti00\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|1\n|0\n|0\n|1\n|0\n|\n|18\n|j\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[7] || Index\n|na\n|na\n|na\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti09\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti08\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti07\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti06\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti05\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|1\n|1\n|0\n|\n|6\n|x\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[8] || Index\n|na\n|na\n|na\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti14\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti13\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti12\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti11\n| style=\"background: #FFAABB; color: black; text-align : center;\" | ti10\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|1\n|\n|1\n|p\n|}\n\nThe Bech32 algorithm encodes the nine unsigned chars above and computes a checksum of those chars and encodes that as well--this gives a six character checksum (in this case, '''utt3p0''') which is appended to the final '''TxRef'''. The final '''TxRef''' given is: '''tx1:r29u-mqjx-putt-3p0''' and is illustrated in the following table:\n\nTxRef character indexes and descriptions\n{| class=\"wikitable\" style=\"text-align: top\"\n!style=\"width:2em\"|Index\n!style=\"width:2em\"|0\n!style=\"width:2em\"|1\n!style=\"width:2em\"|2\n!style=\"width:2em\"|3\n!style=\"width:2em\"|4\n!style=\"width:2em\"|5\n!style=\"width:2em\"|6\n!style=\"width:2em\"|7\n!style=\"width:2em\"|8\n!style=\"width:2em\"|9\n!style=\"width:2em\"|10\n!style=\"width:2em\"|11\n!style=\"width:2em\"|12\n!style=\"width:2em\"|13\n!style=\"width:2em\"|14\n!style=\"width:2em\"|15\n!style=\"width:2em\"|16\n!style=\"width:2em\"|17\n!style=\"width:2em\"|18\n!style=\"width:2em\"|19\n!style=\"width:2em\"|20\n!style=\"width:2em\"|21\n|-\n|Char:\n|  style=\"background: #BBCCEE; color: black; text-align : center;\" | t\n|  style=\"background: #BBCCEE; color: black; text-align : center;\" | x\n|  style=\"background: #FFCCCC; color: black; text-align : center;\" | 1\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | &#58;\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | r\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 2\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 9\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | u\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | m\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | q\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | j\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | x\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | p\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | u\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | t\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | t\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 3\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | p\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 0\n|}\n\n==== Outpoint Index ====\n\nSome uses of '''TxRef''' may want to refer to a specific outpoint of the transaction. In the previous example, since we did not specify the outpoint index, the '''TxRef''' '''tx1:r29u-mqjx-putt-3p0''' implicitly references the first (index 0) outpoint of the 1234th transaction in the 456789th block in the blockchain.\n\nIf instead, for example, we want to reference the second (index 1) outpoint, we need to change the magic code from '''3''' to '''4''' and would include the following in the data to be encoded:\n\n{| class=\"wikitable\"\n!\n!Decimal<br>Value\n!Binary<br>Value\n!'''# of Bits<br>used'''\n!Bit Indexes and Values\n|-\n| style=\"background: #99DDFF; color: black; text-align : center;\" | Magic<br>Code\n| style=\"background: #99DDFF; color: black; text-align : center;\" | 4\n|00000100\n| style=\"background: #99DDFF; color: black; text-align : center;\" | 5\n|(mc04, mc03, mc02, mc01, mc00) = (0, 0, 1, 0, 0)\n|-\n| style=\"background: #BBCC33; color: black; text-align : center;\" | Outpoint Index\n| style=\"background: #BBCC33; color: black; text-align : center;\" | 1\n|00000000 00000001\n| style=\"background: #BBCC33; color: black; text-align : center;\" | 15\n|(op14, op13, op12, op11, op10, op09, op08) = (0, 0, 0, 0, 0, 0, 0)<br>(op07, op06, op05, op04, op03, op02, op01, op00) = (0, 0, 0, 0, 0, 0, 0, 1)\n|}\n\n{| class=\"wikitable\" style=\"text-align: center\"\n!\n!\n!style=\"width:2em\"|7\n!style=\"width:2em\"|6\n!style=\"width:2em\"|5\n!style=\"width:2em\"|4\n!style=\"width:2em\"|3\n!style=\"width:2em\"|2\n!style=\"width:2em\"|1\n!style=\"width:2em\"|0\n!\n!Decimal<br>Value\n!Bech32<br>Character\n|-\n| || || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[0] || Index\n|na\n|na\n|na\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc04\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc03\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc02\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc01\n| style=\"background: #99DDFF; color: black; text-align : center;\" | mc00\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|1\n|0\n|0\n|\n|4\n|y\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[9] || Index\n|na\n|na\n|na\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op04\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op03\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op02\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op01\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op00\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|1\n|\n|1\n|p\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[10] || Index\n|na\n|na\n|na\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op09\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op08\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op07\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op06\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op05\n|\n|\n|\n|-\n|Value\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|\n|0\n|q\n|-\n| || || || || || || || || || || ||\n|-\n| rowspan=\"2\" | data[11] || Index\n|na\n|na\n|na\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op14\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op13\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op12\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op11\n| style=\"background: #BBCC33; color: black; text-align : center;\" | op10\n|\n|\n|\n|-\n| Value\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|0\n|\n|0\n|q\n|}\n\nAfter Bech32 encoding all twelve unsigned chars above, we get the checksum: '''sfp2tt'''. The final '''TxRef''' given is: '''tx1:y29u-mqjx-ppqq-sfp2-tt''' and is illustrated in the following table:\n\nTxRef character indexes and descriptions\n{| class=\"wikitable\" style=\"text-align: top\"\n!style=\"width:2em\"|Index\n!style=\"width:2em\"|0\n!style=\"width:2em\"|1\n!style=\"width:2em\"|2\n!style=\"width:2em\"|3\n!style=\"width:2em\"|4\n!style=\"width:2em\"|5\n!style=\"width:2em\"|6\n!style=\"width:2em\"|7\n!style=\"width:2em\"|8\n!style=\"width:2em\"|9\n!style=\"width:2em\"|10\n!style=\"width:2em\"|11\n!style=\"width:2em\"|12\n!style=\"width:2em\"|13\n!style=\"width:2em\"|14\n!style=\"width:2em\"|15\n!style=\"width:2em\"|16\n!style=\"width:2em\"|17\n!style=\"width:2em\"|18\n!style=\"width:2em\"|19\n!style=\"width:2em\"|20\n!style=\"width:2em\"|21\n!style=\"width:2em\"|22\n!style=\"width:2em\"|23\n!style=\"width:2em\"|24\n!style=\"width:2em\"|25\n|-\n|Char:\n|  style=\"background: #BBCCEE; color: black; text-align : center;\" | t\n|  style=\"background: #BBCCEE; color: black; text-align : center;\" | x\n|  style=\"background: #FFCCCC; color: black; text-align : center;\" | 1\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | &#58;\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | y\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 2\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 9\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | u\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | m\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | q\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | j\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | x\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | p\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | p\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | q\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | q\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | s\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | f\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | p\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | 2\n|  style=\"background: #CCDDAA; color: black; text-align : center;\" | -\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | t\n|  style=\"background: #EEEEBB; color: black; text-align : center;\" | t\n|}\n\n\n=== Decoding ===\n\nThe Bech32 spec defines 32 valid characters as its \"alphabet\". All non-Bech32-alphabet characters present in a '''TxRef''' after the Bech32 separator character MUST be ignored/removed when parsing (except for terminating characters). We do not wish to expect the users to keep their '''TxRef'''s in good form and '''TxRef'''s may contains hyphens, colons, invisible spaces, uppercase or random characters. We expect users to copy, paste, write by-hand, write in a mix of character sets, etc. Parsers SHOULD attempt to correct for these and other common errors, reporting to the user any '''TxRef'''s that violate a proper Bech32 encoding.\n\nAs of early 2021, '''TxRef''' has been in limited use for a couple of years and it is possible that there are some '''TxRef'''s in use which were created with the original specification of Bech32 before the Bech32m refinement was codified. Due to this possibility, a '''TxRef''' parser SHOULD be able to decode both Bech32m and Bech32 encoded '''TxRef'''s. In such a case, a '''TxRef''' parser SHOULD display or somehow notify the user that they are using an obsolete '''TxRef''' and that they should upgrade it to the Bech32m version. Additionally, the parser MAY also display the Bech32m version.\n\n== Rationale ==\n\n<references />\n\n== Reference implementations ==\n\nC Reference Implementation (supports magic codes 0x3 and 0x6): https://github.com/jonasschnelli/bitcoin_txref_code\n\nGo Reference Implementation (supports magic codes 0x3 and 0x6): https://github.com/kulpreet/txref\n\nC++ Reference Implementation (supports magic codes 0x3, 0x4, 0x6, 0x7, 0x0 and 0x1): https://github.com/dcdpr/libtxref/\n\nJava Reference Implementation (supports magic codes 0x3, 0x4, 0x6, 0x7, 0x0 and 0x1): https://github.com/dcdpr/libtxref-java/\n\n== Appendices ==\n\n=== Test Examples ===\n\nThe following examples show values for various combinations on mainnet and testnet; encoding block height, transaction index, and an optional output index.\n\n==== TxRef ====\nThe following list gives properly encoded mainnet '''TxRef'''s and the decoded hex values (block height, transaction index)\n\n* <tt>tx1:rqqq-qqqq-qwtv-vjr</tt>: <tt>(0x0, 0x0)</tt>\n* <tt>tx1:rqqq-qqll-lj68-7n2</tt>: <tt>(0x0, 0x7FFF)</tt>\n* <tt>tx1:r7ll-llqq-qats-vx9</tt>: <tt>(0xFFFFFF, 0x0)</tt>\n* <tt>tx1:r7ll-llll-lp6m-78v</tt>: <tt>(0xFFFFFF, 0x7FFF)</tt>\n\nThe following list gives properly encoded testnet '''TxRef'''s and the decoded hex values (block height, transaction index)\n\n* <tt>txtest1:xqqq-qqqq-qrrd-ksa</tt>: <tt>(0x0, 0x0)</tt>\n* <tt>txtest1:xqqq-qqll-lljx-y35</tt>: <tt>(0x0, 0x7FFF)</tt>\n* <tt>txtest1:x7ll-llqq-qsr3-kym</tt>: <tt>(0xFFFFFF, 0x0)</tt>\n* <tt>txtest1:x7ll-llll-lvj6-y9j</tt>: <tt>(0xFFFFFF, 0x7FFF)</tt>\n\nThe following list gives valid (sometimes strangely formatted) '''TxRef'''s and the decoded values (block height, transaction index)*\n* <tt>tx1:r29u-mqjx-putt-3p0</tt>: <tt>(456789, 1234)</tt>\n* <tt>TX1R29UMQJXPUTT3P0</tt>: <tt>(456789, 1234)</tt>\n* <tt>tx1 r29u mqjx putt 3p0</tt>: <tt>(456789, 1234)</tt>\n* <tt>tx1!r29u/mqj*x-putt^^3p0</tt>: <tt>(456789, 1234)</tt>\n\nThe following list gives invalid '''TxRef'''s and the reason for their invalidity.\n* <tt>tx1:t7ll-llll-lcq3-aj4</tt>: Magic 0xB instead of 0x3.\n* <tt>tx1:rlll-llll-lu9m-00x</tt>: Version 1 instead of 0.\n* <tt>tx1:r7ll-llll-lqfu-gss2</tt>: Valid Bech32, but ten 5 bit unsigned chars instead of nine.\n* <tt>tx1:r7ll-llll-rt5h-wz</tt>: Valid Bech32, but eight 5 bit unsigned chars instead of nine.\n* <tt>tx1:r7ll-LLLL-lp6m-78v</tt>: Invalid Bech32 due to mixed case. Would decode correctly otherwise.\n\n==== TxRef with Outpoints ====\nThe following list gives properly encoded mainnet '''TxRef'''s with Outpoints and the decoded values (block height, transaction index, outpoint index)\n\n* <tt>tx1:yqqq-qqqq-qqqq-rvum-0c</tt>: <tt>(0x0, 0x0, 0x0)</tt>\n* <tt>tx1:yqqq-qqll-lqqq-en8x-05</tt>: <tt>(0x0, 0x7FFF, 0x0)</tt>\n* <tt>tx1:y7ll-llqq-qqqq-ggjg-w6</tt>: <tt>(0xFFFFFF, 0x0, 0x0)</tt>\n* <tt>tx1:y7ll-llll-lqqq-jhf4-wk</tt>: <tt>(0xFFFFFF, 0x7FFF, 0x0)</tt>\n\n* <tt>tx1:yqqq-qqqq-qpqq-pw4v-kq</tt>: <tt>(0x0, 0x0, 0x1)</tt>\n* <tt>tx1:yqqq-qqll-lpqq-m3w3-kv</tt>: <tt>(0x0, 0x7FFF, 0x1)</tt>\n* <tt>tx1:y7ll-llqq-qpqq-22ml-hz</tt>: <tt>(0xFFFFFF, 0x0, 0x1)</tt>\n* <tt>tx1:y7ll-llll-lpqq-s4qz-hw</tt>: <tt>(0xFFFFFF, 0x7FFF, 0x1)</tt>\n\n* <tt>tx1:y29u-mqjx-ppqq-sfp2-tt</tt>: <tt>(456789, 1234, 1)</tt>\n\n\nThe following list gives properly encoded testnet '''TxRef'''s with Outpoints and the decoded values (block height, transaction index, outpoint index)\n\n* <tt>txtest1:8qqq-qqqq-qqqq-d5ns-vl</tt>: <tt>(0x0, 0x0, 0x0)</tt>\n* <tt>txtest1:8qqq-qqll-lqqq-htgd-vn</tt>: <tt>(0x0, 0x7FFF, 0x0)</tt>\n* <tt>txtest1:87ll-llqq-qqqq-xsar-da</tt>: <tt>(0xFFFFFF, 0x0, 0x0)</tt>\n* <tt>txtest1:87ll-llll-lqqq-u0x7-d3</tt>: <tt>(0xFFFFFF, 0x7FFF, 0x0)</tt>\n\n* <tt>txtest1:8qqq-qqqq-qpqq-0k68-48</tt>: <tt>(0x0, 0x0, 0x1)</tt>\n* <tt>txtest1:8qqq-qqll-lpqq-4fp6-4t</tt>: <tt>(0x0, 0x7FFF, 0x1)</tt>\n* <tt>txtest1:87ll-llqq-qpqq-yj55-59</tt>: <tt>(0xFFFFFF, 0x0, 0x1)</tt>\n* <tt>txtest1:87ll-llll-lpqq-7d0f-5f</tt>: <tt>(0xFFFFFF, 0x7FFF, 0x1)</tt>\n\n* <tt>txtest1:829u-mqjx-ppqq-73wp-gv</tt>: <tt>(456789, 1234, 1)</tt>\n\n\n=== TxRef Payload Value Choices: ===\nSome calculations showing why we chose these particular bit-length of the block height and transaction index.\n\n==== Block Height Value: ====\n24 bits: value can be between 0, and 0xFFFFFF (16777216 blocks).\n\n* In early April, 2021, there have been 677700 blocks\n* There are roughly (365 days * 24 hours * 6 blocks / hour) = 52560 blocks every year, implying about (16777216 - 677700) / 52560 = 306 more years of addressable blocks.\n* Some time before year 2327 this specification should be extended.\n\n==== Tx Position Value: ====\n15 bits: value can be between 0x0, and 0x7FFF (32768 transactions).\n\n*The ''realistic'' smallest Tx is 83 Bytes for maximum 12047 tx in a block.\n**4B version + 1B tx_in count + 36B previous_output + 1B script length + 0B signature script + 4B sequence + 1B tx_out count + 8B amount + 1B script length + 23B pubkey script + 4B lock_time = 83B\n*The ''extreme'' smallest Tx is 60 Bytes for maximum 16665 tx in a block.\n**4B version + 1B tx_in count + 36B previous_output + 1B script length + 0B signature script + 4B sequence + 1B tx_out count + 8B amount + 1B script length + 0B pubkey script + 4B lock_time = 60B\n\n== Acknowledgements ==\nSpecial Thanks to Pieter Wuille and Greg Maxwell for Bech32, a wonderful user-facing data encoding.\n", "content_length": 30752}
{"bip_number": 135, "filename": "bip-0135.mediawiki", "content": "<pre>\n  BIP: 135\n  Title: Generalized version bits voting\n  Author: Sancho Panza <sanch0panza@protonmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0135\n                https://bitco.in/forum/threads/bip9-generalized-version-bits-voting-bip-genvbvoting.1968/\n  Status: Rejected\n  Type: Informational\n  Created: 2017-03-29\n  License: CC0-1.0\n           GNU-All-Permissive\n  Post-History: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-April/013969.html\n  Replaces: 9\n</pre>\n\n\n==Abstract==\n\nBIP9 introduced a mechanism for using the version bits to signal support for\nbackwards-compatible changes (soft-forks) using a tally over the previous 2016\nblocks computed at re-targeting intervals. It provided for a fixed threshold and\nnon-configurable lock-in interval applicable to all deployments on a chain.\n\nThis document describes a generalized signaling scheme which allows each\nsignaling bit to have its own configurable threshold, window size (number of\nblocks over which it is tallied) and a configurable lock-in period.\n\nIt extends the semantics of the signaling bits to cover arbitrary consensus\nchanges, referred to under the general term 'forks'. The same range\nof version bits is used for signaling.\n\nThe states of the BIP9 state machine and its original parameters (name, bit,\nstarttime, timeout) are retained. Some state transition conditions are\nextended by additional parameters ('threshold', 'windowsize', 'minlockedblocks',\n'minlockedtime') to provide for fine-tuning of threshold and grace period.\n\n\n==Motivation==\n\nThe Bitcoin protocol requires a flexible scheme for finding consensus on\nprotocol changes, to ensure that it can adapt to the needs of the market and\nremain competitive as an electronic payment system.\n\nWhile BIP9 has served the community well for previous deployments, there are\nsome shortcomings in its approach:\n\n* it specifically applies only to backward-compatible changes\n\n* its fixed 95% threshold is not flexible enough to allow for a 'spectrum of contentiousness' to be represented\n\n* small minorities can veto proposed changes, which can lead to undesirable stagnation\n\nA generalized revision of the BIP9 specification can address these issues\nand satisfy the needs of the market for both soft and hard fork changes\nas well as more flexible activation thresholds and upgrade (grace) periods.\n\nThe proposal should allow more freedom of choice in activation strategies\nwhile remaining backward compatible with respect to existing BIP9-based\ndeployments.\n\n\n==Terms and conventions==\n\nThe version bits used by this proposal for signaling deployment of forks are\nreferred to as 'signaling bits' or shortened to 'bits' where unambiguous.\n\nAll times in this specification are in seconds since the epoch [1].\nDurations / time offsets are in seconds.\n\nThe term 'MTP' refers to the 'median time past' which is calculated as the\nmedian nTime of a block and its 10 predecessors. It is treated as a monotonic\nclock defined by a chain, and evaluated on the ancestor of a block, i.e.\n\nMTP := '''GetMedianTimePast(block.parent)'''\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\ndocument are to be interpreted as described in RFC 2119.\n\n\n==Specification==\n\n\n===Backward compatibility===\n\nThis specification SHALL enable strict backward compatibility with existing\nBIP9-based deployments through suitable parameter configuration. Any part of\nthe specification preventing full backward compatibility SHALL be considered\nas erroneous and amended.\n\nAs before, a set of configuration parameters SHALL exist for the version bits\nfor each chain supported by an implementation. This permits each bit to be\nconfigured independently for each chain (mainnet, testnet, etc.)\n\n\n===Signaling bits===\n\n\nThe signaling bits SHALL comprise the 29 least significant bits of the\nnVersion block header field. nVersion is a 32-bit field which is treated as\na little-endian integer.\n\nSignaling bits SHALL be assigned numbers from 0..28 ranging from the least\nsignificant (bit 0) to the most significant (bit 28) in the range.\n\nThe top 3 bits of nVersion MUST be set to 001 , yielding a range of possible\nnVersion values between [0x20000000...0x3FFFFFFF], inclusive.\n\nIf a block's nVersion does not have its top 3 bits set to 001, all its signaling\nbits MUST be treated as if they are 0 (see also: 'Tallying' section below).\n\n\n===Deployment states===\n\nWith each block and fork, we associate a deployment state.\nThe possible states are:\n\n# '''DEFINED''' is the first state that each fork starts out as. The genesis block for any chain SHALL by definition be in this state for each deployment.\n# '''STARTED''' for blocks past the starttime.\n# '''LOCKED_IN''' after STARTED, if at least threshold out of windowsize blocks have the associated bit set in nVersion, measured at next height that is evenly divisible by the windowsize.\n# '''ACTIVE''' for all blocks after the grace period conditions have been met.\n# '''FAILED''' if past the timeout time and LOCKED_IN was not reached.\n\nIn accordance with BIP9, a block's state SHALL never depend on its own nVersion;\nonly on that of its ancestors.\n\n\n===Fork deployment parameters===\n\nEach fork deployment is specified by the following per-chain parameters:\n\n# The '''name''' specifies a very brief description of the fork, reasonable for use as an identifier. For deployments described in a single BIP, it is recommended to use the name \"bipN\" where N is the appropriate BIP number.\n# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the fork deployment. It is chosen from the set {0,1,2,...,28}.\n# The '''starttime''' specifies a minimum median time past (MTP) of a block at which the bit gains its meaning.\n# The '''timeout''' specifies a time at which the deployment is considered failed. If the MTP of a block >= timeout and the fork has not yet locked in (including this block's bit state), the deployment is considered failed on all descendants of the block.\n# The '''windowsize''' specifies the number of past blocks (including the block under consideration) to be taken into account for locking in a fork.\n# The '''threshold''' specifies a number of blocks, in the range of 1..windowsize, which must signal for a fork in order to lock it in. The support is measured when the chain height is evenly divisible by the windowsize. If the windowsize is set to 2016 (as in BIP9) this coincides with the 2016-block re-targeting intervals.\n# The '''minlockedblocks''' specifies a minimum number of blocks which a fork must remain in locked-in state before it can become active. Both minlockedblocks and minlockedtime (see below) must be satisfied before a fork can become active.\n# The '''minlockedtime''' specifies a minimum grace time, an earliest time after lock-in at which the fork can become active. If the MTP of a block >= (minlockedtime + median time of the block that locked in the fork), then the fork becomes activated. Both minlockedtime and minlockedblocks (see above) must be satisfied before a fork can become active.\n\n\n===Tallying===\n\nIf a block's nVersion does not have its top 3 bits set to 001, all its signaling\nbits MUST be treated as if they are '0'.\n\nA signaling bit value of '1' SHALL indicate support of a fork and SHALL count\ntowards its tally on a chain.\n\nA signaling bit value of '0' SHALL indicate absence of support of a fork and\nSHALL NOT count towards its tally on a chain.\n\nThe signaling bits SHALL be tallied whenever the head of the active chain\nchanges (including after reorganizations).\n\n\n===State transitions===\n\nThe following diagram illustrates the generalized state machine:\n\n<img src=\"bip-0135/bip-0135-states-small.png\" align=\"middle\"></img>\n<br>\n\n'''NOTES:'''\n\nThe genesis block of any chain SHALL have the state DEFINED for each deployment.\n\nA given deployment SHALL remain in the DEFINED state until it either passes the\nstarttime (and becomes STARTED) or the timeout time (and becomes FAILED).\n\nOnce a deployment has STARTED, the signal for that deployment SHALL be tallied\nover the past windowsize blocks whenever a new block is received on that\nchain.\n\nA transition from the STARTED state to the LOCKED_IN state SHALL only occur\nwhen all of these are true:\n\n* the height of the received block is an integer multiple of the window size\n* the MTP is below the timeout time\n* at least threshold out of windowsize blocks have signaled support\n\nA similar height synchronization precondition SHALL exist for the transition from\nLOCKED_IN to ACTIVE.\nThese synchronization conditions are expressed by the \"mod(height, windowsize) = 0\"\nclauses in the diagram, and have been added so that backward compatibility\nwith BIP9's use of the 2016-block re-targeting periods can be configured for\nexisting deployments (see above 'Optional full backward compatibility' section).\n\nA transition from LOCKED_IN to ACTIVE state SHALL only occur if the height\nsynchronization criterion is met and two configurable 'grace period' conditions\nare fulfilled:\n\n# current height MUST be at least minlockedblocks above LOCKED_IN height\n# MTP must exceed LOCKED_IN time by at least minlockedtime seconds\n\nNOTE: If minlockedtime and minlockedblocks are both set to 0, then the fork will\nproceed directly to ACTIVE state once the chain height reaches a multiple of the\nwindowsize.\n\nThe ACTIVE and FAILED states are terminal; a deployment stays in these states\nonce they are reached.\n\nDeployment states are maintained along block chain branches.\nThey need re-computation when a reorganization happens.\n\n\n===New consensus rules===\n\nNew consensus rules deployed by a fork SHALL be enforced for each block that has\nACTIVE state.\n\n\n===Optional operator notifications===\n\nAn implementation SHOULD notify the operator when a deployment transitions\nto STARTED, LOCKED_IN, ACTIVE or FAILED states.\n\nIt is RECOMMENDED that an implementation provide finer-grained notifications\nto the operator which allow him/her to track the measured support level for\ndefined deployments.\n\nAn implementation SHOULD warn the operator if the configured (emitted) nVersion\nhas been overridden to contain bits set to '1' in contravention of the above\nnon-signaling recommendations for DEFINED forks.\n\nIt is RECOMMENDED that an implementation warn the operator if no signal has\nbeen received for a given deployment during a full windowsize period after the\ndeployment has STARTED. This could indicate that something may be wrong with\nthe operator's configuration that is causing them not to receive the signal\ncorrectly.\n\nFor undefined signals, it is RECOMMENDED that implementation track these and\nalert their operators with supportive upgrade notifications, e.g.\n\n* \"warning: signaling started on unknown feature on version bit X\"\n* \"warning: signaling on unknown feature reached X% (over last N blocks)\"\n* \"info: signaling ceased on unknown feature (over last M blocks)\"\n\nSince parameters of these deployments are unknown, it is RECOMMENDED that\nimplementations allow the user to configure the emission of such notifications\n(e.g. suitable N and M parameters in the messages above, e.g. a best-guess\nwindow of 100 blocks).\n\n\n===getblocktemplate changes===\n\nThe getblocktemplate features introduced in BIP9 remain in effect unmodified.\n\n\n==Rationale==\n\nThe timeout into FAILED state allows eventual reuse of bits if a fork was not\nsuccessfully activated.\n\nA fallow period at the conclusion of a fork attempt allows some detection of\nbuggy clients, and allows time for warnings and software upgrades for\nsuccessful forks. The duration of a fallow period is not specified by this\nproposal, although a conventional fallow period of 3 months is RECOMMENDED.\n\nDue to the constraints set by BIP 34, BIP 66 and BIP 65, there are only\n0x7FFFFFFB possible nVersion values available. This limits to at most 30\nindependent deployments.\nBy restricting the top 3 bits to 001 we are left with 29 out of those for\nthe purposes of this proposal, and support two future upgrades for different\nmechanisms (top bits 010 and 011).\n\n\n==Guidelines==\n\n\n===Parameter selection guidelines===\n\nThe following guidelines are suggested for selecting the parameters for a fork:\n\n# '''name''' SHOULD be selected such that no two forks, concurrent or otherwise, ever use the same name.\n# '''bit''' SHOULD be selected such that no two concurrent forks use the same bit. Implementers should make an effort to consult resources such as [2] to establish whether the bit they wish to use can reasonably be assumed to be unclaimed by a concurrent fork, and to announce their use ('claim') of a bit for a fork purpose on various project mailing lists, to reduce chance of collisions.\n# '''starttime''' SHOULD be set to some date in the future, approximately one month after a software release date which includes the fork signaling.  This allows for some release delays, while preventing triggers as a result of parties running pre-release software.\n# '''timeout''' is RECOMMENDED to be 1 year (31536000 seconds) after starttime.\n# '''windowsize''' SHOULD be set large enough to allow reception of an adequately precise signal. A good high-resolution value would be 2016 blocks as used in BIP9. It is NOT RECOMMENDED to use a windowsize less than 100 blocks.\n# '''threshold''' SHOULD be set as high as possible to ensure a smooth activation based on the estimated support and the nature of the proposed changes. It is strongly RECOMMENDED that threshold >= windowsize / 2 (rounded up) to ensure that a proposal is only activated by majority support.\n# '''minlockedblocks''' is RECOMMENDED to be set >= windowsize, to ensure that a full window passes in LOCKED_IN state. Lower values will be ineffective as the transition from LOCKED_IN to ACTIVE is guarded by a synchronization based on the window size.\n# '''minlockedtime''' SHOULD only be set > 0 if a minimum LOCKED_IN time period needs be strictly enforced. It is permissible to set minlockedblocks to 0 and only specify minlockedtime, however the synchronization condition means the grace period can only expire once the time has passed AND the chain height is a multiple of the windowsize.\n\nNOTE: If minlockedtime and minlockedblocks are both set to 0, then the fork will\nproceed to ACTIVE state when the chain height reaches a multiple of the windowsize.\n\nA later deployment using the same bit is possible as long as the starttime is\nafter the previous fork's timeout or activation, but it is discouraged until\nnecessary, and even then recommended to have a pause in between to detect\nbuggy software.\n\n\n===Signaling guidelines===\n\nAn implementation SHOULD signal '0' on a bit if one of the following holds true:\n\n* the deployment parameters are not DEFINED (not configured or explicitly undefined)\n* the deployment is DEFINED and has not yet reached the STARTED state\n* the deployment has succeeded (it has become ACTIVE)\n* the deployment has FAILED\n\nAn implementation SHOULD enable the operator to choose (override) whether to\nsignal '0' or '1' on a bit, once its deployment has at least reached the STARTED\nstate.\n\nAn implementation SHOULD warn the operator if the configured (emitted) nVersion\nhas been overridden to contain bits set to '1' in contravention of the above\nnon-signaling recommendations.\n\nA supporting miner SHOULD signal '1' on a bit for which the deployment\nis LOCKED_IN state so that uptake is visible. However, this has no effect on\nconsensus rules.\nOnce LOCKED_IN, a deployment proceeds to ACTIVE solely based on the configured\ngrace period parameters (see 'Fork deployment parameters' above).\n\nA miner SHOULD signal '0' on a bit if they wish to suspend signaling of support\nfor a fork that is DEFINED in their software.\n\nIt is NOT RECOMMENDED to signal '1' for bits where the meaning is undefined\n(i.e. bits which are unclaimed by proposals).\n\n\n===Settings for BIP9 compatibility===\n\nThis section lists parameter values which can be used to effect compatibility\nwith the existing BIP9 versionbits state machine.\n\nThe following table describes mainnet compatibility options (95%, 2016 blocks):\n\n{| class=\"wikitable\"\n!colspan=3 |\n|-\n! Parameter !! BIP9 value !! BIP135 value\n|-\n| name || some_name || some_name\n|-\n| bit || b || b\n|-\n| starttime || T_start || T_start\n|-\n| timeout || T_timeout || T_timeout\n|-\n| windowsize || n/a || 2016\n|-\n| threshold || n/a || 1916\n|-\n| minlockedblocks || n/a || 2016\n|-\n| minlockedtime || n/a || 0\n|}\n\nThe following table describes testnet compatibility options (75%, 2016 blocks):\n\n{| class=\"wikitable\"\n!colspan=3 |\n|-\n! Parameter !! BIP9 value !! BIP135 value\n|-\n| name || some_name || some_name\n|-\n| bit || b || b\n|-\n| starttime || T_start || T_start\n|-\n| timeout || T_timeout || T_timeout\n|-\n| windowsize || n/a || 2016\n|-\n| threshold || n/a || 1512\n|-\n| minlockedblocks || n/a || 2016\n|-\n| minlockedtime || n/a || 0\n|}\n\n\n==Deployment==\n\nAs this BIP is not itself consensus-relevant (Information like BIP9), it can\nbe rolled out without the use of a BIP9 fork bit.\n\nBackward compatibility through judicious fork configuration parameters should\nensure that it does not interfere with existing known deployments.\n\nBy way of design it does not interfere with unknown (undefined) deployments.\n\n\n==Reference implementation==\n\nA working reference implementation, including tests, can be found in these Pull Requests:\n\n* https://github.com/BitcoinUnlimited/BitcoinUnlimited/pull/458\n\n* https://github.com/bitcoin/bitcoin/pull/10437\n\nExisting unit tests and regression tests have been left active to demonstrate\nbackward compatibility of the default settings with BIP9.\n\n\n==References==\n\n[1] http://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16\n\n[2] [[https://github.com/bitcoin/bips/blob/master/bip-0009/assignments.mediawiki|List of existing BIP9 deployment proposals]]\n\n\n==Copyright==\n\nThis BIP is dual-licensed under the Creative Commons CC0 1.0 Universal and\nGNU All-Permissive licenses.\n", "content_length": 18039}
{"bip_number": 134, "filename": "bip-0134.mediawiki", "content": "<pre>\n  BIP: 134\n  Layer: Consensus (hard fork)\n  Title: Flexible Transactions\n  Author: Tom Zander <tomz@freedommail.ch>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0134\n  Status: Rejected\n  Type: Standards Track\n  Created: 2016-07-27\n  License: CC-BY-SA-4.0\n           OPL\n</pre>\n\n==Abstract==\n\nThis BIP describes the next step in making Bitcoin's most basic element,\nthe transaction, more flexible and easier to extend. At the same time this\nfixes all known cases of malleability and resolves significant amounts of\ntechnical debt.\n\n==Summary==\n\nFlexible Transactions uses the fact that the first 4 bytes in a transaction\ndetermine the version and that the majority of the clients use a\nnon-consensus rule (a policy) to not accept transaction version numbers\nother than those specifically defined by Bitcoin.\nThis BIP chooses a new version number, 4, and defines that the data\nfollowing the bytes for the version is in a format called Compact Message\nFormat (CMF). CMF is a flexible, token based format where each token is a\ncombination of a name, a format and a value. Because the name is added we\ncan skip unused tokens and we can freely add new tokens in a simple manner\nin future. Soft fork upgrades will become much easier and cleaner this\nway.\n\nThis protocol upgrade cleans up past soft fork changes like BIP68 which\nreuse existing fields and do them in a better to maintain and easier\nto parse system. It creates the building blocks to allow new features to be\nadded much cleaner in the future.\n\nIt also shows to be possible to remove signatures from transactions with\nminimal upgrades of software and still maintain a coherent transaction\nhistory. Tests show that this can reduce space usage to about 75%.\n\n==Motivation==\n\nAfter 8 years of using essentially the same transaction version and layout\nBitcoin is in need of an upgrade and lessons learned in that time are\ntaking into account when designing it.  The most important detail is that\nwe have seen a need for more flexibility.  For instance when the 'sequence'\nfields were introduced in the old transaction format, and later deprecated\nagain, the end result was that all transactions still were forced to keep\nthose fields and grow the blockchain while they all were set to the default\nvalue.\n\nThe way towards that flexibility is to use a generic concept made popular\nvarious decades ago with the XML format. The idea is that we give each\nfield a name and this means that new fields can be added or optional fields\ncan be omitted from individual transactions. Some other ideas are the\nstandardization of data-formats (like integer and string encoding) so\nwe create a more consistent system.\nOne thing we shall not inherit from XML is its text-based format. Instead\nwe use the [https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md Compact Message Format]\n(CMF) which is optimized to keep the size small and fast to parse.\n\nToken based file-formats are not new, systems like XML and HTMl use a\nsimilar system to allow future growth and they have been quite successful\nfor decades in part because of this property.\n\nNext to that this protocol upgrade will re-order the data-fields which\nallows us to cleanly fix the malleability issue which means that future\ntechnologies like Lightning Network will depend on this BIP being deployed.\n\nAt the same time, due to this re-ordering of data fields, it becomes very\neasy to remove signatures from a transaction without breaking its tx-id,\nwhich is great for future pruning features.\n\n=== Features ===\n\n* Fixes malleability\n* Linear scaling of signature checking\n* Very flexible future extensibility\n* Makes transactions smaller\n* Supports the Lightning Network\n\nAdditionally, in the v4 (flextrans) format we add the support for the\nfollowing proofs;\n* input amount.  Including the amount means we sign this transaction only if the amount we are spending is the one provided. Wallets that do not have the full UTXO DB can safely sign knowing that if they were lied to about the amount being spent, their signature is useless.\n* scriptBase is the combined script of input and output, without signatures naturally.  Providing this to a hardware wallet means it knows what output it is spending and can respond properly. Including it in the hash means its signature would be broken if we lied..\n* Double spent-proof.  Should a node detect a double spent he can notify his peers about this fact. Instead of sending the entire transactions, instead he sends only a proof.  The node needs to send two pairs of info that proves that in both transactions the CTxIn are identical.\n\n=== Tokens ===\n\nIn the compact message format we define tokens and in this specification we\ndefine how these tokens are named, where they can be placed and which are\noptional.  To refer to XML, this specification would be the schema of\na transaction.\n\n[https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md CMF]\ntokens are triplets of name, format (like PositiveInteger) and value.\nNames in this scope are defined much like an enumeration where the actual\ninteger value (id, below) is equally important to the written name.\nIf any token found that is not covered in the next table it will make the\ntransaction that contains it invalid.\n\n{| class=\"wikitable\"\n|-\n! Name !! id !! Format !! Default Value !! Description\n|-\n|TxEnd              ||  0 ||BoolTrue ||   Required   ||A marker that is the end of the transaction\n|-\n|TxInPrevHash       ||  1 ||ByteArray||   Required   ||TxId we are spending\n|-\n|TxPrevIndex        ||  2 ||Integer  ||       0      ||Index in prev tx we are spending (applied to previous TxInPrevHash)\n|-\n|TxInputStackItem   ||  3 ||ByteArray||      &nbsp;  ||A 'push' of the input script\n|-\n|TxInputStackItemContinued||4||ByteArray||   &nsbp;       ||Another section for the same input\n|-\n|TxOutValue         ||  5 ||Integer  ||   Required   ||Amount of Satoshis to transfer\n|-\n|TxOutScript        ||  6 ||ByteArray||   Required   ||The output script\n|-\n|TxRelativeBlockLock||  7 ||Integer  ||   Optional   ||Part of the input stating the amount of blocks (max 0XFFFF) after that input was mined, it can be mined\n|-\n|TxRelativeTimeLock ||  8 ||Integer  ||   Optional   ||Part of the input stating the amount of time (max 0XFFFF) after that input was mined, it can be mined. 1 Unit is 512 seconds\n|-\n|CoinbaseMessage    ||  9 ||ByteArray||   Optional   ||A message and some data for a coinbase transaction. Can't be used in combination with any TxIn\\* tags\n|-\n|NOP_1x             || 1x ||   &nbsp;||   Optional   ||Values that will be ignored by anyone parsing the transaction\n|-\n|}\n\n\n=== Scripting changes ===\n\nIn Bitcoin transactions version 1, checking of signatures is performed by\nvarious opcodes. The OP_CHECKSIG, OP_CHECKMULTISIG and their equivalents\nthat immediately VERIFY.  These are used to validate the cryptographic\nproofs that users have to provide in order to spend outputs.\n\nWe additionally have some hashing-types in like SIGHASH_SINGLE that all\nspecify slightly different subsections of what part of a transaction will\nbe hashed in order to be signed.\n\nFor transactions with version 4 we calculate a sha256 hash for signing an\nindividual input based on the following content;\n\n# If the hash-type is 0 or 1 we hash the tx-id of the transaction. For other hash types we selectively ignore parts of the transaction exactly like it has always worked. With the caveat that we never serialize any signatures.\n# the TxId of the transaction we are spending in this input.\n# the index of output of the transaction we are spending in this input.\n# the input script we are signing (without the signature, naturally).\n# the amount, as a var-int.\n# the hash-type as a var-int.\n\n\n=== Serialization order===\n\n\nTo keep in line with the name Flexible Transactions, there is very little\nrequirement to have a specific order. The only exception is cases where\nthere are optional values and reordering would make unclear what is meant.\n\nFor this reason the TxInPrevHash always has to be the first token to start\na new input. This is because the TxPrevIndex is optional. The tokens\nTxRelativeTimeLock and TxRelativeBlockLock are part of the input and\nsimilarly have to be set after the TxInPrevHash they belong to.\n\nSimilarly, the TxInputStackItem always has to be the first and can be\nfollowed by a number of TxInputStackItemContinued items.\n\nAt a larger scope we define 3 sections of a transaction.\n\n{| class=\"wikitable\"\n!Segment !! Tags !! Description\n|-\n|Transaction||all not elsewhere used||This section is used to make the TxId\n|-\n|Signatures||TxInputStackItem, TxInputStackItemContinued||The input-proofs\n|-\n|TxEnd||TxEnd||&nbsp;\n|}\n\nThe TxId is calculated by taking the serialized transaction without the\nSignatures and the TxEnd and hashing that.\n\nTxEnd is there to allow a parser to know when one transaction in a stream\nhas ended, allowing the next to be parsed.\n\n=== Block-malleability ===\n\nThe effect of leaving the signatures out of the calculation of the\ntransaction-id implies that the signatures are also not used for the\ncalculation of the merkle tree.  This means that changes in signatures\nwould not be detectable and open an attack vector.\n\nFor this reason the merkle tree is extended to include (append) the hash of\nthe v4 transactions. The merkle tree will continue to have all the\ntransactions' tx-ids but appended to that are the v4 hashes that include the\nsignatures as well.  Specifically the hash is taken over a data-blob that\nis built up from:\n\n# the tx-id\n# The entire bytearray that makes up all of the transactions signatures.  This is a serialization of all of the signature tokens, so the TxInputStackItem and TxInputStackItemContinued in the order based on the inputs they are associated with.\n\n=== Future extensibility ===\n\nThe NOP_1x wildcard used in the table explaining tokens is actually a list\nof 10 values that currently are specified as NOP (no-operation) tags.\n\nAny implementation that supports the v4 transaction format should ignore\nthis field in a transaction. Interpreting and using the transaction as if\nthat field was not present at all.\n\nFuture software may use these fields to decorate a transaction with\nadditional data or features. Transaction generating software should not\ntrivially use these tokens for their own usage without cooperation and\ncommunication with the rest of the Bitcoin ecosystem as miners certainly\nhave the option to reject transactions that use unknown-to-them tokens.\n\nThe amount of tokens that can be added after number 19 is practically\nunlimited and they are currently specified to not be allowed in any\ntransaction and the transaction will be rejected if they are present.\nIn the future a protocol upgrade may chance that and specify meaning for\nany token not yet specified here. Future upgrades should thus be quite a\nlot smoother because there is no change in concepts or in format. Just new\ndata.\n\n==Backwards compatibility ==\n\nFully validating older clients will not be able to understand or validate\nversion 4 transactions and will need to be updated to restore that ability.\n\nSPV (simple payment validation) wallets need to be updated to receive or\ncreate the new transaction type.\n\nThis BIP introduces a new transaction format without changing or\ndeprecating the existing one or any of its practices. Therefore it is\nbackwards compatible for any existing data or parsing-code.\n\n==Reference Implementation==\n\nBitcoin Classic includes an implementation that is following this spec.\nThe spec-author rejects the notion of reference implementation. The\nspecification is always authoritative, the implementation is not.\n\nThe official spec can be found at;\nhttps://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md\n\n==Deployment==\n\nTo be determined\n\n==References==\n\n[https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md] CMF\n\n==Copyright==\n\nCopyright (c) 2016 Tom Zander <tomz@freedommail.ch>\n\nThis document is dual-licensed under the Creative-Commons BY-SA license v4.0\nand the Open Publication License v1.0 with the following licence-options:\n\nDistribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder.\nDistribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder.\n", "content_length": 12516}
{"bip_number": 133, "filename": "bip-0133.mediawiki", "content": "<pre>\n  BIP: 133\n  Layer: Peer Services\n  Title: feefilter message\n  Author: Alex Morcos <morcos@chaincode.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0133\n  Status: Final\n  Type: Standards Track\n  Created: 2016-02-13\n  License: PD\n</pre>\n\n==Abstract==\n\nAdd a new message, \"feefilter\", which serves to instruct peers not to send \"inv\"'s to the node for transactions with fees below the specified fee rate.\n\n==Motivation==\n\nThe concept of a limited mempool was introduced in Bitcoin Core 0.12 to provide protection against attacks or spam transactions of low fees that are not being mined. A reject filter was also introduced to help prevent repeated requests for the same transaction that might have been recently rejected for insufficient fee. These methods help keep resource utilization on a node from getting out of control.\n\nHowever, there are limitations to the effectiveness of these approaches.  The reject filter is reset after every block which means transactions that are inv'ed over a longer time period will be rerequested and there is no method to prevent requesting the transaction the first time.  Furthermore, inv data is sent at least once either to or from each peer for every transaction accepted to the mempool and there is no mechanism by which to know that an inv sent to a given peer would not result in a getdata request because it represents a transaction with too little fee.\n\nAfter receiving a feefilter message, a node can know before sending an inv that a given transaction's fee rate is below the minimum currently required by a given peer, and therefore the node can skip relaying an inv for that transaction to that peer.\n\n==Specification==\n\n# The feefilter message is defined as a message containing an int64_t where pchCommand == \"feefilter\"\n# Upon receipt of a \"feefilter\" message, the node will be permitted, but not required, to filter transaction invs for transactions that fall below the feerate provided in the feefilter message interpreted as satoshis per kilobyte.\n# The fee filter is additive with a bloom filter for transactions so if an SPV client were to load a bloom filter and send a feefilter message, transactions would only be relayed if they passed both filters.\n# Inv's generated from a mempool message are also subject to a fee filter if it exists.\n# Feature discovery is enabled by checking protocol version >= 70013\n\n==Considerations==\nThe propagation efficiency of transactions across the network should not be adversely affected by this change. In general, transactions which are not accepted to a node's mempool are not relayed by this node and the functionality implemented with this message is meant only to filter those transactions. There could be a small number of edge cases where a node's mempool min fee is actually less than the filter value a peer is aware of and transactions with fee rates between these values will now be newly inhibited.\n\nFeefilter messages are not sent to whitelisted peers if the \"-whitelistforcerelay\" option is set. In that case, transactions are intended to be relayed even if they are not accepted to the mempool.\n\nThere are privacy concerns with deanonymizing a node by the fact that it is broadcasting identifying information about its mempool min fee. To help ameliorate this concern, the implementation quantizes the filter value broadcast with a small amount of randomness, in addition, the messages are broadcast to different peers at individually randomly distributed times.\n\nIf a node is using prioritisetransaction to accept transactions whose actual fee rates might fall below the node's mempool min fee, it may want to consider disabling the fee filter to make sure it is exposed to all possible txid's.\n\n==Backward compatibility==\n\nOlder clients remain fully compatible and interoperable after this change. Also, clients implementing this BIP can choose to not send any feefilter messages.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/7542\n\n==Copyright==\nThis document is placed in the public domain.\n", "content_length": 4090}
{"bip_number": 132, "filename": "bip-0132.mediawiki", "content": "<pre>\n  BIP: 132\n  Title: Committee-based BIP Acceptance Process\n  Author: Andy Chase <theandychase@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0132\n  Status: Withdrawn\n  Type: Process\n  Created: 2015-08-31\n  License: PD\n</pre>\n\n== Abstract ==\n\nThe current process for accepting a BIP is not clearly defined. While [https://github.com/bitcoin/bips/blob/master/bip-0001.mediawiki BIP-0001] defines the process for writing and submitting a Bitcoin Improvement Proposal to the community it does not specify the precise method for which BIPs are considered accepted or rejected.\n\nThis proposal sets up a method for determining BIP acceptance.\n\nThis BIP has two parts:\n\n* It sets up a '''process''' which a BIP goes through for comments and acceptance. The Process is:\n** BIP Draft\n** Submitted for comments (2 weeks)\n** Waiting on opinion (2 weeks)\n** BIP becomes either Accepted or Deferred\n* It sets up '''committees''' for reviewing comments and indicating acceptance under precise conditions.\n** Committees are authorized groups that represent client authors, miners, merchants, and users (each as a segment). Each one must represent at least 1% stake in the Bitcoin ecosystem.\n\nBIP acceptance is defined as at least 70% of the represented percentage stake in 3 out of the 4 Bitcoin segments.\n\n== Copyright ==\n\nThis document is placed into the public domain.\n\n== Motivation ==\n\nBIPs represent important improvements to Bitcoin infrastructure, and in order to foster continued innovation, the BIP process must have clearly defined stages and acceptance acknowledgement.\n\n== Rationale ==\n\nA committee system is used to organize the essential concerns of each segment of the Bitcoin ecosystem. Although each segment may have many different viewpoints on each BIP, in order to seek a decisive yes/no on a BIP, a representational authoritative structure is sought. This structure should be fluid, allowing people to move away from committees that do not reflect their views and should be re-validated on each BIP evaluation.\n\n== Weaknesses ==\n\nEach committee submits a declaration including their claim to represent a certain percentage of the Bitcoin ecosystem in some way. Though guidelines are given, it's up to each committee to prove their stake, and it's up to the reader of the opinions to decide if a BIP was truly accepted or rejected.\n\nThe author doesn't believe this is a problem because a BIP cannot be forced on client authors, miners, merchants, or users. Ultimately this BIP is a tool for determining whether a BIP is overwhelmingly accepted. If one committee's validity claim becomes the factor that decides whether the BIP will succeed or fail, this process simply didn't return a clear answer and the BIP should be considered deferred.\n\n== Process ==\n\n* '''Submit for Comments.''' The first BIP champion named in the proposal can call a &quot;submit for comments&quot; at any time by posting to the [https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev Dev Mailing List] mailing with the BIP number and a statement that the champion intends to immediately submit the BIP for comments.\n** The BIP must have been assigned BIP-number (i.e. been approved by the BIP editor) to be submitted for comments.\n* '''Comments.'''\n** After a BIP has been submitted for comments, a two-week waiting period begins in which the community should transition from making suggestions about a proposal to publishing their opinions or concerns on the proposal.\n* '''Reported Opinions.'''\n** After the waiting period has past, committees must submit a summary of the comments which they have received from their represented communities.\n** The deadline for this opinion is four weeks after the BIP was submitted for comments.\n** Committees cannot reverse their decision after the deadline, but at their request may flag their decision as &quot;likely to change if another submit for comments is called&quot;. Committees can change their decision if a resubmit is called.\n** Opinions must include:\n*** One of the following statements: &quot;Intend to accept&quot;, &quot;Intent to implement&quot;, &quot;Decline to accept&quot;, &quot;Intend to accept, but decline to implement&quot;.\n*** If rejected, the opinion must cite clear and specific reasons for rejecting including a checklist for what must happen or be change for their committee to accept the proposal.\n*** If accepted, the committee must list why they accepted the proposal and also include concerns they have or what about the BIP that, if things changed, would cause the committee to likely reverse their decision if another submit for comments was called.\n* '''Accepted.'''\n** If at least 70% of the represented percentage stake in 3 out of 4 segments accept a proposal, the BIP is considered accepted.\n** If a committee fails to submit an opinion, consider the opinion &quot;Decline to accept&quot;.\n** The BIP cannot be substantially changed at this point, but can be replaced. Minor changes or clarifications are allowed but must be recorded in the document.\n* '''Deferred.'''\n** If the acceptance test above is not met, the BIP is sent back into suggestions.\n** BIP can be modified and re-submitted for a comments no sooner than two months after the date of the previous submit for comments is called.\n** The BIP is marked rejected after two failed submission attempts. A rejected BIP can still be modified and re-submitted.\n\n== Committees ==\n\n'''BIP Committees.'''\n\n* BIP Committees are representational structures that represent critical segments of the Bitcoin ecosystem.\n* Each committee must prove and maintain a clear claim that they represent at least 1% of the Bitcoin ecosystem in some form.\n* If an organization or community does not meet that requirement, it should conglomerate itself with other communities and organizations so that it does.\n* The segments that committees can be based around are:\n** Bitcoin software\n** Exchanges/Merchants/services/payment processors\n** Mining operators\n** User communities\n* A person may be represented by any number of segments, but a committee cannot re-use the same resource as another committee in the same segment.\n\n'''Committee Declarations.'''\n* At any point, a Committee Declaration can be posted.\n* This Declaration must contain details about:\n** The segment the Committee is representing\n** Who the committee claim to represent and it's compositional makeup (if made up of multiple miner orgs, user orgs, companies, clients, etc).\n** Proof of claim and minimum 1% stake via:\n*** Software: proof of ownership and user base (Min 1% of Bitcoin userbase)\n*** Merchant: proof of economic activity (Min 1% of Bitcoin economic activity)\n*** Mining: proof of work (Min 1% of Hashpower)\n*** For a user organization, auditable signatures qualifies for a valid committee (Min 1% of Bitcoin userbase)\n** Who is running the committee, their names and roles\n** How represented members can submit comments to the committee\n** A code of conduct and code of ethics which the committee promises to abide by\n* A committee declaration is accepted if:\n** The declaration includes all of the required elements\n** The stake is considered valid\n** Committee validation is considered when considering the results of opinions submitted by committee on a BIP. A committee must have met the required stake percentage before a BIP is submitted for comments, and have maintained that stake until a valid opinion is submitted.\n* Committees can dissolve at any time or submit a declaration at any time\n* Declaration must have been submitted no later than the third day following a BIP's request for comments to be eligible for inclusion in a BIP\n\n== BIP Process Management Role ==\n\nBIPs, Opinions, and Committee Declaration must be public at all times.\n\nA BIP Process Manager should be chosen who is in charge of:\n\n* Declaring where and how BIPs, Opinions, and Committee Declaration should be posted and updated officially.\n* Maintaining the security and authenticity of BIPs, Opinions, and Committee Declarations\n* Publishing advisory documents about what kinds of proof of stakes are valid and what kinds should be rejected.\n* Naming a series of successors for the roles of the BIP Process Manager and BIP Editor (BIP-001) as needed.\n\n== Conditions for activation ==\n\nIn order for this process BIP to become active, it must succeed by its own rules. At least a 4% sample of the Bitcoin community must be represented, with at least one committee in each segment included. Once at least one committee has submitted a declaration, a request for comments will be called and the process should be completed from there.\n\n", "content_length": 8683}
{"bip_number": 131, "filename": "bip-0131.mediawiki", "content": "<pre>\n  BIP: 131\n  Layer: Consensus (hard fork)\n  Title: \"Coalescing Transaction\" Specification (wildcard inputs)\n  Author: Chris Priest <cp368202@ohiou.edu>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0131\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-11-30\n  License: PD\n</pre>\n\n==Abstract==\n\nThis specification defines a new type of transaction that supplements (not replaces)\nnormal \"non coalescing\" bitcoin transactions.\n\n==Motivation==\n\nNormal \"non-coalescing\" Bitcoin Transactions have one large inefficiency: When you want to spend\nfrom multiple inputs with the exact same scriptPubKey, you have to list each\ninput separately, along with the same signature multiple times, even though the signature expresses the same information.\nThis bloats the transaction size and makes it expensive to spend from small value inputs.\n\nBecause small value inputs are expensive to send, they remain in the UTXO pool\nwhich full nodes have to keep around. It is believed that long term increase of the UTXO\nset can have negative scaling consequences on the network.\n\nIf maximum blocksize is made to increase *slower* than the actual number of transactions bitcoin users are sending\nto the network, this problem is projected to get worse. In other words, as transaction\nfees increase, the minimum economical value of a spending a UTXO will increase.\n\n==Specification==\n\n=== Redefinition of Transaction version ===\n\nFirst, this BIP redefines the version field on transactions. The first four bytes\nare defined as the version number, while the last four bytes are defined as the\ntransaction type. Type \"0000\" denotes normal transactions, and \"0001\" defines\ncoalescing transaction.\n\nExamples:\n\nversion 1 transaction with normal inputs:\n    version: 10000000\n\nversion 2 transaction with normal inputs:\n    version: 20000000\n\nversion 2 transaction with coalescing inputs:\n    version: 20000001\n\nEssentially the last bit in the version field is set to 1 to enable wildcard inputs for all\ninputs present in the transaction.\n\n=== Wildcard inputs ===\n\nA coalescing transaction is formulated the exact same way as a version 1 transaction\nwith one exception: each input is treated as a \"wildcard input\".\n\nA wildcard input being the value of all inputs with the exact same scriptPubKey\nin a block lower or equal to the block the wildcard input is confirmed into.\n\n== Changes needed to implement ==\n\nThe bitcoin code needs to be modified in three places in order to handle Coalescing Transactions.\n\n1. <b>Full Node Coalescing validation</b> - When a full node receives a coalescing transaction, it has to\naggregate the value of all the UTXOs in the blockchain older than the input\nwith the same scriptPubKey. If this value is greater than or equal to the\namount of all outputs, then that coalescing transaction is valid and can be propagated.\n\n2. <b>Full Node Non-Coalescing validation</b> - When a non-coalescing transaction comes in, the code needs to be modified\nto check if each input has not been spent by a coalescing transaction. If there exist any\ncoalescing transaction in the blockchain with the same scriptPubKey found in a block *after* that input,\nthen the UTXO has been spent and the transaction is invalid.\n\n3. <b>Wallet</b> - The user facing wallet portion of the reference client should notify\nthe user when their wallet contains many UTXOs that qualify it to benefit from\na coalescing transaction. Wallets should not simply replace non-coalescing transactions\nwith coalescing transactions in all instances.\n\n== Isn't this BIP bad because it encourage address re-use? ==\n\nAddress re-use comes in two forms: re-use by the ''sender'', and re-use by the ''receiver''.\n\nRe-use by the sender is basically using the same address for the change output. This is generally considered bad\nsince people looking through your transaction history can determine who you do business with. When\nyou generate a new address for every change, your privacy is conserved as it is impossible to know which\noutput is a recipient, and which output is the change output. This BIP has '''no effect''' on re-use\nby the sender.\n\nOn the other hand, address re-use by the ''receiver'' occurs under completely different circumstances.\nWhen you publish an address and have multiple people send to that address, you are engaging in address re-use\nfrom the receiver. This activity has historically been considered bad because it leads to re-using a private key.\nWhen you re-use a private key too many times, you run the risk of an attacker performing statistical analysis\non the multiple signatures, which can lead to an attacker finding out your private key.\n\nThis BIP introduces a way to spend multiple inputs ''without'' re-using the private key. In a sense, this BIP\nfixes the problem that makes address re-use bad for the receiver. After this BIP becomes implemented\nand deployed, address re-use by the receiver will no longer be considered bad form.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 5049}
{"bip_number": 130, "filename": "bip-0130.mediawiki", "content": "<pre>\n  BIP: 130\n  Layer: Peer Services\n  Title: sendheaders message\n  Author: Suhas Daftuar <sdaftuar@chaincode.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0130\n  Status: Final\n  Type: Standards Track\n  Created: 2015-05-08\n  License: PD\n</pre>\n\n==Abstract==\n\nAdd a new message, \"sendheaders\", which indicates that a node prefers to receive new block announcements via a \"headers\" message rather than an \"inv\".\n\n==Motivation==\n\nSince the introduction of \"headers-first\" downloading of blocks in 0.10, blocks will not be processed unless\nthey are able to connect to a (valid) headers chain.  Consequently, block relay generally works\nas follows:\n# A node (N) announces the new tip with an \"inv\" message, containing the block hash\n# A peer (P) responds to the \"inv\" with a \"getheaders\" message (to request headers up to the new tip) and a \"getdata\" message for the new tip itself\n# N responds with a \"headers\" message (with the header for the new block along with any preceding headers unknown to P) and a \"block\" message containing the new block\n\nHowever, in the case where a new block is being announced that builds on the tip, it would be generally more efficient if the node N just announced the block header for the new block, rather than just the block hash, and saved the peer from generating and transmitting the getheaders message (and the required block locator).\n\nIn the case of a reorg, where 1 or more blocks are disconnected, nodes currently just send an \"inv\" for the new tip.  Peers currently are able to request the new tip immediately, but wait until the headers for the intermediate blocks are delivered before requesting those blocks.  By announcing headers from the last fork point leading up to the new tip in the block announcement, peers are able to request all the intermediate blocks immediately.\n\n==Specification==\n\n# The sendheaders message is defined as an empty message where pchCommand == \"sendheaders\"\n# Upon receipt of a \"sendheaders\" message, the node will be permitted, but not required, to announce new blocks by sending the header of the new block (along with any other blocks that a node believes a peer might need in order for the block to connect).\n# Feature discovery is enabled by checking protocol version >= 70012\n\n==Additional constraints==\n\nAs support for sendheaders is optional, software that implements this may also optionally impose additional constraints, such as only honoring sendheaders messages shortly after a connection is established.\n\n==Backward compatibility==\n\nOlder clients remain fully compatible and interoperable after this change.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/6494\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 2788}
{"bip_number": 129, "filename": "bip-0129.mediawiki", "content": "<pre>\n  BIP: 129\n  Layer: Applications\n  Title: Bitcoin Secure Multisig Setup (BSMS)\n  Author: Hugo Nguyen <hugo@nunchuk.io>\n          Peter Gray <peter@coinkite.com>\n          Marko Bencun <marko@shiftcrypto.ch>\n          Aaron Chen <aarondongchen@gmail.com>\n          Rodolfo Novak <rodolfo@coinkite.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0129\n  Status: Proposed\n  Type: Standards Track\n  Created: 2020-11-10\n  License: BSD-2-Clause\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a mechanism to set up multisig wallets securely.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nThe Bitcoin multisig experience has been greatly streamlined under [https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki BIP-0174\n(Partially Signed Bitcoin Transaction)]. However, what is still missing is a standardized process for setting up multisig wallets securely across different vendors.\n\nThere are a number of concerns when it comes to setting up a multisig wallet:\n\n# Whether the multisig configuration, such as Signer membership, script type, derivation paths and number of signatures required, is correct and not tampered with.\n# Whether the keys or the multisig configuration are leaked during the setup.\n# Whether the Signer persists the multisig configuration in their respective storage, and under what format.\n# Whether the Signer's storage is tamper-proof.\n# Whether the Signer subsequently uses the multisig configuration to generate and verify receive and change addresses.\n\nAn attacker who can modify the multisig configuration can steal or hold funds for ransom by duping the user into sending funds to the wrong address. An attacker who cannot modify the configuration but can learn about the keys and/or the configuration can monitor transactions in the wallet, resulting in loss of privacy.\n\nThis proposal seeks to address concerns #1, #2 and #3: to mitigate the risk of tampering during the initial setup phase, and to define an interoperable multisig configuration format.\n\nConcerns #4 and #5 should be handled by Signers and are out of scope of this proposal.\n\n==Specification==\n\n===Prerequisites===\nThis proposal assumes the parties in the multisig support [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032], [https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki BIP-0322], [https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki BIP-0380 Output Script Descriptors] ([https://github.com/bitcoin/bips/blob/master/bip-0381.mediawiki BIP-0381],[https://github.com/bitcoin/bips/blob/master/bip-0382.mediawiki BIP-0382],[https://github.com/bitcoin/bips/blob/master/bip-0383.mediawiki BIP-0383]) and [https://tools.ietf.org/html/rfc3686 AES encryption].\n\n===File Extensions===\nAll descriptor and key records should have a <tt>.bsms</tt> file extension. Encrypted data should have a <tt>.dat</tt> extension.\n\n===Newline===\nThis specification uses line feed (LF) control character <tt>\\n</tt>.\n\n===Roles===\n====Coordinator====\n\nThe Coordinator initiates the multisig setup. The Coordinator determines what type of multisig is used and the exact policy script. If encryption is enabled, the Coordinator also distributes a shared secret or shared secrets to the parties involved for secure communication. The Coordinator gathers information from the Signers to generate a descriptor record. The Coordinator distributes the descriptor record back to the Signers.\n\n====Signer====\n\nThe Signer is any software or hardware that controls the private keys and can sign using those keys. The Signer is a participating member in the multisig. Its responsibilities include providing its key record -- which contains a public key or an Extended Public Key (XPUB) -- to the Coordinator, verifying that its <tt>KEY</tt> is included in the descriptor record and persisting the descriptor record in its storage.\n\n===Setup Process===\n\n====Round 1====\n\n=====Coordinator=====\n\n* The Coordinator creates a new multisig wallet creation session. The Coordinator constructs the multisig script and its policy parameters, such as the required number of signatures and the total number of Signers (<tt>M</tt> and <tt>N</tt>).\n* The session should expire after some time period determined by the Coordinator, e.g., 24 hours. The timeout allows the encryption key to have lower entropy.\n* If encryption is enabled, the Coordinator distributes a secret <tt>TOKEN</tt> to each Signer over a secure channel. The Signer can use the <tt>TOKEN</tt> to derive an <tt>ENCRYPTION_KEY</tt>. Refer to the [[#Encryption]] section below for details on the <tt>TOKEN</tt>, the key derivation function and the encryption scheme. Depending on the use case, the Coordinator can decide whether to share one common <tt>TOKEN</tt> for all Signers, or to have one per Signer.\n* If encryption is disabled, the <tt>TOKEN</tt> is set to <tt>0x00</tt>, and all the encryption/decryption steps below can be skipped.\n\n=====Signer=====\n\n* The Signer initiates the multisig wallet creation session by setting the <tt>TOKEN</tt>. The Signer derives an <tt>ENCRYPTION_KEY</tt> from the <tt>TOKEN</tt>. The Signer can keep the session open until a different value for the <tt>TOKEN</tt> is set.\n* The Signer generates a key record by prompting the user for a multisig derivation path and retrieves the <tt>KEY</tt> at that derivation path. Alternatively, the Signer can choose a path on behalf of the user. If the Signer chooses the path, it should try to avoid reusing <tt>KEY</tt>s for different wallets.\n* The first line in the record must be the specification version (<tt>BSMS 1.0</tt> as of this writing). The second line must be the hex-encoded <tt>TOKEN</tt>. The third line must be the <tt>KEY</tt>. The <tt>KEY</tt> is a public key or an XPUB plus the key origin information, written in the descriptor-defined format, i.e.: <tt>[{master key fingerprint}/{derivation path}]{KEY}</tt>. The fourth line is a text description of the key, 80 characters maximum. The fifth line must be a <tt>SIG</tt>, whereas <tt>SIG</tt> is the signature generated by using the private key associated with the public key or XPUB to sign the first four lines. The signature should follow [https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki BIP-0322], legacy format accepted.\n* The Signer calculates the Message Authentication Code (<tt>MAC</tt>) for the record. The first 16 bytes of the <tt>MAC</tt> serves as the Initialization Vector (<tt>IV</tt>) for the encryption.\n* The Signer encrypts the key record with the <tt>ENCRYPTION_KEY</tt> and <tt>IV</tt>.\n* The Signer encodes the <tt>MAC</tt> and the ciphertext into hexadecimal format, then concatenates the results: <tt>(MAC || ciphertext)</tt>.\n\n====Round 2====\n\n=====Coordinator=====\n\n* The Coordinator gathers key records from all participating Signers. The Coordinator verifies that there are exactly <tt>N</tt> unique key records before the wallet setup session expires.\n* For each key record, the Coordinator extracts the <tt>MAC</tt> from the data, sets <tt>IV</tt> to the first 16 bytes of the <tt>MAC</tt>, then decrypts the ciphertext using the <tt>ENCRYPTION_KEY</tt> and <tt>IV</tt>.\n* The Coordinator verifies that the included <tt>MAC</tt> is valid given the plaintext.\n* The Coordinator verifies that the key records have compatible specification versions.\n* The Coordinator verifies that the included <tt>SIG</tt> is valid given the <tt>KEY</tt>.\n* If all key records look good, the Coordinator fills in all necessary information to generate a descriptor record.\n* The first line in the descriptor record must be the specification version (<tt>BSMS 1.0</tt> as of this writing). The second line must be a descriptor or a descriptor template. The third line must be a comma-separated list of derivation path restrictions. The paths must start with <tt>/</tt> and use non-hardened derivation. If there are no template or restrictions, it must say <tt>No path restrictions</tt>. The fourth line must be the wallet's first address. If there are path restrictions, use the first address from the first path restriction.\n* The Coordinator calculates the <tt>MAC</tt> for the record. The first 16 bytes of the <tt>MAC</tt> serves as the <tt>IV</tt> for the encryption..\n* The Coordinator encrypts the descriptor record with the <tt>ENCRYPTION_KEY</tt> and <tt>IV</tt>.\n* The Coordinator encodes the <tt>MAC</tt> and the ciphertext into hexadecimal format, then concatenates the results: <tt>(MAC || ciphertext)</tt>.\n* The Coordinator sends the encrypted descriptor record to all participating Signers.\n\n=====Signer=====\n\n* The Signer imports the descriptor record.\n* The Signer extracts the <tt>MAC</tt> from the data, sets <tt>IV</tt> to the first 16 bytes of the <tt>MAC</tt>, then decrypts the ciphertext using the <tt>ENCRYPTION_KEY</tt> (derived from the open session) and <tt>IV</tt>.\n* The Signer verifies that the included <tt>MAC</tt> is valid given the plaintext.\n* The Signer verifies that it can support the included specification version.\n* The Signer verifies that it can support the descriptor or descriptor template.\n* The Signer checks that its <tt>KEY</tt> is included in the descriptor or descriptor template, using path and fingerprint information provided. The check must perform an exact match on the <tt>KEY</tt>s and not using shortcuts such as matching fingerprints, which is trivial to spoof.\n* The Signer verifies that it is compatible with the derivation path restrictions.\n* The Signer verifies that the wallet's first address is valid.\n* For confirmation, the Signer must display to the user the wallet's first address and policy parameters, including, but not limited to: the derivation path restrictions, <tt>M</tt>, <tt>N</tt>, and the position(s) of the Signer's own <tt>KEY</tt> in the policy script. The total number of Signers, <tt>N</tt>, is important to prevent a <tt>KEY</tt> insertion attack. The position is important for scripts where <tt>KEY</tt> order matters. When applicable, all positions of the <tt>KEY</tt> must be displayed. The full descriptor or descriptor template must also be available for review upon user request.\n* Parties must check with each other that all Signers have the same confirmation (except for the <tt>KEY</tt> positions).\n* If all checks pass, the Signer must persist the descriptor record in its storage.\n\nThis completes the setup.\n\n===Encryption===\n\n====The Token====\nWe define three modes of encryption.\n\n# <tt>NO_ENCRYPTION</tt> : the <tt>TOKEN</tt> is set to <tt>0x00</tt>. Encryption is disabled.\n# <tt>STANDARD</tt> : the <tt>TOKEN</tt> is a 64-bit nonce.\n# <tt>EXTENDED</tt> : the <tt>TOKEN</tt> is a 128-bit nonce.\n\nThe <tt>TOKEN</tt> can be converted to one of these formats:\n* A decimal number (recommended). The number must not exceed the maximum value of the nonce.\n* A mnemonic phrase using [https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP-0039] word list. This would be 6 words in <tt>STANDARD</tt> mode. This encoding is not recommended in <tt>EXTENDED</tt> mode as it can result in potential confusion between seed mnemonics and <tt>TOKEN</tt> mnemonics.\n* A QR code.\n* Other formats.\n\nThe flexibility in the data format allows each Signer to customize the User Experience based on its respective capabilities.\n\n====Key Derivation====\nThe key derivation function is [https://tools.ietf.org/html/rfc2898 PBKDF2], with PRF = SHA512. Specifically:\n\n<tt>DKey = PBKDF2(PRF, Password, Salt, c, dkLen)</tt>\n\nWhereas:\n\n* PRF = SHA512\n* Password = \"No SPOF\"\n* Salt = <tt>TOKEN</tt>\n* c = 2048\n* dkLen = 256 bits (32 bytes)\n* DKey = Derived <tt>ENCRYPTION_KEY</tt>\n\n====Encryption Scheme====\nThe encryption scheme is [https://tools.ietf.org/html/rfc3686 AES-256-CTR].\n\n<tt>MAC = HMAC-SHA256(HMAC_Key, hex-encoded TOKEN || Data)</tt>\n\n<tt>IV = First 16 bytes of MAC</tt>\n\n<tt>Ciphertext = AES-256-CTR-Encrypt(Plaintext, DKey, IV)</tt>\n\n<tt>Plaintext = AES-256-CTR-Decrypt(Ciphertext, DKey, IV)</tt>\n\nWhereas:\n* DKey = <tt>ENCRYPTION_KEY</tt>\n* HMAC_Key = SHA256(<tt>ENCRYPTION_KEY</tt>)\n* Data = the plaintext, e.g. the entire key record in round 1 and the entire descriptor record in round 2\n\nThe <tt>MAC</tt> is to be sent along with the key and descriptor record, as specified above. Because it is a <tt>MAC</tt> over the entire plaintext, this is essentially an [https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-and-MAC_(E&M) Encrypt-and-MAC] form of authenticated encryption.\n\n===Descriptor Template===\nThe output descriptor language only supports one-dimensional lists. This proposal introduces a descriptor template to represent multi-dimensional lists:\n\n<tt>XPUB/**</tt>\n\nWhereas <tt>/**</tt> can be replaced by any number of derivation path restrictions.\n\nA descriptor template must be accompanied by derivation path restrictions. Signers should expand the template into concrete descriptors by replacing <tt>/**</tt> with the restrictions.\n\nFor example, the following template and derivation path restrictions:\n* <tt>wsh(sortedmulti(2,XPUB1/**,XPUB2/**))</tt>\n* <tt>/0/*,/1/*</tt>\n\nShould translate to two concrete descriptors:\n* <tt>wsh(sortedmulti(2,XPUB1/0/*,XPUB2/0/*))</tt>\n* <tt>wsh(sortedmulti(2,XPUB1/1/*,XPUB2/1/*))</tt>\n\n==QR Codes==\nFor signers that use QR codes to transmit data, key and descriptor records can be converted to QR codes, following [https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-005-ur.md the BCR standard].\n\nAlso refer to [https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-015-account.md UR Type Definition for BIP44 Accounts] and [https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-010-output-desc.md UR Type Definition for Bitcoin Output Descriptors] for more details.\n\n==Compatibility==\nThis specification is not backwards compatible with existing multisig implementations.\n\nBSMS is opt-in, meaning existing multisig implementations can continue working as-is, with the caveat that they are likely to have various pitfalls. Some of the problems with existing solutions have been described in the [[#Motivation]] section.\n\nTo comply with this standard, a Signer must be able to persist the descriptor record in its storage.\n\nTo use BSMS for a multisig wallet, the user should wait until all participating Signers in the multisig have implemented BSMS.\n\n==Security==\n\nThis proposal introduces two layers of protection. The first one is a temporary, secret <tt>TOKEN</tt>. The second one is the confirmation of the wallet's first address.\n\nThe <tt>TOKEN</tt> is used to encrypt the two rounds of communication between the Signer and the Coordinator. A <tt>MAC</tt> is also generated from the <tt>TOKEN</tt> and plaintext to authenticate the data being exchanged. The <tt>TOKEN</tt> is only needed during the setup phase, and can be safely discarded afterwards. It is not recommended to use the same <tt>TOKEN</tt> for multiple wallet creation sessions.\n\nThe wallet's first address, on the other hand, can be used to verify the integrity of the multisig configuration. An attacker who tampers with the multisig configuration must also change the wallet's first address. Parties must check with each other that all Signers confirm to the same address and policy parameters to reduce the chance of tampering.\n\n==Privacy==\nEncryption helps improve the privacy of the wallet by avoiding sharing keys and descriptors in plaintext.\n\nIf the parties wish to have stronger privacy, it is recommended to use a higher number of bits for the <tt>TOKEN</tt>, and to completely erase knowledge of the <tt>TOKEN</tt> after the multisig wallet has been set up.\n\n==Test Vectors==\n\n===Mode: <tt>NO_ENCRYPTION</tt> with Public Keys===\n====ROUND 1====\n* Coordinator\n** M-of-N: 1/2\n** ADDRESS_TYPE: NATIVE_SEGWIT\n** TOKEN: 0x00\n\n* Signer 1\n** MASTER_KEY_FINGERPRINT: 59865f44\n** PRIVATE_KEY (m/48'/0'/0'/2'): L5TXU4SdD9e6QGgBjxeegJKxt4FgATLG1TCnFM8JLyEkFuyHEqNM\n** Public Key (m/48'/0'/0'/2'): 026d15412460ba0d881c21837bb999233896085a9ed4e5445bd637c10e579768ba\n** Legacy signature\n** <tt>signer_1_key.bsms</tt>:\n<pre>BSMS 1.0\n00\n[59865f44/48'/0'/0'/2']026d15412460ba0d881c21837bb999233896085a9ed4e5445bd637c10e579768ba\nSigner 1 key\nH6DXgqkCb353BDPkzppMFpOcdJZlpur0WRetQhIBqSn6DFzoQWBtm+ibP5wERDRNi0bxxev9B+FIvyQWq0s6im4=</pre>\n\n* Signer 2\n** MASTER_KEY_FINGERPRINT: b7044ca6\n** PRIVATE_KEY (m/48'/0'/0'/2'): KwT7BZDWjos4JAdfKi8NqF46Kj3rppTwN8KGhPbzmmugiZioFW3r\n** Public Key (m/48'/0'/0'/2'): 030baf0497ab406ff50cb48b4013abac8a0338758d2fd54cd934927afa57cc2062\n** Legacy signature\n** <tt>signer_2_key.bsms</tt>:\n<pre>BSMS 1.0\n00\n[b7044ca6/48'/0'/0'/2']030baf0497ab406ff50cb48b4013abac8a0338758d2fd54cd934927afa57cc2062\nSigner 2 key\nH08mGNGN+NxX/snt+6eX2Q1HjjfDkOtotglshHi7xdsBdIrTVMCQbgQ5SdACNZ0B2AJcifK11nJj43SvaitSemI=</pre>\n\n====ROUND 2====\n* Coordinator\n** <tt>my_multisig_wallet.bsms</tt>:\n<pre>BSMS 1.0\nwsh(sortedmulti(1,[59865f44/48'/0'/0'/2']026d15412460ba0d881c21837bb999233896085a9ed4e5445bd637c10e579768ba,[b7044ca6/48'/0'/0'/2']030baf0497ab406ff50cb48b4013abac8a0338758d2fd54cd934927afa57cc2062))#rzx9dffd\nNo path restrictions\nbc1quqy523xu3l8che3s8vja8n33qtg0uyugr9l5z092s3wa50p8t7rqy6zumf</pre>\n\n===Mode: <tt>NO_ENCRYPTION</tt>===\n====ROUND 1====\n* Coordinator\n** M-of-N: 2/2\n** ADDRESS_TYPE: NATIVE_SEGWIT\n** TOKEN: 0x00\n\n* Signer 1\n** MASTER_KEY_FINGERPRINT: 1cf0bf7e\n** PRIVATE_KEY (m/48'/0'/0'/2'): L3q1sg7iso1L3QfzB1riC9bQpqMynWyBeuLLSKwCDGkHkahB7MgU\n** XPUB (m/48'/0'/0'/2'): xpub6FL8FhxNNUVnG64YurPd16AfGyvFLhh7S2uSsDqR3Qfcm6o9jtcMYwh6DvmcBF9qozxNQmTCVvWtxLpKTnhVLN3Pgnu2D3pAoXYFgVyd8Yz\n** Legacy signature\n** <tt>signer_1_key.bsms</tt>:\n<pre>BSMS 1.0\n00\n[1cf0bf7e/48'/0'/0'/2']xpub6FL8FhxNNUVnG64YurPd16AfGyvFLhh7S2uSsDqR3Qfcm6o9jtcMYwh6DvmcBF9qozxNQmTCVvWtxLpKTnhVLN3Pgnu2D3pAoXYFgVyd8Yz\nSigner 1 key\nIB7v+qi1b+Xrwm/3bF+Rjl8QbIJ/FMQ40kUsOOQo1SqUWn5QlFWbBD8BKPRetfo1L1N7DmYjVscZNsmMrqRJGWw=</pre>\n\n* Signer 2\n** MASTER_KEY_FINGERPRINT: 4fc1dd4a\n** PRIVATE_KEY (m/48'/0'/0'/2'): L4JNkJfLBDyWfTLbKJ1H3w56GUMsvdfjCkzRo5RHXfJ6bdHqm6cN\n** XPUB (m/48'/0'/0'/2'): xpub6EebMbEps7ZcV3FYEnddRsvrFWDrt2tiPmCeM7pPXQEmphvq9ZfJ1LWFUDjf3vxCeBuPrfyGrMazWUsYsetrnHatQZVLJH7LsgCjtMqdzgj\n** Legacy signature\n** <tt>signer_2_key.bsms</tt>:\n<pre>BSMS 1.0\n00\n[4fc1dd4a/48'/0'/0'/2']xpub6EebMbEps7ZcV3FYEnddRsvrFWDrt2tiPmCeM7pPXQEmphvq9ZfJ1LWFUDjf3vxCeBuPrfyGrMazWUsYsetrnHatQZVLJH7LsgCjtMqdzgj\nSigner 2 key\nHzUa4Z76PFHMl54flIIF3XKiHZ+KbWjjxCEG5G3ZqZSqTd6OgTiFFLqq9PXJXdfYm6/cnL8IVWQgjFF9DQhIqQs=</pre>\n\n====ROUND 2====\n* Coordinator\n** <tt>my_multisig_wallet.bsms</tt>:\n<pre>BSMS 1.0\nwsh(sortedmulti(2,[1cf0bf7e/48'/0'/0'/2']xpub6FL8FhxNNUVnG64YurPd16AfGyvFLhh7S2uSsDqR3Qfcm6o9jtcMYwh6DvmcBF9qozxNQmTCVvWtxLpKTnhVLN3Pgnu2D3pAoXYFgVyd8Yz/**,[4fc1dd4a/48'/0'/0'/2']xpub6EebMbEps7ZcV3FYEnddRsvrFWDrt2tiPmCeM7pPXQEmphvq9ZfJ1LWFUDjf3vxCeBuPrfyGrMazWUsYsetrnHatQZVLJH7LsgCjtMqdzgj/**))\n/0/*,/1/*\nbc1qrgc6p3kylfztu06ysl752gwwuekhvtfh9vr7zg43jvu60mutamcsv948ej</pre>\n\n===Mode: <tt>STANDARD</tt> Encryption===\n====ROUND 1====\n* Coordinator\n** M-of-N: 2/2\n** ADDRESS_TYPE: NATIVE_SEGWIT\n** TOKEN (hex): a54044308ceac9b7\n*** TOKEN (decimal): 11907592390080907703\n*** TOKEN (mnemonic): pipe acquire around border prosper swift\n** ENCRYPTION_KEY (hex): 7673ffd9efd70336a5442eda0b31457f7b6cdf7b42fe17f274434df55efa9839\n\n* Signer 1\n** MASTER_KEY_FINGERPRINT: b7868815\n** PRIVATE_KEY (m/48'/0'/0'/2'): KyKvR9kf8r7ZVtdn3kB9ifipr6UKnTNTpWJkGZbHwARDCz5iZ39E\n** XPUB (m/48'/0'/0'/2'): xpub6FA5rfxJc94K1kNtxRby1hoHwi7YDyTWwx1KUR3FwskaF6HzCbZMz3zQwGnCqdiFeMTPV3YneTGS2YQPiuNYsSvtggWWMQpEJD4jXU7ZzEh\n** Legacy signature\n** <tt>signer_1_key.bsms</tt>:\n<pre>BSMS 1.0\na54044308ceac9b7\n[b7868815/48'/0'/0'/2']xpub6FA5rfxJc94K1kNtxRby1hoHwi7YDyTWwx1KUR3FwskaF6HzCbZMz3zQwGnCqdiFeMTPV3YneTGS2YQPiuNYsSvtggWWMQpEJD4jXU7ZzEh\nSigner 1 key\nH8DYht5P6ko0bQqDV6MtUxpzBSK+aVHxbvMavA5byvLrOlCEGmO1WFR7k2wu42J6dxXD8vrmDQSnGq5MTMMbZ98=</pre>\n\n* Signer 1 encryption\n** HMAC_KEY (hex): 3d4c422806ba8964c9ee45070cd675c024d96648a0ddb4001325818c84951de2\n** MAC (hex): fbdbdb64e6a8231c342131d9f13dcd5a954b4c5021658fa5afcb3fc74dc82706\n** IV (hex) : fbdbdb64e6a8231c342131d9f13dcd5a\n** CIPHERTEXT (hex): 53f491cfd1431c292d922ea5a5dec3eb8ddaa6ed38ae109e7b040f0f23013e89a89b4d27476761a01197a3277850b2bc1621ae626efe65f2081eec6eb571c4f787bf1c49d061b43f70fd73cb3f37fa591d2400973ac0644c8941a83f1d4155e98f01fa2fdeb9f86c2e2413154fd18566a28fb0d9d8bd6172efabcfa6dab09ee7029bf3dd43376df52c118a6d291ec168f4ec7f7df951dfc6135fd8cb4b234da62eaea6017dfe5ca418f083e02e3aba2962ba313ba17b6468c7672fb218329a9f3fe4e4887fb87dac57c63ebff0e715a44498d18de8afc10e1cfeb46a1fc65ce871fef8a43b289305433a90c342d025aa4c19454fcfbcf911e9e2f928d5affd0536a6ddc2e816\n** <tt>signer_1_key.dat</tt>: <pre>fbdbdb64e6a8231c342131d9f13dcd5a954b4c5021658fa5afcb3fc74dc8270653f491cfd1431c292d922ea5a5dec3eb8ddaa6ed38ae109e7b040f0f23013e89a89b4d27476761a01197a3277850b2bc1621ae626efe65f2081eec6eb571c4f787bf1c49d061b43f70fd73cb3f37fa591d2400973ac0644c8941a83f1d4155e98f01fa2fdeb9f86c2e2413154fd18566a28fb0d9d8bd6172efabcfa6dab09ee7029bf3dd43376df52c118a6d291ec168f4ec7f7df951dfc6135fd8cb4b234da62eaea6017dfe5ca418f083e02e3aba2962ba313ba17b6468c7672fb218329a9f3fe4e4887fb87dac57c63ebff0e715a44498d18de8afc10e1cfeb46a1fc65ce871fef8a43b289305433a90c342d025aa4c19454fcfbcf911e9e2f928d5affd0536a6ddc2e816</pre>\n\n* Signer 2\n** MASTER_KEY_FINGERPRINT: eedff89a\n** PRIVATE_KEY (m/48'/0'/0'/2'): Kz1ijnkDXmc65NWTYdg47DDaQgSGJAPfhJG9Unm36oqZPpPXuNR6\n** XPUB (m/48'/0'/0'/2'): xpub6EhJvMneoLWAf8cuyLBLQiKiwh89RAmqXEqYeFuaCEHdHwxSRfzLrUxKXEBap7nZSHAYP7Jfq6gZmucotNzpMQ9Sb1nTqerqW8hrtmx6Y6o\n** Legacy signature\n** <tt>signer_2_key.bsms</tt>:\n<pre>BSMS 1.0\na54044308ceac9b7\n[eedff89a/48'/0'/0'/2']xpub6EhJvMneoLWAf8cuyLBLQiKiwh89RAmqXEqYeFuaCEHdHwxSRfzLrUxKXEBap7nZSHAYP7Jfq6gZmucotNzpMQ9Sb1nTqerqW8hrtmx6Y6o\nSigner 2 key\nH/IHW5dMGYsrRdYEz3ux+kKnkWBtxHzfYkREpnYbco38VnMvIxCbDuf7iu6960qDhBLR/RLjlb9UPtLmCMbczDE=</pre>\n\n* Signer 2 encryption\n** HMAC_KEY (hex): 3d4c422806ba8964c9ee45070cd675c024d96648a0ddb4001325818c84951de2\n** MAC (hex): 383d05b7351a2cef7cca2850450f5efbbc4a3f8ea35707dda87a3692f0f2ebae\n** IV (hex) : 383d05b7351a2cef7cca2850450f5efb\n** CIPHERTEXT (hex): 71860b7c69f3a7665c3c3e85c45735bff78535a37ec6610b724627c73696820d519a9251703b17626b63898580233bebbb310aedbc370224b044ee19600bfe583445a6f26fb9bb5790bae516892655adb0e5dfc12be4609c2e0818d4f1f3bfccc4cd1a36f419d6cd842c913ae81eef4865ad473c32c3ee69cd98d6d0a088e2abdd01fe68b5c0503bb9183f9a912506204e5a9c6bd5a1626ff7eac30312a0b85004307c525e52fa3ad45a0b02eabc8cfaea0215bb6e60ee5f32d6673955290e008fbaef362977a21fd9830e3a604f9bb318cdcde456eae91dbedaa069bcd1efb0f981d5b0e502bd4dada903205458a00914887226a8dde317c02a8be4342acb97a8fee79fbe23\n** <tt>signer_2_key.dat</tt>: <pre>383d05b7351a2cef7cca2850450f5efbbc4a3f8ea35707dda87a3692f0f2ebae71860b7c69f3a7665c3c3e85c45735bff78535a37ec6610b724627c73696820d519a9251703b17626b63898580233bebbb310aedbc370224b044ee19600bfe583445a6f26fb9bb5790bae516892655adb0e5dfc12be4609c2e0818d4f1f3bfccc4cd1a36f419d6cd842c913ae81eef4865ad473c32c3ee69cd98d6d0a088e2abdd01fe68b5c0503bb9183f9a912506204e5a9c6bd5a1626ff7eac30312a0b85004307c525e52fa3ad45a0b02eabc8cfaea0215bb6e60ee5f32d6673955290e008fbaef362977a21fd9830e3a604f9bb318cdcde456eae91dbedaa069bcd1efb0f981d5b0e502bd4dada903205458a00914887226a8dde317c02a8be4342acb97a8fee79fbe23</pre>\n\n====ROUND 2====\n*Coordinator\n** <tt>my_multisig_wallet.bsms</tt>:\n<pre>BSMS 1.0\nwsh(sortedmulti(2,[b7868815/48'/0'/0'/2']xpub6FA5rfxJc94K1kNtxRby1hoHwi7YDyTWwx1KUR3FwskaF6HzCbZMz3zQwGnCqdiFeMTPV3YneTGS2YQPiuNYsSvtggWWMQpEJD4jXU7ZzEh/**,[eedff89a/48'/0'/0'/2']xpub6EhJvMneoLWAf8cuyLBLQiKiwh89RAmqXEqYeFuaCEHdHwxSRfzLrUxKXEBap7nZSHAYP7Jfq6gZmucotNzpMQ9Sb1nTqerqW8hrtmx6Y6o/**))\n/0/*,/1/*\nbc1qhs4u273g4azq7kqqpe6vh5wfhasfmrq7nheyzsnq77humd7rwtkqagvakf</pre>\n\n*Coordinator encryption\n** HMAC_KEY (hex): 3d4c422806ba8964c9ee45070cd675c024d96648a0ddb4001325818c84951de2\n** MAC (hex): 734ce791b466861945e1ef6f74c63faec590793de54831f0036b28d08714b71a\n** IV (hex) : 734ce791b466861945e1ef6f74c63fae\n** CIPHERTEXT (hex): 273cad18a5e1eff37dba6d850749594c9a3fd32b2069e8c69983ea269c5044b6bcaea26d9dbc8ad5d28bb8abfa02e3bfc7632fcc5c2b76e9abb1982ff11295858cfe44a8b97110ae970f58fff3fb6477f38ca9609eec78eedb1d640eaba489fd5e41e787b8d0bde48f1fa99cca641cabbee0f513fb1040cb73df10a57c9a34e4efcb069cd4c75467442c15d878ed9f40e3dffb98294931a6da4f444ae46f739b7fe002ce19fcfe71b05b9783d797ba45d568febbc8a2b0850da67f349d8567342352e1712c3d2a7ea1b2721df5efdb844431f0e5dcfa4acacb194c20785c9bb6dde90d64352fc913e9073b3b416be713bcc7632c821bbfddafa6199d471c54fb899f347f5fc706787ccaa82332dc8b93aeb3de3497d8e5c75f0f5d718c74bc6f8194fe999948e517f1c98398d9cb907d200f1d045394704b074dfb10e587f54fd78e95ef4bcbe77bf1376b390c3f47c91c12b2ed14073ea56bceab41f924302e62183c456b06d96b3da30439cb4320c764a0d6d1b3dabc06fc\n** <tt>my_multisig_wallet.dat</tt>: <pre>734ce791b466861945e1ef6f74c63faec590793de54831f0036b28d08714b71a273cad18a5e1eff37dba6d850749594c9a3fd32b2069e8c69983ea269c5044b6bcaea26d9dbc8ad5d28bb8abfa02e3bfc7632fcc5c2b76e9abb1982ff11295858cfe44a8b97110ae970f58fff3fb6477f38ca9609eec78eedb1d640eaba489fd5e41e787b8d0bde48f1fa99cca641cabbee0f513fb1040cb73df10a57c9a34e4efcb069cd4c75467442c15d878ed9f40e3dffb98294931a6da4f444ae46f739b7fe002ce19fcfe71b05b9783d797ba45d568febbc8a2b0850da67f349d8567342352e1712c3d2a7ea1b2721df5efdb844431f0e5dcfa4acacb194c20785c9bb6dde90d64352fc913e9073b3b416be713bcc7632c821bbfddafa6199d471c54fb899f347f5fc706787ccaa82332dc8b93aeb3de3497d8e5c75f0f5d718c74bc6f8194fe999948e517f1c98398d9cb907d200f1d045394704b074dfb10e587f54fd78e95ef4bcbe77bf1376b390c3f47c91c12b2ed14073ea56bceab41f924302e62183c456b06d96b3da30439cb4320c764a0d6d1b3dabc06fc</pre>\n\n===Mode: <tt>EXTENDED</tt> Encryption===\n====ROUND 1====\n*Coordinator\n** M-of-N: 2/3\n** ADDRESS_TYPE: NESTED_SEGWIT\n** TOKEN for Signer 1 (hex): 108a2360adb302774eb521daebbeda5e\n*** TOKEN (decimal): 21984902443033505423410071144203475550\n*** ENCRYPTION_KEY (hex): 63dc1e57dfdc21fa11109d5088be01fb8078a383d2296925ad2b7612b7179777\n** TOKEN for Signer 2 (hex): d3fabc873b98165254fe18a71b5335b0\n*** TOKEN (decimal): 281769005132501859744421970528095647152\n*** ENCRYPTION_KEY (hex): 3dc860a53471ec03af14617fef60921cf215b45a9d684462fa65b9d804ad3ee7\n** TOKEN for Signer 3 (hex): 78a7d5e7549453d719150de5459c9ce5\n*** TOKEN (decimal): 160378811550692397333855096016467696869\n*** ENCRYPTION_KEY (hex): 62b90b4c08c03a0ee872e57aae73f9acfafb6cc09d20b5c9bc0bafaef33619db\n\n* Signer 1\n** MASTER_KEY_FINGERPRINT: 793cc70b\n** PRIVATE_KEY (m/48'/0'/0'/1'): L1ZEgZ4zNYxyNc8UyeqwyKW1UHVMp9sxwPgSi3s9SW8mc7KsiSwJ\n** XPUB (m/48'/0'/0'/1'): xpub6ErVmcYYHmavsMgxEcTZyzN5sqth1ZyRpFNJC26ij1wYGC2SBKYrgt9yariSbn7HLRoZUvhUhmPfsRTPrdhhGFscpPZzmch6UTdmRP1aZUj\n** Legacy signature\n** <tt>signer_1_key.bsms</tt>:\n<pre>BSMS 1.0\n108a2360adb302774eb521daebbeda5e\n[793cc70b/48'/0'/0'/1']xpub6ErVmcYYHmavsMgxEcTZyzN5sqth1ZyRpFNJC26ij1wYGC2SBKYrgt9yariSbn7HLRoZUvhUhmPfsRTPrdhhGFscpPZzmch6UTdmRP1aZUj\nSigner 1 key\nILG47LpCtjoD9UxL87jo5QFqA90t8g9fDQp/KBojdKgPPGB1pMx2bf9hPdORNZIOdCc/2+Gs6AOs3BEK9ubIuBw=</pre>\n\n* Signer 1 encryption\n** HMAC_KEY (hex): 1162cdace4ac9fcde1f96924b93714143d057a701de83ebaed248d1c9154f9fd\n** MAC (hex): ea12776c73de4bd5ea57c2d19eb8e0be856ac0d7f5651f7b74be4563d61ba5b1\n** IV (hex) : ea12776c73de4bd5ea57c2d19eb8e0be\n** CIPHERTEXT (hex): a36f34232bff47a853092654a718fea4f5f57d6a1f3d38fede04e2414da12c90cefc24ef662f736886d9a7fd6e7db636ca47217803c86b7fbcebe4ad6b71cffc261069c135bd2b2430fb2b446ff0203df34fbbc6801243e8a930b9d0cd3a9b160b8dcdc9131ce6e97641e6314b3285ff341013f302e308c1b2eba7ced0103a8999fe2bd86f844392938e7926cd26d023b764d0b8ff92b2fbdf995884c738414b83563ef2a0050279bf46d0e8271ea5d6af8154847c5736129a7a83a35a3cc747b2be4b389886cb57456678353b60473ebc4ab85d9c9131a17a1e288717343d9008825b16c48d7e93927f37b530033192c67b70dec0411a3e5952d2525c7eb80721676e1a6299248c17f8078202f3bb0932e9f263b0ab\n** <tt>signer_1_key.dat</tt>: <pre>ea12776c73de4bd5ea57c2d19eb8e0be856ac0d7f5651f7b74be4563d61ba5b1a36f34232bff47a853092654a718fea4f5f57d6a1f3d38fede04e2414da12c90cefc24ef662f736886d9a7fd6e7db636ca47217803c86b7fbcebe4ad6b71cffc261069c135bd2b2430fb2b446ff0203df34fbbc6801243e8a930b9d0cd3a9b160b8dcdc9131ce6e97641e6314b3285ff341013f302e308c1b2eba7ced0103a8999fe2bd86f844392938e7926cd26d023b764d0b8ff92b2fbdf995884c738414b83563ef2a0050279bf46d0e8271ea5d6af8154847c5736129a7a83a35a3cc747b2be4b389886cb57456678353b60473ebc4ab85d9c9131a17a1e288717343d9008825b16c48d7e93927f37b530033192c67b70dec0411a3e5952d2525c7eb80721676e1a6299248c17f8078202f3bb0932e9f263b0ab</pre>\n\n* Signer 2\n** MASTER_KEY_FINGERPRINT: b3118e52\n** PRIVATE_KEY (m/48'/0'/0'/1'): L4SnPjcHszMg3Wi2YYxEYnzM2zFeFkFr5NcLZ18YQeyJwaSFbTud\n** XPUB (m/48'/0'/0'/1'): xpub6Du5Jn6eYZE96ccmAc1ZTFPzdnzrvqfG4mpamDun2qZYKywoiQJMCbS3kWWMr6U3XW6s125RLsaPABWgv2yA749ieaMe67FxkTjMsbcxCch\n** Legacy signature\n** <tt>signer_2_key.bsms</tt>:\n<pre>BSMS 1.0\nd3fabc873b98165254fe18a71b5335b0\n[b3118e52/48'/0'/0'/1']xpub6Du5Jn6eYZE96ccmAc1ZTFPzdnzrvqfG4mpamDun2qZYKywoiQJMCbS3kWWMr6U3XW6s125RLsaPABWgv2yA749ieaMe67FxkTjMsbcxCch\nSigner 2 key\nIDK4d/oO0pgfrwRu4Zb8vqlPEmJb9aKT1K2CCnI3RKepVAKs3fZsBrypcCdQfUy1TG/3O5vAR3gjldxcCA1Wzg8=</pre>\n\n* Signer 2 encryption\n** HMAC_KEY (hex): 43a4e704bd1bade703023004b00290f1a7b005474a581d869a217068eedf3f57\n** MAC (hex): 4a3ff970d027010e83b4fbf2845a23907a301b3df692a9265e2ca679697ac718\n** IV (hex) : 4a3ff970d027010e83b4fbf2845a2390\n** CIPHERTEXT (hex): c8f4a6a6714eff90aa48cbefe6750c2ee3cc72182eb455e964f0ba59ada3ecd758c29f0fab7e33aaa82a340a18d9c793ddab09dc7e714864faac1ecea370d4f102533b739da38aa0491433f35eadec08f203685f04d1f6ec35d397d99e4f8096a5691075e3f54fd9ff58faf947f276bbe1031f827b274bd2f60fcb526add7058889104b189d7da22ac7be1f7ddd380bbebd5c6983a8a3c5fa86913e3d23c40935072ce03d9bdeb07791dc836d44b4d4c62f364d0e4f3580369ea8f6ebb774b7fda4a7ac6f5ae6b2f52b10cd71bdf3cdb5889e77d5eb1f2f647b798cdd6b3e5b964c9265daea3668d7e4cb53f724151923da1a87bbcd2abd8b164de474d865c51af69885431d26f88a5c8eea7d0dfdb52ca622017808a\n** <tt>signer_2_key.dat</tt>: <pre>4a3ff970d027010e83b4fbf2845a23907a301b3df692a9265e2ca679697ac718c8f4a6a6714eff90aa48cbefe6750c2ee3cc72182eb455e964f0ba59ada3ecd758c29f0fab7e33aaa82a340a18d9c793ddab09dc7e714864faac1ecea370d4f102533b739da38aa0491433f35eadec08f203685f04d1f6ec35d397d99e4f8096a5691075e3f54fd9ff58faf947f276bbe1031f827b274bd2f60fcb526add7058889104b189d7da22ac7be1f7ddd380bbebd5c6983a8a3c5fa86913e3d23c40935072ce03d9bdeb07791dc836d44b4d4c62f364d0e4f3580369ea8f6ebb774b7fda4a7ac6f5ae6b2f52b10cd71bdf3cdb5889e77d5eb1f2f647b798cdd6b3e5b964c9265daea3668d7e4cb53f724151923da1a87bbcd2abd8b164de474d865c51af69885431d26f88a5c8eea7d0dfdb52ca622017808a</pre>\n\n* Signer 3\n** MASTER_KEY_FINGERPRINT: 842bd2ed\n** PRIVATE_KEY (m/48'/0'/0'/1'): L1ehZHpo2UFHc1yaBWDU4bKVycUwcU2TESm92wbfq6xK6qpZZJP6\n** XPUB (m/48'/0'/0'/1'): xpub6Ex81KopPkEt9hJiWHabYy8LNsSR4A7sUQoFBk9dR8XxHrr4p9HrYWN3NCf5uwfopHnQkCG7FYnZMztKbtRtbh6tzZC4xtHPbmVVxRSN7ic\n** Legacy signature\n** <tt>signer_3_key.bsms</tt>:\n<pre>BSMS 1.0\n78a7d5e7549453d719150de5459c9ce5\n[842bd2ed/48'/0'/0'/1']xpub6Ex81KopPkEt9hJiWHabYy8LNsSR4A7sUQoFBk9dR8XxHrr4p9HrYWN3NCf5uwfopHnQkCG7FYnZMztKbtRtbh6tzZC4xtHPbmVVxRSN7ic\nSigner 3 key\nIL77mML0xo/O9dJn0T5EpQLuyRPPrdpgVJbtsdAugW5iX0MQ3Ci0f8jVnXu68Xm07CYjYGKX8af72jmkQKhNud0=</pre>\n\n* Signer 3 encryption\n** HMAC_KEY (hex): ab93ce7bf0f91c62a66d00ea9bf5e5c00b854ee2cfc2fb06f6eeff738abcdc26\n** MAC (hex): e82cfcccbd4bd4d3b76e28133eecd13f7362f4a8b4c4baa3e5f6ba2dfb4d69b8\n** IV (hex) : e82cfcccbd4bd4d3b76e28133eecd13f\n** CIPHERTEXT (hex): b44433f0b564ec35a1e71371f25844088084b47402c90d52fee7237167b58a60a28c234af9123e104773136e8446d799541c8566882787caee7cd1fa8628aba63aa9e9d7cca0ddee92f96dd881535b19a131a1f487a1909e42d62945fd0ba08dacd7dc09a22ffe47e0410b8b85df92e4a8bbf9b46f0062da02e3ae94144a00bae917acc1246d8d1a4dca105708f55379caefef9d4c152f56b65ab4bd7b48f60233f57ba6d705387c79aeaa2a279e3314004bf16fcd7e7d2adef34b0ab3c22bc5461f2c09dce69065605e4fb96958c55984391712b3547e3914ad4ecca2c088be280dfcfe374a112515674aeca57b885e81dbef6a353ca387f4514db3158eb69f0d2725d42ad8102c05c26ad501d48b889c624035ead4\n** <tt>signer_3_key.dat</tt>: <pre>e82cfcccbd4bd4d3b76e28133eecd13f7362f4a8b4c4baa3e5f6ba2dfb4d69b8b44433f0b564ec35a1e71371f25844088084b47402c90d52fee7237167b58a60a28c234af9123e104773136e8446d799541c8566882787caee7cd1fa8628aba63aa9e9d7cca0ddee92f96dd881535b19a131a1f487a1909e42d62945fd0ba08dacd7dc09a22ffe47e0410b8b85df92e4a8bbf9b46f0062da02e3ae94144a00bae917acc1246d8d1a4dca105708f55379caefef9d4c152f56b65ab4bd7b48f60233f57ba6d705387c79aeaa2a279e3314004bf16fcd7e7d2adef34b0ab3c22bc5461f2c09dce69065605e4fb96958c55984391712b3547e3914ad4ecca2c088be280dfcfe374a112515674aeca57b885e81dbef6a353ca387f4514db3158eb69f0d2725d42ad8102c05c26ad501d48b889c624035ead4</pre>\n\n====ROUND 2====\n* Coordinator\n** <tt>my_multisig_wallet.bsms</tt>:\n<pre>BSMS 1.0\nsh(wsh(multi(2,[793cc70b/48'/0'/0'/1']xpub6ErVmcYYHmavsMgxEcTZyzN5sqth1ZyRpFNJC26ij1wYGC2SBKYrgt9yariSbn7HLRoZUvhUhmPfsRTPrdhhGFscpPZzmch6UTdmRP1aZUj/**,[b3118e52/48'/0'/0'/1']xpub6Du5Jn6eYZE96ccmAc1ZTFPzdnzrvqfG4mpamDun2qZYKywoiQJMCbS3kWWMr6U3XW6s125RLsaPABWgv2yA749ieaMe67FxkTjMsbcxCch/**,[842bd2ed/48'/0'/0'/1']xpub6Ex81KopPkEt9hJiWHabYy8LNsSR4A7sUQoFBk9dR8XxHrr4p9HrYWN3NCf5uwfopHnQkCG7FYnZMztKbtRtbh6tzZC4xtHPbmVVxRSN7ic/**)))\n/0/*,/1/*\n3GzMtFXahiu4TpGNGFc4bHMvAcvz5vVQrT</pre>\n\n* Send to Signer 1:\n** HMAC_KEY (hex): 1162cdace4ac9fcde1f96924b93714143d057a701de83ebaed248d1c9154f9fd\n** MAC (hex): 01bf557b6d44b3fbf07f8ec155cbdec42d85d856e174342563dd83b40ad7c025\n** IV (hex) : 01bf557b6d44b3fbf07f8ec155cbdec4\n** CIPHERTEXT (hex): 617ed25b4b8fd88b806cbebcc1731b071465514a805f7ba2de60e291bc9493f31aa0f9b0665ba822cf9a2e21c02649b5c3f7dbad317ae898292cb6fe992520f68c0ebe9d1434b348af10453f1be0a392a616d43ba21e5e7fa3c995dce54db947fe5dbad4a9a77f37b3aef58c54ee3e496c8312d3033359aed0de8cf28b82035ee7a38c9b23c9d95682fb15936bf2247546d2ba9b3ada605f5c89f0a3bbaa86cb4b5dded9a65004912c0afbbfd01f0115447f5625e8523f9de16165d32c4b21103d8ac965e2f7e17641ee1a8c5902e8dbb461c6c7d05141f7bba66b8b3608037fb251b55fa461c9441c6427921545a34a1798127d5bf9cc92423f7e62c769e232c65db8cc5124577012d49941143c3b4758212a8afa0475c9b3597da2e99d585039339b7d73611aa277878d212875051683053db9c630391e0b32356523e9fa8a58a334e16fe6650472f336ddaa8c587992b6c0c0e480b680261579a11cf9d036614abc113dde53653273f5ce82ea0bc10e38ca52ac66838aa49ff46c3a7d5096db439c15d3c2e8de55e4ac7315a57eb9997f219c378af86c858867ce583ed84e4d9c68aecfbca9ebff16b0ac91531125e273b215db688ffe52c8033eb78914b87c0fa2001c52e90c92765712e50384ddcf4d0953ac3cc8137abcb2a85d603a6cc207472677\n** <tt>my_multisig_wallet_for_signer_1.dat</tt>: <pre>01bf557b6d44b3fbf07f8ec155cbdec42d85d856e174342563dd83b40ad7c025617ed25b4b8fd88b806cbebcc1731b071465514a805f7ba2de60e291bc9493f31aa0f9b0665ba822cf9a2e21c02649b5c3f7dbad317ae898292cb6fe992520f68c0ebe9d1434b348af10453f1be0a392a616d43ba21e5e7fa3c995dce54db947fe5dbad4a9a77f37b3aef58c54ee3e496c8312d3033359aed0de8cf28b82035ee7a38c9b23c9d95682fb15936bf2247546d2ba9b3ada605f5c89f0a3bbaa86cb4b5dded9a65004912c0afbbfd01f0115447f5625e8523f9de16165d32c4b21103d8ac965e2f7e17641ee1a8c5902e8dbb461c6c7d05141f7bba66b8b3608037fb251b55fa461c9441c6427921545a34a1798127d5bf9cc92423f7e62c769e232c65db8cc5124577012d49941143c3b4758212a8afa0475c9b3597da2e99d585039339b7d73611aa277878d212875051683053db9c630391e0b32356523e9fa8a58a334e16fe6650472f336ddaa8c587992b6c0c0e480b680261579a11cf9d036614abc113dde53653273f5ce82ea0bc10e38ca52ac66838aa49ff46c3a7d5096db439c15d3c2e8de55e4ac7315a57eb9997f219c378af86c858867ce583ed84e4d9c68aecfbca9ebff16b0ac91531125e273b215db688ffe52c8033eb78914b87c0fa2001c52e90c92765712e50384ddcf4d0953ac3cc8137abcb2a85d603a6cc207472677</pre>\n\n* Send to Signer 2:\n** HMAC_KEY (hex): 43a4e704bd1bade703023004b00290f1a7b005474a581d869a217068eedf3f57\n** MAC (hex): 974ba77900c43c463dadaa6eaf24aaeb1b25b443cf155229b719bcbf8b343092\n** IV (hex) : 974ba77900c43c463dadaa6eaf24aaeb\n** CIPHERTEXT (hex): 86288c97a6341974a35015f97fbbc8db7655639c839fc438706f82fce36a82dd17e2d4d4a674516c4fc5c3a33d6097dd8fc5c6605018946741ed9f58d8fe530a808f16f0dd705cacfd273e34a158bd7566774dd31506b8280e448fabb72d0e7dfc05cee1142b61921dfaf0b0039d885cc0aa76c429025efc2ba49a8af15b58e75a5a83ba4838a9a4c9f13725f5aecefd8511513d93797f37b93150b9dca725685883188e39142dd8d3cf4b617c7936bdb3875415bbf6dfb2fe1a39ae2aed9fd2909aebd0355a5cc9a55bcb84048c851a1873948e495180f336edeb63f54bcf83feaa4d2453251260e24293e49815c2369c1c045083c412c973987fd7c9296a71cda424823ed32380ba442394500b7d2d2335818099090aaf08ca4e180869c546f58da4cb4ff0f95b796a35c40ea455e2ddd3e08bc494ffddc706aaf4d479f4f359e6a89a90df7c9b8f23cab355855a72b90795a0db83a96bce0dd4f77e3f58c0957b4ffe9663251565098e6c31fd4bbf3e1295faaff05e29912d9c37cb944da379a9b2193b466910d05a681e53a2dbe5aa18a2b4874153fe36d8a1aa4cc6e612bd6dbc9abb8e1e61b927fc5458d8e1be9536cd462e4c37672af7928c39e94bdc124a2da7b1bd3cad2cfe559adc33e62eb45bff89db8a47a72dda4f49f21c01a9432f4802a1\n** <tt>my_multisig_wallet_for_signer_2.dat</tt>: <pre>974ba77900c43c463dadaa6eaf24aaeb1b25b443cf155229b719bcbf8b34309286288c97a6341974a35015f97fbbc8db7655639c839fc438706f82fce36a82dd17e2d4d4a674516c4fc5c3a33d6097dd8fc5c6605018946741ed9f58d8fe530a808f16f0dd705cacfd273e34a158bd7566774dd31506b8280e448fabb72d0e7dfc05cee1142b61921dfaf0b0039d885cc0aa76c429025efc2ba49a8af15b58e75a5a83ba4838a9a4c9f13725f5aecefd8511513d93797f37b93150b9dca725685883188e39142dd8d3cf4b617c7936bdb3875415bbf6dfb2fe1a39ae2aed9fd2909aebd0355a5cc9a55bcb84048c851a1873948e495180f336edeb63f54bcf83feaa4d2453251260e24293e49815c2369c1c045083c412c973987fd7c9296a71cda424823ed32380ba442394500b7d2d2335818099090aaf08ca4e180869c546f58da4cb4ff0f95b796a35c40ea455e2ddd3e08bc494ffddc706aaf4d479f4f359e6a89a90df7c9b8f23cab355855a72b90795a0db83a96bce0dd4f77e3f58c0957b4ffe9663251565098e6c31fd4bbf3e1295faaff05e29912d9c37cb944da379a9b2193b466910d05a681e53a2dbe5aa18a2b4874153fe36d8a1aa4cc6e612bd6dbc9abb8e1e61b927fc5458d8e1be9536cd462e4c37672af7928c39e94bdc124a2da7b1bd3cad2cfe559adc33e62eb45bff89db8a47a72dda4f49f21c01a9432f4802a1</pre>\n\n* Send to Signer 3:\n** HMAC_KEY (hex): ab93ce7bf0f91c62a66d00ea9bf5e5c00b854ee2cfc2fb06f6eeff738abcdc26\n** MAC (hex): bb3c93b67d758f244de7ee73e5e61261cea6dff5b3852df8faf265cdf1c73dae\n** IV (hex) : bb3c93b67d758f244de7ee73e5e61261\n** CIPHERTEXT (hex): 7ac33bd9719a3cef6c68e09b3c9677565418933f188bbe50dc70f46329706732fe28ab230468e2a8798d3fbf641867d5b3322113204a372e7650ed06cf94d6df5cc7425b1b3a07690a32e12fd9cdad2c9f42d496c1b02215a7d8d63565aa4935bb2b087af39eebc02d4a2d30a4dbf1e72b9a0dab11473c7254ecf9065eb4f9d80a164c489d5fdae0d15d97b6100b79c3999b91341dfb4f599f738d4d631ae413c17b55daa09a67cb34b40d89c26f0e95ddfbf416033f869da32e502815d720bb342ec1c0e5c6910c598f32162016229cd37ea030b4d3b60f560105abb75531dc960ddf6830c26604c67c2da05b8adc45297dda58b2da4671104969b819cdf1c362bc20d7bdfe4a2fbdb79b4a69e285434d991c269e3d23ce3d95675a0acbec2cae04a310581148d3422c1c0a621fb6d79ecac1743b0e76837389b67cd4734ec5ab560c43a183de35fa98834e1f347a0c0c9b14273b76233f55f04553efcde873de92d766f3cdc5e56bc649bf0cc4951f051619ee9b931cd3872044b0e62ea2c2dacad978dbb8df3afa0b9386535278c295c6a30a56950e57f805770568e937ffafbadb226120991d5ec10effa9f4334800010d141a2ddddc00ac743efa821af37f69840487e4db48036c1e0730788cddbca2f68b3769ec6989d76161e6605af50651b6e86e\n** <tt>my_multisig_wallet_for_signer_3.dat</tt>: <pre>bb3c93b67d758f244de7ee73e5e61261cea6dff5b3852df8faf265cdf1c73dae7ac33bd9719a3cef6c68e09b3c9677565418933f188bbe50dc70f46329706732fe28ab230468e2a8798d3fbf641867d5b3322113204a372e7650ed06cf94d6df5cc7425b1b3a07690a32e12fd9cdad2c9f42d496c1b02215a7d8d63565aa4935bb2b087af39eebc02d4a2d30a4dbf1e72b9a0dab11473c7254ecf9065eb4f9d80a164c489d5fdae0d15d97b6100b79c3999b91341dfb4f599f738d4d631ae413c17b55daa09a67cb34b40d89c26f0e95ddfbf416033f869da32e502815d720bb342ec1c0e5c6910c598f32162016229cd37ea030b4d3b60f560105abb75531dc960ddf6830c26604c67c2da05b8adc45297dda58b2da4671104969b819cdf1c362bc20d7bdfe4a2fbdb79b4a69e285434d991c269e3d23ce3d95675a0acbec2cae04a310581148d3422c1c0a621fb6d79ecac1743b0e76837389b67cd4734ec5ab560c43a183de35fa98834e1f347a0c0c9b14273b76233f55f04553efcde873de92d766f3cdc5e56bc649bf0cc4951f051619ee9b931cd3872044b0e62ea2c2dacad978dbb8df3afa0b9386535278c295c6a30a56950e57f805770568e937ffafbadb226120991d5ec10effa9f4334800010d141a2ddddc00ac743efa821af37f69840487e4db48036c1e0730788cddbca2f68b3769ec6989d76161e6605af50651b6e86e</pre>\n\n==Acknowledgement==\n\nSpecial thanks to Pavol Rusnak, Dmitry Petukhov, Christopher Allen, Craig Raw, Robert Spigler, Gregory Sanders, Ta Tat Tai, Michael Flaxman, Pieter Wuille, Salvatore Ingala, Ava Chow and others for their feedback on the specification.\n\n==References==\n\nRelated mailing list threads:\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-February/018385.html\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-April/018732.html\n\n", "content_length": 40739}
{"bip_number": 127, "filename": "bip-0127.mediawiki", "content": "\n<pre>\n  BIP: 127\n  Layer: Applications\n  Title: Simple Proof-of-Reserves Transactions\n  Author: Steven Roose <steven@stevenroose.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0127\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-01-28\n  License: CC0-1.0\n</pre>\n\n\n==Abstract==\n\nThis BIP describes a simple way to construct proof-of-reserves transactions.\nThis proposal formalizes a standard format for constructing such proofs, easing\ntheir construction with existing wallet infrastructure and enabling general\nproof-verification software.  It relies on existing standards such as regular\nBitcoin transaction serialization/validation and the BIP 174 PSBT format.\nThe proposal also includes the description of a PSBT extension for a better\nuser experience.\n\n==Copyright==\n\nThis BIP is licensed under the Creative Commons CC0 1.0 Universal license.\n\n==Motivation==\n\nFrom the very early days in the history of Bitcoin, there have been companies\nmanaging bitcoins for their users.  These users give up control over their coins\nin return for a certain service.  Inevitably, there have been many cases of\ncompanies losing their users' bitcoins without timely disclosing such events to\nthe public.  Proofs of Reserves are a way for companies managing large amounts\nof bitcoins to prove ownership over a given amount of funds.  The regular proof\nof control helps to ensure that no significant loss has occurred.\n\nWhile the term proof-of-reserves is not new by any means, the procedure is not\nvery common among high-value custodian companies.  One of the reasons for this\nis that every company that wants to perform a proof-of-reserves has to construct\nits own way to do so.  Accordingly, their users have to understand the\nconstruction of the proof in order to be able to verify it.  This raises the bar\nof entry both for custodians and for users.\n\n\n===What this BIP is not doing===\n\nThe proof-of-reserve construction described in this document has some known\nshortcomings, mostly with regards to its privacy properties.  While there exists\nresearch about improved proof-of-reserves mechanisms that have much better\nprivacy properties<ref>Dagher, Gaby G., Benedikt B\u00fcnz, Joseph Bonneau, Jeremy\nClark, and Dan Boneh. \"Provisions: Privacy-preserving proofs of solvency for\nBitcoin exchanges.\" (2015).</ref>, this BIP intentionally only formalizes\nthe de-facto existing method.\n\n\n==Specification==\n\nOur specification consists of two parts:\n# the format for the actual proofs\n# a file format used to package a set of proofs and relevant metadata\n\nThe final construction should have the following properties:\n* flexible proof construction to support complex wallet infrastructures\n* easy integration with existing wallet solutions (both hardware and software wallets)\n* support for verification via a standard procedure, regardless of publisher of the proof\n* proof prevents reuse of proofs by other parties by committing to a message\n* allow validating that the issuer had the funds under his control at a certain block, regardless of what happened after that block\n\n===Proof Format===\n\nTo allow for maximal compatibility with existing systems, proofs are formatted as regular Bitcoin\ntransactions.  However, one small adaptation to the transaction is made that has two functions:\n# make the transaction unspendable to avoid putting funds at risk\n# link the proof to the issuer of the proof to prevent copying proofs from other custodians\n\nThe resulting construction is a Bitcoin transaction with the following\ncharacteristics:\n\n* The first input (the \"commitment input\")\n** MUST have the txid part of the previous outpoint set to the SHA-256 hash of the commitment message prefixed with \"Proof-of-Reserves: \"<ref>If the message is \"Some Message\", the txid part should be <tt>SHA-256(\"Proof-of-Reserves: Some Message\")</tt> with the string encoded as UTF-8.</ref> and index 0.\n* The remaining inputs\n** MUST have signatures that commit to the commitment input (e.g. using <tt>SIGHASH_ALL</tt>).\n* The transaction MUST have a single output that is the exact sum of all the inputs, assuming the commitment input to have 0 value; this means the transaction has no miner fee.\n\nThe existence of the first input (which is just a commitment hash) ensures\nthat this transaction is invalid and can never be confirmed.\n\n\n===Proof File Format===\n\nIn theory, the first part of the specification would be sufficient as a minimum\nviable standard.  However, there are a number of motivations to extend the\nstandard with an extra layer of metadata:\n\n# constructing and combining multiple proofs\n#:Having thousands of UTXOs spread across different offline and online wallets could make it difficult to construct a single proof transaction with all UTXOs.  Allowing multiple proof transactions with the same commitment message and block number gives extra flexibility to custodians with complex wallet infrastructure without making the combined proof less secure.\n# metadata for verification\n#:Not all systems that will be used for verification have access to a full index of all transactions.  However, proofs should be easily verifiable even after some of the UTXOs used in the proof are no longer unspent.  Metadata present in the proof allows for relatively efficient verification of proofs even if no transaction index is available.\n# potential future improvements\n#:The extensible metadata format allows for amending the standard in the future.  One potential improvement would be having UTXO set commitments.  These would allow the proofs-of-reserves to come with accompanying proofs-of-inclusion of all used UTXOs in the UTXO set at the block of proof construction (making validation even more efficient).\n\nThe proposed proof-file format provides a standard way of combining multiple\nproofs and associated metadata.  The specification of the format is in the\nProtocol Buffers<ref>https://github.com/protocolbuffers/protobuf/</ref> format.\n\n<pre>\nsyntax = \"proto3\";\nimport \"google/protobuf/any.proto\";\n\nmessage OutputMeta {\n\t// Identify the outpoint.\n\tbytes txid = 1;\n\tuint32 vout = 2;\n\n\t// The block hash of the block where this output was created.\n\tbytes block_hash = 3;\n}\n\nmessage FinalProof {\n\t// The proof transaction.  Should be able to be parsed like a regular\n\t// Bitcoin transaction.\n\tbytes proof_tx = 1;\n\n\t// The metadata of the outputs used in the proof transaction.\n\trepeated OutputMeta output_metadata = 2;\n}\n\nmessage ProofOfReserves {\n\t// A version number for this format to enable extending it with\n\t// additional fields.\n\tuint32 version = 1;\n\n\t// The network magic for the network in which the proofs are valid.\n\t// 0xD9B4BEF9 for mainnet, 0x0709110B for testnet\n\t//TODO consider BIP44 coin type ids instead:\n\t// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\n\tuint32 network_magic = 2;\n\n\t// The commitment message for this proof-of-reserves.\n\t// This message is global for all the proofs.\n\tstring message = 3;\n\n\t// The block at which this proof is supposed to be validated.\n\t// Verification should take into account unspentness of outputs at this\n\t// block height.\n\tbytes block_hash = 4;\n\n\t// The set of final proof transactions with their output metadata.\n\trepeated FinalProof final_proofs = 5;\n\n\t// Reserved field that can potentially be used by proof-construction tools.\n\t// It can be ignored for verification.\n\trepeated google.protobuf.Any pending_proofs = 6;\n}\n</pre>\n\nThe last field, <tt>pending_proofs</tt>, leaves open some space in the same\nfile that can be used by proof-construction tools.  This allows them to\nconstruct different proofs incrementally without having to switch between file\nformats.\n\n\n===PSBT (BIP 174) extension===\n\nThe \"commitment input\" detailed in the proof format section does not spend an\nexisting UTXO and thus shouldn't be signed (empty <tt>scriptSig</tt> and\nwitness).  This can cause some problems when signing this type of transactions.\nFor example, hardware wallets often require the signer to provide information\nabout all inputs of transactions they are signing, such as the previous output\nor previous transaction; this data obviously doesn't exist for the commitment\ninputs.\n\nFor most existing devices, it's possible to circumvent these requirements by\nproviding dummy data or by instructing the device to ignore this specific\ninput.  However, there is still a UX problem.  Because the hardware wallet\ndevice doesn't recognize the transaction as a proof-of-reserves transaction it\nwill think it is signing a regular transaction that is spending all the money\nin the UTXOs.  Most devices will ask for confirmation with a message along the\nlines of \"Are you sure you want to send XXX BTC to address [...]?\".  This is\nnot the best user experience.\n\nAn addition to the BIP 174 PSBT format could help signing devices to recognize proof-of-reserve transactions.\nThe following field is added to the BIP 174 <tt>INPUT</tt> map:\n\n* Type: Proof-of-reserves commitment <tt>PSBT_IN_POR_COMMITMENT = 0x09</tt>\n** Key: None. The key must only contain the 1 byte type.\n*** <tt>{0x09}</tt>\n** Value: The UTF-8 encoded commitment message string for the proof-of-reserves.\n*** <tt>{porCommitment}</tt>\n\nWallets processing an input that has this field set\n* MUST make sure the txid of the previous outpoint is set to the SHA-256 hash of the prefixed commitment message string, as detailed above;\n* MUST assume the input value to be 0 (without requiring the previous output or transaction to be provided);\n* SHOULD display the commitment message to ask the user for confirmation before signing any inputs;\n* SHOULD only provide signatures with a signature hash that commits to this input;\n* SHOULD accept an empty <tt>scriptSig</tt> for this input (as if the <tt>scriptPubKey</tt> was <tt>OP_TRUE</tt>).\n\n\n==Compatibility==\n\nThe proof transaction specification is based on the Bitcoin transaction\nserialization protocol and will thus always be compatible with serializers\nthat can interpret Bitcoin transactions.  The protobuf file format is custom\nto this BIP and has a version byte to enable updates while attempting to remain\nbackwards compatible.\n\n\n==Implementations==\n\nA proof-of-concept implementation of the PSBT extension in the\n[https://github.com/rust-bitcoin/rust-bitcoin rust-bitcoin] project can be\nfound in the <tt>psbt-por</tt> branch here:\nhttps://github.com/stevenroose/rust-bitcoin/tree/psbt-por\n\nA work-in-progress implementation of a tool that produces and verifies proofs\nin the described format can be found here:\nhttps://github.com/stevenroose/reserves\n\nAn implementation of the custom proof PSBTs is part of the [https://bitcoindevkit.org/ BDK], and can be found here: https://crates.io/crates/bdk-reserves\n\n== Footnotes ==\n\n<references />\n\n", "content_length": 10766}
{"bip_number": 126, "filename": "bip-0126.mediawiki", "content": "<pre>\n  BIP: 126\n  Title: Best Practices for Heterogeneous Input Script Transactions\n  Author: Kristov Atlas <kristov@openbitcoinprivacyproject.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0126\n  Status: Draft\n  Type: Informational\n  Created: 2016-02-10\n  License: PD\n</pre>\n\n==Abstract==\n\nWhen a Bitcoin transaction contains inputs that reference previous transaction outputs sent to different Bitcoin addresses, personally identifiable information of the user will leak into the blockchain in an uncontrolled manner. While undesirable, these transactions are frequently unavoidable due to the natural fragmentation of wallet balances over time.\n\nThis document proposes a set of best practice guidelines which minimize the uncontrolled disclosure of personally identifiable information by defining standard forms for transactions containing heterogeneous input scripts.\n\n==Copyright==\n\nThis BIP is in the public domain.\n\n==Definitions==\n\n* '''Heterogenous input script transaction (HIT)''': A transaction containing multiple inputs where the scripts of the previous transaction outputs being consumed are not identical (e.g. a transaction spending outputs which were sent to more than one Bitcoin address)\n* '''Unavoidable heterogeneous input script transaction''': A HIT created as a result of a user\u2019s desire to create a new output with a value larger than the value of his wallet's largest existing unspent output\n* '''Intentional heterogeneous input script transaction''': A HIT created as part of a user protection protocol for reducing uncontrolled disclosure of personally-identifying information (PII)\n\nThroughout this procedure, when input scripts are evaluated for uniqueness, \"input script\" should be interpreted to mean, \"the script of the previous output referenced by an input to a transaction\".\n\n==Motivations==\n\nThe recommendations in this document are designed to accomplish three goals:\n\n# Maximise the effectiveness of user-protecting protocols: Users may find that protection protocols are counterproductive if such transactions have a distinctive fingerprint which renders them ineffective.\n# Minimise the adverse consequences of unavoidable heterogeneous input transactions: If unavoidable HITs are indistinguishable from intentional HITs, a user creating an unavoidable HIT benefits from ambiguity with respect to graph analysis.\n# Limiting the effect on UTXO set growth: To date, non-standardized intentional HITs tend to increase the network's UTXO set with each transaction; this standard attempts to minimize this effect by standardizing unavoidable and intentional HITs to limit UTXO set growth.\n\nIn order to achieve these goals, this specification proposes a set of best practices for heterogeneous input script transaction creation. These practices accommodate all applicable requirements of both intentional and unavoidable HITs while maximising the effectiveness of both in terms of preventing uncontrolled disclosure of PII.\n\nIn order to achieve this, two forms of HIT are proposed: Standard form and alternate form.\n\n==Interaction with Other Procedures==\n\nApplications which wish to comply both with this procedure and BIP69 should apply this procedure prior to applying BIP69.\n\n==Standard form heterogeneous input script transaction==\n\n===Rules===\n\nA HIT is Standard form if it adheres to all of the following rules:\n\n# The number of unique output scripts must be equal to the number of unique input scripts (irrespective of the number of inputs and outputs).\n# All output scripts must be unique.\n# At least one pair of outputs must be of equal value.\n# The largest output in the transaction is a member of a set containing at least two identically-sized outputs.\n\n===Rationale===\n\nThe requirement for equal numbers of unique input/output scripts instead of equal number of inputs/outputs accommodates user-protecting UTXO selection behavior. Wallets may contain spendable outputs with identical scripts due to intentional or accidental address reuse, or due to dusting attacks. In order to minimise the adverse consequences of address reuse, any time a UTXO is included in a transaction as an input, all UTXOs with the same spending script should also be included in the transaction.\n\nThe requirement that all output scripts are unique prevents address reuse. Restricting the number of outputs to the number of unique input scripts prevents this policy from growing the network\u2019s UTXO set. A standard form HIT transaction will always have a number of inputs greater than or equal to the number of outputs.\n\nThe requirement for at least one pair of outputs in an intentional HIT to be of equal value results in optimal behavior, and causes intentional HITs to resemble unavoidable HITs.\n\n==Alternate form heterogeneous input script transactions==\n\nThe formation of a standard form HIT is not possible in the following cases:\n\n# The HIT is unavoidable, and the user\u2019s wallet contains an insufficient number or size of UTXOs to create a standard form HIT.\n# The user wishes to reduce the number of utxos in their wallet, and does not have any sets of utxos with identical scripts.\n\nWhen one of the following cases exist, a compliant implementation may create an alternate form HIT by constructing a transaction as follows:\n\n===Procedure===\n\n# Find the smallest combination of inputs whose value is at least the value of the desired spend.\n## Add these inputs to the transaction.\n## Add a spend output to the transaction.\n## Add a change output to the transaction containing the difference between the current set of inputs and the desired spend.\n# Repeat step 1 to create a second pair of outputs, where one output has the same value as the spend output of the previous step.\n# (optional) Repeat step 2 until the desired number of inputs have been consumed and/or the desired number outputs have been created.\n# Adjust the change outputs as necessary to pay the desired transaction fee.\n\nClients which create intentional HITs must have the capability to form alternate form HITs, and must do so for a non-zero fraction of the transactions they create.\n\n===Rules===\n\nAn HIT formed via the preceding procedure will adhere to the following conditions:\n\n# The number of unique input scripts must exceed the number of output scripts.\n# All output scripts must be unique.\n# At least one pair of outputs must be of equal value.\n## \"Standard outputs\" refers to the set of outputs with equal value\n## \"Standard value\" refers to the value of the standard outputs\n## \"Change outputs\" refers to all outputs which are not standard outputs\n# For a HIT containing n standard outputs, there must exist at least one possible way to organize the inputs and outputs into n sets, where all sets satisfy the following:\n## The set contains one or more inputs, exactly one standard output, and exactly one change output\n## An input or output that appears in one set must not appear in any other set\n## The sum of the inputs in the set minus the value of the change output is equal to the standard value with a tolerance equal to the transaction fee.\n## Change outputs with a value of zero (virtual change outputs) are permitted. The are defined for the purpose of testing whether or not a HIT adheres to this specification but are not present in the version of the transaction which is broadcast to the network.\n\n==Non-compliant heterogeneous input script transactions==\n\nIf a user wishes to create an output that is larger than half the total size of their spendable outputs, or if their inputs are not distributed in a manner in which the alternate form procedure can be completed, then the user can not create a transaction which is compliant with this procedure.\n\n==Reference==\n\n* [[bip-0069.mediawiki|BIP69 - Lexicographical Indexing of Transaction Inputs and Outputs]]\n", "content_length": 7849}
{"bip_number": 125, "filename": "bip-0125.mediawiki", "content": "<pre>\n  BIP: 125\n  Layer: Applications\n  Title: Opt-in Full Replace-by-Fee Signaling\n  Author: David A. Harding <dave@dtrt.org>\n          Peter Todd <pete@petertodd.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0125\n  Status: Final\n  Type: Standards Track\n  Created: 2015-12-04\n  License: PD\n</pre>\n\n==Abstract==\n\nMany nodes today will not replace any transaction in their mempool with\nanother transaction that spends the same inputs, making it difficult for\nspenders to adjust their previously-sent transactions to deal with\nunexpected confirmation delays or to perform other useful replacements.\n\nThe opt-in full Replace-by-Fee (opt-in full-RBF) signaling policy\ndescribed here allows spenders to add a signal to a transaction indicating\nthat they want to be able to replace that transaction in the future.\nIn response to this signal,\n\n* Nodes may allow transactions containing this signal to be replaced in their mempools.\n\n* The recipient or recipients of a transaction containing this signal may choose not to treat it as payment until it has been confirmed, eliminating the risk that the spender will use allowed replacements to defraud them.\n\nNodes and recipients may continue to treat transactions without the\nsignal the same way they treated them before, preserving the existing\nstatus quo.\n\n==Summary==\n\nThis policy specifies two ways a transaction can signal that it is\nreplaceable.\n\n* '''Explicit signaling:''' A transaction is considered to have opted in to allowing replacement of itself if any of its inputs have an nSequence number less than (0xffffffff - 1).\n\n* '''Inherited signaling:''' Transactions that don't explicitly signal replaceability are replaceable under this policy for as long as any one of their ancestors signals replaceability and remains unconfirmed.\n\n===Implementation Details===\n\nThe initial implementation expected in Bitcoin Core 0.12.0 uses the following rules:\n\nOne or more transactions currently in the mempool (original\ntransactions) will be replaced by a new transaction (replacement\ntransaction) that spends one or more of the same inputs if,\n\n# The original transactions signal replaceability explicitly or through inheritance as described in the above Summary section.\n\n# The replacement transaction may only include an unconfirmed input if that input was included in one of the original transactions.  (An unconfirmed input spends an output from a currently-unconfirmed transaction.)\n\n# The replacement transaction pays an absolute fee of at least the sum paid by the original transactions.\n\n# The replacement transaction must also pay for its own bandwidth at or above the rate set by the node's minimum relay fee setting.  For example, if the minimum relay fee is 1 satoshi/byte and the replacement transaction is 500 bytes total, then the replacement must pay a fee at least 500 satoshis higher than the sum of the originals.\n\n# The number of original transactions to be replaced and their descendant transactions which will be evicted from the mempool must not exceed a total of 100 transactions.\n\nThe initial implementation may be seen in\n[https://github.com/bitcoin/bitcoin/pull/6871 Bitcoin Core PR#6871]\nand specifically the master branch commits from\n5891f870d68d90408aa5ce5b597fb574f2d2cbca to\n16a2f93629f75d182871f288f0396afe6cdc8504 (inclusive).\n\n===Receiving wallet policy===\n\nWallets that display unconfirmed transactions to users or that provide\ndata about unconfirmed transactions to automated systems should consider\ndoing one of the following:\n\n# Conveying additional suspicion about opt-in full-RBF transactions to the user or data consumer.\n\n# Ignoring the opt-in transaction until it has been confirmed.\n\nBecause descendant transactions may also be replaceable under this\npolicy through inherited signaling, any method used to process opt-in\nfull-RBF transactions should be inherited by any descendant transactions\nfor as long as any ancestor opt-in full-RBF transactions remain\nunconfirmed.\n\n===Spending wallet policy===\n\nWallets that don't want to signal replaceability should use either a max\nsequence number (0xffffffff) or a sequence number of (0xffffffff-1) when\nthey also want to use locktime; all known wallets currently do this.\nThey should also take care not to spend any unconfirmed transaction that\nsignals replaceability explicitly or through inherited signaling; most wallets also\ncurrently do this by not spending any unconfirmed transactions except\nfor those they created themselves.\n\nWallets that do want to make replacements should use explicit signaling\nand meet the criteria described above in the Implementation Details\nsection. A\n[https://en.bitcoin.it/wiki/Transaction_replacement Bitcoin Wiki page]\nhas been created to help wallet authors track deployed mempool policies\nrelating to transaction replacement.\n\nThe initial implementation makes use of P2P protocol reject messages for\nrejected replacements, allowing P2P clients to determine whether their\nreplacements were initially accepted by their peers. Standard P2P\nlightweight client practice of sending to some peers while listening for\nrelays from other peers should allow clients to determine whether the\nreplacement has propagated.\n\n==Motivation==\n\nSatoshi Nakamoto's original Bitcoin implementation provided the\nnSequence number field in each input to\n[https://github.com/trottier/original-bitcoin/blob/master/src/main.cpp#L434 allow replacement]\nof transactions containing that input within the\nmempool. When receiving replacements, nodes were supposed to replace\ntransactions whose inputs had lower sequence numbers with transactions\nthat had higher sequence numbers.\n\nIn that implementation, replacement transactions did not have to pay\nadditional fees, so there was no direct incentive for miners to\ninclude the replacement and no built-in rate limiting that prevented\noveruse of relay node bandwidth. Nakamoto\n[https://github.com/bitcoin/bitcoin/commit/05454818dc7ed92f577a1a1ef6798049f17a52e7#diff-118fcbaaba162ba17933c7893247df3aR522 removed replacement]\nfrom Bitcoin version 0.3.12, leaving only the\ncomment, \"Disable replacement feature for now\".\n\nReplacing transactions with higher-fee transactions provided a way for\nspenders to align their desires with miners, but by the time a\nReplace-by-Fee (RBF) patch was available to re-enable replacement, some\nreceivers had begun to expect that the first version of a transaction\nthey saw was highly likely to be the version of the transaction to be\nconfirmed, and so some users advocated that replacement should be\ndisallowed.\n\nTo address those concerns, a variation on RBF was created that\nrequired that the replacement transaction pay all of the same outputs as\nthe original transaction in equal or greater amount.  This was called\nRBF First Seen Safe (RBF-FSS), and the original RBF became known as\nfull-RBF.  Although agreeable to recipients who relied on the\nfirst-seen version of a transaction, each use of RBF-FSS required\nadding an extra input to a transaction, resulting in wallets being\nunable to use it if they had no spare inputs, a loss of privacy when\ninputs from different origins get used in the same transaction, and a\nwasteful increase in transaction byte size.\n\nOpt-in full-RBF uses Nakamoto's original semantics (with a slight\ntweak to allow locktime users to opt-out) to signal that replacement\nis possible, providing first-seen users with the ability to ignore\nthose transactions while also allowing for the efficiency benefits\nof full-RBF.\n\nThere are no known problematic interactions between opt-in full-RBF and\nother uses of nSequence. Specifically, opt-in full-RBF is compatible\nwith consensus-enforced locktime as provided in the Bitcoin 0.1\nimplementation, BIP68 (Relative lock-time using consensus-enforced\nsequence numbers), and BIP112 (CHECKSEQUENCEVERIFY).\n\n==Deployment==\n\nNow, and since Bitcoin's first release, 100% of the network hash rate\nmines transactions using opt-in full-RBF semantics (sequence less than\n(0xffffffff - 1)).\n\nOpt-in full-RBF as a default mempool replacement policy among nodes\nand miners is expected to become widespread as they upgrade to Bitcoin\nCore 0.12.0 (release expected Jan/Feb 2016) and similar node software\nsuch as Bitcoin LJR.\n\nActual replacement may be unreliable until two conditions have been satisfied:\n\n# Enough nodes have upgraded to support it, providing a relay path for replacements to go from spending wallets to miners controlling significant amounts of hash rate.\n\n# Enough hash rate has upgraded to support replacement, allowing for reasonable probability that a replacement can be mined.\n\n==Backwards compatibility==\n\nAt the time opt-in RBF support was added/proposed, no known wallet created transactions by default with nSequence set below (0xffffffff - 1), so no known wallet explicitly signaled replaceability by default. Also no known popular wallet spent other users' unconfirmed transactions by default, so no known wallets signaled inherited replaceability.\n\n==See also==\n\n# [https://en.bitcoin.it/wiki/Transaction_replacement Transaction Replaceability on Bitcoin Wiki] targeted at helping wallet authors use RBF\n\n# Tools for creating opt-in full-RBF transactions: https://github.com/petertodd/replace-by-fee-tools#replace-by-fee-tools\n\n# [https://www.reddit.com/r/Bitcoin/comments/3urm8o/optin_rbf_is_misunderstood_ask_questions_about_it/ Reddit: Questions about opt-in RBF] targeted at helping community members understand opt-in full-RBF\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 9565}
{"bip_number": 124, "filename": "bip-0124.mediawiki", "content": "<pre>\n  BIP: 124\n  Layer: Applications\n  Title: Hierarchical Deterministic Script Templates\n  Author: Eric Lombrozo <eric@ciphrex.com>\n          William Swanson <swansontec@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0124\n  Status: Rejected\n  Type: Informational\n  Created: 2015-11-20\n  License: PD\n  Post-History: http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-November/011795.html\n</pre>\n\n==Abstract==\n\nThis BIP defines a script template format that can be used by wallets to deterministically generate scripts with specific authorization policies using the key derivation mechanism defined in BIP32.\n\n==Motivation==\n\nCurrently existing wallets typically issue scripts in only a tiny handful of widely used formats. The most popular formats are pay-to-pubkey-hash and m-of-n pay-to-script-hash (BIP16). However, different wallets tend to use mutually incompatible derivation schemes to generate signing keys and construct scripts from them. Moreover, with the advent of hashlocked and timelocked contracts (BIP65, BIP112), it is necessary for different wallets to be able to cooperatively generate even more sophisticated scripts.\n\nIn addition, there's a lot of ongoing work in the development of multilayered protocols that use the blockchain as a settlement layer (i.e. the Lightning Network). These efforts require sufficiently generalized templates to allow for rapidly evolving script designs.\n\nThis BIP provides a generalized format for constructing a script template that guarantees that different wallets will all produce the same scripts for a given set of derivation paths according to BIP32.\n\n==Specification==\n\n===Keys===\n\nAn individual key is determined by a BIP32 derivation path and an index. For convenience, we introduce the following notation:\n\n'''A'''<sub>k</sub> = (derivation path for A)/k\n\n===Key Groups===\n\nLet '''m'''<sub>i</sub> denote distinct BIP32 derivation paths. We define a key group of n keys as a set of key derivation paths with a free index k:\n\n{'''K'''<sub>k</sub>} = { '''m'''<sub>1</sub>/k, '''m'''<sub>2</sub>/k, '''m'''<sub>3</sub>/k, ..., '''m'''<sub>n</sub>/k }\n\nKey groups are useful for constructing scripts that are symmetric in a set of keys. Scripts are symmetric in a set of keys if the semantics of the script is unaffected by permutations of the keys. Key groups enforce a canonical form and can improve privacy.\n\n===Sorting===\n\nWe define a lexicographic sorting of the keys. (TODO: specification of sorting conventions - compressed pubkeys, encoding, etc...)\n\nDefine {'''K'''<sub>k</sub>}<sub>j</sub> to be the jth element of the sorted keys for derivation index k.\n\n===Script Templates===\n\nWe construct script templates by inserting placeholders for data into a script. To denote a placeholder, we use the following notation:\n\n''Script''('''A''') = opcodes ['''A'''] opcodes\n\nWe extend this notation to an arbitrary number of placeholders:\n\n''Script''('''X1''', '''X2''', ..., '''Xn''') = opcodes ['''X1'''] opcodes ['''X2'''] opcodes ... opcodes ['''Xn'''] opcodes\n\nWe introduce the following convenient notation for sorted key groups:\n\n[{'''K'''<sub>k</sub>}] = [{'''K'''<sub>k</sub>}<sub>1</sub>] [{'''K'''<sub>k</sub>}<sub>2</sub>] ... [{'''K'''<sub>k</sub>}<sub>n</sub>]\n\n===Operations on Keys===\n\nIn some applications, we might want to insert the result of some operation performed on a key rather than the key itself into the script. For example, we might want to insert a Hash160 of key '''A'''<sub>k</sub>. We can use the following notation:\n\n[''Hash160''('''A'''<sub>k</sub>)]\n\n===Encoding===\n\nTODO\n\n==Examples==\n\n===2-of-3 Multisig===\n\nThe script template is defined by:\n\n''Script''('''X''') = 2 ['''X'''] 3 OP_CHECKMULTISIG\n\nLetting '''K'''<sub>k</sub> = { '''m'''<sub>1</sub>/k, '''m'''<sub>2</sub>/k, '''m'''<sub>3</sub>/k }, the ''k''th script for this key group is denoted by ''Script''({'''K'''<sub>k</sub>}).\n\n===1-of-1 or 2-of-3===\n\nThe script template is defined by:\n\n''Script''('''A''', '''B''') = <br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_DUP ['''A'''] OP_CHECKSIG<br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_NOTIF<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 ['''B'''] 3 OP_CHECKMULTISIGVERIFY <br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_NOTIF<br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_ENDIF<br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_TRUE<br>\n\nLet '''M'''<sub>k</sub> = '''m'''/k be a key of a superuser that can authorize all transactions and {'''K'''<sub>k</sub>} be a key group of three users that can only authorize transactions if at least two of them agree.\n\nThe ''k''th script is given by ''Script''('''M'''<sub>k</sub>, {'''K'''<sub>k</sub>}).\n\n===Timelocked Contract===\n\nThe output is payable to Alice immediately if she knows the private key for '''A'''<sub>k</sub>. Bob must know the private key for '''B'''<sub>k</sub> and also wait for a timeout '''t''' before being able to spend the output.\n\nThe script template is defined by:\n\n''Script''('''A''', '''B''', '''T''') = <br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_IF <br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OP_DUP OP_HASH160 [''Hash160''('''A''')] OP_EQUALVERIFY OP_CHECKSIG <br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_ELSE <br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ['''T'''] OP_CHECKLOCKTIMEVERIFY OP_DROP <br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OP_DUP OP_HASH160 [''Hash160''('''B''')] OP_EQUALVERIFY OP_CHECKSIG <br>\n&nbsp; &nbsp; &nbsp; &nbsp; OP_ENDIF\n\nThe ''k''th script with timeout '''t''' is given by ''Script''('''A'''<sub>k</sub>, '''B'''<sub>k</sub>, '''t''').\n\n==References==\n\n* [[bip-0016.mediawiki|BIP16 - Pay to Script Hash]]\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0065.mediawiki|BIP65 - OP_CHECKLOCKTIMEVERIFY]]\n* [[bip-0112.mediawiki|BIP112 - CHECKSEQUENCEVERIFY]]\n* [[https://lightning.network/lightning-network-paper.pdf|Lightning Network Whitepaper]]\n\n==Copyright==\n\nThis document is placed in the public domain.\n\n", "content_length": 6021}
{"bip_number": 123, "filename": "bip-0123.mediawiki", "content": "<pre>\n  BIP: 123\n  Title: BIP Classification\n  Author: Eric Lombrozo <elombrozo@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0123\n  Status: Active\n  Type: Process\n  Created: 2015-08-26\n  License: CC0-1.0\n           GNU-All-Permissive\n</pre>\n\n==Abstract==\n\nThis document describes a classification scheme for BIPs.\n\nBIPs are classified by system layers with lower numbered layers involving more intricate interoperability requirements.\n\nThe specification defines the layers and sets forth specific criteria for deciding to which layer a particular standards BIP belongs.\n\n==Copyright==\n\nThis BIP is dual-licensed under the Creative Commons CC0 1.0 Universal and GNU All-Permissive licenses.\n\n==Motivation==\n\nBitcoin is a system involving a number of different standards. Some standards are absolute requirements for interoperability while others can be considered optional, giving implementers a choice of whether to support them.\n\nIn order to have a BIP process which more closely reflects the interoperability requirements, it is necessary to categorize BIPs accordingly. Lower layers present considerably greater challenges in getting standards accepted and deployed.\n\n==Specification==\n\nStandards BIPs are placed in one of four layers:\n\n# Consensus\n# Peer Services\n# API/RPC\n# Applications\n\nNon-standards BIPs may be placed in these layers, or none at all.\n\n===1. Consensus Layer===\n\nThe consensus layer defines cryptographic commitment structures. Its purpose is ensuring that anyone can locally evaluate whether a particular state and history is valid, providing settlement guarantees, and assuring eventual convergence.\n\nThe consensus layer is not concerned with how messages are propagated on a network.\n\nDisagreements over the consensus layer can result in network partitioning, or forks, where different nodes might end up accepting different incompatible histories. We further subdivide consensus layer changes into soft forks and hard forks.\n\n====Soft Forks====\n\nIn a soft fork, some structures that were valid under the old rules are no longer valid under the new rules. Structures that were invalid under the old rules continue to be invalid under the new rules.\n\n====Hard Forks====\n\nIn a hard fork, structures that were invalid under the old rules become valid under the new rules.\n\n===2. Peer Services Layer===\n\nThe peer services layer specifies how nodes find each other and propagate messages.\n\nOnly a subset of all specified peer services are required for basic node interoperability. Nodes can support further optional extensions.\n\nIt is always possible to add new services without breaking compatibility with existing services, then gradually deprecate older services. In this manner, the entire network can be upgraded without serious risks of service disruption.\n\n===3. API/RPC Layer===\n\nThe API/RPC layer specifies higher level calls accessible to applications. Support for these BIPs is not required for basic network interoperability but might be expected by some client applications.\n\nThere's room at this layer to allow for competing standards without breaking basic network interoperability.\n\n===4. Applications Layer===\n\nThe applications layer specifies high level structures, abstractions, and conventions that allow different applications to support similar features and share data.\n\n==Classification of existing BIPs==\n\n{| class=\"wikitable sortable\" style=\"width: auto; text-align: center; font-size: smaller; table-layout: fixed;\"\n!Number\n!Layer\n!Title\n!Owner\n!Type\n!Status\n|- style=\"background-color: #cfffcf\"\n| [[bip-0001.mediawiki|1]]\n|\n| BIP Purpose and Guidelines\n| Amir Taaki\n| Process\n| Active\n|-\n| [[bip-0002.mediawiki|2]]\n|\n| BIP process, revised\n| Luke Dashjr\n| Process\n| Draft\n|- style=\"background-color: #cfffcf\"\n| [[bip-0009.mediawiki|9]]\n|\n| Version bits with timeout and delay\n| Pieter Wuille, Peter Todd, Greg Maxwell, Rusty Russell\n| Informational\n| Final\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0010.mediawiki|10]]\n| Applications\n| Multi-Sig Transaction Distribution\n| Alan Reiner\n| Informational\n| Withdrawn\n|- style=\"background-color: #cfffcf\"\n| [[bip-0011.mediawiki|11]]\n| Applications\n| M-of-N Standard Transactions\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0012.mediawiki|12]]\n| Consensus (soft fork)\n| OP_EVAL\n| Gavin Andresen\n| Standard\n| Withdrawn\n|- style=\"background-color: #cfffcf\"\n| [[bip-0013.mediawiki|13]]\n| Applications\n| Address Format for pay-to-script-hash\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0014.mediawiki|14]]\n| Peer Services\n| Protocol Version and User Agent\n| Amir Taaki, Patrick Strateman\n| Standard\n| Final\n|-\n| [[bip-0015.mediawiki|15]]\n| Applications\n| Aliases\n| Amir Taaki\n| Standard\n| Deferred\n|- style=\"background-color: #cfffcf\"\n| [[bip-0016.mediawiki|16]]\n| Consensus (soft fork)\n| Pay to Script Hash\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0017.mediawiki|17]]\n| Consensus (soft fork)\n| OP_CHECKHASHVERIFY (CHV)\n| Luke Dashjr\n| Standard\n| Withdrawn\n|- style=\"background-color: #ffffcf\"\n| [[bip-0018.mediawiki|18]]\n| Consensus (soft fork)\n| hashScriptCheck\n| Luke Dashjr\n| Standard\n| Accepted\n|-\n| [[bip-0019.mediawiki|19]]\n| Applications\n| M-of-N Standard Transactions (Low SigOp)\n| Luke Dashjr\n| Standard\n| Draft\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0020.mediawiki|20]]\n| Applications\n| URI Scheme\n| Luke Dashjr\n| Standard\n| Replaced\n|- style=\"background-color: #cfffcf\"\n| [[bip-0021.mediawiki|21]]\n| Applications\n| URI Scheme\n| Nils Schneider, Matt Corallo\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0022.mediawiki|22]]\n| API/RPC\n| getblocktemplate - Fundamentals\n| Luke Dashjr\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0023.mediawiki|23]]\n| API/RPC\n| getblocktemplate - Pooled Mining\n| Luke Dashjr\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0030.mediawiki|30]]\n| Consensus (soft fork)\n| Duplicate transactions\n| Pieter Wuille\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0031.mediawiki|31]]\n| Peer Services\n| Pong message\n| Mike Hearn\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0032.mediawiki|32]]\n| Applications\n| Hierarchical Deterministic Wallets\n| Pieter Wuille\n| Informational\n| Final\n|-\n| [[bip-0033.mediawiki|33]]\n| Peer Services\n| Stratized Nodes\n| Amir Taaki\n| Standard\n| Draft\n|- style=\"background-color: #cfffcf\"\n| [[bip-0034.mediawiki|34]]\n| Consensus (soft fork)\n| Block v2, Height in Coinbase\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0035.mediawiki|35]]\n| Peer Services\n| mempool message\n| Jeff Garzik\n| Standard\n| Final\n|-\n| [[bip-0036.mediawiki|36]]\n| Peer Services\n| Custom Services\n| Stefan Thomas\n| Standard\n| Draft\n|- style=\"background-color: #cfffcf\"\n| [[bip-0037.mediawiki|37]]\n| Peer Services\n| Connection Bloom filtering\n| Mike Hearn, Matt Corallo\n| Standard\n| Final\n|-\n| [[bip-0038.mediawiki|38]]\n| Applications\n| Passphrase-protected private key\n| Mike Caldwell, Aaron Voisine\n| Standard\n| Draft\n|- style=\"background-color: #ffffcf\"\n| [[bip-0039.mediawiki|39]]\n| Applications\n| Mnemonic code for generating deterministic keys\n| Marek Palatinus, Pavol Rusnak, Aaron Voisine, Sean Bowe\n| Standard\n| Accepted\n|-\n| [[bip-0042.mediawiki|42]]\n| Consensus (soft fork)\n| A finite monetary supply for Bitcoin\n| Pieter Wuille\n| Standard\n| Draft\n|-\n| [[bip-0043.mediawiki|43]]\n| Applications\n| Purpose Field for Deterministic Wallets\n| Marek Palatinus, Pavol Rusnak\n| Informational\n| Draft\n|- style=\"background-color: #ffffcf\"\n| [[bip-0044.mediawiki|44]]\n| Applications\n| Multi-Account Hierarchy for Deterministic Wallets\n| Marek Palatinus, Pavol Rusnak\n| Standard\n| Accepted\n|- style=\"background-color: #ffffcf\"\n| [[bip-0045.mediawiki|45]]\n| Applications\n| Structure for Deterministic P2SH Multisignature Wallets\n| Manuel Araoz, Ryan X. Charles, Matias Alejo Garcia\n| Standard\n| Accepted\n|-\n| [[bip-0047.mediawiki|47]]\n| Applications\n| Reusable Payment Codes for Hierarchical Deterministic Wallets\n| Justus Ranvier\n| Informational\n| Draft\n|-\n| [[bip-0049.mediawiki|49]]\n| Applications\n| Derivation scheme for P2WPKH-nested-in-P2SH based accounts\n| Daniel Weigl\n| Informational\n| Draft\n|- style=\"background-color: #cfffcf\"\n| [[bip-0050.mediawiki|50]]\n|\n| March 2013 Chain Fork Post-Mortem\n| Gavin Andresen\n| Informational\n| Final\n|-\n| [[bip-0060.mediawiki|60]]\n| Peer Services\n| Fixed Length \"version\" Message (Relay-Transactions Field)\n| Amir Taaki\n| Standard\n| Draft\n|- style=\"background-color: #cfffcf\"\n| [[bip-0061.mediawiki|61]]\n| Peer Services\n| Reject P2P message\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0062.mediawiki|62]]\n| Consensus (soft fork)\n| Dealing with malleability\n| Pieter Wuille\n| Standard\n| Withdrawn\n|-\n| [[bip-0064.mediawiki|64]]\n| Peer Services\n| getutxo message\n| Mike Hearn\n| Standard\n| Draft\n|- style=\"background-color: #cfffcf\"\n| [[bip-0065.mediawiki|65]]\n| Consensus (soft fork)\n| OP_CHECKLOCKTIMEVERIFY\n| Peter Todd\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0066.mediawiki|66]]\n| Consensus (soft fork)\n| Strict DER signatures\n| Pieter Wuille\n| Standard\n| Final\n|- style=\"background-color: #ffffcf\"\n| [[bip-0067.mediawiki|67]]\n| Applications\n| Deterministic Pay-to-script-hash multi-signature addresses through public key sorting\n| Thomas Kerin, Jean-Pierre Rupp, Ruben de Vries\n| Standard\n| Accepted\n|- style=\"background-color: #cfffcf\"\n| [[bip-0068.mediawiki|68]]\n| Consensus (soft fork)\n| Relative lock-time using consensus-enforced sequence numbers\n| Mark Friedenbach, BtcDrak, Nicolas Dorier, kinoshitajona\n| Standard\n| Final\n|- style=\"background-color: #ffffcf\"\n| [[bip-0069.mediawiki|69]]\n| Applications\n| Lexicographical Indexing of Transaction Inputs and Outputs\n| Kristov Atlas\n| Informational\n| Accepted\n|- style=\"background-color: #cfffcf\"\n| [[bip-0070.mediawiki|70]]\n| Applications\n| Payment Protocol\n| Gavin Andresen, Mike Hearn\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0071.mediawiki|71]]\n| Applications\n| Payment Protocol MIME types\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0072.mediawiki|72]]\n| Applications\n| bitcoin: uri extensions for Payment Protocol\n| Gavin Andresen\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0073.mediawiki|73]]\n| Applications\n| Use \"Accept\" header for response type negotiation with Payment Request URLs\n| Stephen Pair\n| Standard\n| Final\n|-\n| [[bip-0074.mediawiki|74]]\n| Applications\n| Allow zero value OP_RETURN in Payment Protocol\n| Toby Padilla\n| Standard\n| Draft\n|-\n| [[bip-0075.mediawiki|75]]\n| Applications\n| Out of Band Address Exchange using Payment Protocol Encryption\n| Justin Newton, Matt David, Aaron Voisine, James MacWhyte\n| Standard\n| Draft\n|-\n| [[bip-0080.mediawiki|80]]\n|\n| Hierarchy for Non-Colored Voting Pool Deterministic Multisig Wallets\n| Justus Ranvier, Jimmy Song\n| Informational\n| Deferred\n|-\n| [[bip-0081.mediawiki|81]]\n|\n| Hierarchy for Colored Voting Pool Deterministic Multisig Wallets\n| Justus Ranvier, Jimmy Song\n| Informational\n| Deferred\n|-\n| [[bip-0083.mediawiki|83]]\n| Applications\n| Dynamic Hierarchical Deterministic Key Trees\n| Eric Lombrozo\n| Standard\n| Draft\n|-\n| [[bip-0099.mediawiki|99]]\n|\n| Motivation and deployment of consensus rule changes ([soft/hard]forks)\n| Jorge Tim\u00f3n\n| Informational\n| Draft\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0101.mediawiki|101]]\n| Consensus (hard fork)\n| Increase maximum block size\n| Gavin Andresen\n| Standard\n| Withdrawn\n|-\n| [[bip-0102.mediawiki|102]]\n| Consensus (hard fork)\n| Block size increase to 2MB\n| Jeff Garzik\n| Standard\n| Draft\n|-\n| [[bip-0103.mediawiki|103]]\n| Consensus (hard fork)\n| Block size following technological growth\n| Pieter Wuille\n| Standard\n| Draft\n|-\n| [[bip-0105.mediawiki|105]]\n| Consensus (hard fork)\n| Consensus based block size retargeting algorithm\n| BtcDrak\n| Standard\n| Draft\n|-\n| [[bip-0106.mediawiki|106]]\n| Consensus (hard fork)\n| Dynamically Controlled Bitcoin Block Size Max Cap\n| Upal Chakraborty\n| Standard\n| Draft\n|-\n| [[bip-0107.mediawiki|107]]\n| Consensus (hard fork)\n| Dynamic limit on the block size\n| Washington Y. Sanchez\n| Standard\n| Draft\n|-\n| [[bip-0109.mediawiki|109]]\n| Consensus (hard fork)\n| Two million byte size limit with sigop and sighash limits\n| Gavin Andresen\n| Standard\n| Draft\n|- style=\"background-color: #ffffcf\"\n| [[bip-0111.mediawiki|111]]\n| Peer Services\n| NODE_BLOOM service bit\n| Matt Corallo, Peter Todd\n| Standard\n| Accepted\n|- style=\"background-color: #cfffcf\"\n| [[bip-0112.mediawiki|112]]\n| Consensus (soft fork)\n| CHECKSEQUENCEVERIFY\n| BtcDrak, Mark Friedenbach, Eric Lombrozo\n| Standard\n| Final\n|- style=\"background-color: #cfffcf\"\n| [[bip-0113.mediawiki|113]]\n| Consensus (soft fork)\n| Median time-past as endpoint for lock-time calculations\n| Thomas Kerin, Mark Friedenbach\n| Standard\n| Final\n|-\n| [[bip-0114.mediawiki|114]]\n| Consensus (soft fork)\n| Merkelized Abstract Syntax Tree\n| Johnson Lau\n| Standard\n| Draft\n|-\n| [[bip-0120.mediawiki|120]]\n| Applications\n| Proof of Payment\n| Kalle Rosenbaum\n| Standard\n| Draft\n|-\n| [[bip-0121.mediawiki|121]]\n| Applications\n| Proof of Payment URI scheme\n| Kalle Rosenbaum\n| Standard\n| Draft\n|-\n| [[bip-0122.mediawiki|122]]\n| Applications\n| URI scheme for Blockchain references / exploration\n| Marco Pontello\n| Standard\n| Draft\n|-\n| [[bip-0123.mediawiki|123]]\n|\n| BIP Classification\n| Eric Lombrozo\n| Process\n| Draft\n|-\n| [[bip-0124.mediawiki|124]]\n| Applications\n| Hierarchical Deterministic Script Templates\n| Eric Lombrozo, William Swanson\n| Informational\n| Draft\n|- style=\"background-color: #ffffcf\"\n| [[bip-0125.mediawiki|125]]\n| Applications\n| Opt-in Full Replace-by-Fee Signaling\n| David A. Harding, Peter Todd\n| Standard\n| Accepted\n|-\n| [[bip-0126.mediawiki|126]]\n|\n| Best Practices for Heterogeneous Input Script Transactions\n| Kristov Atlas\n| Informational\n| Draft\n|- style=\"background-color: #ffffcf\"\n| [[bip-0130.mediawiki|130]]\n| Peer Services\n| sendheaders message\n| Suhas Daftuar\n| Standard\n| Accepted\n|-\n| [[bip-0131.mediawiki|131]]\n| Consensus (hard fork)\n| \"Coalescing Transaction\" Specification (wildcard inputs)\n| Chris Priest\n| Standard\n| Draft\n|- style=\"background-color: #ffcfcf\"\n| [[bip-0132.mediawiki|132]]\n|\n| Committee-based BIP Acceptance Process\n| Andy Chase\n| Process\n| Withdrawn\n|-\n| [[bip-0133.mediawiki|133]]\n| Peer Services\n| feefilter message\n| Alex Morcos\n| Standard\n| Draft\n|-\n| [[bip-0134.mediawiki|134]]\n| Consensus (hard fork)\n| Flexible Transactions\n| Tom Zander\n| Standard\n| Draft\n|-\n| [[bip-0140.mediawiki|140]]\n| Consensus (soft fork)\n| Normalized TXID\n| Christian Decker\n| Standard\n| Draft\n|-\n| [[bip-0141.mediawiki|141]]\n| Consensus (soft fork)\n| Segregated Witness (Consensus layer)\n| Eric Lombrozo, Johnson Lau, Pieter Wuille\n| Standard\n| Draft\n|-\n| [[bip-0142.mediawiki|142]]\n| Applications\n| Address Format for Segregated Witness\n| Johnson Lau\n| Standard\n| Deferred\n|-\n| [[bip-0143.mediawiki|143]]\n| Consensus (soft fork)\n| Transaction Signature Verification for Version 0 Witness Program\n| Johnson Lau, Pieter Wuille\n| Standard\n| Draft\n|-\n| [[bip-0144.mediawiki|144]]\n| Peer Services\n| Segregated Witness (Peer Services)\n| Eric Lombrozo, Pieter Wuille\n| Standard\n| Draft\n|-\n| [[bip-0145.mediawiki|145]]\n| API/RPC\n| getblocktemplate Updates for Segregated Witness\n| Luke Dashjr\n| Standard\n| Draft\n|-\n| [[bip-0146.mediawiki|146]]\n| Consensus (soft fork)\n| Dealing with signature encoding malleability\n| Johnson Lau, Pieter Wuille\n| Standard\n| Draft\n|-\n| [[bip-0147.mediawiki|147]]\n| Consensus (soft fork)\n| Dealing with dummy stack element malleability\n| Johnson Lau\n| Standard\n| Draft\n|-\n| [[bip-0150.mediawiki|150]]\n| Peer Services\n| Peer Authentication\n| Jonas Schnelli\n| Standard\n| Draft\n|-\n| [[bip-0151.mediawiki|151]]\n| Peer Services\n| Peer-to-Peer Communication Encryption\n| Jonas Schnelli\n| Standard\n| Draft\n|-\n| [[bip-0152.mediawiki|152]]\n| Peer Services\n| Compact Block Relay\n| Matt Corallo\n| Standard\n| Draft\n|}\n", "content_length": 16144}
{"bip_number": 122, "filename": "bip-0122.mediawiki", "content": "<pre>\n  BIP: 122\n  Layer: Applications\n  Title: URI scheme for Blockchain references / exploration\n  Author: Marco Pontello <marcopon@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0122\n  Status: Draft\n  Type: Standards Track\n  Created: 2015-08-29\n  License: PD\n  Post-History: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010712.html\n</pre>\n\n==Abstract==\n\nThis BIP proposes a URI scheme for looking up blocks, transactions and addresses on a Blockchain explorer, or in general to make proper Blockchain references.\n\n==Motivation==\n\nThe purpose of this URI scheme is to enable users to handle all the requests for details about blocks, transactions, etc. with their preferred tool (being that a web service or a local application).\nCurrently a Bitcoin client usually points to an arbitrary blockchain explorer when the user looks for the details of a transaction or allows the user to choose from a set of alternatives.\nResorting to copy + paste into a browser is often required.\nThe same happens with posts and messages that reference some particular txs or blocks, if they provide links at all.\n\n==Specification==\n\nThe URI follow this form:\n\n <nowiki>blockchain:[//<chain>]/<tx|block|address>/<hash></nowiki>\n\nWhere:\n\n{| class=\"wikitable\"\n! style=\"text-align: center;\" | Element\n! colspan=\"2\" style=\"text-align: center;\" | Description\n! Required?\n|-\n| chain\n| colspan=\"2\" | '''chain ID''' (see below) of the desired chain, leading 0s included. If omitted (which would be the usual case), Bitcoin main net is assumed.\n| optional\n|-\n| rowspan=\"3\" | type\n| tx\n| for transactions.\n| rowspan=\"3\" | required\n|-\n| block\n| for blocks (supports both hash or height).\n|-\n| address\n| for addresses.\n|-\n| hash\n| colspan=\"2\" | the relevant hash to refer to (leading zeros included), or block height.\n| required\n|}\n\n====ABNF grammar====\n\n<pre>\nblockchainuri = \"blockchain:\" [\"//\" chain] \"/\" object\nobject = (\"tx\" \"/\" hash) / (\"block\" \"/\" (hash / blockheight)) /\n         (\"address\" \"/\" address)\nchain = hash\nhash = 64HEXDIG\nblockheight = 1*15DIGIT ; 15 is somehow arbitrary, i.e. a \"small\" int.\naddress = base58 ; https://en.wikipedia.org/wiki/Base58\n</pre>\n\n----\n===Definition of chain ID===\n\nThe '''chain ID''' of a chain is the block hash of the corresponding genesis block. For forked chains, it's the block hash of the first block after fork.\n\nSo, for example:\n<pre>\nBitcoin main   : 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\nBitcoin test   : 000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\nBitcoin regtest: 0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\n</pre>\n\nAn example of forked chain (Feathercoin, that forked Litecoin):\n\n<img src=bip-0122/chainid.png></img>\n\n<pre>\nLitecoin   : 12a765e31ffd4059bada1e25190f6e98c99d9714d334efa41a195a7e7e04bfe2\nFeathercoin: fdbe99b90c90bae7505796461471d89ae8388ab953997aa06a355bbda8d915cb\n</pre>\n\n\n==Examples==\n\nA transaction on Bitcoin main net:\n blockchain:/tx/b462ae6eb8bdae2e060239a2a3ea5d9c3e0f9ef34d9717beb2dcf0ed42cee7da\n\nA block on Bitcoin main net:\n blockchain:/block/00000000000000000119af5bcae2926df54ae262e9071a94a99c913cc217cc72\nor\n blockchain:/block/372338\n\nAn address on Bitcoin main net:\n blockchain:/address/16EW6Rv9P9AxFDBrZV816dD4sj1EAYUX3f\n\nA transaction on Bitcoin test net:\n blockchain://000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943/tx/3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a\n\n==Rationale==\n\nFrom the point of view of a wallet (or other Blockchain related tool) developers which need to reference Blockchain data, using this scheme mean that he can simply make it a `blockchain:` link without having to worry about any specific Blockchain explorer or provide a means for the user to select one.\n\nBlockchain explorers in turn will simply offer to handle the `blockchain:` URI schema, the first time the user visit their website, or launch/install the application, or even set themselves if there isn't already one.\n\nUsers can link directly to their preferred block explorer (avoiding copy + paste which can be awkward on mobile devices).\n\n== Sample implementation ==\n\n[https://github.com/MarcoPon/blockchain-exploration Demo Blockchain: URI handler on GitHub]\n\n==Acknowledgements==\n\nThanks to Btc Drak for suggesting support for different networks and Jorge Timon for the suggestion that we could identify each network by its genesis block hash.\nThanks to Richard Moore, Matt Whitlock, Andreas Schildbach for help with the structure and hierarchy of the URI scheme.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 4674}
{"bip_number": 121, "filename": "bip-0121.mediawiki", "content": "<pre>\n  BIP: 121\n  Layer: Applications\n  Title: Proof of Payment URI scheme\n  Author: Kalle Rosenbaum <kalle@rosenbaum.se>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0121\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2015-07-27\n</pre>\n\n== Abstract ==\n\nThis is a proposal for a URI scheme to be used in the Proof of Payment\nprocess.\n\n== Motivation ==\n\nTo make a Proof of Payment, the party that wants the proof needs to\ntransfer a Proof of Payment request to the wallet software of the\nother party. To facilitate that transfer, a new URI scheme\nrepresenting the PoP request is proposed. This URI can then be encoded\nin QR images or be sent over NFC in order to transfer it to the wallet.\n\n== Specification ==\n\nThe specification is the same as BIP0021, with the following\ndifferences:\n\n* The URI scheme is <tt>btcpop</tt> instead of <tt>bitcoin</tt>\n* The path component, i.e. the address part, is always empty.\n* A mandatory <tt>p</tt> parameter whose value contains the destination for the PoP. This could for example be a <tt>https:</tt> URL or a <tt>mailto:</tt> URI.\n* A mandatory <tt>n</tt> parameter representing the nonce, base58 encoded.\n* An optional <tt>txid</tt> parameter containing the Base58 encoded hash of the transaction to prove.\n\nJust as in BIP0021, elements of the query component may contain\ncharacters outside the valid range. These must first be encoded\naccording to UTF-8, and then each octet of the corresponding UTF-8\nsequence must be percent-encoded as described in RFC 3986.\n\nAll parameters except <tt>p</tt> and <tt>n</tt> are hints to the\nwallet on which transaction to create a PoP for.\n\nThe extensibility of BIP0021 applies to this scheme as well. For\nexample, a <tt>date</tt> parameter or a <tt>toaddr</tt> parameter\nmight be useful. <tt>req-*</tt> parameters are also allowed and obey\nthe same rules as in BIP0021, clients not supporting a <tt>req-*</tt>\nparameter must consider the URI invalid.\n\n=== Keep URIs short ===\n\nImplementations should keep the URIs as short as possible. This is\nbecause it makes QR decoding more stable. A camera with a scratched\nlens or low resolution may run into problems scanning huge QR\ncodes. This is why the <tt>txid</tt> parameter is encoded in Base58\ninstead of the classic hex encoded string. We get away with 44\ncharacters instead of 64. Also, the <tt>nonce</tt> parameter is Base58\nencoded for the same reason.\n\n== Interpretation ==\n\n=== Transaction hints ===\n\nThe wallet processing the URI must use the hints in the PoP request to\nfilter its transaction set. The <tt>label</tt>, <tt>amount</tt> and\n<tt>message</tt> parameters must, if present in the URI, exactly match\nthe data associated with the original payment according to the\nfollowing table:\n\n{|\n| <tt>btcpop:</tt> URI parameter || <tt>bitcoin:</tt> URI parameter || BIP70 PaymentDetails data\n|-\n| <tt>label</tt>                 || <tt>label</tt>                  || <tt>memo</tt>\n|-\n| <tt>amount</tt>                || <tt>amount</tt>                 || <tt>sum of outputs.amount</tt>\n|-\n| <tt>message</tt>               || <tt>message</tt>                || <tt>-</tt>\n|}\n\nThe <tt>txid</tt> parameter value must match the transaction hash of\nthe payment.\n\nAfter filtering, the resulting transaction set is displayed to the\nuser who selects one of them to prove. An implementation could also\nautomatically select a transaction in the filtered set, but\nthere must still be a way for the user to select freely among the\nmatching transactions. If the filtered set is empty, no transaction\nfits the hints and a message about that is presented to the user. If\nthe filtered set contains exactly one transaction, which is\npreferable, that transaction can be automatically selected.\n\nAs a fallback, there must also be a way for the user to select any\ntransaction from the wallet regardless of the transaction hints. This\ncan be useful if the metadata of the wallet is lost, possibly due to a\nrestore from backup.\n\n=== PoP destination <tt>p</tt> ===\n\nThe <tt>p</tt> parameter value is the destination where to send the\nPoP to. This destination is typically a <tt>https:</tt> URL or a\n<tt>http:</tt> URL, but it could be any type of URI, for example\n<tt>mailto:</tt>. To keep <tt>btcpop:</tt> URIs short, users should\nnot make their <tt>p</tt> parameter unnecessarily long.\n\n==== <tt>http:</tt> and <tt>https:</tt> URLs ====\n\nWallet implementations must support the <tt>http:</tt> and\n<tt>https:</tt> schemes in which case <tt>POST</tt> method must be\nused. The PoP is sent as a binary serialized transaction. The content\ntype of the POST request must be set to\n<tt>application/bitcoin-pop</tt>\n\n== Examples ==\n\nSend PoP for a transaction with label \"video 42923\" to\n<nowiki>https://www.example.com/pop/352</nowiki>, using nonce\n<tt>0x73 0xd5 0x1a 0xbb 0xd8 0x9c</tt>:\n<pre>\n btcpop:?p=https://www.example.com/pop/352&n=zgWTm8yH&label=video%2042923\n</pre>\nSend PoP through mail using\n<nowiki>mailto:pop@example.com?subject=pop444</nowiki>, amount\nis 13370000 satoshis, nonce is <tt>0x6f 0xe 0xfb 0x68 0x92 0xf9</tt>.\nNote that the <tt>?</tt> before <tt>subject</tt> is OK according to RFC3986,\nsince the query part starts from the first <tt>?</tt>:\n<pre>\n btcpop:?p=mailto:pop@example.com?subject%3Dpop444&n=xJdKmEbr&amount=0.1337\n</pre>\nSend PoP for transaction with id\n<tt>cca7507897abc89628f450e8b1e0c6fca4ec3f7b34cccf55f3f531c659ff4d79</tt>\nto pizza place at <nowiki>http://pizza.example.com/pop/laszlo111</nowiki> using nonce <tt>0xfc 0xcc 0x2c 0x35 0xf0 0xb8</tt>\n<pre>\n btcpop:?p=http://pizza.example.com/pop/laszlo111&n=3AtNpVrPh&txid=Emt9MPvt1joznqHy5eEHkNtcuQuYWXzYJBQZN6BJm6NL\n</pre>\n== Reference implementation ==\n\n[https://github.com/kallerosenbaum/poppoc PoP Demo server on GitHub]\n\n[https://github.com/kallerosenbaum/wallet PoP-enabled Mycelium fork on GitHub]\n\n== References ==\n\n[https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki BIP0021]: URI Scheme\n\n[https://github.com/bitcoin/bips/blob/master/bip-0120.mediawiki BIP0120]: Proof of Payment\n\n[https://www.ietf.org/rfc/rfc3986.txt RFC3986]: Uniform Resource Identifier (URI): Generic Syntax\n", "content_length": 6162}
{"bip_number": 120, "filename": "bip-0120.mediawiki", "content": "<pre>\n  BIP: 120\n  Layer: Applications\n  Title: Proof of Payment\n  Author: Kalle Rosenbaum <kalle@rosenbaum.se>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0120\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2015-07-28\n</pre>\n\n== Abstract ==\n\nThis BIP describes a system called Proof of Payment, PoP. It is used to prove that a wallet has the credentials that were used to sign a previously generated transaction. Or simply put, it lets you prove that you have made a payment.\n\n== Motivation ==\n\nThere are several scenarios in which it would be useful to prove that you have paid for something. For example:\n\n* A pre-paid hotel room where your PoP functions as a key to the door.\n* An online video rental service where you pay for a video and watch it on any device.\n* An ad-sign where you pay in advance for e.g. 2 weeks exclusivity. During this period you can upload new content to the sign whenever you like using PoP.\n* Log in to a pay site using a PoP.\n* A parking lot you pay for monthly and the car authenticates itself using PoP.\n* A lottery where all participants pay to the same address, and the winner is selected among the transactions to that address. You exchange the prize for a PoP for the winning transaction.\n\nWith Proof of Payment, these use cases can be achieved without any personal information (user name, password, e-mail address, etc) being involved.\n\n== Rationale ==\n\nDesirable properties:\n\n# A PoP should be generated on demand.\n# It should only be usable once to avoid issues due to theft.\n# It should be able to create a PoP for any payment, regardless of script type (P2SH, P2PKH, etc.).\n# It should prove that you have enough credentials to unlock all the inputs of the proven transaction.\n# It should be easy to implement by wallets and servers to ease adoption.\n\nCurrent methods of proving a payment:\n\n* In BIP0070, the PaymentRequest together with the transactions fulfilling the request makes some sort of proof. However, it does not meet 1, 2 or 4 and it obviously only meets 3 if the payment is made through BIP0070. Also, there's no standard way to request/provide the proof. If standardized it would probably meet 5.\n* Signing messages, chosen by the server, with the private keys used to sign the transaction. This could meet 1 and 2 but probably not 3. This is not standardized either. 4 Could be met if designed so.\n\nIf an input script type is P2SH, any satisfying script should do, just as if it was a payment. For M-of-N multisig scripts, that would mean that any set of M keys should be sufficient, not necessarily the same set of M keys that signed the transaction. This is important because strictly demanding the same set of M keys would defeat the purpose of a multisig address.\n\n== Specification ==\n\n=== Data structure ===\n\nA proof of payment for a transaction T, here called PoP(T), is used to prove that one has ownership of the credentials needed to unlock all the inputs of T. It has the exact same structure as a bitcoin transaction with the same inputs as T and in the same order as in T, but with each sequence number set to 0. There is exactly one output, here called the pop output, with value 0. The pop output must have the following format:\n\n OP_RETURN <version> <txid> <nonce>\n\n{|\n! Field        !! Size [B] !! Description\n|-\n| &lt;version> || 2        || Version, little endian, currently 0x01 0x00\n|-\n| &lt;txid>    || 32       || The transaction to prove\n|-\n| &lt;nonce>   || 6        || Random data\n|}\n\nThe lock_time of the PoP must be set to 499999999 to prevent the PoP from being included in a block, should it appear on the bitcoin p2p network. This is also the reason for setting the sequence numbers to 0, since sequence number of ffffffff would make lock_time ineffective. This specification demands that all input sequence numbers are 0, not just one of them, which would be sufficient to make lock_time effective. This is for simplicity reasons.\n\nAn illustration of the PoP data structure and its original payment is shown below.\n\n<pre>\n  T\n +------------------------------------------------+\n |inputs                | outputs                 |\n |       Value,Sequence | Value,Script            |\n +------------------------------------------------+\n |input0 1,ffffffff     | 0,pay to A              |\n |input1 3,ffffffff     | 2,OP_RETURN <some data> |\n |input2 4,ffffffff     | 1,pay to B              |\n |                      | 4,pay to C              |\n +------------------------------------------------+\n\n  PoP(T)\n +-------------------------------------------------------------+\n | inputs               | outputs                              |\n |       Value,Sequence | Value,Script                         |\n +-------------------------------------------------------------+\n |input0 1,00000000     | 0,OP_RETURN <version> <txid> <nonce> |\n |input1 3,00000000     |                                      |\n |input2 4,00000000     |                                      |\n +-------------------------------------------------------------+\n | lock_time=499999999                                         |\n +-------------------------------------------------------------+\n</pre>\n\nThe PoP is signed using the same signing process that is used for bitcoin transactions.\n\nThe purpose of the nonce is to make it harder to use a stolen PoP; Once the PoP has reached the server, that PoP is useless since the server will generate a new nonce for every PoP request.\n\n=== Process ===\n\n# A proof of payment request is sent from the server to the wallet. The PoP request contains:\n## a random nonce\n## a destination where to send the PoP, for example a https URL\n## data hinting the wallet which transaction to create a proof for. For example:\n##* txid, if known by the server\n##* PaymentRequest.PaymentDetails.merchant_data (in case of a BIP0070 payment)\n##* amount, label, message or other information from a BIP0021 URI\n# The wallet identifies a transaction T, if possible. Otherwise it asks the user to select among the ones that match the hints in 1.iii.\n# The wallet creates an unsigned PoP (UPoP) for T, and asks the user to sign it.\n# The user confirms\n# The UPoP(T) is signed by the wallet, creating PoP(T).\n# The PoP is sent to the destination in 1.ii.\n# The server receiving the PoP validates it and responds with \u201cvalid\u201d or \u201cinvalid\u201d.\n# The wallet displays the response in some way to the user.\n\n'''Remarks:'''\n\n* The method of transferring the PoP request at step 1 is not specified here. Instead that is specified in separate specifications, see BIP0121.\n* The nonce must be randomly generated by the server for every new PoP request.\n\n=== Validating a PoP ===\n\nThe server needs to validate the PoP and reply with \"valid\" or \"invalid\". That process is outlined below. If any step fails, the validation is aborted and \"invalid\" is returned:\n\n# Check the format of the PoP. It must pass normal transaction checks, except that the inputs may already be spent.\n# Check that lock_time is 499999999.\n# Check that there is exactly one output. This output must have value 0 and conform to the OP_RETURN output format outlined above.\n# Check that the nonce is the same as the one requested.\n# Check that the inputs of the PoP are exactly the same as in transaction T, except that the sequence numbers must all be 0. The ordering of the inputs must also be the same as in T.\n# Run the scripts of all the inputs. All scripts must return true.\n# Check that the txid in the PoP output is the transaction you actually want proof for. If you don\u2019t know exactly what transaction you want proof for, check that the transaction actually pays for the product/service you deliver.\n# Return \"valid\".\n\n== Security considerations ==\n\n* Someone can intercept the PoP-request and change any parameter in it. These can be mitigated by using secure connections. Examples of tampered parameters:\n** Pop destination - Stealing your PoP.\n** label - Trick you to sign an unintended pop or set a label that your wallet doesn't have any record for, resulting in a broken service. Always check the PoP before signing.\n** nonce - Your pop will not validate on server.\n* Someone can steal a PoP, for example by tampering with the PoP request, and try to use the service hoping to get a matching nonce. Probability per try: 1/(2^48). The server should have a mechanism for detecting a brute force attack of this kind, or at least slow down the process by delaying the PoP request by some 100 ms or so.\n* Even if a wallet has no funds it might still be valuable as a generator for PoPs. This makes it important to keep the security of the wallet after it has been emptied.\n* Transaction malleability may cause the server to have a different transaction id for a payment than the client's wallet. In that case the wallet will not be able to prove the transaction to the server. Wallets should not rely on the transaction id of the outgoing transaction. Instead it should listen for the transaction on the network and put that in its list of transactions.\n\n== Reference implementation ==\n\n[https://github.com/kallerosenbaum/poppoc PoP Demo server on GitHub]\n\n[https://github.com/kallerosenbaum/wallet PoP-enabled Mycelium fork on GitHub]\n\n== References ==\n\n[https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki BIP0021]: URI Scheme\n\n[https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki BIP0070]: Payment Protocol\n\n[https://github.com/bitcoin/bips/blob/master/bip-0121.mediawiki BIP0121]: Proof of Payment URI scheme\n", "content_length": 9540}
{"bip_number": 119, "filename": "bip-0119.mediawiki", "content": "<pre>\n  BIP: 119\n  Layer: Consensus (soft fork)\n  Title: CHECKTEMPLATEVERIFY\n  Author: Jeremy Rubin <j@rubin.io>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119\n  Status: Draft\n  Type: Standards Track\n  Created: 2020-01-06\n  License: BSD-3-Clause\n</pre>\n\n==Abstract==\n\nThis BIP proposes a new opcode, OP_CHECKTEMPLATEVERIFY, to be activated\nas a change to the semantics of OP_NOP4.\n\n==Summary==\n\nOP_CHECKTEMPLATEVERIFY uses opcode OP_NOP4 (0xb3) as a soft fork upgrade.\n\nOP_CHECKTEMPLATEVERIFY does the following:\n\n* There is at least one element on the stack, fail otherwise\n* The element on the stack is 32 bytes long, NOP otherwise\n* The DefaultCheckTemplateVerifyHash of the transaction at the current input index is equal to the element on the stack, fail otherwise\n\nThe DefaultCheckTemplateVerifyHash commits to the serialized version, locktime, scriptSigs hash (if any\nnon-null scriptSigs), number of inputs, sequences hash, number of outputs, outputs hash, and\ncurrently executing input index.\n\nThe recommended standardness rules additionally:\n\n* Reject non-32 byte as SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS.\n\n==Motivation==\n\nThis BIP introduces a transaction template, a simple spending restriction that\npattern matches a transaction against a hashed transaction specification.\nOP_CHECKTEMPLATEVERIFY reduces many of the trust, interactivity, and storage\nrequirements inherent with the use of pre-signing in applications.\nFor more details on applications, please see the references.\n\n\n==Detailed Specification==\n\nThe below code is the main logic for verifying CHECKTEMPLATEVERIFY, described\nin pythonic pseudocode. The canonical specification for the semantics of\nOP_CHECKTEMPLATEVERIFY as implemented in C++ in the context of Bitcoin Core can\nbe seen in the reference implementation.\n\nThe execution of the opcode is as follows:\n<source lang=\"python\">\ndef execute_bip_119(self):\n    # Before soft-fork activation / failed activation\n    # continue to treat as NOP4\n    if not self.flags.script_verify_default_check_template_verify_hash:\n        # Potentially set for node-local policy to discourage premature use\n        if self.flags.script_verify_discourage_upgradable_nops:\n            return self.errors_with(errors.script_err_discourage_upgradable_nops)\n        return self.return_as_nop()\n\n    # CTV always requires at least one stack argument\n    if len(self.stack) < 1:\n        return self.errors_with(errors.script_err_invalid_stack_operation)\n\n    # CTV only verifies the hash against a 32 byte argument\n    if len(self.stack[-1]) == 32:\n        # Ensure the precomputed data required for anti-DoS is available,\n        # or cache it on first use\n        if self.context.precomputed_ctv_data == None:\n            self.context.precomputed_ctv_data = self.context.tx.get_default_check_template_precomputed_data()\n\n        # If the hashes do not match, return error\n        if stack[-1] != self.context.tx.get_default_check_template_hash(self.context.nIn, self.context.precomputed_ctv_data):\n            return self.errors_with(errors.script_err_template_mismatch)\n\n        return self.return_as_nop()\n\n    # future upgrade can add semantics for this opcode with different length args\n    # so discourage use when applicable\n    if self.flags.script_verify_discourage_upgradable_nops:\n        return self.errors_with(errors.script_err_discourage_upgradable_nops)\n    else:\n        return self.return_as_nop()\n</source>\n\nThe computation of this hash can be implemented as specified below (where self\nis the transaction type). Care must be taken that in any validation context,\nthe precomputed data must be initialized to prevent Denial-of-Service attacks.\nAny implementation *must* cache these parts of the hash computation to avoid\nquadratic hashing DoS. All variable length computations must be precomputed\nincluding hashes of the scriptsigs, sequences, and outputs. See the section\n\"Denial of Service and Validation Costs\" below. This is not a performance\noptimization.\n\n<source lang=\"python\">\n\ndef ser_compact_size(l):\n    r = b\"\"\n    if l < 253:\n        # Serialize as unsigned char\n        r = struct.pack(\"B\", l)\n    elif l < 0x10000:\n        # Serialize as unsigned char 253 followed by unsigned 2 byte integer (little endian)\n        r = struct.pack(\"<BH\", 253, l)\n    elif l < 0x100000000:\n        # Serialize as unsigned char 254 followed by unsigned 4 byte integer (little endian)\n        r = struct.pack(\"<BI\", 254, l)\n    else:\n        # Serialize as unsigned char 255 followed by unsigned 8 byte integer (little endian)\n        r = struct.pack(\"<BQ\", 255, l)\n    return r\n\ndef ser_string(s):\n    return ser_compact_size(len(s)) + s\n\nclass CTxOut:\n    def serialize(self):\n        r = b\"\"\n        # serialize as signed 8 byte integer (little endian)\n        r += struct.pack(\"<q\", self.nValue)\n        r += ser_string(self.scriptPubKey)\n        return r\n\ndef get_default_check_template_precomputed_data(self):\n    result = {}\n    # If there are no scriptSigs we do not need to precompute a hash\n    if any(inp.scriptSig for inp in self.vin):\n        result[\"scriptSigs\"] = sha256(b\"\".join(ser_string(inp.scriptSig) for inp in self.vin))\n    # The same value is also pre-computed for and defined in BIP-341 and can be shared.\n    # each nSequence is packed as 4 byte unsigned integer (little endian)\n    result[\"sequences\"] = sha256(b\"\".join(struct.pack(\"<I\", inp.nSequence) for inp in self.vin))\n    # The same value is also pre-computed for and defined in BIP-341 and can be shared\n    # See class CTxOut above for details.\n    result[\"outputs\"] = sha256(b\"\".join(out.serialize() for out in self.vout))\n    return result\n\n# parameter precomputed must be passed in for DoS resistance\ndef get_default_check_template_hash(self, nIn, precomputed = None):\n    if precomputed == None:\n        precomputed = self.get_default_check_template_precomputed_data()\n    r = b\"\"\n    # Serialize as 4 byte signed integer (little endian)\n    r += struct.pack(\"<i\", self.nVersion)\n    # Serialize as 4 byte unsigned integer (little endian)\n    r += struct.pack(\"<I\", self.nLockTime)\n    # we do not include the hash in the case where there is no\n    # scriptSigs\n    if \"scriptSigs\" in precomputed:\n        r += precomputed[\"scriptSigs\"]\n    # Serialize as 4 byte unsigned integer (little endian)\n    r += struct.pack(\"<I\", len(self.vin))\n    r += precomputed[\"sequences\"]\n    # Serialize as 4 byte unsigned integer (little endian)\n    r += struct.pack(\"<I\", len(self.vout))\n    r += precomputed[\"outputs\"]\n    # Serialize as 4 byte unsigned integer (little endian)\n    r += struct.pack(\"<I\", nIn)\n    return sha256(r)\n</source>\n\n\nA PayToBareDefaultCheckTemplateVerifyHash output matches the following template:\n\n<source lang=\"python\">\n# Extra-fast test for pay-to-basic-standard-template CScripts:\ndef is_pay_to_bare_default_check_template_verify_hash(self):\n    return len(self) == 34 and self[0] == 0x20 and self[-1] == OP_CHECKTEMPLATEVERIFY\n</source>\n\n\n==Deployment==\n\nActivation logic is elided from this BIP and is more appropriately discussed elsewhere.\n\nUntil BIP-119 reaches ACTIVE state and the\nSCRIPT_VERIFY_DEFAULT_CHECK_TEMPLATE_VERIFY_HASH flag is enforced, node implementations should (are recommended to)\nexecute a NOP4 as SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS (to deny entry to the mempool) for policy and must evaluate as\na NOP for consensus (during block validation).\n\nIn order to facilitate using CHECKTEMPLATEVERIFY, the common case of a\nPayToBareDefaultCheckTemplateVerifyHash\nwith no scriptSig data may (is recommended to) be made standard to permit relaying. Future bare scripts may be\nstandardized later as policy changes at the preference of the implementer.\n\n\n==Reference Implementation==\n\nA reference implementation and tests are available here in the PR to Bitcoin Core https://github.com/bitcoin/bitcoin/pull/21702.\n\nIt is not ideal to link to a PR, as it may be rebased and changed, but it is the best place to find\nthe current implementation and review comments of others.\nA recent commit hash in that PR including tests and vectors can be found here https://github.com/jeremyrubin/bitcoin/commit/3109df5616796282786706738994a5b97b8a5a38.\nOnce the PR is merged, this BIP should be updated to point to the specific code released.\n\nTest vectors are available in [/bip-0119/vectors the bip-0119/vectors\ndirectory] for checking compatibility with the reference implementation and BIP.\n\n==Rationale==\n\nOP_CHECKTEMPLATEVERIFY's design is a small code change and simple to analyze. It is\ncompatible with future upgrades if new template types are required\nfor more complex but demonstrably safe use cases.\n\nBelow we'll discuss the rules one-by-one:\n\n====The DefaultCheckTemplateVerifyHash of the transaction at the current input index matches the top of the stack====\n\nThe set of data committed to is a superset of data which can impact the TXID of the transaction,\nother than the inputs. This ensures that for a given known input, the TXIDs can also be known ahead\nof time. Otherwise, CHECKTEMPLATEVERIFY would not be usable for Batched Channel Creation constructions\nas the redemption TXID could be malleated and pre-signed transactions invalidated, unless the channels\nare built using an LN-Symmetry-like protocol. Note that there may be other types of pre-signed contracts that\nmay or may not be able to use LN-Symmetry-like constructs, therefore making TXIDs predictable makes CTV more\ncomposable with arbitrary sub-protocols.\n\n=====Committing to the version and locktime=====\n\nWere these values not committed, it would be possible to delay the spending of\nan output arbitrarily as well as possible to change the TXID.\n\nCommitting these values, rather than restricting them to specific values, is\nmore flexible as it permits users of CHECKTEMPLATEVERIFY to set the version and\nlocktime as they please.\n\n=====Committing to the ScriptSigs Hash=====\n\nThe scriptsig in a segwit transaction must be exactly empty, unless it is a P2SH\nsegwit transaction in which case it must be only the exact redeemscript. P2SH is incompatible\n(unless the P2SH hash is broken) with CHECKTEMPLATEVERIFY because the template hash must commit\nto the ScriptSig, which must contain the redeemscript, which is a hash cycle.\n\nTo prevent malleability when not using a segwit input, we also commit to the\nscriptsig. This makes it possible to use a 2 input CHECKTEMPLATEVERIFY with a legacy pre-signed\nspend, as long as the exact scriptsig for the legacy output is committed. This is more robust than\nsimply disallowing any scriptSig to be set with CHECKTEMPLATEVERIFY.\n\nIf no scriptSigs are set in the transaction, there is no purpose in hashing the data or including it\nin the DefaultCheckTemplateVerifyHash, so we elide it. It is expected to be common that no scriptSigs will be\nset as segwit mandates that the scriptSig must be empty (to avoid malleability).\n\nWe commit to the hash rather than the values themselves as this is already\nprecomputed for each transaction to optimize SIGHASH_ALL signatures.\n\nCommitting to the hash additionally makes it simpler to construct DefaultCheckTemplateVerifyHash safely and unambiguously from\nscript.\n\n=====Committing to the number of inputs=====\n\nIf we allow more than one input to be spent in the transaction then it would be\npossible for two outputs to request payment to the same set of outputs,\nresulting in half the intended payments being discarded, the \"half-spend\" problem.\n\nFurthermore, the restriction on which inputs can be co-spent is critical for\npayments-channel constructs where a stable TXID is a requirement (updates would\nneed to be signed on all combinations of inputs).\n\nHowever, there are legitimate use cases for allowing multiple inputs. For\nexample:\n\nScript paths:\n\n    Path A: <+24 hours> OP_CHECKSEQUENCEVERIFY OP_CHECKTEMPLATEVERIFY <Pay Alice 1 Bitcoin (1 input) nLockTime for +24 hours>\n    Path B: OP_CHECKTEMPLATEVERIFY <Pay Bob 2 Bitcoin (2 inputs)>\n\nIn this case, there are 24 hours for the output to, with the addition of a\nsecond output, pay Bob 2 BTC. If 24 hours lapses, then Alice may redeem her 1\nBTC from the contract. Both input UTXOs may have the exact same Path B, or only one.\n\nThe issue with these constructs is that there are N! orders that the inputs can\nbe ordered in and it's not generally possible to restrict the ordering.\n\nCHECKTEMPLATEVERIFY allows for users to guarantee the exact number of inputs being\nspent. In general, using CHECKTEMPLATEVERIFY with more than one input is difficult\nand exposes subtle issues, so multiple inputs should not be used except in\nspecific applications.\n\nIn principle, committing to the Sequences Hash (below) implicitly commits to the number of inputs,\nmaking this field strictly redundant. However, separately committing to this number makes it easier\nto construct DefaultCheckTemplateVerifyHash from script.\n\nWe treat the number of inputs as a `uint32_t` because Bitcoin's consensus decoding logic limits vectors\nto `MAX_SIZE=33554432` and that is larger than `uint16_t` and smaller than `uint32_t`. 32 bits is also\nfriendly for manipulation using Bitcoin's current math opcodes, should `OP_CAT` be added. Note that\nthe max inputs in a block is further restricted by the block size to around 25,000, which would fit\ninto a `uint16_t`, but that is an unnecessary abstraction leak.\n\n=====Committing to the Sequences Hash=====\n\nIf we don't commit to the sequences, then the TXID can be malleated. This also allows us to enforce\na relative sequence lock without an OP_CSV. It is insufficient to just pair CHECKTEMPLATEVERIFY\nwith OP_CSV because OP_CSV enforces a minimum nSequence value, not a literal value.\n\nWe commit to the hash rather than the values themselves as this is already\nprecomputed for each transaction to optimize SIGHASH_ALL signatures.\n\nCommitting to the hash additionally makes it simpler to construct DefaultCheckTemplateVerifyHash safely and unambiguously from\nscript.\n\n=====Committing to the Number of Outputs=====\n\nIn principle, committing to the Outputs Hash (below) implicitly commits to the number of outputs,\nmaking this field strictly redundant. However, separately committing to this number makes it easier\nto construct DefaultCheckTemplateVerifyHash from script.\n\nWe treat the number of outputs as a `uint32_t` because a `COutpoint` index is a `uint32_t`.\nFurther, Bitcoin's consensus decoding logic limits vectors to `MAX_SIZE=33554432` and that is\nlarger than `uint16_t` and smaller than `uint32_t`. 32 bits is also friendly for manipulation using\nBitcoin's current math opcodes, should `OP_CAT` be added.\n\n=====Committing to the outputs hash=====\n\nThis ensures that spending the UTXO is guaranteed to create the exact outputs\nrequested.\n\nWe commit to the hash rather than the values themselves as this is already\nprecomputed for each transaction to optimize SIGHASH_ALL signatures.\n\nCommitting to the hash additionally makes it simpler to construct DefaultCheckTemplateVerifyHash safely and unambiguously from\nscript.\n\n=====Committing to the current input's index=====\n\nCommitting to the currently executing input's index is not strictly needed for anti-malleability,\nhowever it does restrict the input orderings eliminating a source of malleability for protocol\ndesigners.\n\nHowever, committing to the index eliminates key-reuse vulnerability to the half-spend problem.\nAs CHECKTEMPLATEVERIFY scripts commit to being spent at particular index, reused instances of these\nscripts cannot be spent at the same index, which implies that they cannot be spent in the same transaction.\nThis makes it safer to design wallet vault contracts without half-spend vulnerabilities.\n\nCommitting to the current index doesn't prevent one from expressing a CHECKTEMPLATEVERIFY which can\nbe spent at multiple indices. In current script, the CHECKTEMPLATEVERIFY operation can be wrapped\nin an OP_IF for each index (or Tapscript branches in the future). If OP_CAT or OP_SHA256STREAM are\nadded to Bitcoin, the index may simply be passed in by the witness before hashing.\n\n=====Committing to Values by Hash=====\n\nCommitting to values by hash makes it easier and more efficient to construct a\nDefaultCheckTemplateVerifyHash\nfrom script. Fields which are not intended to be set may be committed to by hash without incurring\nO(n) overhead to re-hash.\n\nFurthermore, if OP_SHA256STREAM is added in the future, it may be possible to write a script which\nallows adding a single output to a list of outputs without incurring O(n) overhead by committing to\na hash midstate in the script.\n\n=====Using SHA256=====\n\nSHA256 is a 32 byte hash which meets Bitcoin's security standards and is\navailable already inside of Bitcoin Script for programmatic creation of template\nprograms.\n\nRIPEMD160, a 20 byte hash, might also be a viable hash in some contexts and has some benefits. For fee efficiency,\nRIPEMD160 saves 12 bytes. However, RIPEMD160 was not chosen for BIP-119 because it introduces\nrisks around the verification of programs created by third parties to be subject to a\n[birthday-attack https://bitcoin.stackexchange.com/questions/54841/birthday-attack-on-p2sh] on\ntransaction preimages.\n\n=====Using Non-Tagged Hashes=====\n\nThe Taproot/Schnorr BIPs use Tagged Hashes\n(`SHA256(SHA256(tag)||SHA256(tag)||msg)`) to prevent taproot leaves, branches,\ntweaks, and signatures from overlapping in a way that might introduce a security\n[vulnerability https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016091.html].\n\nOP_CHECKTEMPLATEVERIFY is not subject to this sort of vulnerability as the\nhashes are effectively tagged externally, that is, by OP_CHECKTEMPLATEVERIFY\nitself and therefore cannot be confused for another hash.\n\nIt would be a conservative design decision to make it a tagged hash even if\nthere was no obvious benefit and no cost. However, in the future, if OP_CAT were\nto be introduced to Bitcoin, it would make programs which dynamically build\nOP_CHECKTEMPLATEVERIFY hashes less space-efficient. Therefore, bare untagged hashes\nare used in BIP-119.\n\n=====The Ordering of Fields=====\n\nStrictly speaking, the ordering of fields is insignificant. However, with a\ncarefully selected order, the efficiency of future scripts (e.g., those using a\nOP_CAT or OP_SHA256STREAM) may be improved (as described in the Future Upgrades\nsection).\n\nIn particular, the order is selected in order of least likely to change to most.\n\n#nVersion\n#nLockTime\n#scriptSig hash (maybe!)\n#input count\n#sequences hash\n#output count\n#outputs hash\n#input index\n\nSeveral fields are infrequently modified. nVersion should change infrequently. nLockTime should\ngenerally be fixed to 0 (in the case of a payment tree, only the *first* lock time is needed to\nprevent fee-sniping the root). scriptSig hash should generally not be set at all.\n\nSince there are many possible sequences hash for a given input count, the input count comes before\nthe sequences hash.\n\nSince there are many possible outputs hashes for a given out count, the output count comes before\nthe outputs hash.\n\nSince we're generally using a single input to many output design, we're more likely to modify the\noutputs hash than the inputs hash.\n\nWe usually have just a single input on a CHECKTEMPLATEVERIFY script, which would suggest that it\ndoes not make sense for input index to be the last field. However, given the desirability of being\nable to express a \"don't care\" index easily (e.g., for decentralized kickstarter-type transactions),\nthis value is placed last.\n\n===Design Tradeoffs and Risks===\n\nCHECKTEMPLATEVERIFY's design limits script authors to relatively precise template matching. The\nstructure of CHECKTEMPLATEVERIFY template is such that most of the transaction details must be known\nexactly at the time of construction, with the exception of the inputs.\n\nCHECKTEMPLATEVERIFY can be nested -- that is, a transaction that is created by spending an output with a\n`<H> OP_CHECKTEMPLATEVERIFY` restriction may create outputs with `<X> OP_CHECKTEMPLATEVERIFY` restrictions.\nThis expansion is inherently finite, as re-creating an output with a script containing the hash `<H>` from a transaction\nspending an output with the hash `<H>` creates a hash cycle. This can also be thought of as each template hash `<H>` having\na \"path height\" of the longest chain of possible unbroken `OP_CHECKTEMPLATEVERIFY` verifying transactions, and the path height is\nstrictly decreasing.\n\nFurthermore, templates are restricted to be spendable as a known number of inputs only and\nat a specific input index, preventing unintentional introduction of the 'half spend' problem.\n\nTemplates, as restricted as they are, bear some risks.\n\n====Denial of Service and Validation Costs====\n\nCTV is designed to be able to be validated very cheaply without introducing DoS, either by checking a\nprecomputed hash or computing a hash of fixed length arguments (some of which may be cached from more\nexpensive computations).\n\nIn particular, CTV requires that clients cache the computation of a hash over all the scriptSigs, sequences,\nand outputs. Before CTV, the hash of the scriptSigs was not required. CTV also requires that the presence of\nany non-empty scriptSig be hashed, but this can be handled as a part of the scriptSigs hash.\n\nAs such, evaluating a CTV hash during consensus is always O(1) computation when the caches are available.\nThese caches usually must be available due to similar issues in CHECKSIG behavior. Computing the caches\nis O(T) (the size of the transaction).\n\nAn example of a script that could experience a DoS issue without caching is:\n\n    <H> CTV CTV CTV... CTV\n\nSuch a script would cause the interpreter to compute hashes (supposing N CTV's) over O(N*T) data.\nIf the scriptSigs non-nullity is not cached, then the O(T) transaction could be scanned over O(N)\ntimes as well (although cheaper than hashing, still a DoS). As such, CTV caches hashes and computations\nover all variable length fields in a transaction.\n\nFor CTV, the Denial-of-Service exposure and validation costs are relatively clear. Implementers must be careful\nto correctly code CTV to make use of existing caches and cache the (new for CTV) computations over scriptSigs.\nOther more flexible proposals may have a more difficult time solving DoS issues as more complex template computations may\nbe less cacheable and expose issues around quadratic hashing, it is a tradeoff CTV makes in favor of cheap and secure\nvalidation at the expense of flexibility. For example, if CTV allowed the hashing only select outputs by a bitmask,\ncaching of all combinations of outputs would not be possible and would cause a quadratic hashing DoS vulnerability.\n\n====Permanently Unspendable Outputs====\n\nThe preimage argument passed to CHECKTEMPLATEVERIFY may be unknown or otherwise unsatisfiable.\nHowever, requiring knowledge that an address is spendable from is incompatible with sender's ability\nto spend to any address (especially, OP_RETURN). If a sender needs to know the template can be spent\nfrom before sending, they may request a signature of a provably non-transaction challenge string\nfrom the leaves of the CHECKTEMPLATEVERIFY tree.\n\n====Forwarding Addresses====\n\nKey-reuse with CHECKTEMPLATEVERIFY may be used as a form of \"forwarding address contract\".\nA forwarding address is an address which can automatically execute in a predefined way.\nFor example, an exchange's hot wallet might use an address which can automatically be moved to a cold\nstorage address after a relative timeout.\n\nThe issue is that reusing addresses in this way can lead to loss of funds.\nSuppose one creates a template address which forwards 1 BTC to cold storage.\nCreating an output to this address with less than 1 BTC will be frozen permanently.\nPaying more than 1 BTC will lead to the funds in excess of 1BTC to be paid as a large miner fee.\nCHECKTEMPLATEVERIFY could commit to the exact amount of bitcoin provided by the inputs/amount of fee\npaid, but as this is a user error and not a malleability issue this is not done.\nFuture soft-forks could introduce opcodes which allow conditionalizing which template or script\nbranches may be used based on inspecting the amount of funds available in a transaction\n\nAs a general best practice, it is incumbent on Bitcoin users to not reuse any address unless you are\ncertain that the address is acceptable for the payment attempted. This limitation and risk is not\nunique to CHECKTEMPLATEVERIFY. For example, atomic swap scripts are single use once the hash is\nrevealed. Future Taproot scripts may contain many logical branches that would be unsafe for being\nspent to multiple times (e.g., a Hash Time Lock branch should be instantiated with unique hashes\neach time it is used). Keys which have signed a SIGHASH_ANYPREVOUT transaction can similarly become\nreuse-unsafe.\n\nBecause CHECKTEMPLATEVERIFY commits to the input index currently being spent, reused-keys are\nguaranteed to execute in separate transactions which reduces the risk of \"half-spend\" type issues.\n\n====NOP-Default and Recommended Standardness Rules====\n\nIf the argument length is not exactly 32, CHECKTEMPLATEVERIFY treats it as a NOP during\nconsensus validation. Implementations are recommended to fail in such circumstances during non-consensus\nrelaying and mempool validation. In particular, making an invalid-length argument a failure aids future\nsoft-forks upgrades to be able to rely on the tighter standard restrictions to safely loosen\nthe restrictions for standardness while tightening them for consensus with the upgrade's rules.\n\nThe standardness rules may lead an unscrupulous script developer to accidentally rely on the\nstricter standardness rules to be enforced during consensus. Should that developer submit a\ntransaction directly to the network relying on standardness rejection, a standardness-invalid but\nconsensus-valid transaction may be caused, leading to a potential loss of funds.\n\n====Feature Redundancy====\n\nThere are other opcodes that, if implemented, could make the CHECKTEMPLATEVERIFY's functionality redundant.\nHowever, given CHECKTEMPLATEVERIFY's simple semantics and low on chain cost it's likely that it\nwould continue to be favored even if redundant with other capabilities. Or, in the case of opcodes\nsuch as OP_VAULT, OP_CHECKCONTRACTVERIFY, and OP_TXHASH, OP_CHECKTEMPLATEVERIFY is a part of their\ncurrently proposed implementations.\n\nMore powerful opcodes, like OP_COV proposed in MES16 or OP_TXHASH, would also bring some benefits in terms of\nimproving the ability to pay fees endogenously rather than relying on exogenous child-pays-for-parent or\nother fee paying mechanisms such as transaction sponsors. However, these features come at substantially\nincreased complexity and room for behaviors unintended by the application developer.\n\nAlternatively, SIGHASH_ANYPREVOUTANYSCRIPT can be used to implement something similar to templates,\nvia a scriptPubKey like:\n\n    <sig of desired TX with PK and fixed nonce R || SIGHASH_ANYPREVOUTANYSCRIPT <PK with public SK> OP_CHECKSIG\n\nSIGHASH_ANYPREVOUTANYSCRIPT capabilities\nabove are similar to what CHECKTEMPLATEVERIFY offers. The key functional\ndifference between SIGHASH_ANYPREVOUTANYSCRIPT and OP_CHECKTEMPLATEVERIFY is\nthat OP_CHECKTEMPLATEVERIFY restricts the number of additional inputs and\nprecludes dynamically determined change outputs while\nSIGHASH_ANYPREVOUTANYSCRIPT can be combined with SIGHASH_SINGLE or\nSIGHASH_ANYONECANPAY. For the additional inputs, OP_CHECKTEMPLATEVERIFY also\ncommits to the scriptsig and sequence, which allows for specifying specific P2SH\nscripts (or segwit v0 P2SH) which have some use cases. Furthermore,\nCHECKTEMPLATEVERIFY has benefits in terms of script size (depending on choice of\nPK, SIGHASH_ANYPREVOUTANYSCRIPT may use about 2x-3x the bytes) and verification\nspeed, as OP_CHECKTEMPLATEVERIFY requires only hash computation rather than\nsignature operations. This can be significant when constructing large payment\ntrees or programmatic compilations. CHECKTEMPLATEVERIFY also has a feature-wise\nbenefit in that it provides a robust pathway for future template upgrades, as proposed\nin OP_TXHASH.\n\nOP_CHECKSIGFROMSTACKVERIFY along with OP_CAT may also be used to emulate\nCHECKTEMPLATEVERIFY. However such constructions are more complicated to implement in application\nscripts than CHECKTEMPLATEVERIFY, and encumber additional verification overhead absent\nfrom CHECKTEMPLATEVERIFY.\n\nGiven the simplicity of this approach to implement and analyze, and the benefits realizable by user\napplications, CHECKTEMPLATEVERIFY's single template based approach is proposed in lieu of a generalized\nsystem for specifying transactions in script.\n\n\n====Future Upgrades====\n\nThis section describes updates to OP_CHECKTEMPLATEVERIFY that are possible in\nthe future as well as synergies with other possible upgrades.\n\n=====CHECKTEMPLATEVERIFY Versions=====\n\nOP_CHECKTEMPLATEVERIFY currently only verifies properties of 32 byte arguments.\nIn the future, meaning could be ascribed to other length arguments. For\nexample, a 33-byte argument could just the last byte as a control program. In\nthat case, DefaultCheckTemplateVerifyHash could be computed when the flag byte\nis set to CTVHASH_ALL. Other programs could be added similar to a SIGHASH_TYPE.\nFor example, CTVHASH_GROUP could read data from the Taproot Annex for\ncompatibility with SIGHASH_GROUP type proposals and allow dynamic malleability\nof which indexes get hashed for bundling.\n\nThe work done for the OP_TXHASH pre-BIP details one approach to upgrading the\nOP_CHECKTEMPLATEVERIFY semantics.\n\n=====OP_CHECKSIGFROMSTACKVERIFY=====\n\nWere both OP_CHECKTEMPLATEVERIFY and OP_CHECKSIGFROMSTACKVERIFY to be added to\nBitcoin, it would be possible to implement a variant of LN-Symmetry's floating\ntransactions using the following script:\n\n    witness(S+n): <sig> <H(tx with nLockTime S+n paying to program(S+n))>\n    program(S): OP_CHECKTEMPLATEVERIFY <musig_key(pk_update_a, pk_update_b)> OP_CHECKSIGFROMSTACKVERIFY <S+1> OP_CHECKLOCKTIMEVERIFY\n\nCompared to SIGHASH_ANYPREVOUTANYSCRIPT, because OP_CHECKTEMPLATEVERIFY does not\nallow something similar to SIGHASH_ANYONECANPAY or SIGHASH_SINGLE, protocol\nimplementers might sign transactions with Ephemeral Anchors or additional Inputs\nfor paying fees or an alternative such as transaction sponsors might be considered.\n\nNote that this use of OP_CHECKSIGFROMSTACKVERIFY and OP_CHECKTEMPLATEVERIFY, without the `<S+1> OP_CHECKLOCKTIMEVERIFY` ratchet,\nenables a form of self-reproducing automata address with a one-time-trusted-setup, albeit with limited utility given the specifics\nof OP_CHECKTEMPLATEVERIFY's DefaultCheckTemplateVerifyHash. In comparison, SIGHASH_ANYPREVOUT enables a more\npowerful self-reproducing automata (colloquially called SpookChains), that uses a variety of combinations of SIGHASH flags\nto be able to restrict state transitions based on amount.\n\n=====OP_AMOUNTVERIFY=====\n\nAn opcode which verifies the exact amount that is being spent in the\ntransaction, the amount paid as fees, or made available in a given output could\nbe used to make safer OP_CHECKTEMPLATEVERIFY addresses. For instance, if the\nOP_CHECKTEMPLATEVERIFY program P expects exactly S satoshis, sending S-1\nsatoshis would result in a frozen UTXO and sending S+n satoshis would result in\nn satoshis being paid to fee. A range check could restrict the program to only\napply for expected values and default to a keypath otherwise, e.g.:\n\n    IF OP_AMOUNTVERIFY <N> OP_GREATER <PK> CHECKSIG ELSE <H> OP_CHECKTEMPLATEVERIFY\n\n=====OP_CAT/OP_SHA256STREAM=====\n\nOP_CHECKTEMPLATEVERIFY is (as described in the Ordering of Fields section)\nefficient for specifying transactions dynamically from script should Bitcoin get enhanced\ndata manipulation opcodes.\n\nAs an example, the following code checks an input index argument and\nconcatenates it to the template and checks the template matches the transaction.\n\n    OP_SIZE 4 OP_EQUALVERIFY\n    <nVersion || nLockTime || input count || sequences hash || output count || outputs hash>\n    OP_SWAP OP_CAT OP_SHA256 OP_CHECKTEMPLATEVERIFY\n\nNote that were OP_CAT to be introduced with a size limit, e.g. 520 bytes, one would be limited\nto use it to introspect transactions with 12 inputs and 12 outputs (depending on script type).\n\n== Backwards Compatibility ==\n\nOP_CHECKTEMPLATEVERIFY replaces a OP_NOP4 with stricter verification semantics. Therefore, scripts\nwhich previously were valid will cease to be valid with this change. Stricter verification semantics\nfor an OP_NOP are a soft fork, so existing software will be fully functional without upgrade except\nfor mining and block validation. Similar soft forks for OP_CHECKSEQUENCEVERIFY and OP_CHECKLOCKTIMEVERIFY\n(see BIP-0065 and BIP-0112) have similarly changed OP_NOP semantics without introducing compatibility issues.\n\nIn contrast to previous forks, OP_CHECKTEMPLATEVERIFY's reference implementation does not allow transactions with spending\nscripts using it to be accepted to the mempool or relayed under standard policy until the new rule is active. Other implementations\nare recommended to follow this rule as well, but not required.\n\nOlder wallet software will be able to accept spends from OP_CHECKTEMPLATEVERIFY outputs, but will\nrequire an upgrade in order to treat PayToBareDefaultCheckTemplateVerifyHash chains with a confirmed ancestor as\nbeing \"trusted\" (i.e., eligible for spending before the transaction is confirmed).\n\nBackports of OP_CHECKTEMPLATEVERIFY can be trivially prepared (see the reference implementation)\nfor older node versions that can be patched but not upgraded to a newer major release.\n\n== Script Compatibility ==\n\nOP_CHECKTEMPLATEVERIFY is made available in all script versions. Application developers should\nnote that P2SH and P2SH Segwit, which reveal the program in the scriptSig, may not use `<H> CTV`\nlike fragments in their program as the scriptSig commitment creates a hash cycle.\n\n== References ==\n\n*[https://utxos.org utxos.org informational site]\n*[https://covenants.info covenant informational site]\n*[https://learn.sapio-lang.org Sapio Bitcoin smart contract language]\n*[https://rubin.io/advent21 27 Blog Posts on building smart contracts with Sapio and CTV, including examples described here.]\n*[https://www.youtube.com/watch?v=YxsjdIl0034&t=2451 Scaling Bitcoin Presentation]\n*[https://bitcoinops.org/en/newsletters/2019/05/29/ Optech Newsletter Covering OP_CHECKOUTPUTSHASHVERIFY]\n*[https://rubin.io/public/pdfs/multi-txn-contracts.pdf Structuring Multi Transaction Contracts in Bitcoin]\n*[https://github.com/jeremyrubin/lazuli Lazuli Notes (ECDSA based N-of-N Signatures for Certified Post-Dated UTXOs)]\n*[https://web.archive.org/web/20220203124718/https://fc16.ifca.ai/bitcoin/papers/MES16.pdf Bitcoin Covenants]\n*[https://bitcointalk.org/index.php?topic=278122.0 CoinCovenants using SCIP signatures, an amusingly bad idea.]\n*[https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf Enhancing Bitcoin Transactions with Covenants]\n*[https://github.com/jamesob/simple-ctv-vault Simple CTV Vaults]\n*[https://github.com/kanzure/python-vaults Python Vaults]\n*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019808.html CTV Dramatically Improves DLCs]\n*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020225.html Calculus of Covenants]\n*[https://rubin.io/bitcoin/2021/12/10/advent-13/ Payment Pools with CTV]\n*[https://rubin.io/bitcoin/2021/12/11/advent-14/ Channels with CTV]\n*[https://rubin.io/bitcoin/2021/12/09/advent-12/ Congestion Control with CTV]\n*[https://rubin.io/bitcoin/2021/12/07/advent-10/ Building Vaults on Bitcoin]\n*[https://arkdev.info/ (Ark Labs) Ark Documentation]\n*[https://docs.second.tech/protocol/intro/ (Second) Ark Documentation]\n*[https://rubin.io/bitcoin/2022/09/14/drivechain-apo/ SpookChains]\n*[https://github.com/bitcoin/bips/pull/1500 OP_TXHASH]\n\n\n===Note on Similar Alternatives===\n\nAn earlier version of CHECKTEMPLATEVERIFY, CHECKOUTPUTSHASHVERIFY, is withdrawn\nin favor of CHECKTEMPLATEVERIFY. CHECKOUTPUTSHASHVERIFY did not commit to the\nversion or lock time and was thus insecure.\n\nCHECKTEMPLATEVERIFY could also be implemented as an extension to Taproot, and was\nproposed this way earlier. However, particular applications may want to use OP_CHECKTEMPLATEVERIFY\nin bare legacy scripts to maximize efficiency.\n\nCHECKTEMPLATEVERIFY has also been previously referred to as OP_SECURETHEBAG, which is mentioned here\nto aid in searching and referencing discussion on this BIP.\n\n==Copyright==\n\nThis document is licensed under the 3-clause BSD license.\n", "content_length": 36540}
{"bip_number": 118, "filename": "bip-0118.mediawiki", "content": "<pre>\n  BIP: 118\n  Layer: Consensus (soft fork)\n  Title: SIGHASH_ANYPREVOUT for Taproot Scripts\n  Author: Christian Decker <decker.christian@gmail.com>\n          Anthony Towns <aj@erisian.com.au>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0118\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-02-28\n  License: BSD-3-Clause\n  Requires: 340, 341, 342\n</pre>\n\n== Introduction ==\n\n=== Abstract ===\n\nThis BIP describes a new type of public key for tapscript ([[bip-0342.mediawiki|BIP 342]]) transactions.\nIt allows signatures for these public keys to not commit to the exact UTXO being spent.\nThis enables dynamic binding of transactions to different UTXOs, provided they have compatible scripts.\n\n=== Copyright ===\n\nThis document is licensed under the 3-clause BSD license.\n\n=== Motivation ===\n\nOff-chain protocols make use of transactions that are not yet broadcast to the Bitcoin network in order to renegotiate the final state that should be settled on-chain.\nIn a number of cases it is desirable to respond to a given transaction being seen on-chain with a predetermined reaction in the form of another transaction.\nOften the same reaction is desired for a variety of different transactions that may be seen on-chain, but because the input signatures in the response transaction commit to the exact transaction that is being reacted to, this means a new signature must be created for every possible transaction one wishes to be able to react to.\n\nThis proposal introduces a new public key type<ref>'''Why a new public key type?'''\nNew public key types for tapscript can be introduced in a soft fork by specifying new rules for ''unknown public key types'' as specified in [[bip-0342.mediawiki|BIP 342]], as this only requires adding restrictions to the pre-existing signature opcodes.\nPossible alternative approaches would be to define new script opcodes, to use a different taproot leaf version, or to use a different set of SegWit outputs than those specified by [[bip-0341.mediawiki|BIP 341]]; however all of these approaches are more complicated, and are better reserved for other upgrades where the additional flexibility is actually needed.\nIn this case, we specify a new transaction digest, but retain the same elliptic curve and signature algorithm (ie, secp256k1 and [[bip-0340.mediawiki|BIP 340]]).</ref>\nthat modifies the behavior of the transaction digest algorithm used in the signature creation and verification, by excluding the commitment to the previous output (and, optionally, the witness script<ref>'''Why (and why not) commit to the witness script?'''\nThe [https://blockstream.com/eltoo.pdf eltoo] paper provides an example of why committing to the witness script is not always appropriate.\nIt uses script and the transaction <code>nLockTime</code> to make signatures asymmetric, so that a transaction with an earlier signature can be spent by a transaction with a later signature, but a transaction with a later signature cannot be spent by a transaction with an earlier signature.\nAs a result, a single signature for a third, even later transaction must be able to spend both the prior transactions, even though they have a different tapscript.\nOn the other hand, these cases also provide a good reason to have the option to commit to the script: because each transaction has a new script, committing to the script allows you to produce a signature that applies to precisely one of these transactions.\nIn the eltoo case, this allows you to have a signature for an update transaction that can be applied to any prior update, and a signature for a settlement transaction that applies only to the corresponding update transaction, while using the same key for both, which in turn allows for a more compact script.\n</ref> and value <ref>'''Why (and why not) commit to the input value?'''\nCommitting to the input value may provide additional safety that a signature can't be maliciously reused to claim funds that the signer does not intend to spend, so by default it seems sensible to commit to it. However, doing so prevents being able to use a single signature to consolidate a group of UTXOs with the same spending condition into a single UTXO which may be useful for some protocols, such as the proposal for [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html layered commitments with eltoo].</ref>).\nRemoving this commitment allows dynamic rebinding of a signed transaction to another previous output that requires authorisation by the same key.\n\nThe dynamic rebinding is opt-in due to using a separate public key type, and the breadth of transactions the signature can be rebound to can be further restricted by using different keys, committing to the script being spent in the signature, using different amounts between UTXOs, using different nSequence values in the spending transaction, or using the codeseparator opcode to commit to the position in the script.\n\n== Specification ==\n\nThis BIP modifies the behaviour of the [[bip-0342.mediawiki|BIP 342]] signature opcodes<ref>'''What about key path spends?'''\nThis proposal only supports ANYPREVOUT signatures via script path spends, and does not support ANYPREVOUT signatures for key path spends.\nThis is for two reasons: first, not supporting key path spends allows this proposal to be independent of the core changes included in [[bip-0341.mediawiki|BIP 341]] and [[bip-0342.mediawiki|BIP 342]]; second, it allows addresses to opt-in or opt-out of ANYPREVOUT support while remaining indistinguishable prior to being spent.\n</ref> (<code>CHECKSIG</code>, <code>CHECKSIGVERIFY</code>, and <code>CHECKSIGADD</code>) for public keys that have a length of 33 bytes and a first byte of <code>0x01</code> or the public key which is precisely the single byte vector <code>0x01</code><ref>'''Use of 0x01 public key type'''\nBecause <code>OP_0</code> leaves an empty vector on the stack it would not satisfy [[bip-0342.mediawiki|BIP 342]]'s rules for unknown public key types. As such, it is convenient to use one of <code>OP_1..OP_16</code> or <code>OP_1NEGATE</code> as a way to reference the taproot internal key.\nTo keep things as simple as possible, we use the first of these, and add the same byte as a prefix to allow ANYPREVOUT signatures for explicitly specified keys.\n</ref>.\nThese keys are termed '''BIP 118 public keys'''.\n\n==== Rules for signature opcodes ====\n\nThe [[bip-0342.mediawiki|BIP 342]] rules for signature opcodes are modified by removing keys with the first byte <code>0x01</code> and length of either 1-byte or 33-bytes from the list of unknown public key types, and adding the following rule prior to the handling of unknown public key types:\n\n* If the public key is the single byte <code>0x01</code>, or if the public key is 33 bytes and the first byte of the public key is <code>0x01</code>, it is considered to be a BIP 118 public key:\n** If the signature is not the empty vector, the signature is validated according to the [[bip-0341.mediawiki|BIP 341]] signing validation rules with the public key, allowable <code>hash_type</code> values, and transaction digest modified as defined below.\n\n==== Public key ====\n\nTo convert the 1-byte BIP 118 public key for use with [[bip-0340.mediawiki|BIP 340]], use the 32-byte taproot internal key, <code>p</code>, as defined in [[bip-0341.mediawiki|BIP 341]].\n\nTo convert a 33-byte BIP 118 public key for use with [[bip-0340.mediawiki|BIP 340]], remove the <code>0x01</code> prefix and use the remaining 32 bytes.\n\n==== Signature message ====\n\nWe define the functions ''Msg118(hash_type)'' and ''Ext118(hash_type)'' which compute the message being signed as a byte array.\n\nThe parameter ''hash_type'' is an 8-bit unsigned value, reusing values defined in [[bip-0341.mediawiki|BIP 341]], with the addition that the values <code>0x41</code>, <code>0x42</code>, <code>0x43</code>, <code>0xc1</code>, <code>0xc2</code>, and <code>0xc3</code> are also valid for BIP 118 public keys.\n\nWe define the following constants using bits 6 and 7 of <code>hash_type</code>:\n\n* <code>SIGHASH_ANYPREVOUT = 0x40</code>\n* <code>SIGHASH_ANYPREVOUTANYSCRIPT = 0xc0</code>\n\nThe following restrictions apply and cause validation failure if violated:\n* Using any undefined ''hash_type'' (not ''0x00'', ''0x01'', ''0x02'',  ''0x03'', ''0x41'', ''0x42'', ''0x43'', ''0x81'', ''0x82'', ''0x83'', ''0xc1'', ''0xc2'', or ''0xc3'').\n* Using <code>SIGHASH_SINGLE</code> without a \"corresponding output\" (an output with the same index as the input being verified).\n\nIf these restrictions are not violated, ''Msg118(hash_type)'' evaluates as follows.\n\nIf ''hash_type & 0x40 == 0'', then ''Msg118(hash_type) = SigMsg(hash_type, 1)'', where ''SigMsg'' is as defined in [[bip-0341.mediawiki|BIP 341]].\n\nIf ''hash_type & 0x40 != 0'', then ''Msg118(hash_type)'' is the concatenation of the following data, in order (with byte size of each item listed in parentheses). Numerical values in 2, 4, or 8-byte items are encoded in little-endian.\n\n* Control:\n** ''hash_type'' (1).\n* Transaction data:\n** ''nVersion'' (4): the ''nVersion'' of the transaction.\n** ''nLockTime'' (4): the ''nLockTime'' of the transaction.\n** If ''hash_type & 3'' does not equal <code>SIGHASH_NONE</code> or <code>SIGHASH_SINGLE</code>:\n*** ''sha_outputs'' (32): the SHA256 of the serialization of all outputs in <code>CTxOut</code> format.\n* Data about this input:\n** ''spend_type'' (1): equal to 2 if no annex is present, or 3 otherwise (the original witness stack has two or more witness elements, and the first byte of the last element is ''0x50'')\n** If ''hash_type & 0xc0'' is <code>SIGHASH_ANYPREVOUT</code>:\n*** ''amount'' (8): value of the previous output spent by this input.\n*** ''scriptPubKey'' (35): ''scriptPubKey'' of the previous output spent by this input, serialized as script inside <code>CTxOut</code>. Its size is always 35 bytes.\n** ''nSequence'' (4): ''nSequence'' of this input.\n** If an annex is present (the lowest bit of ''spend_type'' is set):\n*** ''sha_annex'' (32): the SHA256 of ''(compact_size(size of annex) || annex)'', where ''annex'' includes the mandatory ''0x50'' prefix.\n* Data about this output:\n** If ''hash_type & 3'' equals <code>SIGHASH_SINGLE</code>:\n*** ''sha_single_output'' (32): the SHA256 of the corresponding output in <code>CTxOut</code> format.\n\nSimilarly, ''Ext118(hash_type)'' evaluates to the concatenation of the following data, in order:\n\n* Extension:\n** If ''hash_type & 0xc0'' is not <code>SIGHASH_ANYPREVOUTANYSCRIPT</codE>:\n*** ''tapleaf_hash'' (32): the tapleaf hash as defined in [[bip-0341.mediawiki|BIP 341]]\n** ''key_version'' (1): a constant value ''0x01'' representing that this is a signature for a BIP 118 public key.\n** ''codesep_pos'' (4): the opcode position of the last executed <code>OP_CODESEPARATOR</code> before the currently executed signature opcode, with the value in little endian (or ''0xffffffff'' if none executed). The first opcode in a script has a position of 0. A multi-byte push opcode is counted as one opcode, regardless of the size of data being pushed.\n\nTo verify a signature ''sig'' for a BIP 118 public key ''p'':\n\n* If the ''sig'' is 64 bytes long, return ''Verify(p, hash<sub>TapSigHash</sub>(0x00 || Msg118(0x00) || Ext118(0x00)), sig)''\n* If the ''sig'' is 65 bytes long, return ''sig[64] &ne; 0x00 and Verify(p, hash<sub>TapSighash</sub>(0x00 || Msg118(sig[64]) || Ext118(sig[64])), sig[0:64])''.\n* Otherwise, fail.\n\n''Verify'' is as defined in [[bip-0340.mediawiki|BIP 340]].\n\nThe key differences from [[bip-0342.mediawiki|BIP 342]] signature verification are:\n\n* In all cases, <code>key_version</code> is set to the constant value <code>0x01</code> instead of <code>0x00</code>.<ref>'''Why change key_version?''' Changing <code>key_version</code> ensures that if the same private key is used to generate both a [[bip-0342.mediawiki|BIP 342]] key and a BIP 118 public key, that a signature for the [[bip-0342.mediawiki|BIP 342]] key is not also valid for the BIP 118 public key (and vice-versa).</ref>\n* If <code>SIGHASH_ANYPREVOUT</code> is set, the digest is calculated as if <code>SIGHASH_ANYONECANPAY</code> was set, except <code>outpoint</code> is not included in the digest.\n* If <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> is set, the digest is calculated as if <code>SIGHASH_ANYONECANPAY</code> was set, except <code>outpoint</code>, <code>amount</code>, <code>scriptPubKey</code> and <code>tapleaf_hash</code> are not included in the digest.\n\n== Security ==\n\n==== Signature replay ====\n\nBy design, <code>SIGHASH_ANYPREVOUT</code> and <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> introduce additional potential for signature replay (that is they allow the same signature to be reused on a different transaction) when compared to <code>SIGHASH_ALL</code> and <code>SIGHASH_ANYONECANPAY</code> signatures.\n\nBoth <code>SIGHASH_ALL</code> and <code>SIGHASH_ANYONECANPAY</code> signatures prevent signature replay by committing to one or more inputs, so replay of the signature is only possible if the same input can be spent multiple times, which is not possible on the Bitcoin blockchain (due to enforcement of [[bip-0030.mediawiki|BIP 30]]).\nWith <code>SIGHASH_ANYPREVOUT</code> signature replay is possible for different UTXOs with the same <code>scriptPubKey</code> and the same value, while with <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> signature replay is possible for any UTXOs that reuse the same BIP 118 public key in one of their potential scripts.\n\nAs a consequence, implementers MUST ensure that BIP 118 public keys are only reused when signature replay cannot cause loss of funds (eg due to other features of the protocol or other constraints on the transaction), or when such a loss of funds is acceptable.\n\n==== Malleability ====\n\nUse of <code>SIGHASH_ANYPREVOUT</code> or <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> may introduce additional malleability vectors.\n\nIn particular, a transaction authenticated using only ANYPREVOUT signatures is malleable to anyone able to provide an alternate input satisfied by the signature -- an input changed in this way would produce a new, valid transaction paying the same recipient, but with a different txid.\nDepending on the changes to the inputs, this might conflict with the original transaction (if some inputs remain shared) or might result in a double-payment to the recipient (if they do not).\n\nFurther, for a chain of transactions using the same <code>scriptPubKey</code> and value, and only authenticated via ANYPREVOUT signatures (as envisioned in eltoo for failure cases), it may be possible for any third party to malleate the transactions (and their txids) without having access to any of the private keys, particularly by omitting intermediate transactions.\n\nThis form of malleation can be dealt with by the child transactions also using ANYPREVOUT signatures -- when a parent transaction is malleated, its children can be adjusted to reference the new txid as the input and the ANYPREVOUT signatures remain valid.\n\nHowever child transactions that are authorised by a <code>SIGHASH_ALL</code> or <code>SIGHASH_ANYONECANPAY</code> signature will need new signatures if their inputs are malleated in this way.\nThis risk may be mitigated somewhat by using [[bip-0068.mediawiki|BIP 68]]/[[bip-0112.mediawiki|BIP 112]] relative time locks before spending a UTXO that had been authorised via an ANYPREVOUT signature with <code>SIGHASH_ALL</code> or <code>SIGHASH_ANYONECANPAY</code>: a relative timelock can ensure that the inputs have enough confirmations that they can only be replaced in the event of a large block reorg.\nNote that this approach has drawbacks: relative timelocks prevent fee-bumping via child-pays-for-parent, and have the obvious drawback of making the funds temporarily unusable until the timelock expires.\n\n==== Privacy considerations ====\n\nIt is expected that ANYPREVOUT signatures will only be rarely used in practice.\nProtocol and wallet designers should aim to have their transactions use Taproot key path spends whenever possible, both for efficiency reasons due to the lower transaction weight, but also for privacy reasons to avoid third parties being able to distinguish their transactions from those of other protocols.\n\nTransactions that do use ANYPREVOUT signatures will therefore reveal information about the transaction, potentially including that cooperation was impossible, or what protocol or software was used (due to the details of the script).\n\nIn order to maximise privacy, it is therefore recommended that protocol designers only use BIP 118 public keys in scripts that will be spent using at least one ANYPREVOUT signature, and either use key path spends or alternate scripts in the taproot merkle tree for any spends that can be authorised without ANYPREVOUT signatures.\nFollowing this recommendation may require additional script branches, which may mean disregarding this recommendation may result in a better tradeoff between cost and privacy in some circumstances.\n\n== Rationale ==\n\n<references />\n\n== Deployment ==\n\nTODO\n\nThis may be deployed as a soft-fork either concurrent with, or subsequent to the deployment of [[bip-0340.mediawiki|BIP 340]], [[bip-0341.mediawiki|BIP 341]] and [[bip-0342.mediawiki|BIP 342]].\n\n== Backwards compatibility ==\n\nAs a soft fork, older software will continue to operate without modification.\nNodes that have not upgraded to support [[bip-0341.mediawiki|BIP 341]] will see all taproot witness programs as anyone-can-spend scripts, and nodes that have upgraded to support [[bip-0341.mediawiki|BIP 341]] and [[bip-0342.mediawiki|BIP 342]] but not BIP 118 will simply treat any non-empty signature against a BIP 118 public key as valid.\nAs such, nodes are strongly encourage to upgrade in order to fully validate signatures for the new public key type.\n\nNon-upgraded wallets can receive and send bitcoin from non-upgraded and upgraded wallets using SegWit version 0 programs, traditional pay-to-pubkey-hash, etc.\nDepending on the implementation, non-upgraded wallets may be able to send to SegWit version 1 programs if they support sending to [[bip-0350.mediawiki|BIP350]] Bech32m addresses and do not prevent the transaction from being broadcast due to considering the outputs non-standard.\n\n== Revisions ==\n\nApart from being based on Taproot rather than SegWit v0, the main differences to prior revisions of this BIP are:\n\n* The sighash flag has been renamed from \"NOINPUT\" to \"ANYPREVOUT\" to reflect that while any prevout may potentially be used with the signature, some aspects of the input are still committed to, namely the input nSequence value, and (optionally) the spending conditions and amount.\n* Previously NOINPUT would have worked for direct public key spends (assuming deployment was fleshed out in a way similar to BIP 141 P2WPKH and P2WSH), however this proposal only applies to signatures via tapscript, and not direct key path spends. This means that addresses must opt-in to the ability to be spent by a <code>SIGHASH_ANYPREVOUT</code> or <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> signature by including an appropriate tapscript path when the address is created.\n* NOINPUT signatures do not commit to the output's spending conditions either via <code>scriptPubKey</code> or the redeem/witness script. This behaviour is preserved when <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> is used, but when <code>SIGHASH_ANYPREVOUT</code> is used, the signature now commits to <code>scriptPubKey</code> and the tapscript.\n* NOINPUT signatures did commit to the input's amount. This behaviour is preserved when <code>SIGHASH_ANYPREVOUT</code> is used, but not when <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> is used.\n* <code>OP_CODESEPARATOR</code> in script will affect both <code>SIGHASH_ANYPREVOUT</code> and <code>SIGHASH_ANYPREVOUTANYSCRIPT</code> signatures, whereas it would not have in the previous draft.\n\n== Acknowledgements ==\n\nThe <code>SIGHASH_NOINPUT</code> flag was first proposed by Joseph Poon in [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012460.html February 2016], after being mentioned in the original [http://lightning.network/lightning-network-paper.pdf Lightning paper] by Joseph Poon and Thaddeus Dryja.\nThis document is the result of discussions with many people and had direct input from Greg Maxwell, Jonas Nick, Pieter Wuille and others.\n\n", "content_length": 20417}
{"bip_number": 117, "filename": "bip-0117.mediawiki", "content": "<pre>\n  BIP: 117\n  Layer: Consensus (soft fork)\n  Title: Tail Call Execution Semantics\n  Author: Mark Friedenbach <mark@friedenbach.org>\n          Kalle Alm <kalle.alm@gmail.com>\n          BtcDrak <btcdrak@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0117\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-08-25\n  License: CC-BY-SA-4.0\n  License-Code: MIT\n</pre>\n\n==Abstract==\n\nBIP16 (Pay to Script Hash)[1] and BIP141 (Segregated Witness)[2] provide mechanisms by which script policy can be revealed at spend time as part of the execution witness.\nIn both cases only a single script can be committed to by the construct.\nWhile useful for achieving the goals of these proposals, they still require that all policies be specified within the confine of a single script, regardless of whether the policies are needed at the time of spend.\n\nThis BIP, in conjunction with BIP116 (MERKLEBRANCHVERIFY)[3] allows for a script to commit to a practically unbounded number of code pathways, and then reveal the actual code pathway used at spend time.\nThis achieves a form of generalized MAST[4] enabling decomposition of complex branching scripts into a set of non-branching flat execution pathways, committing to the entire set of possible pathways, and then revealing only the path used at spend time.\n\n==Copyright==\n\nThis BIP is licensed under a Creative Commons Attribution-ShareAlike license. All provided source code is licensed under the MIT license.\n\n==Specification==\n\nIf, at the end of script execution:\n\n* the execution state is non-clean, meaning\n*# the main stack has more than one item on it, or\n*# the main stack has exactly one item and the alt-stack is not empty;\n* the top-most element of the main stack evaluates as true when interpreted as a bool; and\n* the top-most element is not a single byte or is outside the inclusive range of <code>0x51</code> to <code>0x60</code>,\n\nthen that top-most element of the main stack is popped and interpreted as a serialized script and executed,\nwhile the remaining elements of both stacks remain in place as inputs.\n\nIf the above conditions hold except for the last one, such that:\n\n* the top-most element ''is'' a single byte within the inclusive range of <code>0x51</code> (<code>OP_1</code>, meaning N=2) to <code>0x60</code> (<code>OP_16</code>, meaning N=17); and\n* other than this top-most element there are at least N additional elements on the main stack and alt stack combined,\n\nthen the top-most element of the main stack is dropped,\nand the N=2 (<code>0x51</code>) to 17 (<code>0x60</code>) further elements are popped from the main stack,\ncontinuing from the alt stack if the main stack is exhausted,\nand concatenated together in reverse order to form a serialized script,\nwhich is then executed with the remaining elements of both stacks remaining in place as inputs.\n\nThe presence of CHECKSIG or CHECKMULTISIG within the subscript do not count towards the global MAX_BLOCK_SIGOPS_COST limit,\nand the number of non-push opcodes executed in the subscript is not limited by MAX_OPS_PER_SCRIPT.\nExecution state, other than the above exceptions, carries over into the subscript,\nand termination of the subscript terminates execution of the script as a whole.\nThis is known as execution with tail-call semantics.\n\nOnly one such tail-call of a subscript is allowed per script execution context, and only from within a segwit redeem script.\nAlternatively stated, neither evaluation of witness stack nor execution of the scriptPubKey or scriptSig or P2SH redeem script results in tail-call semantics.\n\n==Motivation==\n\nBIP16 (Pay to Script Hash)[1] and BIP141 (Segregated Witness)[2] allow delayed revelation of a script's policy until the time of spend.\nHowever these approaches are limited in that only a single policy can be committed to in a given transaction output.\nIt is not possible to commit to multiple policies and then choose, at spend time, which to reveal.\n\nBIP116 (MERKLEBRANCHVERIFY)[3] allows multiple data elements to be committed to while only revealing those necessary at the time of spend.\nThe MERKLEBRANCHVERIFY opcode is only able to provide commitments to a preselected set of data values, and does not by itself allow for executing code.\n\nThis BIP generalizes the approach of these prior methods by allowing the redeem script to perform any type of computation necessary to place the policy script on the stack.\nThe policy script is then executed from the top of the data stack in a way similar to how BIP16 and BIP141 enable redeem scripts to be executed from the top of the witness stack.\nIn particular, using MERKLEBRANCHVERIFY[3] in the scriptPubKey or redeem script allows selection of the policy script that contains only the necessary conditions for validation of the spend.\nThis is a form of generalized MAST[4] where a stage of precomputation splits a syntax tree into possible execution pathways, which are then enumerated and hashed into a Merkle tree of policy scripts.\nAt spend time membership in this tree of the provided policy script is proven before execution recurses into the policy script.\n\n==Rationale==\n\nThis proposal is a soft-fork change to bitcoin's consensus rules because leaving a script that data-wise evaluates as true from its serialized form on the stack as execution terminates would result in the script validation returning true anyway.\nGiving the subscript a chance to terminate execution is only further constraining the validation rules.\nThe only scripts which would evaluate as false are the empty script, or a script that does nothing more than push empty/zero values to the stack.\nNone of these scripts have any real-world utility, so excluding them to achieve soft-fork compatibility doesn't come with any downsides.\n\nBy restricting ourselves to tail-call evaluation instead of a more general EVAL opcode we greatly simplify the implementation.\nTail-call semantics means that execution never returns to the calling script's context, and therefore no state needs to be saved or later restored.\nThe implementation is truly as simple as pulling the subscript off the stack, resetting a few state variables, and performing a jump back to the beginning of the script interpreter.\n\nThe restriction to allow only one layer of tail-call recursion is admittedly limiting, however the technical challenges to supporting multi-layer tail-call recursion are significant.\nA new metric would have to be developed to track script resource usage, for which transaction data witness size are only two factors.\nThis new weight would have to be relayed with transactions, used as the basis for fee calculation, validated in-line with transaction execution, and policy decided upon for DoS-banning peers that propagate violating transactions.\n\nHowever should these problems be overcome, dropping the single recursion constraint is itself a soft-fork for the same reason, applied inductively.\nAllowing only one layer of tail-call recursion allows us to receive the primary benefit of multi-policy commitments / generalized MAST,\nwhile leaving the door open to future generalized tail-call recursion if and when the necessary changes are made to resource accounting and p2p transaction distribution.\n\nThe global SIGOP limit and per-script opcode limits do not apply to the policy script\nbecause dynamic selection of the policy script makes it not possible for static analysis tools to verify these limits in general,\nand because performance improvements to libsecp256k1 and Bitcoin Core have made these limits no longer necessary as they once were.\nThe validation costs are still limited by the number of signature operations it is possible to encode within block size limits,\nand the maximum script size per input is limited to 10,000 + 17*520 = 18,840 bytes.\n\nTo allow for this drop of global and per-script limits,\ntail-call evaluation cannot be allowed for direct execution of the scriptPubKey,\nas such scripts are fetched from the UTXO and do not count towards block size limits of the block being validated.\nLikewise tail-call from P2SH redeem scripts is not supported due to quadratic blow-up vulnerabilities that are fixed in segwit.\n\n==Generalized MAST==\n\nWhen combined with BIP116 (MERKLEBRANCHVERIFY)[3], tail-call semantics allows for generalized MAST capabilities[4].\nThe script author starts with a full description of the entire contract they want to validate at the time of spend.\nThe possible execution pathways through the script are then enumerated, with conditional branches replaced by a validation of the condition and the branch taken.\nThe list of possible execution pathways is then put into a Merkle tree, with the flattened policy scripts as the leaves of this tree.\nThe final redeem script which funds are sent to is as follows:\n\n  redeemScript: <nowiki><root> 2 MERKLEBRANCHVERIFY 2DROP DROP</nowiki>\n  witness: <nowiki><argN> ... <arg1> <policyScript> <proof></nowiki>\n\nWhere <code>policyScript</code> is the flattened execution pathway, <code>proof</code> is the serialized Merkle branch and path that proves the policyScript is drawn from the set used to construct the Merkle tree <code>root</code>, and <code>arg1</code> through <code>argN</code> are the arguments required by <code>policyScript</code>.\nThe <code>2</code> indicates that a single leaf (<code>1 << 1</code>) follows, and the leaf value is not pre-hashed.\nThe <code>2DROP DROP</code> is necessary to remove the arguments to MERKLEBRANCHVERIFY from the stack.\n\nThe above example was designed for clarity, but actually violates the CLEANSTACK rule of segwit v0 script execution.\nUnless the CLEANSTACK rule is dropped or modified in a new segwit output version, this would script would have to be modified to use the alt-stack, as follows:\n\n  redeemScript: <nowiki>[TOALTSTACK]*N <root> 2 MERKLEBRANCHVERIFY 2DROP DROP</nowiki>\n  witness: <nowiki><policyScript> <proof> <arg1> ... <argN></nowiki>\n\nWhere <code>[TOALTSTACK]*N</code> is the TOALTSTACK opcode repeated N times.\nThis moves <code>arg1</code> through <code>argN</code> to the alt-stack in reverse order, such that <code>arg1</code> is on the top of the alt-stack when execution of <code>policyScript</code> begins.\nThe <code>policyScript</code> would also have to be modified to fetch its arguments from the alt-stack, of course.\n\nIf the total set of policy scripts includes scripts that take a varying number of parameters, that too can be supported, within reasonable limits.\nThe following redeem script allows between 1 and 3 witness arguments in addition to the policy script and Merkle proof:\n\n  witness: <nowiki><policyScript> <proof> <arg1> ... <argN></nowiki> // N is between 1 and 3\n  redeemScript: DEPTH TOALTSTACK                    // Save number of witness elements to alt-stack\n                TOALTSTACK                          // Save 1st element (required) to alt-stack\n                DEPTH 2 SUB                         // Calculate number of optional elements, ignoring policyScript and proof\n                DUP IF SWAP TOALTSTACK 1SUB ENDIF   // Save 2nd element (optional) to alt-stack, if it is present\n                IF TOALTSTACK ENDIF                 // Save 3rd element (optional) to alt-stack, if it is present; consume counter\n                <nowiki><root></nowiki> 2 MERKLEBRANCHVERIFY 2DROP DROP\n  alt-stack: <nowiki><N+2> <argN> ... <arg1></nowiki>\n\nBecause the number of witness elements is pushed onto the alt-stack, this enables policy scripts to verify the number of arguments passed, even though the size of the alt-stack is not usually accessible to script.\nThe following policy script for use with the above redeem script will only accept 2 witness elements on the alt-stack, preventing witness malleability:\n\n  policyScript: <nowiki>FROMALTSTACK ...check arg1... FROMALTSTACK ...check&consume arg2/arg1&2... FROMALTSTACK 4 EQUAL\n\nThe number 4 is expected as that includes the <code>policyScript</code> and <code>proof</code>.\n\nThe verbosity of this example can be prevented by using a uniform number of witness elements as parameters for all policy subscripts, eliminating the conditionals and stack size counts.\nFuture script version upgrades should also consider relaxing CLEANSTACK rules to allow direct pass-through of arguments from the witness/redeem script to the policy script on the main stack.\n\n===Comparison with BIP114===\n\nBIP114 (Merkelized Abstract Syntax Tree)[5] specifies an explicit MAST scheme activated by BIP141 script versioning[2].\nUnlike BIP114, the scheme proposed by this BIP in conjunction with BIP116 (MERKLEBRANCHVERIFY)[3] implicitly enables MAST constructs using script itself to validate membership of the policy script in the MAST.\nThis has the advantage of requiring vastly fewer consensus code changes, as well as potentially enabling future script-based innovation without requiring any further consensus code changes at all, as the MAST scheme itself is programmable.\n\nFurthermore, by adding MERKLEBRANCHVERIFY and tail-call semantics to all script using the NOP-expansion space, BIP141 style script versioning is not required.\nThis removes a potentially significant hurdle to deployment by making this feature not dependent on resolving outstanding issues over address formats, how script version upgrades should be deployed, and consensus over what other features might go into a v1 upgrade.\n\n==Implementation==\n\nAn implementation of this BIP, including both consensus code changes and tests are available at the following Github repository:\n\n[https://github.com/maaku/bitcoin/tree/tail-call-semantics]\n\n==Deployment==\n\nThis BIP will be deployed by BIP8 (Version bits with lock-in by height)[9] with the name \"tailcall\" and using bit 3.\n\nFor Bitcoin mainnet, the BIP8 startheight will be at height M to be determined and BIP8 timeout activation will occur on height M + 50,400 blocks.\n\nFor Bitcoin testnet, the BIP8 startheight will be at height T to be determined and BIP8 timeout activation will occur on height T + 50,400 blocks.\n\nWe note that CLEANSTACK means that transactions which use this feature are already considered non-standard by the rules of the network, making deployment easier than was the case with, for example, with BIP68 (Relative lock-time using consensus-enforced sequence numbers)[6].\n\n==Compatibility==\n\nThe v0 segwit rules prohibit leaving anything on the stack, so for v0 parameters have to be passed on the alt stack for compatibility reasons.\n\n==References==\n\n[1] [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16: Pay to Script Hash]\n\n[2] [https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141: Segregated Witness (Consensus Layer)]\n\n[3] [https://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki BIP116: MERKLEBRANCHVERIFY]\n\n[4] \"[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015028.html An explanation and justification of the tail-call and MBV approach to MAST]\", Mark Friedenbach, Bitcoin Development Mailing List, 20 September 2017.\n\n[5] [https://github.com/bitcoin/bips/blob/master/bip-0114.mediawiki BIP114: Merkelized Abstract Syntax Tree]\n\n[6] [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP68: Relative lock-time using consensus-enforced sequence numbers]\n", "content_length": 15292}
{"bip_number": 116, "filename": "bip-0116.mediawiki", "content": "<pre>\n  BIP: 116\n  Layer: Consensus (soft fork)\n  Title: MERKLEBRANCHVERIFY\n  Author: Mark Friedenbach <mark@friedenbach.org>\n          Kalle Alm <kalle.alm@gmail.com>\n          BtcDrak <btcdrak@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0116\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-08-25\n  License: CC-BY-SA-4.0\n  License-Code: MIT\n</pre>\n\n==Abstract==\n\nA general approach to bitcoin contracts is to fully enumerate the possible spending conditions and then program verification of these conditions into a single script.\nAt redemption, the spending condition used is explicitly selected, e.g. by pushing a value on the witness stack that cascades through a series of if/else constructs.\n\nThis approach has significant downsides, such as requiring all program pathways to be visible in the scriptPubKey or redeem script, even those which are not used at validation.\nThis wastes space on the block chain, restricts the size of possible scripts due to push limits, and impacts both privacy and fungibility as details of the contract can often be specific to the user.\n\nThis BIP proposes a new soft-fork upgradeable opcode, MERKLEBRANCHVERIFY, which allows script writers to commit to a set of data elements and have one or more of these elements be provided at redemption without having to reveal the entire set.\nAs these data elements can be used to encode policy, such as public keys or validation subscripts, the MERKLEBRANCHVERIFY opcode can be used to overcome these limitations of existing bitcoin script.\n\n==Copyright==\n\nThis BIP is licensed under a Creative Commons Attribution-ShareAlike license. All provided source code is licensed under the MIT license.\n\n==Specification==\n\nMERKLEBRANCHVERIFY redefines the existing NOP4 opcode.\nWhen executed, if any of the following conditions are true, the script interpreter will terminate with an error:\n\n# the stack contains less than three (3) items;\n# the first item on the stack is more than 2 bytes;\n# the first item on the stack, interpreted as an integer, N, is negative or not minimally encoded;\n# the second item on the stack is not exactly 32 bytes;\n# the third item on the stack is not a serialized Merkle tree inclusion proof as specified by BIP98[1] and requiring exactly <code>floor(N/2)</code> VERIFY hashes; or\n# the remainder of the stack contains less than <code>floor(N/2)</code> additional items, together referred to as the input stack elements.\n\nIf the low-order bit of N is clear, <code>N&1 == 0</code>, each input stack element is hashed using double-SHA256.\nOtherwise, each element must be exactly 32 bytes in length and are interpreted as serialized hashes.\nThese are the VERIFY hashes.\n\nIf the fast Merkle root computed from the Merkle tree inclusion proof, the third item on the stack,\nwith the VERIFY hashes in the order as presented on the stack, from top to bottom,\ndoes not exactly match the second item on the stack,\nthe script interpreter will terminate with an error.\n\nOtherwise, script execution will continue as if a NOP had been executed.\n\n==Motivation==\n\nAlthough BIP16 (Pay to Script Hash)[2] and BIP141 (Segregated Witness)[3] both allow the redeem script to be kept out of the scriptPubKey and therefore out of the UTXO set, the entire spending conditions for a coin must nevertheless be revealed when that coin is spent.\nThis includes execution pathways or policy conditions which end up not being needed by the redemption.\nNot only is it inefficient to require this unnecessary information to be present on the blockchain, albeit in the witness, it also impacts privacy and fungibility as some unused script policies may be identifying.\nUsing a Merkle hash tree to commit to the policy options, and then only forcing revelation of the policy used at redemption minimizes this information leakage.\n\nUsing Merkle hash trees to commit to policy allows for considerably more complex contracts than would otherwise be possible, due to various built-in script size and runtime limitations.\nWith Merkle commitments to policy these size and runtime limitations constrain the complexity of any one policy that can be used rather than the sum of all possible policies.\n\n==Rationale==\n\nThe MERKLEBRANCHVERIFY opcode uses fast Merkle hash trees as specified by BIP98[1] rather than the construct used by Satoshi for committing transactions to the block header as the later has a known vulnerability relating to duplicate entries that introduces a source of malleability to downstream protocols[4].\nA source of malleability in Merkle proofs could potentially lead to spend vulnerabilities in protocols that use MERKLEBRANCHVERIFY.\nFor example, a compact 2-of-N policy could be written by using MERKLEBRANCHVERIFY to prove that two keys are extracted from the same tree, one at a time, then checking the proofs for bitwise equality to make sure the same entry wasn't used twice.\nWith the vulnerable Merkle tree implementation there are privileged positions in unbalanced Merkle trees that allow multiple proofs to be constructed for the same, single entry.\n\nBIP141 (Segregated Witness)[3] provides support for a powerful form of script upgrades called script versioning, which is able to achieve the sort of upgrades which would previously have been hard-forks.\nIf script versioning were used for deployment then MERKLEBRANCHVERIFY could be written to consume its inputs, which would provide a small 2-byte savings for many anticipated use cases.\nHowever the more familiar NOP-expansion soft-fork mechanism used by BIP65 (CHECKLOCKTIMEVERIFY)[5] and BIP112 (CHECKSEQUENCEVERIFY)[6] was chosen over script versioning for the following two reasons:\n\n# '''Infrastructure compatibility.''' Using soft-fork NOP extensions allows MERKLEBRANCHVERIFY to be used by any existing software able to consume custom scripts, and results in standard P2SH or P2WSH-nested-in-P2SH addresses without the need for BIP143[7] signing code. This allows MERKLEBRANCHVERIFY to be used immediately by services that need it rather than wait on support for script versioning and/or BIP-143[7] signatures in tools and libraries.\n# '''Delayed decision on script upgrade protocol.''' There are unresolved issues with respect to how script versioning should be used for future script upgrades. There are only 16 available script versions reserved for future use, and so they should be treated as a scarce resource. Additionally, script feature versioning should arguably be specified in the witness and the BIP141 script versioning only be used to specify the structure of the witness, however no such protocol exists as of yet. Using the NOP-expansion space prevents MERKLEBRANCHVERIFY from being stalled due to waiting on script upgrade procedure to be worked out, while making use of expansion space that is already available.\n\nThe MERKLEBRANCHVERIFY opcode allows for VERIFY hashes to be presented directly, or calculated from the leaf values using double-SHA256.\nIn most cases the latter approach is expected to be used so that the leaf value(s) can be used for both branch validation and other purposes without any explicit preprocessing.\nHowever allowing already-calculated hash values as inputs enables using chained MERKLEBRANCHVERIFY opcodes to verify branches of trees with proofs large enough that they would not fit in the 520 byte script push limitation.\nAs specified, a 30-branch path can be verified by proving the path from the leaf to the 15th interior node as the 'root', then proving that node's hash to be a child of the actual Merkle tree root hash.\nValidation of a 256-branch path (e.g. a binary prefix tree with a hash value as key) would require 18 chained validations, which would fit within current script limitations.\n\n==Applications==\n\n===1-of-N for large N===\n\nHere is a redeem script that allows a coin to be spent by any key from a large set, without linear scaling in script size:\n\n  redeemScript: <root> 2 MERKLEBRANCHVERIFY 2DROP DROP CHECKSIG\n  witness: <sig> <pubkey> <proof>\n\nThe redeem script looks very similar to the standard pay-to-pubkey-hash, except instead of showing that the pubkey's hash is the same as the commitment given, we demonstrate that the pubkey is one of potentially many pubkeys included in the Merkle tree committed to in the redeem script.\nThe low-order bit of the first parameter, 2, is clear, meaning that there is one input (<code>(2>>1) == 1</code>), the serialized pubkey, and its VERIFY hash needs to be calculated by MERKLEBRANCHVERIFY using double-SHA256.\n\n===Honeypots===\n\nAs described by Pieter Wuille[8] the 1-of-N scheme is particularly useful for constructing honeypots.\nThe desire is to put a large bounty on a server, larger than the value of the server itself so that if the server is compromised it is highly likely that the hacker will claim the bitcoin, thereby revealing the intrusion.\nHowever if there are many servers, e.g. 1,000, it becomes excessively expensive to lock up separate bounties for each server.\nIt would be desirable if the same bounty was shared across multiple servers in such a way that the spend would reveal which server was compromised.\n\nThis is accomplished by generating 1,000 different keys, building a hash tree of these public keys, and placing each key and associated Merkle path on separate servers.\nWhen the honeypot is claimed, the (previous) owner of the coins can tell which server was compromised from the key and path used to claim the funds.\n\n==Implementation==\n\nAn implementation of this BIP, including both consensus code updates and tests is available at the following Github repository:\n\n[https://github.com/maaku/bitcoin/tree/merkle-branch-verify]\n\n==Deployment==\n\nThis BIP will be deployed by BIP8 (Version bits with lock-in by height)[10] with the name \"merklebranchverify\" and using bit 2.\n\nFor Bitcoin mainnet, the BIP8 startheight will be at height M to be determined and BIP8 timeout activation will occur on height M + 50,400 blocks.\n\nFor Bitcoin testnet, the BIP8 startheight will be at height T to be determined and BIP8 timeout activation will occur on height T + 50,400 blocks.\n\nWe note that DISCOURAGE_UPGRADABLE_NOPS means that transactions which use this feature are already considered non-standard by the rules of the network, making deployment easier than was the case with, for example, with BIP68 (Relative lock-time using consensus-enforced sequence numbers)[9].\n\n==Compatibility==\n\nOld clients will consider the OP_MERKLEBRANCHVERIFY as a NOP and ignore it. Proof will not be verified, but the transaction will be accepted.\n\n==References==\n\n[1] [https://github.com/bitcoin/bips/blob/master/bip-0098.mediawiki BIP98: Fast Merkle Trees (Consensus layer)]\n\n[2] [https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP16: Pay to Script Hash]\n\n[3] [https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki BIP141: Segregated Witness (Consensus layer)]\n\n[4] [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459 National Vulnerability Database: CVE-2012-2459]\n\n[5] [https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP65: OP_CHECKLOCKTIMEVERIFY]\n\n[6] [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP112: CHECKSEQUENCEVERIFY]\n\n[7] [https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki BIP143: Transaction Signature Verification for Version 0 Witness Program]\n\n[8] [https://blockstream.com/2015/08/24/treesignatures.html Multisig on steroids using tree signatures]\n\n[9] [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP68: Relative lock-time using consensus-enforced sequence numbers]\n\n[10] [https://github.com/bitcoin/bips/blob/master/bip-0008.mediawiki BIP8: Version bits with lock-in by height]\n", "content_length": 11754}
{"bip_number": 115, "filename": "bip-0115.mediawiki", "content": "<pre>\n  BIP: 115\n  Layer: Consensus (soft fork)\n  Title: Generic anti-replay protection using Script\n  Author: Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0115\n  Status: Rejected\n  Type: Standards Track\n  Created: 2016-09-23\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes a new opcode (<code>OP_CHECKBLOCKATHEIGHT</code>) for the Bitcoin scripting system that allows construction of transactions which are valid only on specific blockchains.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Specification==\n\n<code>OP_CHECKBLOCKATHEIGHT</code> redefines the existing <code>OP_NOP5</code> opcode.\n\nWhen this opcode is executed:\n\n* If the stack has fewer than 2 elements, the script fails.\n* If the top item on the stack cannot be interpreted as a minimal-length 32-bit CScriptNum, the script fails.\n* The top item on the stack is interpreted as a block height (ParamHeight).\n* If the blockchain (in the context of the execution) does not have ParamHeight blocks prior to the one including this transaction, the script fails (this failure must not be cached across blocks; it is equivalent to non-final status).\n* If ParamHeight specifies a block deeper than 52596 blocks in the chain (including negative values), the opcode completes successfully and script continues as normal.\n* The second-to-top item on the stack is interpreted as a block hash (ParamBlockHash).\n* If ParamBlockHash is longer than 28 bytes, the script fails.\n* If ParamBlockHash does not match the equivalent ending bytes of the block hash specified by ParamHeight, the script fails.\n\nOtherwise, script execution will continue as if a NOP had been executed.\n\n===Deployment===\n\nThis BIP will be deployed by \"version bits\" [[bip-0009.mediawiki|BIP9]] with the '''name''' \"cbah\" and using '''bit''' TBD.\n\nFor Bitcoin '''mainnet''', the BIP9 '''starttime''' will be TBD (Epoch timestamp TBD) and BIP9 '''timeout''' will be TBD (Epoch timestamp TBD).\n\nFor Bitcoin '''mainnet''', the BIP9 '''starttime''' will be TBD (Epoch timestamp TBD) and BIP9 '''timeout''' will be TBD (Epoch timestamp TBD).\n\n==Motivation==\n\n===Securely recovering from double spends===\n\nIn some circumstances, users may wish to spend received bitcoins before they have confirmed on the blockchain (Tx B1).\nHowever, if the transaction sending them those bitcoins (Tx A1) is double-spent, the wallet must re-issue their own transaction spending them (Tx B2).\nSo long as the double-spend of the incoming transaction (Tx A2) also pays the wallet, this can be managed by simply updating the outgoing transaction with the new outpoint and resigning.\nHowever, if the double-spend does not pay the wallet, the situation is presently irrecoverable:\nit must spend different, non-conflicting TXOs in Tx B2, which allows an attacker to then reorganise the chain (reversing the incoming transaction's double-spend) and confirm both of his transactions Tx B1 and Tx B2.\n\nBy adding <code>OP_CHECKBLOCKATHEIGHT</code>, the wallet can issue Tx B2 with a condition that the block confirming Tx A2 is in the history, thus eliminating this risk.\n\n===Replay protection in the event of a persistent blockchain split===\n\nIn the event of a persistent blockchain split, some mechanism is desired by which the UTXOs valid in either chain may be spent without the transaction being validly replayable on the other chain.\n\nThis can be guaranteed by choosing a block which exists only on either side of the split, and pinning (using <code>OP_CHECKBLOCKATHEIGHT</code>) common UTXOs to be spent only on chains based on that block.\n\n==Best practices for wallets==\n\nTo avoid unnecessary conflicts when a chain is reorganized, wallets should always avoid specifying the last 100 blocks when practical.\nWallets that use recent blocks when unavoidable SHOULD actively monitor the network and re-create transactions that are reorganised out with updated block hashes.\nUnless it conflicts with local/user security policies, wallets SHOULD retain the private key in memory to re-sign such transactions until the pinned block is at least 100 blocks deep into the chain.\n\nFor ordinary usage, wallets SHOULD specify the ParamBlockHash as 16 bytes.\n\n==Rationale==\n\nHow is this different from the transaction's lock-time?\n\n* The lock-time specifies a time or block height before a transaction becomes valid. <code>OP_CHECKBLOCKATHEIGHT</code>, on the other hand, specifies a specific block's hash.\n\nWhy are block heights required to be absolute, rather than relative?\n\n* A relative block height would allow for creation of transactions which are valid at block N, but not N+1. This is carefully avoided by Bitcoin to ensure that if any given block is reorganised out, non-malicious transactions can be simply re-confirmed in a later block.\n\nWhy are blocks older than 52596 deep in the chain not verified?\n\n* This is to avoid creating an infinite storage requirement from all full nodes which would be necessary to maintain all the block headers indefinitely. 52596 block headers requires a fixed size of approximately 4 MB.\n* In any case where you might want to specify a deeper block, you can also just as well specify a more recent one that descends from it.\n* It is assumed that 1 year is sufficient time to double-spend any common UTXOs on all blockchains of interest.\n* If a deeper check is needed, it can be softforked in. Making the check more shallow, on the other hand, is a hardfork.\n\nWhy is ParamBlockHash allowed to match less than the full block hash?\n\n* In a chain split, it is sufficient to check only a few bytes to avoid replay.\n* In all scenarios, it is likely sufficient to check only a minority of the full hash to avoid any realistic chance of replay.\n* Allowing less than the full hash to be specified saves space in transaction data.\n* Using a single byte can be combined with other opcodes (such as <code>OP_LESSTHAN</code>) to enable on-chain gambling logic.\n\nWhat if ParamBlockHash has leading zeros? Should this be prevented?\n\n* If leading zeros are included, they should be compared to the actual block hash. (If they were truncated, fewer bytes would be compared.)\n* It is unlikely that the leading zeros will ever be necessary for sufficient precision, so the additional space is not a concern.\n* Since all block hashes are in principle shorter than 29 bytes, ParamBlockHash may not be larger than 28 bytes.\n\nWhy is it safe to allow checking blocks as recently as the immediate previous block?\n\n* This should only be used when necessary (ie, the deeper block is not sufficient), and when the wallet can actively issue updates should the blockchain reorganise.\n* While this allows intentionally creating a transaction which may be invalid in a reorganization, the same can already be accomplished by creating double spends.\n\n==Backwards Compatibility==\n\n<code>OP_NOP5</code> ought to be forbidden by policy by all miners for future extensions such as this, so old miners will under no circumstances produce blocks which would now be considered invalid under the new rules.\nHowever, miners must still upgrade to avoid accepting and building on top of such a possible invalid block as part of an attack.\n\nOld nodes will likely also not relay transactions using this opcode for the same extensibility reasons, but this is not important since the rule cannot be verified deterministically outside the context of a block.\n\n==Reference Implementation==\n\nhttps://github.com/bitcoin/bitcoin/compare/master...luke-jr:cbah\n", "content_length": 7568}
{"bip_number": 114, "filename": "bip-0114.mediawiki", "content": "<pre>\n  BIP: 114\n  Layer: Consensus (soft fork)\n  Title: Merkelized Abstract Syntax Tree\n  Author: Johnson Lau <jl2012@xbt.hk>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0114\n  Status: Rejected\n  Type: Standards Track\n  Created: 2016-04-02\n  License: PD\n</pre>\n\n==Abstract==\nThis BIP defines a new witness program type that uses a Merkle tree to encode mutually exclusive branches in a script. This enables complicated redemption conditions that are currently not possible, improves privacy by hiding unexecuted scripts, and allows inclusion of non-consensus enforced data with very low or no additional cost.\n\n==Motivation==\n===Evolution of Bitcoin script system===\nBitcoin uses a script system to specify the conditions for redemption of transaction outputs. In its original design, the conditions for redemption are directly recorded in the scriptPubKey by the sender of the funds. This model has several drawbacks, particularly for complicated scripts:\n# It could be difficult for the receiver to specify the conditions;\n# Large scripts take up more UTXO space;\n# The sender will pay for the additional block space;\n# To prevent DoS attack, scripts are limited to 10,000 bytes and 201 op codes;\n# Any unexecuted branches and non-consensus enforced data in the script are visible to the public, consuming block space while damaging privacy.\n\nThe [[bip-0016.mediawiki|BIP16]] (Pay-to-script-hash, \"P2SH\") fixes the first 3 problems by using a fixed-length 20-byte script hash in the scriptPubKey, and moving the responsibility for supplying the script to the redeemer. However, due to the data push size limit in script, a P2SH script may not be bigger than 520 bytes. Also, P2SH still requires the redeemer to publish all unexecuted branches of the script.\n\nThe [[bip-0141.mediawiki|BIP141]] defines 2 new types of scripts that support segregated witness. The pay-to-witness-script-hash (P2WSH) is similar to P2SH is many ways. By supplying the script in witness, P2WSH restores the original 10,000 byte script limit. However, it still requires publishing of unexecuted branches.\n\n===Merkelized Abstract Syntax Tree===\nThe idea of Merkelized Abstract Syntax Tree (MAST) is to use a Merkle tree to encode branches in a script. When spending, users may provide only the branches they are executing, and hashes that connect the branches to the fixed size Merkel root. This reduces the size of redemption stack from O(n) to O(log n) (n as the number of branches). This enables complicated redemption conditions that is currently not possible due to the script size and opcode limit, improves privacy by hiding unexecuted branches, and allows inclusion of non-consensus enforced data with very low or no additional cost.\n\n==Specification==\nIn [[bip-0141.mediawiki|BIP141]], witness programs with a version byte of 1 or larger are considered to be anyone-can-spend scripts. The following new validation rules are applied if the witness program version byte is 1 and the program size is 32 bytes.<ref>If the version byte is 1, but the witness program is not 32 bytes, no further interpretation of the witness program or witness stack happens. This is reserved for future extensions.</ref> The witness program is the <code>MAST Root</code>.\n\nTo redeem an output of this kind, the witness must consist of the following items:\n\n\n  Script_stack_1\n  Script_stack_2\n  .\n  .\n  Script_stack_X (X \u2265 0)\n  Subscript_1\n  Subscript_2\n  .\n  .\n  Subscript_Y (1 \u2264 Y \u2264 255)\n  Position\n  Path\n  Metadata (Y|MAST Version)\n\n\n<code>Metadata</code> is the last witness item. It is a vector of 1 to 5 bytes. The first byte is an unsigned integer between 1 to 255 denoting the number of <code>Subscript</code> (defined hereinafter). The following 0 to 4 byte(s) is an unsigned little-endian integer denoting the <code>MAST version</code>. <code>MAST Version</code> must be minimally encoded (the most significant byte must not be 0).\n\n<code>Path</code> is the second last witness item. It is a serialized Merkle path of the <code>Script Hash</code> (defined hereinafter). Size of <code>Path</code> must be a multiple of 32 bytes, and not more than 1024 bytes. Each 32 byte word is a double-SHA256 merkle node in the merkle branch connecting to the <code>Script Root</code> (defined hereinafter). <code>Depth</code> of the tree (0 to 32) is the size of <code>Path</code> divided by 32.\n\n<code>Position</code> is the third last witness item. It indicates the location of the <code>Script Hash</code> in the Merkle tree, with zero indicating the leftmost position. It is an unsigned little-endian integer with not more than 4 bytes. It must be minimally encoded: the value must not be larger than the maximum number of items allowed by the <code>Depth</code> of the tree, and the most significant byte must not be 0. For example, if <code>Depth</code> is 4, the valid range of <code>Position</code> is 0 to 15 (2<sup>4</sup>-1).\n\nDepends on the first byte of <code>Metadata</code>, there should be 1 to 255 <code>Subscript</code> witness item(s) before <code>Position</code>.\n\n<code>Script Hash</code> is defined as:\n\n  Script Hash = H(Y|H(Subscript_1)|H(Subscript_2)|...|H(Subscript_Y))\n  H() = SHA256(SHA256())\n\nwhere <code>Y</code> is a 1-byte value denoting number of <code>Subscript</code>, followed by the hash of each <code>Subscript</code>\n\n<code>Script Root</code> is the Merkle root calculated by the <code>ComputeMerkleRootFromBranch</code> function, using <code>Script Hash</code>, <code>Path</code> and <code>Position</code>.\n\n<code>MAST Root</code> is <code>H(MAST Version|Script Root)</code>. The pre-image has a fixed size of 36 bytes: 4 bytes for <code>MAST Version</code> (unsigned little-endian integer) and 32 bytes for <code>Script Root</code>.\n\nThe script evaluation fails if <code>MAST Root</code> does not match the witness program.\n\nIf the <code>MAST Root</code> matches the witness program and <code>MAST Version</code> is greater than 0, the script returns a success without further evaluation. <code>SigOpsCost</code> is counted as 0. This is reserved for future script upgrades.\n\nIf the <code>MAST Version</code> is 0, the <code>Subscript</code>(s) are serialized to form the final <code>MAST Script</code>, beginning with </code>Subscript_1</code>. The unused witness item(s) before the </code>Subscript_1</code> are used as <code>Input Stack</code> to feed to the <code>MASTScript</code>. (Similar to P2WSH in BIP141)\n\nThe script fails with one of the following conditions:\n* <code>MAST Script</code> is malformed (i.e. not enough data provided for the last push operation). Individual <code>Subscript</code> might be malformed, as long as they are serialized into a valid <code>MAST Script</code>\n* Size of <code>MAST Script</code> is larger than 10,000 bytes\n* Size of any one of the <code>Input Stack</code> item is larger than 520 bytes\n* Number of non-push operations (<code>nOpCount</code>) is more than 201. <code>nOpCount</code> is the sum of the number of non-push operations in <code>MAST Script</code> (counted in the same way as P2WSH <code>witnessScript</code>), number of <code>Subscript</code> (Y), and <code>Depth</code> of the Merkle tree.\n\nThe <code>MAST Script</code> is then evaluated with the <code>Input Stack</code> (with some new or redefined opcodes described in BIPXXX). The evaluation must not fail, and result in an exactly empty stack.\n\nCounting of <code>SigOpsCost</code> is based on the <code>MAST Script</code>, described in BIPYYY.\n\n== Rationale ==\n=== MAST Structure ===\nThis proposal is a restricted case of more general MAST. In a general MAST design, users may freely assign one or more script branches for execution. In this proposal, only one branch is allowed for execution, and users are required to transform a complicated condition into several mutually exclusive branches. For example, if the desired redeem condition is:\n\n  (A or B) and (C or D or E) and (F or G)\n\nIn a general MAST design, the 7 branches (A to G) will form a 3-level Merkle tree, plus an \"overall condition\" describing the relationship of different branches. In redemption, the \"overall condition\", executed branches (e.g. B, D, F), and Merkle path data will be provided for validation.\n\nIn the current proposal, the user has to transform the redeem condition into 12 mutually exclusive branches and form a 4-level Merkle tree, and present only one branch in redemption:\n\n\n  A and C and F\n  B and C and F\n  A and D and F\n  .\n  .\n  B and E and G\n\nOne way to implement the general MAST design is using a combination of <code>OP_EVAL</code>, <code>OP_CAT</code>, and <code>OP_HASH256</code>. However, that will suffer from the problems of <code>OP_EVAL</code>, including risks of indefinite program loop and inability to do static program analysis. A complicated implementation is required to fix these problems and is difficult to review.\n\nThe advantages of the current proposal are:\n* <code>Subscript</code> are located at a fixed position in the witness stack. This allows static program analysis, such as static <code>SigOpsCost</code> counting and early termination of scripts with disabled opcodes.\n* If different parties in a contract do not want to expose their scripts to each other, they may provide only <code>H(Subscript)</code> and keep the <code>Subscript</code> private until redemption.\n* If they are willing to share the actual scripts, they may combine them into one <code>Subscript</code> for each branch, saving some <code>nOpCount</code> and a few bytes of witness space.\n\nThere are some disadvantages, but only when the redemption condition is very complicated:\n* It may require more branches than a general MAST design (as shown in the previous example) and take more witness space in redemption\n* Creation and storage of the MAST structure may take more time and space. However, such additional costs affect only the related parties in the contract but not any other Bitcoin users.\n\n=== MAST Version ===\nThis proposal allows users to indicate the version of scripting language in the witness, which is cheaper than doing that in <code>scriptPubKey</code> or <code>scriptSig</code>. Undefined versions remain anyone-can-spend and are reserved for future expansions. A new version could be used for relaxing constraints (e.g. the 10,000 bytes size limit of <code>MAST Script</code>), adding or redefining opcodes, or even introducing a completely novel scripting system.\n\n=== nOpCount limit ===\nIn version 0 MAST, the extra hashing operations in calculating the <code>MAST Root</code> are counted towards the 201 <code>nOpCount</code> limit to prevent abusive use. This limitation is not applied to undefined <code>MAST Version</code> for flexibility, but it is constrained by the 255 <code>Subscript</code> and 32 <code>Depth</code> limits.\n\n=== Script evaluation ===\nThis proposal requires script evaluation resulting in an empty stack, instead of a single <code>TRUE</code> value as in P2WSH. This allows each party in a contract to provide its own <code>Subscript</code>, and demonstrate the required <code>Input Stack</code> to clean up its own <code>Subscript</code>. In this case, order of the <code>Subscript</code> is not important since the overall objective is to clean up the stack after evaluation.\n\n== Examples ==\n=== Calculation of MAST Root ===\n\n<img src=bip-0114/mastexample.png></img>\n\n\n  Subscript:\n    SA = 1 EQUALVERIFY (0x5188)\n    SB = 2 EQUALVERIFY (0x5288)\n    SC = 3 EQUALVERIFY (0x5388)\n    SD = 4 EQUALVERIFY (0x5488)\n    SE = 5 EQUALVERIFY (0x5588)\n    SF = 6 EQUALVERIFY (0x5688)\n    SG = 7 EQUALVERIFY (0x5788)\n    SH = 8 EQUALVERIFY (0x5888)\n    M = RETURN \"Hello\" (0x6a0548656c6c6f)\n  Hash:\n    HA = H(0x01|H(SA)) = H(0x015acb54166e0db370cd1b05a29120373568dacea2abc3748459ec3da2106e4b4e) = 0xd385d7268ad7e1ec51660f833d54787d2d8d79b6b1809d9c1d06c9e71f7be204\n    HB = H(0x02|H(SB)|H(SC)) = 0x7cbfa08e44ea9f4f996873be95d9bffd97d4b91a5af32cc5f64efb8461727cdd\n    HF = H(0x03|H(SD)|H(SE)|H(SF)) = 0x4611414355945a7c2fcc62a53a0004821b87e68f93048ffba7a55a3cb1e9783b\n    HG = H(0x01|H(SG)) = 0xaa5fbdf58264650eadec33691ba1e7606d0a62f570eea348a465c55bc86ffc10\n    HC = H(0x01|H(M)) = 0x70426d480d5b28d93c5be54803681f99abf4e8df4eab4dc87aaa543f0d138159\n    HD = H(0x0x|H(SH)) = 0x8482f6c9c3fe90dd4d533b4efedb6a241b95ec9267d1bd5aaaee36d2ce2dd6da\n    HE = H(HA|HB) = 0x049b9f2f94f0a9bdea624e39cd7d6b27a365c6a0545bf0e9d88d86eff4894210\n    HH = H(HC|HD) = 0xc709fdc632f370f3367da45378d1cf430c5fda6805e731ad5761c213cf2d276e\n    HI = H(HE|HF) = 0xead5e1a1e7e41b77b794f091df9be3f0e9f41d47304eb43dece90688f69843b7\n    HJ = H(HG|HH) = 0xd00fc690c4700d0f983f9700740066531ea826b21a4cbc62f80317261723d477\n    Script Root = H(HI|HJ) = 0x26d5235d20daf1440a15a248f5b5b4f201392128072c55afa64a26ccc6f56bd9\n    MAST Root = H(MAST Version|Script Root) = H(0x0000000026d5235d20daf1440a15a248f5b5b4f201392128072c55afa64a26ccc6f56bd9) = 0xb4b706e0c02eab9aba58419eb7ea2a286fb1c01d7406105fc12742bf8a3f97c9\n\n\nThe scriptPubKey with native witness program is:\n\n  1 <0xb4b706e0c02eab9aba58419eb7ea2a286fb1c01d7406105fc12742bf8a3f97c9>\n  (0x5120b4b706e0c02eab9aba58419eb7ea2a286fb1c01d7406105fc12742bf8a3f97c9)\n\n\nTo redeem with the <code>SD|SE|SF</code> branch, the witness is\n\n  Script_stack_1: 0x06\n  Script_stack_2: 0x05\n  Script_stack_3: 0x04\n  Subscript_1:    0x5488\n  Subscript_2:    0x5588\n  Subscript_3:    0x5688\n  Position:       0x01 (HF is the second hash in its level)\n  Path (HE|HJ):   0x049b9f2f94f0a9bdea624e39cd7d6b27a365c6a0545bf0e9d88d86eff4894210d00fc690c4700d0f983f9700740066531ea826b21a4cbc62f80317261723d477\n  Metadata:       0x03 (3 Subscript)\n\n\n\n=== Imbalance MAST ===\nWhen constructing a MAST, if the user believes that some of the branches are more likely to be executed, they may put them closer to the <code>Script Root</code>. It will save some witness space when the preferred branches are actually executed.\n\n=== Escrow with Timeout ===\nThe following is the \"Escrow with Timeout\" example in [[bip-0112.mediawiki|BIP112]]:\n    IF\n        2 <Alice's pubkey> <Bob's pubkey> <Escrow's pubkey> 3 CHECKMULTISIG\n    ELSE\n        \"30d\" CHECKSEQUENCEVERIFY DROP\n        <Alice's pubkey> CHECKSIG\n    ENDIF\n\nUsing compressed public key, the size of this script is 150 bytes.\n\nWith MAST, this script could be broken down into 2 mutually exclusive branches:<ref>In BIPXXX, it is proposed that CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY will pop the top stack item</ref>\n    2 <Alice's pubkey> <Bob's pubkey> <Escrow's pubkey> 3 CHECKMULTISIGVERIFY (105 bytes)\n    \"30d\" CHECKSEQUENCEVERIFY <Alice's pubkey> CHECKSIGVERIFY (42 bytes)\n\nSince only one branch will be published, it is more difficult for a blockchain analyst to determine the details of the escrow.\n\n=== Hashed Time-Lock Contract ===\nThe following is the \"Hashed TIme-Lock Contract\" example in [[bip-0112.mediawiki|BIP112]]:\n    HASH160 DUP <R-HASH> EQUAL\n    IF\n        \"24h\" CHECKSEQUENCEVERIFY\n        2DROP\n        <Alice's pubkey>\n    ELSE\n        <Commit-Revocation-Hash> EQUAL\n        NOTIF\n            \"Timestamp\" CHECKLOCKTIMEVERIFY DROP\n        ENDIF\n        <Bob's pubkey>\n    ENDIF\n    CHECKSIG\n\nTo create a MAST Root, it is flattened to 3 mutually exclusive branches:\n    HASH160 <R-HASH> EQUALVERIFY \"24h\" CHECKSEQUENCEVERIFY <Alice's pubkey> CHECKSIGVERIFY\n    HASH160 <Commit-Revocation-Hash> EQUALVERIFY <Bob's pubkey> CHECKSIGVERIFY\n    \"Timestamp\" CHECKLOCKTIMEVERIFY <Bob's pubkey> CHECKSIGVERIFY\n\nwhich significantly improves readability and reduces the witness size when it is redeemed.\n\n=== Large multi-signature constructs ===\nThe current CHECKMULTISIG supports up to 20 public keys. Although it is possible to extend it beyond 20 keys by using multiple CHECKSIGs and IF/ELSE conditions, the construction could be very complicated and soon use up the 10,000 bytes and 201 <code>nOpCount</code> limit.\n\nWith MAST, large and complex multi-signature constructs could be flattened to many simple CHECKMULTISIGVERIFY conditions. For example, a 3-of-2000 multi-signature scheme could be expressed as 1,331,334,000 3-of-3 CHECKMULTISIGVERIFY, which forms a 31-level MAST. The scriptPubKey still maintains a fixed size of 34 bytes, and the redemption witness will be very compact, with less than 1,500 bytes.\n\n=== Commitment of non-consensus enforced data ===\nCurrently, committing non-consensus enforced data in the scriptPubKey requires the use of OP_RETURN which occupies additional block space. With MAST, users may commit such data as a branch. Depends on the number of executable branches, inclusion of such a commitment may incur no extra witness space, or 32 bytes at most.\n\nAn useful case would be specifying \"message-signing keys\", which are not valid for spending, but allow users to sign any message without touching the cold storage \"funding key\".\n\n== Backward compatibility ==\nAs a soft fork, older software will continue to operate without modification. Non-upgraded nodes, however, will consider MAST programs as anyone-can-spend scripts. Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion.\n\n== Deployment ==\nThis BIP depends on [[bip-0141.mediawiki|BIP141]] and will be deployed by version-bits [[bip-0009.mediawiki|BIP9]] after BIP141 is enforced. Exact details TBD.\n\n== Credits ==\nThe idea of MAST originates from Russell O\u2019Connor, Pieter Wuille, and [https://bitcointalk.org/index.php?topic=255145.msg2757327#msg2757327 Peter Todd].\n\n== Reference Implementation ==\nhttps://github.com/jl2012/bitcoin/tree/bip114v2 (WIP)\n\n<source lang=\"cpp\">\n//New rules apply if version byte is 1 and witness program size is 32 bytes\nif (witversion == 1 && program.size() == 32 && (flags & SCRIPT_VERIFY_MAST)) {\n    CHashWriter sRoot(SER_GETHASH, 0);\n    CHashWriter sScriptHash(SER_GETHASH, 0);\n    uint32_t nMASTVersion = 0;\n    size_t stacksize = witness.stack.size();\n    if (stacksize < 4)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n    std::vector<unsigned char> metadata = witness.stack.back(); // The last witness stack item is metadata\n    if (metadata.size() < 1 || metadata.size() > 5)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n\n    // The first byte of metadata is the number of subscripts (1 to 255)\n    uint32_t nSubscript = static_cast<uint32_t>(metadata[0]);\n    if (nSubscript == 0 || stacksize < nSubscript + 3)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n    int nOpCount = nSubscript; // Each condition consumes a nOpCount\n    sScriptHash << metadata[0];\n\n    // The rest of metadata is MAST version in minimally-coded unsigned little endian int\n    if (metadata.back() == 0)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n    if (metadata.size() > 1) {\n        for (size_t i = 1; i != metadata.size(); ++i)\n            nMASTVersion |= static_cast<uint32_t>(metadata[i]) << 8 * (i - 1);\n    }\n\n    // Unknown MAST version is non-standard\n    if (nMASTVersion > 0 && flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n\n    sRoot << nMASTVersion;\n\n    // The second last witness stack item is the pathdata\n    // Size of pathdata must be divisible by 32 (0 is allowed)\n    // Depth of the Merkle tree is implied by the size of pathdata, and must not be greater than 32\n    std::vector<unsigned char> pathdata = witness.stack.at(stacksize - 2);\n    if (pathdata.size() & 0x1F)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n    unsigned int depth = pathdata.size() >> 5;\n    if (depth > 32)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n\n    // Each level of Merkle tree consumes a nOpCount\n    // Evaluation of version 0 MAST terminates early if there are too many nOpCount\n    // Not enforced in unknown MAST version for upgrade flexibility\n    nOpCount = nOpCount + depth;\n    if (nMASTVersion == 0 && nOpCount > MAX_OPS_PER_SCRIPT)\n        return set_error(serror, SCRIPT_ERR_OP_COUNT);\n\n    // path is a vector of 32-byte hashes\n    std::vector <uint256> path;\n    path.resize(depth);\n    for (unsigned int j = 0; j < depth; j++)\n        memcpy(path[j].begin(), &pathdata[32 * j], 32);\n\n    // The third last witness stack item is the positiondata\n    // Position is in minimally-coded unsigned little endian int\n    std::vector<unsigned char> positiondata = witness.stack.at(stacksize - 3);\n    if (positiondata.size() > 4)\n        return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n    uint32_t position = 0;\n    if (positiondata.size() > 0) {\n        if (positiondata.back() == 0)\n            return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n        for (size_t k = 0; k != positiondata.size(); ++k)\n            position |= static_cast<uint32_t>(positiondata[k]) << 8 * k;\n    }\n\n    // Position value must not exceed the number of leaves at the depth\n    if (depth < 32) {\n        if (position >= (1U << depth))\n            return set_error(serror, SCRIPT_ERR_INVALID_MAST_STACK);\n    }\n\n    // Sub-scripts are located before positiondata\n    for (size_t i = stacksize - nSubscript - 3; i <= stacksize - 4; i++) {\n        CScript subscript(witness.stack.at(i).begin(), witness.stack.at(i).end());\n\n        // Evaluation of version 0 MAST terminates early if script is oversize\n        // Not enforced in unknown MAST version for upgrade flexibility\n        if (nMASTVersion == 0 && (scriptPubKey.size() + subscript.size()) > MAX_SCRIPT_SIZE)\n            return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n        uint256 hashSubScript;\n        CHash256().Write(&subscript[0], subscript.size()).Finalize(hashSubScript.begin());\n        sScriptHash << hashSubScript;\n        scriptPubKey = scriptPubKey + subscript; // Final scriptPubKey is a serialization of subscripts\n    }\n    uint256 hashScript = sScriptHash.GetHash();\n\n    // Calculate MAST Root and compare against witness program\n    uint256 rootScript = ComputeMerkleRootFromBranch(hashScript, path, position);\n    sRoot << rootScript;\n    uint256 rootMAST = sRoot.GetHash();\n    if (memcmp(rootMAST.begin(), &program[0], 32))\n        return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n\n    if (nMASTVersion == 0) {\n        stack = std::vector<std::vector<unsigned char> >(witness.stack.begin(), witness.stack.end() - 3 - nSubscript);\n        for (unsigned int i = 0; i < stack.size(); i++) {\n            if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE)\n                return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n        }\n\n        // Script evaluation must not fail, and return an empty stack\n        if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V1, nOpCount, serror))\n            return false;\n        if (stack.size() != 0)\n            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n    }\n\n    return set_success(serror);\n}\n</source>\n\nCopying from <code>src/consensus/merkle.cpp</code>:\n<source lang=\"cpp\">\nuint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint256>& vMerkleBranch, uint32_t nIndex) {\n    uint256 hash = leaf;\n    for (std::vector<uint256>::const_iterator it = vMerkleBranch.begin(); it != vMerkleBranch.end(); ++it) {\n        if (nIndex & 1) {\n            hash = Hash(BEGIN(*it), END(*it), BEGIN(hash), END(hash));\n        } else {\n            hash = Hash(BEGIN(hash), END(hash), BEGIN(*it), END(*it));\n        }\n        nIndex >>= 1;\n    }\n    return hash;\n}\n</source>\n\n\n== References ==\n*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n\n== Copyright ==\nThis document is placed in the public domain.\n", "content_length": 23648}
{"bip_number": 113, "filename": "bip-0113.mediawiki", "content": "<pre>\n  BIP: 113\n  Layer: Consensus (soft fork)\n  Title: Median time-past as endpoint for lock-time calculations\n  Author: Thomas Kerin <me@thomaskerin.io>\n          Mark Friedenbach <mark@friedenbach.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0113\n  Status: Final\n  Type: Standards Track\n  Created: 2015-08-10\n  License: PD\n</pre>\n\n\n==Abstract==\n\nThis BIP is a proposal to redefine the semantics used in determining a\ntime-locked transaction's eligibility for inclusion in a block. The\nmedian of the last 11 blocks is used instead of the block's timestamp,\nensuring that it increases monotonically with each block.\n\n\n==Motivation==\n\nAt present, transactions are excluded from inclusion in a block if the\npresent time or block height is less than or equal to that specified\nin the locktime. Since the consensus rules do not mandate strict\nordering of block timestamps, this has the unfortunate outcome of\ncreating a perverse incentive for miners to lie about the time of\ntheir blocks in order to collect more fees by including transactions\nthat by wall clock determination have not yet matured.\n\nThis BIP proposes comparing the locktime against the median of the\npast 11 block's timestamps, rather than the timestamp of the block\nincluding the transaction. Existing consensus rules guarantee this\nvalue to monotonically advance, thereby removing the capability for\nminers to claim more transaction fees by lying about the timestamps of\ntheir block.\n\nThis proposal seeks to ensure reliable behaviour in locktime calculations\nas required by BIP65 (CHECKLOCKTIMEVERIFY) and matching the behavior of\nBIP68 (sequence numbers) and BIP112 (CHECKSEQUENCEVERIFY).\n\n\n==Specification==\n\nThe values for transaction locktime remain unchanged. The difference is only in\nthe calculation determining whether a transaction can be included. Instead of\nan unreliable timestamp, the following function is used to determine the current\nblock time for the purpose of checking lock-time constraints:\n\n    enum { nMedianTimeSpan=11 };\n\n    int64_t GetMedianTimePast(const CBlockIndex* pindex)\n    {\n        int64_t pmedian[nMedianTimeSpan];\n        int64_t* pbegin = &pmedian[nMedianTimeSpan];\n        int64_t* pend = &pmedian[nMedianTimeSpan];\n        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n             *(--pbegin) = pindex->GetBlockTime();\n        std::sort(pbegin, pend);\n        return pbegin[(pend - pbegin)/2];\n    }\n\nLock-time constraints are checked by the consensus method IsFinalTx().\nThis method takes the block time as one parameter. This BIP proposes\nthat after activation calls to IsFinalTx() within consensus code use\nthe return value of `GetMedianTimePast(pindexPrev)` instead.\n\nThe new rule applies to all transactions, including the coinbase transaction.\n\nA reference implementation of this proposal is provided by the\nfollowing pull request:\n\nhttps://github.com/bitcoin/bitcoin/pull/6566\n\n\n==Deployment==\n\nThis BIP is to be deployed by \"versionbits\" BIP9 using bit 0.\n\nFor Bitcoin '''mainnet''', the BIP9 '''starttime''' will be midnight 1st May 2016 UTC (Epoch timestamp 1462060800) and BIP9 '''timeout''' will be midnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nFor Bitcoin '''testnet''', the BIP9 '''starttime''' will be midnight 1st March 2016 UTC (Epoch timestamp 1456790400) and BIP9 '''timeout''' will be midnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nThis BIP must be deployed simultaneously with BIP68 and BIP112 using the same deployment mechanism.\n\n\n==Acknowledgements==\n\nMark Friedenbach for designing and authoring the reference\nimplementation of this BIP.\n\nThanks go to Gregory Maxwell who came up with the original idea,\nin #bitcoin-wizards on 2013-07-16.\n\nThomas Kerin authored this BIP document.\n\n\n==Compatibility==\n\nTransactions generated using time-based lock-time will take\napproximately an hour longer to confirm than would be expected under\nthe old rules. This is not known to introduce any compatibility\nconcerns with existing protocols.\n\n\n==References==\n\n[https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki BIP9: Versionbits]\n\n[https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP65: OP_CHECKLOCKTIMEVERIFY]\n\n[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP68: Consensus-enforced transaction replacement signaled via sequence numbers]\n\n[https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP112: CHECKSEQUENCEVERIFY]\n\n[http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010396.html Softfork deployment considerations]\n\n[https://gist.github.com/sipa/bf69659f43e763540550 Version bits]\n\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 4760}
{"bip_number": 112, "filename": "bip-0112.mediawiki", "content": "<pre>\n  BIP: 112\n  Layer: Consensus (soft fork)\n  Title: CHECKSEQUENCEVERIFY\n  Author: BtcDrak <btcdrak@gmail.com>\n          Mark Friedenbach <mark@friedenbach.org>\n          Eric Lombrozo <elombrozo@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0112\n  Status: Final\n  Type: Standards Track\n  Created: 2015-08-10\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP describes a new opcode (CHECKSEQUENCEVERIFY) for the Bitcoin\nscripting system that in combination with BIP 68 allows execution\npathways of a script to be restricted based on the age of the output\nbeing spent.\n\n\n==Summary==\n\nCHECKSEQUENCEVERIFY redefines the existing NOP3 opcode.\nWhen executed, if any of the following conditions are true, the script interpreter will terminate with an error:\n\n* the stack is empty; or\n* the top item on the stack is less than 0; or\n* the top item on the stack has the disable flag (1 << 31) unset; and\n** the transaction version is less than 2; or\n** the transaction input sequence number disable flag (1 << 31) is set; or\n** the relative lock-time type is not the same; or\n** the top stack item is greater than the transaction input sequence (when masked according to the BIP68);\n\nOtherwise, script execution will continue as if a NOP had been executed.\n\nBIP 68 prevents a non-final transaction from being selected for inclusion in a block until the corresponding input has reached the specified age, as measured in block-height or block-time. By comparing the argument to CHECKSEQUENCEVERIFY against the nSequence field, we indirectly verify a desired minimum age of\nthe output being spent; until that relative age has been reached any script execution pathway including the CHECKSEQUENCEVERIFY will fail to validate, causing the transaction not to be selected for inclusion in a block.\n\n\n==Motivation==\n\nBIP 68 repurposes the transaction nSequence field meaning by giving\nsequence numbers new consensus-enforced semantics as a relative\nlock-time. However, there is no way to build Bitcoin scripts to make\ndecisions based on this field.\n\nBy making the nSequence field accessible to script, it becomes\npossible to construct code pathways that only become accessible some\nminimum time after proof-of-publication. This enables a wide variety\nof applications in phased protocols such as escrow, payment channels,\nor bidirectional pegs.\n\n\n===Contracts With Expiration Deadlines===\n\n====Escrow with Timeout====\n\nAn escrow that times out automatically 30 days after being funded can be\nestablished in the following way. Alice, Bob and Escrow create a 2-of-3\naddress with the following redeemscript.\n\n    IF\n        2 <Alice's pubkey> <Bob's pubkey> <Escrow's pubkey> 3 CHECKMULTISIG\n    ELSE\n        \"30d\" CHECKSEQUENCEVERIFY DROP\n        <Alice's pubkey> CHECKSIG\n    ENDIF\n\nAt any time funds can be spent using signatures from any two of Alice,\nBob or the Escrow.\n\nAfter 30 days Alice can sign alone.\n\nThe clock does not start ticking until the payment to the escrow address\nconfirms.\n\n\n===Retroactive Invalidation===\n\nIn many instances, we would like to create contracts that can be revoked in case\nof some future event. However, given the immutable nature of the blockchain, it\nis practically impossible to retroactively invalidate a previous commitment that\nhas already confirmed. The only mechanism we really have for retroactive\ninvalidation is blockchain reorganization which, for fundamental security\nreasons, is designed to be very hard and very expensive to do.\n\nDespite this limitation, we do have a way to provide something functionally similar to retroactive invalidation while preserving irreversibility of past commitments\nusing CHECKSEQUENCEVERIFY. By constructing scripts with multiple branches of\nexecution where one or more of the branches are delayed we provide\na time window in which someone can supply an invalidation condition that allows the\noutput to be spent, effectively invalidating the would-be delayed branch and potentially discouraging\nanother party from broadcasting the transaction in the first place. If the invalidation\ncondition does not occur before the timeout, the delayed branch becomes spendable,\nhonoring the original contract.\n\nSome more specific applications of this idea:\n\n====Hash Time-Locked Contracts====\n\nHash Time-Locked Contracts (HTLCs) provide a general mechanism for off-chain contract negotiation. An execution pathway can be made to require knowledge of a secret (a hash preimage) that can be presented within an invalidation time window. By sharing the secret it is possible to guarantee to the counterparty that the transaction will never be broadcast since this would allow the counterparty to claim the output immediately while one would have to wait for the time window to pass. If the secret has not been shared, the counterparty will be unable to use the instant pathway and the delayed pathway must be used instead.\n\n====Bidirectional Payment Channels====\n\nScriptable relative locktime provides a predictable amount of time to respond in\nthe event a counterparty broadcasts a revoked transaction: Absolute locktime\nnecessitates closing the channel and reopen it when getting close to the timeout,\nwhereas with relative locktime, the clock starts ticking the moment the\ntransactions confirms in a block. It also provides a means to know exactly how\nlong to wait (in number of blocks) before funds can be pulled out of the channel\nin the event of a noncooperative counterparty.\n\n\n====Lightning Network====\n\nThe lightning network extends the bidirectional payment channel idea to allow for payments to be routed over multiple bidirectional payment channel hops.\n\nThese channels are based on an anchor transaction that requires a 2-of-2\nmultisig from Alice and Bob, and a series of revocable commitment\ntransactions that spend the anchor transaction.  The commitment\ntransaction splits the funds from the anchor between Alice and Bob and\nthe latest commitment transaction may be published by either party at\nany time, finalising the channel.\n\nIdeally then, a revoked commitment transaction would never be able to\nbe successfully spent; and the latest commitment transaction would be\nable to be spent very quickly.\n\nTo allow a commitment transaction to be effectively revoked, Alice\nand Bob have slightly different versions of the latest commitment\ntransaction. In Alice's version, any outputs in the commitment\ntransaction that pay Alice also include a forced delay, and an\nalternative branch that allows Bob to spend the output if he knows that\ntransaction's revocation code. In Bob's version, payments to Bob are\nsimilarly encumbered. When Alice and Bob negotiate new balances and\nnew commitment transactions, they also reveal the old revocation code,\nthus committing to not relaying the old transaction.\n\nA simple output, paying to Alice might then look like:\n\n    HASH160 <revokehash> EQUAL\n    IF\n        <Bob's pubkey>\n    ELSE\n        \"24h\" CHECKSEQUENCEVERIFY DROP\n        <Alice's pubkey>\n    ENDIF\n    CHECKSIG\n\nThis allows Alice to publish the latest commitment transaction at any\ntime and spend the funds after 24 hours, but also ensures that if Alice\nrelays a revoked transaction, that Bob has 24 hours to claim the funds.\n\nWith CHECKLOCKTIMEVERIFY, this would look like:\n\n    HASH160 <revokehash> EQUAL\n    IF\n        <Bob's pubkey>\n    ELSE\n        \"2015/12/15\" CHECKLOCKTIMEVERIFY DROP\n        <Alice's pubkey>\n    ENDIF\n    CHECKSIG\n\nThis form of transaction would mean that if the anchor is unspent on\n2015/12/16, Alice can use this commitment even if it has been revoked,\nsimply by spending it immediately, giving no time for Bob to claim it.\n\nThis means that the channel has a deadline that cannot be pushed\nback without hitting the blockchain; and also that funds may not be\navailable until the deadline is hit. CHECKSEQUENCEVERIFY allows you\nto avoid making such a tradeoff.\n\nHashed Time-Lock Contracts (HTLCs) make this slightly more complicated,\nsince in principle they may pay either Alice or Bob, depending on whether\nAlice discovers a secret R, or a timeout is reached, but the same principle\napplies -- the branch paying Alice in Alice's commitment transaction gets a\ndelay, and the entire output can be claimed by the other party if the\nrevocation secret is known. With CHECKSEQUENCEVERIFY, a HTLC payable to\nAlice might look like the following in Alice's commitment transaction:\n\n    HASH160 DUP <R-HASH> EQUAL\n    IF\n        \"24h\" CHECKSEQUENCEVERIFY\n        2DROP\n        <Alice's pubkey>\n    ELSE\n        <Commit-Revocation-Hash> EQUAL\n        NOTIF\n            \"2015/10/20 10:33\" CHECKLOCKTIMEVERIFY DROP\n        ENDIF\n        <Bob's pubkey>\n    ENDIF\n    CHECKSIG\n\nand correspondingly in Bob's commitment transaction:\n\n   HASH160 DUP <R-HASH> EQUAL\n   SWAP <Commit-Revocation-Hash> EQUAL ADD\n   IF\n       <Alice's pubkey>\n   ELSE\n       \"2015/10/20 10:33\" CHECKLOCKTIMEVERIFY\n       \"24h\" CHECKSEQUENCEVERIFY\n       2DROP\n       <Bob's pubkey>\n   ENDIF\n   CHECKSIG\n\nNote that both CHECKSEQUENCEVERIFY and CHECKLOCKTIMEVERIFY are used in the\nfinal branch of above to ensure Bob cannot spend the output until after both\nthe timeout is complete and Alice has had time to reveal the revocation\nsecret.\n\nSee the [https://github.com/ElementsProject/lightning/blob/master/doc/miscellaneous/deployable-lightning.pdf Deployable Lightning] paper.\n\n\n====2-Way Pegged Sidechains====\n\nThe 2-way pegged sidechain requires a new REORGPROOFVERIFY opcode, the semantics of which are outside the scope of this BIP. CHECKSEQUENCEVERIFY is used to make sure that sufficient time has passed since the return peg was posted to publish a reorg proof:\n\n    IF\n        lockTxHeight <lockTxHash> nlocktxOut [<workAmount>] reorgBounty Hash160(<...>) <genesisHash> REORGPROOFVERIFY\n    ELSE\n        withdrawLockTime CHECKSEQUENCEVERIFY DROP HASH160 p2shWithdrawDest EQUAL\n    ENDIF\n\n\n==Specification==\n\nRefer to the reference implementation, reproduced below, for the precise\nsemantics and detailed rationale for those semantics.\n\n<pre>\n/* Below flags apply in the context of BIP 68 */\n/* If this flag set, CTxIn::nSequence is NOT interpreted as a\n * relative lock-time. */\nstatic const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/* If CTxIn::nSequence encodes a relative lock-time and this flag\n * is set, the relative lock-time has units of 512 seconds,\n * otherwise it specifies blocks with a granularity of 1. */\nstatic const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/* If CTxIn::nSequence encodes a relative lock-time, this mask is\n * applied to extract that lock-time from the sequence field. */\nstatic const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\ncase OP_NOP3:\n{\n    if (!(flags & SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n        // not enabled; treat as a NOP3\n        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n        }\n        break;\n    }\n\n    if (stack.size() < 1)\n       return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n\n    // Note that elsewhere numeric opcodes are limited to\n    // operands in the range -2**31+1 to 2**31-1, however it is\n    // legal for opcodes to produce results exceeding that\n    // range. This limitation is implemented by CScriptNum's\n    // default 4-byte limit.\n    //\n    // Thus as a special case we tell CScriptNum to accept up\n    // to 5-byte bignums, which are good until 2**39-1, well\n    // beyond the 2**32-1 limit of the nSequence field itself.\n    const CScriptNum nSequence(stacktop(-1), fRequireMinimal, 5);\n\n    // In the rare event that the argument may be < 0 due to\n    // some arithmetic being done first, you can always use\n    // 0 MAX CHECKSEQUENCEVERIFY.\n    if (nSequence < 0)\n        return set_error(serror, SCRIPT_ERR_NEGATIVE_LOCKTIME);\n\n    // To provide for future soft-fork extensibility, if the\n    // operand has the disabled lock-time flag set,\n    // CHECKSEQUENCEVERIFY behaves as a NOP.\n    if ((nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0)\n        break;\n\n    // Compare the specified sequence number with the input.\n    if (!checker.CheckSequence(nSequence))\n        return set_error(serror, SCRIPT_ERR_UNSATISFIED_LOCKTIME);\n\n    break;\n}\n\nbool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) const\n{\n    // Relative lock times are supported by comparing the passed\n    // in operand to the sequence number of the input.\n    const int64_t txToSequence = (int64_t)txTo->vin[nIn].nSequence;\n\n    // Fail if the transaction's version number is not set high\n    // enough to trigger BIP 68 rules.\n    if (static_cast<uint32_t>(txTo->nVersion) < 2)\n        return false;\n\n    // Sequence numbers with their most significant bit set are not\n    // consensus constrained. Testing that the transaction's sequence\n    // number do not have this bit set prevents using this property\n    // to get around a CHECKSEQUENCEVERIFY check.\n    if (txToSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG)\n        return false;\n\n    // Mask off any bits that do not have consensus-enforced meaning\n    // before doing the integer comparisons\n    const uint32_t nLockTimeMask = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | CTxIn::SEQUENCE_LOCKTIME_MASK;\n    const int64_t txToSequenceMasked = txToSequence & nLockTimeMask;\n    const CScriptNum nSequenceMasked = nSequence & nLockTimeMask;\n\n    // There are two kinds of nSequence: lock-by-blockheight\n    // and lock-by-blocktime, distinguished by whether\n    // nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n    //\n    // We want to compare apples to apples, so fail the script\n    // unless the type of nSequenceMasked being tested is the same as\n    // the nSequenceMasked in the transaction.\n    if (!(\n        (txToSequenceMasked <  CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked <  CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) ||\n        (txToSequenceMasked >= CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG)\n    ))\n        return false;\n\n    // Now that we know we're comparing apples-to-apples, the\n    // comparison is a simple numeric one.\n    if (nSequenceMasked > txToSequenceMasked)\n        return false;\n\n    return true;\n}\n</pre>\n\n==Reference Implementation==\n\nA reference implementation is provided by the following pull request:\n\nhttps://github.com/bitcoin/bitcoin/pull/7524\n\n\n==Deployment==\n\nThis BIP is to be deployed by \"versionbits\" BIP9 using bit 0.\n\nFor Bitcoin '''mainnet''', the BIP9 '''starttime''' will be midnight 1st May 2016 UTC (Epoch timestamp 1462060800) and BIP9 '''timeout''' will be midnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nFor Bitcoin '''testnet''', the BIP9 '''starttime''' will be midnight 1st March 2016 UTC (Epoch timestamp 1456790400) and BIP9 '''timeout''' will be midnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nThis BIP must be deployed simultaneously with BIP68 and BIP113 using the same deployment mechanism.\n\n==Credits==\n\nMark Friedenbach invented the application of sequence numbers to\nachieve relative lock-time, and wrote the reference implementation of\nCHECKSEQUENCEVERIFY.\n\nThe reference implementation and this BIP was based heavily on work\ndone by Peter Todd for the closely related BIP 65.\n\nBtcDrak authored this BIP document.\n\nThanks to Eric Lombrozo and Anthony Towns for contributing example use cases.\n\n\n==References==\n\n[https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki BIP 9] Versionbits\n\n[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP 68] Relative lock-time through consensus-enforced sequence numbers\n\n[https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP 65] OP_CHECKLOCKTIMEVERIFY\n\n[https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki BIP 113] Median past block time for time-lock constraints\n\n[http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-July/000021.html HTLCs using OP_CHECKSEQUENCEVERIFY/OP_LOCKTIMEVERIFY and revocation hashes]\n\n[http://lightning.network/lightning-network-paper.pdf Lightning Network]\n\n[https://github.com/ElementsProject/lightning/blob/master/doc/miscellaneous/deployable-lightning.pdf Deployable Lightning]\n\n[http://diyhpl.us/diyhpluswiki/transcripts/sf-bitcoin-meetup/2015-02-23-scaling-bitcoin-to-billions-of-transactions-per-day/ Scaling Bitcoin to Billions of Transactions Per Day]\n\n[http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010396.html Softfork deployment considerations]\n\n[https://web.archive.org/web/20210925124425/https://gist.github.com/sipa/bf69659f43e763540550 Version bits]\n\n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html Jeremy Spilman Micropayment Channels]\n\n\n==Copyright==\n\nThis document is placed in the public domain.\n\n\n", "content_length": 16830}
{"bip_number": 111, "filename": "bip-0111.mediawiki", "content": "<pre>\n  BIP: 111\n  Layer: Peer Services\n  Title: NODE_BLOOM service bit\n  Author: Matt Corallo <bip111@bluematt.me>\n          Peter Todd <pete@petertodd.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0111\n  Status: Final\n  Type: Standards Track\n  Created: 2015-08-20\n  License: PD\n</pre>\n\n== Abstract ==\n\nThis BIP extends BIP 37, Connection Bloom filtering, by defining a\nservice bit to allow peers to advertise that they support bloom filters\nexplicitly. It also bumps the protocol version to allow peers to\nidentify old nodes which allow bloom filtering of the connection despite\nlacking the new service bit.\n\n\n== Motivation ==\n\nBIP 37 did not specify a service bit for the bloom filter service, thus\nimplicitly assuming that all nodes that serve peers data support it.\nHowever, the connection filtering algorithm proposed in BIP 37, and\nimplemented in several clients today, has been shown to provide little\nto no privacy<ref>http://eprint.iacr.org/2014/763</ref>, as well as being a large DoS risk on some nodes<ref>[http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-July/003044.html] is one example where the issues were found, though others independently discovered issues as well. Sample DoS exploit code available at https://github.com/petertodd/bloom-io-attack.</ref>.\nThus, allowing node operators to disable connection bloom filtering is a\nmuch-needed feature.\n\n\n== Specification ==\n\nThe following protocol bit is added:\n\n<pre>\n    NODE_BLOOM = (1 << 2)\n</pre>\n\nNodes which support bloom filters should set that protocol bit.\nOtherwise it should remain unset. In addition the protocol version is\nincreased from 70002 to 70011 in the reference implementation. It is\noften the case that nodes which have a protocol version smaller than\n70011, but larger than 70000 support bloom filtered connections without\nthe NODE_BLOOM bit set, however clients which require bloom filtered\nconnections should avoid making this assumption.\n\nNODE_BLOOM is distinct from NODE_NETWORK, and it is legal to advertise\nNODE_BLOOM but not NODE_NETWORK (though there is little reason to do\nso now, some proposals may make this more useful in the future)\n\nIf a node does not support bloom filters but receives a \"filterload\",\n\"filteradd\", or \"filterclear\" message from a peer the node should\ndisconnect that peer immediately. For backwards compatibility, in\ninitial implementations, nodes may choose to only disconnect nodes which\nhave the new protocol version set and attempt to send a filter command.\n\nWhile outside the scope of this BIP it is suggested that DNS seeds and\nother peer discovery mechanisms support the ability to specify the\nservices required; current implementations simply check only that\nNODE_NETWORK is set.\n\n\n== Design rational ==\n\nA service bit was chosen as applying a bloom filter is a service.\n\nThe increase in protocol version is for backwards compatibility. In\ninitial implementations, old nodes which are not yet aware of NODE_BLOOM\nand use a protocol version < 70011 may still send filter messages to a\nnode without NODE_BLOOM. This feature may be removed after there are\nsufficient NODE_BLOOM nodes available and SPV clients have upgraded,\nallowing node operators to fully close the bloom-related DoS vectors.\n\n\n== Reference Implementation ==\n\nhttps://github.com/bitcoin/bitcoin/pull/6579\n\n\n== Copyright ==\n\nThis document is placed in the public domain.\n\n\n== References ==\n<references>\n", "content_length": 3473}
{"bip_number": 109, "filename": "bip-0109.mediawiki", "content": "<pre>\n  BIP: 109\n  Layer: Consensus (hard fork)\n  Title: Two million byte size limit with sigop and sighash limits\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0109\n  Status: Rejected\n  Type: Standards Track\n  Created: 2016-01-28\n  License: PD\n</pre>\n\n==Abstract==\n\nOne-time increase in total amount of transaction data permitted in a block from 1MB to 2MB, with limits on signature operations and hashing.\n\n==Motivation==\n\n# Continue current economic policy.\n# Exercise hard fork network upgrade.\n# Mitigate potential CPU exhaustion attacks\n\n==Specification==\n\n=== MAX_BLOCK_SIZE increased to 2,000,000 bytes ===\n\nThe maximum number of bytes in a canonically serialized block shall be increased from\n1,000,000 bytes to 2,000,000 bytes.\n\n=== Switch to accurately-counted sigop limit of 20,000 per block ===\n\nThe existing MAX_SIGOPS limit of 20,000 signature operations per block shall be retained,\nbut only ECDSA verifications actually performed to validate the block shall be counted.\n\nIn particular:\n\n* The coinbase scriptSig is not counted\n* Signature operations in un-executed branches of a Script are not counted\n* OP_CHECKMULTISIG evaluations are counted accurately; if the signature for a 1-of-20 OP_CHECKMULTISIG is satisfied by the public key nearest the top of the execution stack, it is counted as one signature operation. If it is satisfied by the public key nearest the bottom of the execution stack, it is counted as twenty signature operations.\n* Signature operations involving invalidly encoded signatures or public keys are not counted towards the limit\n\n=== Add a new limit of 1,300,000,000 bytes hashed to compute transaction signatures per block ===\n\nThe amount of data hashed to compute signature hashes is limited to 1,300,000,000 bytes per block. The same rules for counting are used as for counting signature operations.\n\n=== Activation: 75% hashpower support trigger, followed by 28-day 'grace period' ===\n\nSolo miners or mining pool operators express their support for this BIP by setting the fourth-highest-bit in the block's 32-bit version number (0x10000000 in hex). The first block with that bit set, a timestamp less than or equal to the expiration time, and with at least 750 out of 1000 blocks preceding it (with heights H-1000..H-1) with that bit set, shall define the beginning of a grace period. Blocks with timestamps greater than or equal to the triggering block's timestamp plus 28 days (60*60*24*28 seconds) shall be subject to the new limits.\n\nAs always, miners are expected to use their best judgement for what is best for the entire Bitcoin ecosystem when making decisions about what consensus-level changes to support.\n\n=== Expiration: 1-Jan-2018 ===\n\nIf this BIP is not triggered before 1-Jan-2018 00:00:00 GMT it should be considered withdrawn.\n\nMiners that support this BIP should set bit 0x10000000 in the block version until 1-Jan-2018. After that date, that bit can be safely re-used for future consensus rule upgrades.\n\n==Backward compatibility==\n\nFully validating older clients are not compatible with this change.\nThe first block exceeding the old limits on block size or inaccurately counted signature operations will partition older clients off the new network.\n\nSPV (simple payment validation) wallets are compatible with this change.\n\n==Rationale==\n\nIn the short term, an increase is needed to handle increasing transaction volume.\n\nThe limits on signature operations and amount of signature hashing done prevent possible CPU exhaustion attacks by \"rogue miners\" producing very expensive-to-validate two megabyte blocks. The signature hashing limit is chosen to be impossible to reach with any non-attack transaction or block, to minimize the impact on existing mining or wallet software.\n\nThe choices of constants for the deployment scheme were motivated by prior experience with upgrades to the Bitcoin consensus rules:\n\n* 0x10000000 was chosen to be compatible with the BIP 9 proposal for parallel deployment of soft forks\n* 75% was chosen instead of 95% to minimize the opportunity for a single large mining pool or miner to be able to veto an increase, either because of ideological opposition or threat of violence or extortion.\n* A four-week grace period after the voting period was chosen as a balance between giving people sufficient time to upgrade and keeping people's attention on the urgent need to upgrade.\n\n==Implementation==\n\nhttps://github.com/gavinandresen/bitcoin-git/tree/two_mb_bump\n\nSee also http://gavinandresen.ninja/a-guided-tour-of-the-2mb-fork\n\n==Copyright==\n\nThis work is placed in the public domain.\n", "content_length": 4695}
{"bip_number": 107, "filename": "bip-0107.mediawiki", "content": "<pre>\n  BIP: 107\n  Layer: Consensus (hard fork)\n  Title: Dynamic limit on the block size\n  Author: Washington Y. Sanchez <washington.sanchez@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0107\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-09-11\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP proposes a dynamic limit to the block size based on transaction volume.\n\n==Motivation==\n\nOver the next few years, large infrastructure investments will be made into:\n\n# Improving global network connectivity\n# Improving block propagation across the Bitcoin network\n# Layer 2 services and networks for off-chain transactions\n# General efficiency improvements to transactions and the blockchain\n\n* While there is a consensus between Bitcoin developers, miners, businesses and users that the block size needs to be increased, there is a lingering concern over the potential unintended consequences that may augment the trend towards network and mining centralization (largely driven by mining hardware such as ASICs) and thereby threaten the security of the network.\n* In contrast, failing to respond to elevated on-chain transaction volume may lead to a consumer-failure of Bitcoin, where ordinary users - having enjoyed over 6 years of submitting transactions on-chain at relatively low cost - will be priced out of blockchain with the emergence of a prohibitive 'fee market'.\n* These two concerns must be delicately balanced so that all users can benefit from a robust, scalable, and neutral network.\n\n==Specification==\n\n* Increases in the block size will occur in 2 phases\n* '''Phase 1'''\n** The block size will be increased similar to [[https://twitter.com/adam3us/status/636410827969421312|Adam Back's proposal]], as a safe runway prior to switching to Phase 2, while network and protocol infrastructure is improved\n** The schedule:\n*** ''2016-2017:'' 2 MB\n*** ''2018-2019:'' 4 MB\n*** ''2020:'' 6 MB\n* '''Phase 2'''\n** In 2020, the maximum block size will be increased dynamically according to sustained increases in transaction volume\n** Every 4032 blocks (~4 weeks), a CHECK will be performed to determine if a raise in the maximum block size should occur\n*** This calculates to a theoretical maximum of 13 increases per year\n** IF of the last >= 3025 blocks were >=60% full, the maximum block size will be increased by 10%\n** The maximum block size can only ever be increased, not decreased\n* The default <code>limitfreerelay</code> will also be raised in proportion to maximum block size increases\n** Transactions without fees can continue to be submitted and relayed on the network as per normal\n** <code>limitfreerelay</code> also helps counter attempts to trigger a block size increase by 'penny-flooding'\n\nFor example:\n* When the dynamic rules for increasing the block size go live on January 1st 2020, the starting maximum block size will be 6 MB\n* IF >=3025 blocks are >= 3.6 MB, the new maximum block size become 6.6 MB.\n* The theoretical maximum block size at the end of 2020 would be ~20.7 MB, assuming all 13 increases are triggered every 4 weeks by the end of the year.\n\n==Rationale==\n\n* '''Phase 1'''\n** This runway has a schedule for conservative increases to the block size in order to relieve transaction volume pressure while allowing network and protocol infrastructure improvements to be made, as well as layer 2 services to emerge\n* '''Phase 2'''\n** Why 60% full blocks?\n*** IF blocks are 60% full, they count as a ''vote'' towards increasing the block size\n*** If this parameter is too low, the trigger sensitivity may be too high and vulnerable to spam attacks or miner collusion\n*** Setting the parameter too high may set the trigger sensitivity too low, causing transaction delays that are trying to be avoided in the first place\n*** Between September 2013-2015, the standard deviation measured from average block size (n=730 data points from blockchain.info) was ~ 0.13 MB or 13% of the maximum block size\n**** If blocks needed to be 90% full before an increase were triggered, normal variance in the average block size would mean some blocks would be full before an increase could be triggered\n*** Therefore, we need a ''safe distance'' away from the maximum block size to avoid normal block size variance hitting the limit. The 60% level represents a 3 standard deviation distance from the limit.\n** Why 3025 blocks?\n*** The assessment period is 4032 blocks or ~ 4 weeks, with the threshold set as 4032 blocks/0.75 + 1\n*** Increases in the maximum block size should only occur after a sustained trend can be observed in order to:\n***# Demonstrate a market-driven secular elevation in the transaction volume\n***# Increase the cost to trigger an increase by spam attacks or miner collusion with zero fee transactions\n*** In other words, increases to the maximum block size must be conservative but meaningful to relieve transaction volume pressure in response to true market demand\n** Why 10% increase in the block size?\n*** Increases in the block size are designed to be conservative and in balance with the number of theoretical opportunities  to increase the block size per year\n*** Makes any resources spent for spam attacks or miner collusion relatively expensive to achieve a minor increase in the block size. A sustained attack would need to be launched that may be too costly, and ideally detectable by the community\n\n==Deployment==\nSimilar deployment model to BIP101:\n<blockquote>Activation is achieved when 750 of 1,000 consecutive blocks in the best chain have a version number with the first, second, third, and thirtieth bits set (0x20000007 in hex). The activation time will be the timestamp of the 750'th block plus a two week (1,209,600 second) grace period to give any remaining miners or services time to upgrade to support larger blocks.</blockquote>\n\n==Acknowledgements==\n\nThanks to Austin Williams, Brian Hoffman, Angel Leon, Bulukani Mlalazi, Chris Pacia, and Ryan Shea for their comments.\n\n==Copyright==\n\nThis work is placed in the public domain.\n", "content_length": 6070}
{"bip_number": 106, "filename": "bip-0106.mediawiki", "content": "<pre>\n  BIP: 106\n  Layer: Consensus (hard fork)\n  Title: Dynamically Controlled Bitcoin Block Size Max Cap\n  Author: Upal Chakraborty <bitcoin@upalc.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0106\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-08-24\n</pre>\n\n==Abstract==\n\nThis BIP proposes replacing the fixed one megabyte maximum block size with a dynamically controlled maximum block size that may increase or decrease with difficulty change depending on various network factors. I have two proposals regarding this...\n\ni. Depending only on previous block size calculation.\n\nii. Depending on previous block size calculation and previous Tx fee collected by miners.\n\n==Motivation==\n\nWith increased adoption, transaction volume on bitcoin network is bound to grow. If the one megabyte max cap is not changed to a flexible one which changes itself with changing network demand, then adoption will hamper and bitcoin's growth may choke up. Following graph shows the change in average block size since inception...\n\nhttps://blockchain.info/charts/avg-block-size?timespan=all&showDataPoints=false&daysAverageString=1&show_header=true&scale=0&address=\n\n==Specification==\n\n===Proposal 1 : Depending only on previous block size calculation===\n\n  If more than 50% of block's size, found in the first 2000 of the last difficulty period, is more than 90% MaxBlockSize\n      Double MaxBlockSize\n  Else if more than 90% of block's size, found in the first 2000 of the last difficulty period, is less than 50% MaxBlockSize\n      Half MaxBlockSize\n  Else\n      Keep the same MaxBlockSize\n\n===Proposal 2 : Depending on previous block size calculation and previous Tx fee collected by miners===\n\n  TotalBlockSizeInLastButOneDifficulty = Sum of all Block size of first 2008 blocks in last 2 difficulty period\n  TotalBlockSizeInLastDifficulty = Sum of all Block size of second 2008 blocks in last 2 difficulty period (This actually includes 8 blocks from last but one difficulty)\n\n  TotalTxFeeInLastButOneDifficulty = Sum of all Tx fees of first 2008 blocks in last 2 difficulty period\n  TotalTxFeeInLastDifficulty = Sum of all Tx fees of second 2008 blocks in last 2 difficulty period (This actually includes 8 blocks from last but one difficulty)\n\n  If ( ( (Sum of first 4016 block size in last 2 difficulty period)/4016 > 50% MaxBlockSize) AND (TotalTxFeeInLastDifficulty > TotalTxFeeInLastButOneDifficulty) AND (TotalBlockSizeInLastDifficulty > TotalBlockSizeInLastButOneDifficulty) )\n      MaxBlockSize = TotalBlockSizeInLastDifficulty * MaxBlockSize / TotalBlockSizeInLastButOneDifficulty\n  Else If ( ( (Sum of first 4016 block size in last 2 difficulty period)/4016 < 50% MaxBlockSize) AND (TotalTxFeeInLastDifficulty < TotalTxFeeInLastButOneDifficulty) AND (TotalBlockSizeInLastDifficulty < TotalBlockSizeInLastButOneDifficulty) )\n      MaxBlockSize = TotalBlockSizeInLastDifficulty * MaxBlockSize / TotalBlockSizeInLastButOneDifficulty\n  Else\n      Keep the same MaxBlockSize\n\n==Rationale==\n\nThese two proposals have been derived after discussion on [https://bitcointalk.org/index.php?topic=1154536.0 BitcoinTalk] and [http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010285.html bitcoin-dev mailing list]. The original idea and its evolution in the light of various arguments can be found [http://upalc.com/maxblocksize.php here].\n\n===Proposal 1 : Depending only on previous block size calculation===\n\nThis solution is derived directly from the indication of the problem. If transaction volume increases, then we will naturally see bigger blocks. On the contrary, if there are not enough transaction volume, but maximum block size is high, then only few blocks may sweep the mempool. Hence, if block size is itself taken into consideration, then maximum block size can most rationally be derived. Moreover, this solution not only increases, but also decreases the maximum block size, just like difficulty.\n\n===Proposal 2 : Depending on previous block size calculation and previous Tx fee collected by miners===\n\nThis solution takes care of stable mining subsidy. It will not increase maximum block size, if Tx fee collection is not increasing and thereby creating a Tx fee pressure on the market. On the other hand, though the block size max cap is dynamically controlled, it is very difficult to game by any party because the increase or decrease of block size max cap will take place in the same ratio of average block size increase or decrease.\n\n==Compatibility==\n\nThis is a hard-forking change to the Bitcoin protocol; anybody running code that fully validates blocks must upgrade before the activation time or they will risk rejecting a chain containing larger-than-one-megabyte blocks.\n\n==Other solutions considered==\n\n[http://gtf.org/garzik/bitcoin/BIP100-blocksizechangeproposal.pdf Making Decentralized Economic Policy] - by Jeff Garzik\n\n[https://bitcointalk.org/index.php?topic=1078521.0 Elastic block cap with rollover penalties] - by Meni Rosenfeld\n\n[https://github.com/bitcoin/bips/blob/master/bip-0101.mediawiki Increase maximum block size] - by Gavin Andresen\n\n[https://gist.github.com/sipa/c65665fc360ca7a176a6 Block size following technological growth] - by Pieter Wuille\n\n[https://lightning.network/lightning-network-paper.pdf The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments] - by Joseph Poon & Thaddeus Dryja\n\n==Deployment==\n\nIf consensus is achieved, deployment can be made at a future block number at which difficulty will change.\n", "content_length": 5558}
{"bip_number": 105, "filename": "bip-0105.mediawiki", "content": "<pre>\n  BIP: 105\n  Layer: Consensus (hard fork)\n  Title: Consensus based block size retargeting algorithm\n  Author: BtcDrak <btcdrak@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0105\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-08-21\n  License: PD\n</pre>\n\n==Abstract==\n\nA method of altering the maximum allowed block size of the Bitcoin protocol\nusing a consensus based approach.\n\n==Motivation==\n\nThere is a belief that Bitcoin cannot easily respond to raising the\nblocksize limit if popularity was to suddenly increase due to a mass adoption\ncurve, because co-ordinating a hard fork takes considerable time, and being\nunable to respond in a timely manner would irreparably harm the credibility of\nbitcoin.\n\nAdditionally, predetermined block size increases are problematic because they\nattempt to predict the future, and if too large could have unintended\nconsequences like damaging the possibility for a fee market to develop\nas block subsidy decreases substantially over the next 9 years; introducing\nor exacerbating mining attack vectors; or somehow affect the network in unknown\nor unpredicted ways. Since fixed changes are hard to deploy, the damage could be\nextensive.\n\nDynamic block size adjustments also suffer from the potential to be gamed by the\nlarger hash power.\n\nFree voting as suggested by BIP100 allows miners to sell their votes out of band\nat no risk, and enable the sponsor the ability to manipulate the blocksize.\nIt also provides a cost free method or the larger pools to vote in ways to\nmanipulate the blocksize such to disadvantage or attack smaller pools.\n\n\n==Rationale==\n\nBy introducing a cost to increase the block size ensures the mining community\nwill collude to increase it only when there is a clear necessity, and reduce it\nwhen it is unnecessary. Larger miners cannot force their wishes so easily\nbecause not only will they have to pay extra a difficulty target, then can be\ndownvoted at no cost by the objecting hash power.\n\nUsing difficulty as a penalty is better than a fixed cost in bitcoins because it\nis less predictable.\n\nIn order to prevent miners having complete control over blocksize, an upper\nlimit is required at protocol level. This feature ensures full nodes retain\ncontrol over consensus, remembering full nodes are the mechanism to keep miners\nhonest.\n\n\n==Specification==\n\nThe initial block size limit shall be 1MB.\n\nEach time a miner creates a block, they may vote to increase or decrease the\nblocksize by a maximum of 10% of the current block size limit. These votes will\nbe used to recalculate the new block size limit every 2016 blocks.\n\nVotes are cast using the block's coinbase transaction scriptSig.\n\nAs per BIP34, the coinbase transaction scriptSig starts with a push of the block\nheight. The next push is a little-endian number representing the preferred block\nsize in bytes. For example, 0x4c(OP_PUSHDATA1) 0x03(size of constant) 0x80 0x84 0x1e(2MB)\nor 0x4c(OP_PUSHDATA1) 0x04(size of constant) 0x80 0x96 0x98 0x00(10MB).\n\nIf a miner votes for an increase, the block hash must meet a difficulty target\nwhich is proportionally larger than the standard difficulty target based on the\npercentage increase they voted for.\n\nVotes proposing decreasing the block size limit do not need to meet a higher\ndifficulty target.\n\nMiners can vote for no change by voting for the current block size.\n\nFor blocks to be valid the blockhash must meet the required difficulty target\nfor the vote otherwise the block is invalid and will be rejected.\n\nEvery 2016 blocks, the block size limit will be recalculated by the median of\nall votes in the last 2016 blocks. This will redefine the block size limit for\nthe next 2016 blocks.\n\nBlocks that are larger than the calculated base block size limit are invalid and\nwill be rejected.\n\nThe base block size limit may not reduce below 1MB or increase above 8MB (the exact\nnumber for the upper limit requires further discussion).\n\n\n==Acknowledgements==\n\nThis proposal is based on ideas and concepts derived from the writings of\nMeni Rosenfeld and Gregory Maxwell.\n\n\n==References==\n\n[[bip-0034.mediawiki|BIP34]]\n\n==Copyright==\n\nThis work is placed in the public domain.\n", "content_length": 4232}
{"bip_number": 104, "filename": "bip-0104.mediawiki", "content": "<pre>\n  BIP: 104\n  Layer: Consensus (hard fork)\n  Title: 'Block75' - Max block size like difficulty\n  Author: t.khan <teekhan42@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0104\n  Status: Rejected\n  Type: Standards Track\n  Created: 2017-01-13\n  License: BSD-2-Clause\n           GNU-All-Permissive\n</pre>\n\n==Abstract==\n\nAutomatic adjustment of max block size with the target of keeping blocks 75% full, based on the average block size of the previous 2016 blocks. This would be done on the same schedule as difficulty.\n\n==Motivation==\n\nBlocks are already too full and cannot support further transaction growth. While SegWit and Lightning (and other off-chain solutions) will help, they will not solve this problem.\n\nBitcoin needs a reasonably effective and predictable way of managing the maximum block size which allows moderate growth, keeps max block size as small as possible, and prevents wild swings in transaction fees.\n\nThe every two-week and automatic adjustment of difficulty has proven to be a reasonably effective and predictable way of managing how quickly blocks are mined. It works well because humans aren\u2019t involved  (except for setting the original target of a 10 minute per block average), and therefore it isn\u2019t political or contentious. It\u2019s simply a response to changing network resources.\n\nIt\u2019s clear at this point that human beings should not be involved in the determination of max block size, just as they\u2019re not involved in deciding the difficulty. Therefore, it is logical and consistent with Bitcoin\u2019s design to implement a permanent solution which, as with the difficulty adjustment, is simply an automatic response to changing transaction volumes. With the target of keeping blocks 75% full on average, this is the goal of Block75.\n\n\n==Specification==\n\nThe max block size will be recalculated every 2016 blocks, along with difficulty, using Block75\u2019s simple algorithm:\n\n<code>\nnew max block size = x + (x * (AVERAGE_CAPACITY - TARGET_CAPACITY))\n</code>\n\n* TARGET_CAPACITY = 0.75\u00a0 \u00a0 //Block75's target of keeping blocks 75% full\n* AVERAGE_CAPACITY = average percentage full of the last 2016 blocks, as a decimal\n* x = current max block size\n\n\nAll code which generates/validates blocks or uses/references the current hardcoded limits will need to be changed to support Block75.\n\n==Rationale==\n\nThe 75% full block target was selected because:\n* it is the middle ground between blocks being too small (average 100% full) and blocks being unnecessarily large (average 50% full)\n* it can handle short-term spikes in transaction volume of up to 33%\n* it limits the growth of max block size to less than 25% over the previous period\n* it will maintain average transaction fees at a stable level similar to that of May/June 2016\n\nThe 2016 block (~2 weeks) period was selected because:\n* it has been shown to be reasonably adaptive to changing network resources (re: difficulty)\n* the frequent and gradual adjustments that result will be relatively easy for miners and node operators to predict and adapt to, as any unforeseen consequences will be visible well in advance\n* it minimizes any effect a malicious party could have in an attempt to manipulate max block size\n\nThe Block75 algorithm will adjust the max block size up and down in response to transaction volume, including changes brought on by SegWit and Lightning. This is important as it will keep average transaction fees stable, thereby allowing miners and businesses using Bitcoin more certainty regarding future income/expenses.\n\n==Other solutions considered==\nA hardcoded increase to max block size (2MB, 8MB, etc.), rejected because:\n* only a temporary solution, whatever limit was chosen would inevitably become a problem again\n* would cause transaction fees to vary wildly over time\n\nAllow miners to vote for max block size, rejected because:\n* overly complex and political\n* human involvement makes this slow to respond to changing transaction volumes\n* focuses power over max block size to a relatively small group of people\n* unpredictable transaction fees caused by this would create uncertainty in the ecosystem\n\n==Backward Compatibility==\nThis BIP is not backward compatible (hard fork). Any code which fully validates blocks must be upgraded prior to activation, as failure to do so will result in rejection of blocks over the current 1MB limit.\n\n==Activation==\nTo help negate some of the risks associated with a hard fork and to prevent a single relatively small mining pool from preventing Block75's adoption, activation would occur at the next difficulty adjustment once 900 of the last 1,000 blocks mined signal support and a grace period of 4,032 blocks (~1 month) has elapsed.\n\n==Copyright==\nThis BIP is dual-licensed under the BSD 2-clause license and the GNU All-Permissive License.\n", "content_length": 4856}
{"bip_number": 103, "filename": "bip-0103.mediawiki", "content": "<pre>\n  BIP: 103\n  Layer: Consensus (hard fork)\n  Title: Block size following technological growth\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0103\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2015-07-21\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP proposes a block size growth intended to accommodate for hardware and other technological improvements for the foreseeable future.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nMany people want to see Bitcoin scale over time, allowing an increasing number of transactions on the block chain. It would come at an increased cost for the ecosystem (bandwidth, processing, and storage for relay nodes, as well as an impact on propagation speed of blocks on the network), but technology also improves over time. When all technologies depended on have improved as well as their availability on the market, there is no reason why Bitcoin's fundamental transaction rate cannot improve proportionally.\n\nCurrently, there is a consensus rule in place that limits the size of blocks to 1000000 bytes. Changing this requires a hard-forking change: one that will require every full node in the network to implement the new rules. The new chain created by those changed nodes will be rejected by old nodes, so this would effectively be a request to the ecosystem to migrate to a new and incompatible network. Doing this while controversy exists is dangerous to the network and the ecosystem.\n\nFurthermore, the effective space available is always constrained by a hash rate majority and its ability to process transactions. No hard forking change that relaxes the block size limit can be guaranteed to provide enough space for every possible demand - or even any particular demand - unless strong centralization of the mining ecosystem is expected. Because of that, the development of a fee market and the evolution towards an ecosystem that is able to cope with block space competition should be considered healthy. This does not mean the block size or its limitation needs to be constant forever. However, the purpose of such a change should be evolution with technological growth, and not kicking the can down the road because of a fear of change in economics.\n\nBitcoin's advantage over other systems does not lie in scalability. Well-designed centralized systems can trivially compete with Bitcoin's on-chain transactions in terms of cost, speed, reliability, convenience, and scale. Its power lies in transparency, lack of need for trust in network peers, miners, and those who influence or control the system. Wanting to increase the scale of the system is in conflict with all of those. Attempting to buy time with a fast increase is not wanting to face that reality, and treating the system as something whose scale trumps all other concerns. A long term scalability plan should aim on decreasing the need for trust required in off-chain systems, rather than increasing the need for trust in Bitcoin.\n\nIn summary, hard forks are extremely powerful, and we need to use them very responsibly as a community. They have the ability to fundamentally change the technology or economics of the system, and can be used to disadvantage those who expected certain rules to be immutable. They should be restricted to uncontroversial changes, or risk eroding the expectation of low trust needed in the system in the longer term. As the block size debate has been controversial so far - for good or bad reasons - this BIP aims for gradual change and its effects start far enough in the future.\n\n==Specification==\n\nThe block size limitation is replaced by the function below, applied to the median of the timestamps of the previous 11 blocks, or in code terms: the block size limit for pindexBlock is GetMaxBlockSize(pindexBlock->pprev->GetMedianTimePast()).\n\nThe sigop limit scales proportionally.\n\nIt implements a series of block size steps, one every ~97 days, between January 2017 and July 2063, each increasing the maximum block size by 4.4%. This allows an overall growth of 17.7% per year.\n\n<pre>\nuint32_t GetMaxBlockSize(int64_t nMedianTimePast) {\n    // The first step is on January 1st 2017.\n    if (nMedianTimePast < 1483246800) {\n        return 1000000;\n    }\n    // After that, one step happens every 2^23 seconds.\n    int64_t step = (nMedianTimePast - 1483246800) >> 23;\n    // Don't do more than 11 doublings for now.\n    step = std::min<int64_t>(step, 175);\n    // Every step is a 2^(1/16) factor.\n    static const uint32_t bases[16] = {\n        // bases[i] == round(1000000 * pow(2.0, (i + 1) / 16.0))\n        1044274, 1090508, 1138789, 1189207,\n        1241858, 1296840, 1354256, 1414214,\n        1476826, 1542211, 1610490, 1681793,\n        1756252, 1834008, 1915207, 2000000\n    };\n    return bases[step & 15] << (step / 16);\n}\n</pre>\n\n==Rationale==\n\nWaiting 1.5 years before the hard fork takes place should provide ample time to minimize the risk of a hard fork, if found uncontroversial.\n\nBecause every increase (including the first) is only 4.4%, risk from large market or technological changes is minimized.\n\nThe growth rate of 17.7% growth per year is consistent with the average growth rate of bandwidth the last years, which seems to be the bottleneck. If over time, this growth factor is beyond what the actual technology offers, the intention should be to soft fork a tighter limit.\n\nUsing a time-based check is very simple to implement, needs little context, is efficient, and is trivially reviewable. Using the \"median time past\" guarantees monotonic behaviour, as this median is required to be increasing, according to Bitcoin's existing consensus rules. Using the \"median time past\" of the block before means we know in advance what the limit of each block will be, without depending on the actual block's timestamp.\n\n==Compatibility==\n\nThis is a hard forking change, thus breaks compatibility with old fully-validating node. It should not be deployed without widespread consensus.\n\n==Acknowledgements==\n\nThanks to Gregory Maxwell and Wladimir J. van der Laan for their suggestions.\n", "content_length": 6212}
{"bip_number": 102, "filename": "bip-0102.mediawiki", "content": "<pre>\n  BIP: 102\n  Layer: Consensus (hard fork)\n  Title: Block size increase to 2MB\n  Author: Jeff Garzik <jgarzik@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0102\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-06-23\n</pre>\n\n==Abstract==\n\nSimple, one-time increase in total amount of transaction data permitted in a block from 1MB to 2MB.\n\n==Motivation==\n\n# Continue current economic policy.\n# Exercise hard fork network upgrade.\n\n==Specification==\n\n# MAX_BLOCK_SIZE increased to 2,000,000 bytes at trigger point.\n# Increase maximum block sigops by similar factor, preserving SIZE/50 formula.\n# Trigger:  (1) Block time 00:00:00 on flag day, AND (2) 95% of the last 1,000 blocks have signaled support.\n\n==Backward compatibility==\n\nFully validating older clients are not compatible with this change.\nThe first block exceeding 1,000,000 bytes will partition older clients\noff the new network.\n\n==Discussion==\n\nIn the short term, an increase is needed to continue to current\neconomic policies with regards to fees and block space, matching\nmarket expectations and preventing market disruption.\n\nIn the long term, this limit should focus on reflecting the maximum\nnetwork engineering limit.\n\n==Implementation==\n\nhttps://github.com/jgarzik/bitcoin/tree/2015_2mb_blocksize\n\n", "content_length": 1350}
{"bip_number": 101, "filename": "bip-0101.mediawiki", "content": "<pre>\n  BIP: 101\n  Layer: Consensus (hard fork)\n  Title: Increase maximum block size\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0101\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2015-06-22\n</pre>\n\n==Abstract==\n\nThis BIP proposes replacing the fixed one megabyte maximum block size with a maximum size that grows over time at a predictable rate.\n\n==Motivation==\n\nTransaction volume on the Bitcoin network has been growing, and will soon reach the one-megabyte-every-ten-minutes limit imposed by the one megabyte maximum block size. Increasing the maximum size reduces the impact of that limit on Bitcoin adoption and growth.\n\n==Specification==\n\nAfter deployment (see the Deployment section for details), the maximum allowed size of a block on the main network shall be calculated based on the timestamp in the block header.\n\nThe maximum size shall be 8,000,000 bytes at a timestamp of 2016-01-11 00:00:00 UTC (timestamp 1452470400), and shall double every 63,072,000 seconds (two years, ignoring leap years), until 2036-01-06 00:00:00 UTC (timestamp 2083190400). The maximum size of blocks in between doublings will increase linearly based on the block's timestamp. The maximum size of blocks after 2036-01-06 00:00:00 UTC shall be 8,192,000,000 bytes.\n\nExpressed in pseudo-code, using integer math, assuming that block_timestamp is after the activation time (as described in the Deployment section below):\n\n    function max_block_size(block_timestamp):\n\n        time_start = 1452470400\n        time_double = 60*60*24*365*2\n        size_start = 8000000\n        if block_timestamp >= time_start+time_double*10\n            return size_start * 2^10\n\n        // Piecewise-linear-between-doublings growth:\n        time_delta = block_timestamp - time_start\n        doublings = time_delta / time_double\n        remainder = time_delta % time_double\n        interpolate = (size_start * 2^doublings * remainder) / time_double\n        max_size = size_start * 2^doublings + interpolate\n\n        return max_size\n\n==Deployment==\n\nDeployment shall be controlled by hash-power supermajority vote (similar to the technique used in BIP34), but the earliest possible activation time is 2016-01-11 00:00:00 UTC.\n\nActivation is achieved when 750 of 1,000 consecutive blocks in the best chain have a version number with the first, second, third, and thirtieth bits set (0x20000007 in hex). The activation time will be the timestamp of the 750'th block plus a two week (1,209,600 second) grace period to give any remaining miners or services time to upgrade to support larger blocks. If a supermajority is achieved more than two weeks before 2016-01-11 00:00:00 UTC, the activation time will be 2016-01-11 00:00:00 UTC.\n\nBlock version numbers are used only for activation; once activation is achieved, the maximum block size shall be as described in the specification section, regardless of the version number of the block.\n\n==Test network==\n\nTest network parameters are the same as the main network, except starting earlier with easier supermajority conditions and a shorter grace period:\n\n    starting time: 1 Aug 2015 (timestamp 1438387200)\n    activation condition: 75 of 100 blocks\n    grace period: 24 hours\n\n==Rationale==\n\nThe initial size of 8,000,000 bytes was chosen after testing the current reference implementation code with larger block sizes and receiving feedback from miners on bandwidth-constrained networks (in particular, Chinese miners behind the Great Firewall of China).\n\nThe doubling interval was chosen based on long-term growth trends for CPU power, storage, and Internet bandwidth. The 20-year limit was chosen because exponential growth cannot continue forever. If long-term trends do not continue, maximum block sizes can be reduced by miner consensus (a soft-fork).\n\nCalculations are based on timestamps and not blockchain height because a timestamp is part of every block's header. This allows implementations to know a block's maximum size after they have downloaded it's header, but before downloading any transactions.\n\nThe deployment plan is taken from Jeff Garzik's proposed BIP100 block size increase, and is designed to give miners, merchants, and full-node-running-end-users sufficient time to upgrade to software that supports bigger blocks. A 75% supermajority was chosen so that one large mining pool does not have effective veto power over a blocksize increase. The version number scheme is designed to be compatible with Pieter's Wuille's proposed \"Version bits\" BIP, and to not interfere with any other consensus rule changes in the process of being rolled out.\n\n==Objections to this proposal==\n\nRaising the 1MB block size has been [https://www.google.com/webhp?#q=1mb+limit+site%3Abitcointalk.org discussed and debated for years].\n\n===Centralization of full nodes===\n\nThe number of fully-validating nodes reachable on the network has been steadily declining. Increasing the capacity of the network to handle transactions by increasing the maximum block size may accelerate that decline, meaning a less distributed network that is more vulnerable to disruption. The size of this effect is debatable; the author of this BIP believes that the decline in fully validating nodes on the network is largely due to the availability of convenient, attractive, secure, lightweight wallet software and the general trend away from computing on desktop computers to mobile phones and tablets.\n\nIncreasing the capacity of the network to handle transactions should enable increased adoption by users and businesses, especially in areas of the world where existing financial infrastructure is weak. That could lead to a more robust network with nodes running in more political jurisdictions.\n\n===Centralization of mining: costs===\n\nMiners benefit from low-latency, high-bandwidth connections because they increase their chances of winning a \"block race\" (two or more blocks found at approximately the same time). With the current peer-to-peer networking protocol, announcing larger blocks requires more bandwidth. If the costs grow high enough, the result will be a very small number of very large miners.\n\nThe limits proposed by this BIP are designed so that running a fully validating node has very modest costs, which, if current trends in the cost of technology continue, will become even less expensive over time.\n\n===Centralization of mining: big-block attacks===\n\n[http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/008820.html Simulations show] that with the current peer-to-peer protocol, miners behind high-latency or low-bandwidth links are at a disadvantage compared to miners connected to a majority of hashpower via low-latency, high-bandwidth links. Larger blocks increase the advantage of miners with high-bandwidth connections, although that advantage can be minimized with changes to the way new blocks are announced (e.g. http://bitcoinrelaynetwork.org/ ).\n\nIf latency and bandwidth to other miners were the only variable that affected the profitability of mining, and miners were driven purely by profit, the end result would be one miner running on one machine, where latency was zero and bandwidth was essentially infinite.\n\nHowever, many other factors influence miner profitability, including cost of electricity and labor and real estate, ability to use waste heat productively, access to capital to invest in mining equipment, etc. Increasing the influence of bandwidth in the mining profitability equation will not necessarily lead to more centralization.\n\n===Unspent Transaction Output Growth===\n\nThis BIP makes no attempt to restrict the approximately 100% per-year growth in unspent transaction outputs (see http://gavinandresen.ninja/utxo-uhoh for details), because the author believe that problem should be solved by a further restriction on blocks described in a separate BIP (perhaps an additional limit on how much the transactions in any block may increase the UTXO set size).\n\n==Long-term fee incentives==\n\nhttp://gavinandresen.ninja/block-size-and-miner-fees-again\n\n==Other solutions considered==\n\nThere have been dozens of proposals for increasing the block size over the years. Some notable ideas:\n\n===One-time increase===\n\nA small, quick one-time increase to, for example, 2MB blocks, would be the most conservative option.\n\nHowever, a one-time increase requires just as much care in testing and deployment as a longer-term fix. And the entire debate over how large or small a limit is appropriate would be repeated as soon as the new limit was reached.\n\n===Dynamic limit proposals===\n\nBIP 100 proposes a dynamic limit determined by miner preferences expressed in coinbase transactions, with limits on the rate of growth. It gives miners more direct control over the maximum block size, which some people see as an advantage over this proposal and some see as a disadvantage. It is more complex to implement, because the maximum allowed size for a block depends on information contained in coinbase transactions from previous blocks (which may not be immediately known if block contents are being fetched out-of-order in a 'headers-first' mode).\n\n[https://bitcointalk.org/index.php?topic=1078521.0 Meni Rosenfeld has proposed] that miners sacrifice mining reward to \"pay for\" bigger blocks, so there is an incentive to create bigger blocks only if transaction fees cover the cost of creating a larger block. This proposal is significantly more complex to implement, and it is not clear if a set of parameters for setting the cost of making a block bigger can be found that is not equivalent to a centrally-controlled network-wide minimum transaction fee.\n\n==Compatibility==\n\nThis is a hard-forking change to the Bitcoin protocol; anybody running code that fully validates blocks must upgrade before the activation time or they will risk rejecting a chain containing larger-than-one-megabyte blocks.\n\nSimplified Payment Verification software is not affected, unless it makes assumptions about the maximum depth of a transaction's merkle branch based on the minimum size of a transaction and the maximum block size.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/6341\n\n", "content_length": 10262}
{"bip_number": 100, "filename": "bip-0100.mediawiki", "content": "<pre>\n  BIP: 100\n  Layer: Consensus (hard fork)\n  Title: Dynamic maximum block size by miner vote\n  Author: Jeff Garzik <jgarzik@gmail.com>\n          Tom Harding <tomh@thinlink.com>\n          Dagur Valberg Johannsson <dagurval@pvv.ntnu.no>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0100\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-06-11\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nReplace the static 1M block size hard limit with a hard limit set by coinbase vote, conducted on the same schedule as difficulty retargeting.\n\n==Motivation==\n\nMiners directly feel the effects, both positive and negative, of any maximum block size change imposed by their peers.  Larger blocks allow more growth in the on-chain ecosystem, while smaller blocks reduce resource requirements network-wide.  Miners also act as an efficient proxy for the rest of the ecosystem, since they are paid in the tokens collected for the blocks they create.\n\nA simple deterministic system is specified, whereby a 75% mining supermajority may activate a change to the maximum block size each 2016 blocks.  Each change is limited to a 5% increase from the previous block size hard limit, or a decrease of similar magnitude.  Among adopting nodes, there will be no disagreement on the evolution of the maximum block size.\n\nThe system is compatible with emergent consensus, but whereas under that system a miner may choose to accept any size block, a miner following BIP100 observes the 75% supermajority rule, and the 5% change limit rule.  Excessive-block values signaled by emergent consensus blocks are considered in the calculation of the BIP100 block size hard limit, and the BIP100 calculated maximum block size is signaled as an excessive-block value for the benefit of all observers.\n\n==Specification==\n\n===Dynamic Maximum Block Size===\n# Initial value of <code>hardLimit</code> is 1000000 bytes, preserving current system.\n# Changing <code>hardLimit</code> is accomplished by encoding a proposed value, a vote, within a block's coinbase scriptSig, and by processing the votes contained in the previous retargeting period.<br /><br />\n## Vote encoding\n### A vote is represented as a megabyte value using the BIP100 pattern<br /><br /><code>/BIP100/B[0-9]+/</code><br /><br />Example: <code>/BIP100/B8/</code> is a vote for a 8000000-byte <code>hardLimit</code>.<br /><br />\n### If the block height is encoded at the start of the coinbase scriptSig, as per BIP34, it is ignored.\n### Only the first BIP100 pattern match is processed in \"Maximum block size recalculation\" below.\n### A megabyte value is represented by consecutive base-ten digits.\n### If no BIP100 pattern is matched, the first matching emergent consensus pattern <code>/EB[0-9]+/</code>, if any, is accepted as the megabyte vote.<br /><br />\n## Maximum block size recalculation\n### A <code>new hardLimit</code> is calculated after each difficulty adjustment period of 2016 blocks, and applies to the next 2016 blocks.\n### Absent/zero-valued votes are counted as votes for the <code>current hardLimit</code>.\n### The votes of the previous 2016 blocks are sorted by megabyte vote.\n### Raising <code>hardLimit</code><br /><br />\n#### The <code>raise value</code> is defined as the vote of the 1512th highest block, converted to bytes.\n#### If the resultant <code>raise value</code> is greater than (<code>current hardLimit</code> * 1.05) rounded down, it is set to that value.\n#### If the resultant <code>raise value</code> is greater than <code>current hardLimit</code>, the <code>raise value</code> becomes the <code>new hardLimit</code> and the recalculation is complete.<br /><br />\n### Lowering <code>hardLimit</code><br /><br />\n#### The <code>lower value</code> is defined as the vote of the 1512th lowest block, converted to bytes.\n#### If the resultant <code>lower value</code> is less than (<code>current hardLimit</code> / 1.05) rounded down, it is set to that value.\n#### If the resultant <code>lower value</code> is less than <code>current hardLimit</code>, the <code>lower value</code> becomes the <code>new hardLimit</code> and the recalculation is complete.<br /><br />\n### Otherwise, <code>new hardLimit</code> remains the same as <code>current hardLimit</code>.\n\n===Signature Hashing Operations Limits===\n# The per-block signature hashing operations limit is scaled to (actual block size, fractional megabyte rounded to next higher megabyte) / 50.\n# A maximum serialized transaction size of 1000000 bytes is imposed.\n\n==Recommendations==\n\n===Publication of <code>hardLimit</code>===\n# For the benefit of all observers, it is recommended that <code>hardLimit</code> be published.  Example: a complete coinbase string might read <br /><br /><code>/BIP100/B8/EB2.123456/</code><br /><br /> which indicates a vote for 8M maximum block size, and an enforced <code>hardLimit</code> of 2.123456 megabytes for the block containing the coinbase string.\n\n==Deployment==\n\nThis BIP is presumed deployed and activated as of block height 449568 by implementing nodes on the bitcoin mainnet. It has no effect until a raise value different from 1M is observed, which requires at least 1512 of 2016 blocks to vote differently from 1M.\n\n==Backward compatibility==\n\nThe first block larger than 1M will create a network partition, as nodes with a fixed 1M hard limit reject that block.\n\n==Implementations==\nhttps://github.com/bitcoinxt/bitcoinxt/pull/188</br>\nhttps://github.com/bitcoinxt/bitcoin/pull/1</br>\nhttps://github.com/BitcoinUnlimited/BitcoinUnlimited/pull/398</br>\n\n==Copyright==\nThis document is licensed under the BSD 2-clause license.\n\n", "content_length": 5659}
{"bip_number": 99, "filename": "bip-0099.mediawiki", "content": "<pre>\n  BIP: 99\n  Title: Motivation and deployment of consensus rule changes ([soft/hard]forks)\n  Author: Jorge Tim\u00f3n <jtimon@jtimon.cc>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0099\n  Status: Rejected\n  Type: Informational\n  Created: 2015-06-20\n  License: PD\n  Post-History: http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/008936.html\n</pre>\n\n==Abstract==\n\nThis BIP attempts to create a taxonomy of the different types of\nconsensus forks and proposes a deployment mechanism for each of them.\n\n==Motivation==\n\nThe security assumptions of p2p consensus-based systems like Bitcoin are\nnot always well-understood, and the best upgrade mechanisms to the\nconsensus validation rules may vary depending on the type of change being deployed.\nDiscussing such changes without a uniform view on the deployment\npaths often leads to misunderstandings and unnecessarily delays the\ndeployment of changes.\n\n==Definitions==\n\n;Software fork\n: A copy of an existing project. In free software, this can be done without the permission of the original project's maintainers.\n\n;Consensus fork\n: A divergence in the implementation of the verification consensus rules can impede the expected eventual convergence of the network in a single chain that has the most proof of work and also satisfies the rules. This can be intentional or be caused by a bug in consensus validation reimplementations.\n\n;Softfork\n: A consensus fork wherein everything that was previously invalid remains invalid while blocks that would have previously considered valid become invalid. A hashrate majority of miners can impose the new rules. They have some deployment advantages like backward compatibility.\n\n;Hardfork\n: A consensus fork that makes previously invalid blocks valid. Hardforks require all users to upgrade.\n\n;Libconsensus\n: a theoretical piece of software that contains the specifications that define the validity of a block for a given state and chain parameters (ie it may act differently on, for example, regtest).\n\n;Libbitcoinconsensus\n: the existing implementation is a library that is compiled by default with Bitcoin Core master and exposes a single C function named bitcoinconsensus_verify_script(). Although it has a deterministic build and implements the most complex rules (most of the cryptography, which is itself heavily based on libsecp256k1 after #REPLACE_libsecp256k1_PR), it is still not a complete specification of the consensus rules. Since libconsensus doesn't manage the current state but only the validation of the next block given that state, it is known that this long effort of encapsulation and decoupling will eventually finish, and that the person who moves the last line\n\n==Taxonomy of consensus forks==\n\n===Accidental consensus fork===\n\nSoftware forks are very different in nature from consensus rules forks. No software\nmaintainer has special powers over consensus rules changes. There's\nmany good reasons (experimentation, lack of features, independent\ndevelopment, diversity, etc) to fork the Bitcoin Core software and it's good\nthat there's many alternative implementations of the protocol (forks\nof Bitcoin Core or written from scratch).\n\nBut sometimes a bug in the reimplementation of the consensus\nvalidation rules can prevent users of alternative implementation from\nfollowing the longest (most work) valid chain. This can result in\nthose users losing coins or being defrauded, making reimplementations\nof the consensus validation rules very risky. Note that a natural\nlanguage specification of those rules doesn't help since the\nconsensus is not determined by such specification but by the software\nthat the majority of the network runs. That's why \"the implementation\nis the specification\".\n\nBut Bitcoin Core contains many more things than just consensus\nvalidation and it would be unreasonable for all alternative\nimplementations to depend on it. Bitcoin Core should not be the\nspecification. That's why the consensus validation is being separated\ninto a libbitcoinconsensus library with a C API easily accessible from\nany language. This makes alternative implementations much more secure\nwithout burdening them with specific design choices made by Bitcoin\nCore. It is to be noted that sharing the same code for consensus\nvalidation doesn't prevent alternative implementations from\nindependently changing their consensus rules: they can always fork\nthe libbitcoinconsensus project (once it is in a separate repository).\n\nHopefully libbitcoinconsensus will remove this type of consensus fork\nwhich - being accidental - obviously doesn't need a deployment plan.\n\n====11/12 March 2013 Chain Fork====\n\nThere is a precedent of an accidental consensus fork at height 225430.\nWithout entering into much detail (see <ref name=\"bip-50\">https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki</ref>), the situation was different from\nwhat's being described from the alternative implementation risks (today alternative implementation\nstill usually rely in different degrees on Bitcoin Core trusted proxies, which\nis very reasonable considering the lack of a complete libconsensus).\nThe two conflicting consensus validation implementations were two\ndifferent versions of Bitcoin Core (Bitcoin-qt at the time): 0.8\nagainst all versions prior to it. Most miners had been fast on\nupgrading to 0.8 and they were also fast on downgrading to 0.7 as an\nemergency when they were asked to by the developers community.\n\nA short summary would be that BDB was being\nabandoned in favor of levelDB, and - at the same time - the miner's\npolicy block size limit was being lift (it was not a consensus rule,\nnot even enforced via softfork). Even after testing, a case where\nlevelDB couldn't correctly validate certain bigger blocks only appeared after\ndeployment in production. Fortunately this was handled very well and\nrapidly by the whole worldwide community and nobody is unhappy about\nthe solution.\n\nBut there's some philosophical disagreements on the terms of what the\nsolution was: we can add a pedantic note on that.\nIf \"the implementation is the specification\", then those\nlevelDB-specific limitations were part of the consensus rules.\nThen additional rules were necessary and any alternative\nimplementation (including 0.8) would have to implement it. Then a\nplanned consensus fork to migrate all Bitcoin-qt 0.7- users could\nremove those additional consensus restrictions.\nHad libconsensus being implemented without depending on levelDB,\nthose additional restrictions wouldn't have been part of \"the specification\"\nand this would just have been a bug in the\nconsensus rules, just a consensus-critical bug in a set of\nimplementations, concretely all satoshi-bitcoin-0.7-or-less (which\nhappened to be a huge super majority of the users), but other\nimplementations (like libbitcoin) would be free from such bug and\nimplementing the correct libconsensus specification. But since the\nbuggy implementation was a super-majority, the solution would have\nbeen to instantly (from a specific block) change the rules to not let\nthe super-majority deviate from the specification and then have\nanother consensus fork to remove them. Two theoretical consensus forks\ninstead of one but the first one deployed practically for free. The\npractical result would have been identical and only the definitions\nchange. This means discussing something that went uncontroversially\nwell further is \"philosophical bike-shed\" (TM).\n\n===Unilateral softforks===\n\nIf it is in their best interest of miners to softfork it should be\nassumed that they may likely enforce it. In some cases, even against the will of a\nsuper-majority of users. This is practically an attack on the network\nand the only solution is to carefully design the incentives so that\nthe case is simply impossible. If that fails, miners should still\nconsider the risk of motivating a schism hardfork before attempting\nsuch a consensus fork. A deployment plan for this case is also\nunnecessary.\n\n===Schism hardforks===\n\nFundamental disagreements and controversies are part of social\nsystems, like the one defined as the human participants in the Bitcoin\nnetwork. Without judging the motivation of the rule discrepancies or\nwhat rules were in place first, we're defining schism<ref name=\"schism\">https://en.wikipedia.org/wiki/Schism</ref> hardforks as\nthose in which - for whatever reason - users are consciously going to validate 2\ndifferent sets of consensus rules. Since they will validate different\nrulesets, they will end up following 2 different chains for at least\nsome time, maybe forever.\n\nOne possible result observed in the past\nis that one of the chains rapidly disappears, but nothing indicates\nthat this must always be the case.\n\nWhile 2 chains coexist, they can be considered two different\ncurrencies.\nWe could say that bitcoin becomes bitcoinA and bitcoinB. The implications for market\ncapitalization are completely unpredictable,\n\nmaybe mc(bitcoinA) = mc(bitcoinB) = mc(old_bitcoin),\n\nmaybe mc(bitcoinA) + mc(bitcoinB) = mc(old_bitcoin),\n\nmaybe mc(bitcoinA) + mc(bitcoinB) = 1000 * mc(old_bitcoin),\n\nmaybe mc(bitcoinA) + mc(bitcoinB) = 0,\n\n...\n\nSchism hardforks have been compared to one type of altcoins called\n\"spinoffs\"<ref name=\"spinoffs\">https://bitcointalk.org/index.php?topic=563972.0</ref> that distribute all or part of its initial seigniorage to\nbitcoin owners at a given block height.\n\nThis is very disruptive and hopefully will never be needed. But if\nit's needed the best deployment path is just to activate the rule\nchanges after certain block height in the future. On the other hand,\nit is healthy decentralization-wise that many independent software\nprojects are ready to deploy a schism hardfork.\n\nIn all of the following examples there's clearly a confrontation that\nis being resolved using an intentional consensus hardfork.\n\n====ASIC-reset hardfork====\n\nImagine ASIC production has been consolidated to a single company and\ndistribution is simply not happening: the company is keeping them to\nmine itself. For that or another reason, a single entity controls\n40%+ of the hashrate and there's no hope for an spontaneous\nimprovement in decentralization. Such an untenable centralization could\nbe fixed (with great risks) by switching the hash function used in the\nproof of work, effectively \"pressing the restart button\" on the ASIC\nmarket. The next function should be simple to implement in ASIC as\nwell so that the market can more easily develop as a healthy and\ncompetitive one (as opposed to what the \"ASIC-hard\" proponents would\nwant), but that's another story...]\n\nSince in this case the confrontation is clearly against the current\nminers any notion of \"miners' voting\" is utterly irrelevant.\n\n====Anti-Block-creator hardfork====\n\nThere's less extreme cases where changing the pow function would not\nbe necessary. For example, let's imagine a bright future where\ncommoditized ASICs are running in millions home-heaters all over the\nworld, but the block size has been completely removed and the network has devolved to a\nvery centralized system where only 2 big pools have the resources to\nfully validate full blocks and create block templates with competitive levels of\ntransaction fees. In that case, changing the pow function would be a\nterrible waste and a risk that could be avoided. A hardfork restoring\na block size limit could help fixing this situation. Please don't\ntake it as an argument for or against raising the block size limit:\nit's just an example. But in this case, again, those 2 big pools\nwould probably be against the fork and, again, their voting is\nirrelevant.\n\nLike in the previous example, miners are expected to oppose and they\nhave to be ignored.\n\n====Anti-cabal hardfork====\n\nLet's imagine BIP66 had a crypto backdoor\nthat nobody noticed and allows an evil developer cabal to steal\neveryone's coins. The users and non-evil developers could join, fork\nlibconsensus and use the forked version in their respective bitcoin\nimplementations.\nShould miner's \"vote\" be required to express their consent? What if some miners\nare part of the cabal? In the unlikely event that most miners are\npart of such an evil cabal, changing the pow function may be\nrequired. In other cases, mining \"vote\" doesn't have much value\neither since this kind of hardfork would not qualify as\nuncontroversial anyway.\n\n===Uncontroversial consensus upgrades===\n\n\"Uncontroversial\" is something tough to define in this context. What\nif a single user decides he won't upgrade no matter what and\nhe doesn't even attempt to explain his decision? Obviously, such\na user should be just ignored. But what if the circumstances are\nslightly different? What if they're 2, 10 users? where's the line.\nIt is possible that we can never have a better definition than \"I know\nit when I see it\" [citation needed].\n\n====Uncontroversial softforks====\n\nIf a majority of miners adopts a softfork, users will follow that\nchain, even without understanding the new rules. For them is like\nif blocks are created in a certain way or certain valid transactions\nare being rejected by miners for some reason. For old nodes it just\nlooks like the new rules are policy rules rather than consensus rules.\nThis greatly reduces the deployment risks, making softforks the\npreferred consensus rules upgrade mechanism.\n\nThe first precedent of a softfork was the introduction of P2SH\ndocumented in BIP16. There were competing proposals, but BIP12 had\nclear disadvantage and  BIP17 was considered a less tested but\nfunctionally equivalent version by most of the reviewers. Although it\nwas later discovered that BIP16 had unnecessary limitations and BIP17\nis now considered superior, this probably still qualified for our\nvague concept of \"uncontroversial\".\n\nAt the time, there was no \"mining voting\" implementation and it was\nsimply deployed using the timestamp of the blocks at some time in the\nfuture as the activation trigger. This can't guarantee the assumption\nthat most miners have upgraded before enforcing the new rules and\nthat's why the voting mechanism and first used for BIP30 and BIP66.\nThe current voting threshold for softfork enforcement is 95%. There's\nalso a 75% threshold for miners to activate it as a policy rule, but\nit should be safe for miners to activate such a policy from the start\nor later than 75%, as long as they enforce it as consensus rule after 95%.\n\nThe current miners' voting mechanism can be modified to allow for\nchanges to be deployed in parallel, the rejection of a concrete\nsoftfork without getting locked for the deployment of the next one,\nand also a more efficient use of the version field in block\nheaders<ref name=\"versionbits\">https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki</ref>. BIP65 is expected to be deployed with the improved\nmechanism.\n\n====Uncontroversial hardforks====\n\nSome consensus changes require all participants to upgrade their software\nbefore the new rules can be safely activated or they will face serious\nrisk of following the wrong chain and being defrauded. Even if the\nexact same mechanism used for softforks would be more risky in these\ncases, that doesn't mean that this type of changes cannot be deployed\nin an uncontroversial and safe manner.\n\nThe simplest approach is to select a block height far enough in the\nfuture that everybody has plenty of time to change their software.\nBut if you're aiming for universal adoption, that includes miners'\nadoption, so it seems reasonable to use a mining voting on top of\nthat. In this case there's only one relevant threshold and it could\nbe different from the softfork one. Probably 100% is too strict,\nsince it would allow a relatively small miner to attack the network\nand block a consensus upgrade. Something between 99% and 95% is\nprobably a sensible choice for this parameter.\n\n====Uncontroversial emergency hardforks====\n\nEmergency forks may not have time to consult miners and have to be\ndeployed simply by choosing a block height not so far in the future.\n\nBut emergency forks could be prepared ahead of time. For example, an\nintermediary version of software could allow blocks\nthat are double the size of old blocks (after a certain height in the\nfuture) while still making miners reject bigger blocks as a softfork\nrule. Then miners can start the regular process for uncontroversial\nsoftfork (or a unilateral softfork if they're a majority) at any\npoint in the future if it is required, and both intermediary and new\nversions would be prepared for it (which would make deployment much\neasier). Other related consensus changes could be deployed in the\nmeantime (say, quadrupling the block size) making the emergency\nsoftfork unnecessary.\n\n==Code==\n\nThis BIP is complemented with a concrete code proposal<ref name=\"timewarp\">https://github.com/jtimon/bitcoin/tree/hardfork-timewarp-0.11</ref> for an\nuncontroversial hardfork which acts as a precedent and removes the\nperception that hardforks are impossible in Bitcoin. The deployment of\nthe proposal should not block any other potential hardforks (thus it\nwill required the version bits proposal<ref name=\"versionbits\"/> to be implemented). The\nchange itself doesn't add much complexity to Bitcoin Core and is simple\nenough that is trivial to apply to diverse implementations (that\ncurrently can only use libbitcoinconsensus to validate script-related\nrules). The change has been already widely tested in many altcoins.\n\nThe chosen consensus change is the fix of the timewarp attack\ndiscovered and also fixed with a simple patch<ref name\"original-references\">\nOriginal References:\nhttps://bitcointalk.org/index.php?topic=114751.0,\nhttps://bitcointalk.org/index.php?topic=43692.msg521772#msg521772;\nRebased patch:\nhttps://github.com/freicoin/freicoin/commit/beb2fa54745180d755949470466cbffd1cd6ff14\n</ref>\nby @ArtForz. This\nchange has been deployed by most altcoins that made any minimally\nmeaningful change to bitcoin and thus can be considered somewhat\ntested (in fact, most SHA256d altcoins that didn't implement it have\ndied or being forced to implement it as an emergency hardfork). When\ndeploying this change has been discussed, usually arguments in the\nlines of \"if we get to the point when this matters to bitcoin, we\nwould be already in serious trouble\" were used against it. This\nshouldn't be seen as a disadvantage in this context, since it means we\ncan safely activate the fix very far away in the future (say, 4 years\nworth of blocks).\n\n==Footnotes==\n\n<references />\n\n==Attribution==\n\nIncorporated corrections and suggestions from: Andy Chase, Bryan Bishop,\nBtcdrak, Gavin Andresen, Gregory Sanders, Luke Dashjr, Marco Falke.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 18697}
{"bip_number": 98, "filename": "bip-0098.mediawiki", "content": "<pre>\n  BIP: 98\n  Layer: Consensus (soft fork)\n  Title: Fast Merkle Trees\n  Author: Mark Friedenbach <mark@friedenbach.org>\n          Kalle Alm <kalle.alm@gmail.com>\n          BtcDrak <btcdrak@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0098\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-08-24\n  License: CC-BY-SA-4.0\n  License-Code: MIT\n</pre>\n\n==Abstract==\n\nIn many applications it is useful to prove membership of a data element in a set without having to reveal the entire contents of that set.\nThe Merkle hash-tree, where inner/non-leaf nodes are labeled with the hash of the labels or values of its children, is a cryptographic tool that achieves this goal.\nBitcoin uses a Merkle hash-tree construct for committing the transactions of a block into the block header.\nThis particular design, created by Satoshi, suffers from a serious flaw related to duplicate entries documented in the National Vulnerability Database as CVE-2012-2459[1], and also suffers from less than optimal performance due to unnecessary double-hashing.\n\nThis Bitcoin Improvement Proposal describes a more efficient Merkle hash-tree construct that is not vulnerable to CVE-2012-2459\nand achieves an approximate 55% decrease in hash-tree construction and validation times as compared with fully optimized implementations of the Satoshi Merkle hash-tree construct.\n\n==Copyright==\n\nThis BIP is licensed under a Creative Commons Attribution-ShareAlike license. All provided source code is licensed under the MIT license.\n\n==Motivation==\n\nA Merkle hash-tree is a directed acyclic graph data structure where all non-terminal nodes are labeled with the hash of combined labels or values of the node(s) it is connected to.\nBitcoin uses a unique Merkle hash-tree construct invented by Satoshi for calculating the block header commitment to the list of transactions in a block.\nWhile it would be convenient for new applications to make use of this same data structure so as to share implementation and maintenance costs, there are three principal drawbacks to reuse.\n\nFirst, Satoshi's Merkle hash-tree has a serious vulnerability[1] related to duplicate tree entries that can cause bugs in protocols that use it.\nWhile it is possible to secure protocols and implementations against exploit of this flaw, it requires foresight and it is a bit more tricky to design secure protocols that work around this vulnerability.\nDesigners of new protocols ought avoid using the Satoshi Merkle hash-tree construct where at all possible in order to responsibly decrease the likelihood of downstream bugs in na\u00efve implementations.\n\nSecond, Satoshi's Merkle hash-tree performs an unnecessary number of cryptographic hash function compression rounds, resulting in construction and validation times that are approximately three (3) times more computation than is strictly necessary in a na\u00efve implementation, or 2.32x more computation in an implementation specialized for this purpose only[2].\nNew implementations that do not require backwards compatibility ought to consider hash-tree implementations that do not carry this unnecessary performance hit.\n\nThird, Satoshi's algorithm presumes construction of a tree index from an ordered list, and therefore is designed to support balanced trees with a uniform path length from root to leaf for all elements in the tree.\nMany applications, on the other hand, benefit from having unbalanced trees, particularly if the shorter path is more likely to be used.\nWhile it is possible to make a few elements of a Satoshi hash-tree have shorter paths than the others, the tricks for doing so are dependent on the size of the tree and not very flexible.\n\nTogether these three reasons provide justification for specifying a standard Merkle hash-tree structure for use in new protocols that fixes these issues.\nThis BIP describes such a structure, and provides an example implementation.\n\n==Specification==\n\nA Merkle hash-tree as defined by this BIP is an arbitrarily-balanced binary tree whose terminal/leaf nodes are labelled with the double-SHA256 hashes of data, whose format is outside the scope of this BIP, and inner nodes with labels constructed from the fast-SHA256 hash of its children's labels.\nThe following image depicts an example unbalanced hash-tree:\n\n:: [[File:bip-0098/unbalanced-hash-tree.png]]\n\n'''A''', '''B''', and '''C''' are leaf labels, 32-byte double-SHA256 hashes of the data associated with the leaf.\n'''Node''' and '''Root''' are inner nodes, whose labels are fast-SHA256 (defined below) hashes of their respective children's labels.\n'''Node''' is labelled with the fast-SHA256 hash of the concatenation of '''B''' and '''C'''.\n'''Root''' is labelled with the fast-SHA256 hash of the concatenation of '''A''' and '''Node''', and is the ''Merkle root'' of the tree.\nNodes with single children are not allowed.\n\nThe ''double-SHA256'' cryptographic hash function takes an arbitrary-length data as input and produces a 32-byte hash by running the data through the SHA-256 hash function as specified in FIPS 180-4[3], and then running the same hash function again on the 32-byte result, as a protection against length-extension attacks.\n\nThe ''fast-SHA256'' cryptographic hash function takes two 32-byte hash values, concatenates these to produce a 64-byte buffer, and applies a single run of the SHA-256 hash function with a custom 'initialization vector' (IV) and without message padding.\nThe result is a 32-byte 'midstate' which is the combined hash value and the label of the inner node.\nThe changed IV protects against path-length extension attacks (grinding to interpret a hash as both an inner node and a leaf).\nfast-SHA256 is only defined for two 32-byte inputs.\nThe custom IV is the intermediate hash value generated after performing a standard SHA-256 of the following hex-encoded bytes and extracting the midstate:\n\n    cbbb9d5dc1059ed8 e7730eaff25e24a3 f367f2fc266a0373 fe7a4d34486d08ae\n    d41670a136851f32 663914b66b4b3c23 1b9e3d7740a60887 63c11d86d446cb1c\n\nThis data is the first 512 fractional bits of the square root of 23, the 9th prime number.\nThe resulting midstate is used as IV for the fast-SHA256 cryptographic hash function:\n\n    static unsigned char _MidstateIV[32] =\n        { 0x89, 0xcc, 0x59, 0xc6, 0xf7, 0xce, 0x43, 0xfc,\n          0xf6, 0x12, 0x67, 0x0e, 0x78, 0xe9, 0x36, 0x2e,\n          0x76, 0x8f, 0xd2, 0xc9, 0x18, 0xbd, 0x42, 0xed,\n          0x0e, 0x0b, 0x9f, 0x79, 0xee, 0xf6, 0x8a, 0x24 };\n\nAs fast-SHA256 is only defined for two (2) 32-byte hash inputs, there are necessarily two special cases:\nan empty Merkle tree is not allowed, nor is any root hash defined for such a \"tree\";\nand a Merkle tree with a single value has a root hash label equal to that self-same value of the leaf branch, the only node in the tree (a passthrough operation with no hashing).\n\n===Rationale===\n\nThe fast-SHA256 hash function can be calculated 2.32x faster than a specialized double-SHA256 implementation[2], or three (3) times faster than an implementation applying a generic SHA-256 primitive twice,\nas hashing 64 bytes of data with SHA-256 as specified by FIPS 180-4[3] takes two compression runs (because of message padding) and then a third compression run for the double-SHA256 construction.\nValidating a fast-SHA256 Merkle root is therefore more than twice as fast as the double-SHA256 construction used by Satoshi in bitcoin.\nFurthermore the fastest fast-SHA256 implementation ''is'' the generic SHA-256 implementation, enabling generic circuitry and code reuse without a cost to performance.\n\nThe application of fast-SHA256 to inner node label updates is safe in this limited domain because the inputs are hash values and fixed in number and in length,\nso the sorts of attacks prevented by message padding and double-hashing do not apply.\n\nThe 'initialization vector' for fast-SHA256 is changed in order to prevent a category of attacks on higher level protocols where a partial collision can serve as both a leaf hash and as an inner node commitment to another leaf hash.\nThe IV is computed using standard SHA-256 plus midstate extraction so as to preserve compatibility with cryptographic library interfaces that do not support custom IVs, at the cost of a 2x performance hit if neither custom IVs nor resuming from midstate are supported.\nThe data hashed is a nothing-up-my-sleeve number that is unlikely to have a known hash preimage.\nThe prime 23 was chosen as the leading fractional bits of the first eight (8) primes, two (2) through nineteen (19), are constants used in the setup of SHA-256 itself.\nUsing the next prime in sequence reduces the likelihood of introducing weakness due to reuse of a constant factor.\n\nThe Merkle root hash of a single element tree is a simple pass-through of the leaf hash without modification so as to allow for chained validation of split proofs.\nThis is particularly useful when the validation environment constrains proof sizes, such as push limits in Bitcoin script.\nChained validation allows a verifier to split one proof into two or more, where the leaf is shown to be under an inner node, and that inner node is shown to be under the root.\nWithout pass-through hashing in a single-element tree, use of chained validation would unnecessarily introduce a minimum path length requirement equal to the number of chain links.\nPass-through hashing of single elements allows instead for one or more of the chained validations to use a \"NOP\" proof consisting of a zero-length path,\nthereby allowing, for example, a fixed series of four (4) chained validations to verify a length three (3) or shorter path.\n\n==Inclusion Proofs==\n\nAn important use of Merkle hash-trees is the ability to compactly prove membership with log-sized proofs.\nThis section specifies a standard encoding for a multi-element inclusion proof.\n\nTo prove that a set of hashes is contained within a Merkle tree with a given root requires four pieces of information:\n\n# The root hash of the Merkle tree;\n# The hash values to be verified, a set usually consisting of the double-SHA256 hash of data elements, but potentially the labels of inner nodes instead, or both;\n# The paths from the root to the nodes containing the values under consideration, expressed as a serialized binary tree structure; and\n# The hash values of branches not taken along those paths.\n\nTypically the last two elements, the paths and the elided branch hashes, are lumped together and referred to as the ''proof''.\n\nSerialization begins with a variable-length integer (VarInt)  used to encode N, the number of internal nodes in the proof.\nNext the structure of the tree is traversed using depth-first, left-to-right, pre-order algorithm to visit each internal nodes, which are serialized using a packed 3-bit representation for the configuration of each node, consuming <code>(3*N + 7) / 8</code> bytes.\nThen the number skipped hashes (those included in the proof, not verified by the proof) is serialized as a variable-length integer (VarInt),\nfollowed by the hashes themselves in the order previously traversed.\n\nThere are eight possible configurations of internal nodes, as given in the following diagram:\n\n:: [[File:bip-0098/node-variants.png]]\n\nIn this diagram, DESCEND means the branch links to another internal node, as indicated by its child graph elements labeled \"...\";\nSKIP means the branch contains a hash of an elided subtree or element, and the fast-SHA256 root hash of this subtree or double-SHA256 hash of the element is included in the proof structure; and\nVERIFY means the branch contains an externally provided hash that is needed as witness for the verification of the proof.\nIn tabular form, these code values are:\n\n{| class=\"wikitable\"\n|-\n| scope=\"col\"| Code\n| scope=\"col\"| Left\n| scope=\"col\"| Right\n|-\n| scope=\"row\"| 000\n| VERIFY\n| SKIP\n|-\n| scope=\"row\"| 001\n| VERIFY\n| VERIFY\n|-\n| scope=\"row\"| 010\n| VERIFY\n| DESCEND\n|-\n| scope=\"row\"| 011\n| DESCEND\n| SKIP\n|-\n| scope=\"row\"| 100\n| DESCEND\n| VERIFY\n|-\n| scope=\"row\"| 101\n| DESCEND\n| DESCEND\n|-\n| scope=\"row\"| 110\n| SKIP\n| VERIFY\n|-\n| scope=\"row\"| 111\n| SKIP\n| DESCEND\n|}\n\nThese 3-bit codes are packed into a byte array such that eight (8) codes would fit in every three (3) bytes.\nThe order of filling a byte begins with the most significant bit <code>0x80</code> and ends with the least significant bit <code>0x01</code>.\nUnless the number of inner nodes is a multiple of eight (8), there will be excess low-order bits in the final byte of serialization.\nThese excess bits must be zero.\n\nNote that the tree serialization is self-segmenting.\nBy tracking tree structure a proof reader will know when the parser has reached the last internal node.\nThe number of inner nodes serialized in the proof MUST equal the number of nodes inferred from the tree structure itself.\nSimilarly, the number of SKIP hashes can also be inferred from the tree structure as serialized, and MUST equal the number of hashes provided within the proof.\n\nThe single-hash proof has N=0 (the number of inner nodes),\nthe tree structure is not serialized (as there are no inner nodes),\nand the number of SKIP hashes can be either 0 or 1.\n\n===Example===\n\nConsider the following Merkle tree structure:\n\n:: [[File:bip-0098/traversal-example.png]]\n\nThere are six (6) internal nodes.\nThe depth-first, left-to-right, pre-order traversal of the tree visits these nodes in the following order: A, B, D, F, C, then E.\nThere are three (3) skipped hashes, visited in the following order: 0x00..., 0x66..., and 0x22...\nThe remaining four (4) hashes are provided at runtime to be verified by the proof.\n\n{|\n| scope=\"col\"|\n| scope=\"col\"| Byte 1\n| scope=\"col\"| Byte 2\n| scope=\"col\"| Byte 3\n|-\n| scope=\"row\"| Bits\n| 76543210\n| 76543210\n| 76543210\n|-\n| scope=\"row\"| Nodes\n| AAABBBDD\n| DFFFCCCE\n| EE------\n|-\n| scope=\"row\"| Code\n| 10111101\n| 10000100\n| 01000000\n|}\n\nThe serialization begins with the VarInt encoded number of inner nodes, <code>0x06</code>, followed by the tree serialization itself, <code>0xbd8440</code>.\nNext the number of SKIP hashes is VarInt encoded, <code>0x03</code>, followed by the three (3) hashes in sequence.\nThe resulting 101 byte proof, encoded in base64:.\n\n    Br2EQAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZmZmZmZmZmZmZmZmZmZmZmZm\n    ZmZmZmZmZmZmZmZmREREREREREREREREREREREREREREREREREREREREREQ=\n\n===Rationale===\n\nThe 3-bit encoding for inner nodes allows encoding all relevant configurations of the nodes where the left and right branches can each be one of {DESCEND, SKIP, VERIFY}.\nThe excluded 9th possibility would have both branches as SKIP:\n\n:: [[File:bip-0098/skip-skip.png]]\n\nThis possibility is not allowed as for verification purposes it is entirely equivalent to the shorter proof where the branch to that node was SKIP'ed.\nDisallowing a node with two SKIP branches eliminates what would otherwise be a source of proof malleability.\n\nThe number of hashing operations required to verify a proof is one less than the number of hashes (SKIP and VERIFY combined),\nand is exactly equal to the number of inner nodes serialized as the beginning of the proof as N.\nThe variable-length integer encoding has the property that serialized integers, sorted lexicographically, will also be sorted numerically.\nSince the first serialized item is the number of inner nodes, sorting proofs lexicographically has the effect of sorting the proofs by the amount of work required to verify.\n\nThe number of hashes required as input for verification of a proof is N+1 minus the number of SKIP hashes,\nand can be quickly calculated without parsing the tree structure.\n\nThe coding and packing rules for the serialized tree structure were also chosen to make lexicographical comparison useful (or at least not meaningless).\nIf we consider a fully-expanded tree (no SKIP hashes, all VERIFY) to be encoding a list of elements in the order traversed depth-first from left-to-right,\nthen we can extract proofs for subsets of the list by SKIP'ing the hashes of missing values and recursively pruning any resulting SKIP,SKIP nodes.\nLexicographically comparing the resulting serialized tree structures is the same as lexicographically comparing lists of indices from the original list verified by the derived proof.\n\nBecause the number of inner nodes and the number of SKIP hashes is extractible from the tree structure,\nboth variable-length integers in the proof are redundant and could have been omitted.\nHowever that would require either construction and storage of the explicit tree in memory at deserialization time,\nor duplication of the relatively complicated tree parsing code in both the serialization and verification methods.\nFor that reason (as well as to handle the single-hash edge case) the redundant inner node and SKIP hash counts are made explicit in the serialization,\nand the two values must match what is inferred from the tree structure for a proof to be valid.\nThis makes deserialization trivial and defers tree construction until verification time,\nwhich has the additional benefit of enabling log-space verification algorithms.\n\n==Fast Merkle Lists==\n\nMany applications use a Merkle tree to provide indexing of, or compact membership proofs about the elements in a list.\nThis addendum specifies an algorithm that constructs a canonical balanced tree structure for lists of various lengths.\nIt differs in a subtle but important way from the algorithm used by Satoshi so as to structurally prevent the vulnerability described in [1].\n\n# Begin with a list of arbitrary data strings.\n# Pre-process the list by replacing each element with its double-SHA256 hash.\n# If the list is empty, return the zero hash.\n# While the list has 2 or more elements,\n#* Pass through the list combining adjacent entries with the fast-SHA256 hash. If the list has an odd number of elements, leave the last element as-is (this fixes [1]). This step reduces a list of N elements to ceil(N/2) entries.\n# The last remaining item in the list is the Merkle root.\n\nThis algorithm differs from Merkle lists used in bitcoin in two ways.\nFirst, fast-SHA256 is used instead of double-SHA256 for inner node labels.\nSecond, final entries on an odd-length list are not duplicated and hashed, which is the mistake that led to CVE-2012-2459[1].\n\n==Implementation==\n\nAn implementation of this BIP for extraction of Merkle branches and fast, log-space Merkle branch validation is available at the following Github repository:\n\n[https://github.com/maaku/bitcoin/tree/fast-merkle-tree]\n\nAlso included in this repo is a 'merklebranch' RPC for calculating root values and extracting inclusion proofs for both arbitrary trees and trees constructed from lists of values using the algorithm in this BIP,\nand a 'mergemerklebranch' RPC for unifying two or more fast Merkle tree inclusion proofs--replacing SKIP hashes in one proof with a subtree extracted from another.\n\n==Deployment==\n\nThis BIP is used by BIP116 (MERKLEBRANCHVERIFY)[4] to add Merkle inclusion proof verification to script by means of a soft-fork NOP expansion opcode.\nDeployment of MERKLEBRANCHVERIFY would make the contents of this BIP consensus critical.\nThe deployment plan for BIP116 is covered in the text of that BIP.\n\n==Compatibility==\n\nThis BIP on its own does not cause any backwards incompatibility.\n\n==References==\n\n[1] [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459 National Vulnerability Database: CVE-2012-2459]\n\n[2] [https://github.com/sipa/bitcoin/tree/201709_dsha256_64 github.com:sipa/bitcoin 201709_dsha256_64] Pieter Wuille, September 2017, personal communication. By making use of knowledge that the inputs at each stage are fixed length, Mr. Wuille was able to achieve a 22.7% reduction in the time it takes to compute the double-SHA256 hash of 64 bytes of data, the hash aggregation function of the Satoshi Merkle tree construction.\n\n[3] [http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf Secure Hash Standard]\n\n[4] [https://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki BIP 116 MERKLEBRANCHVERIFY]\n", "content_length": 20037}
{"bip_number": 94, "filename": "bip-0094.mediawiki", "content": "<pre>\n  BIP: 94\n  Layer: Applications\n  Title: Testnet 4\n  Author: Fabian Jahr <fjahr@protonmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0094\n  Status: Final\n  Type: Standards Track\n  Created: 2024-05-27\n  License: CC0-1.0\n  Post-History: https://gnusha.org/pi/bitcoindev/CADL_X_eXjbRFROuJU0b336vPVy5Q2RJvhcx64NSNPH-3fDCUfw@mail.gmail.com/\n                https://gnusha.org/pi/bitcoindev/a6e3VPsXJf9p3gt_FmNF_Up-wrFuNMKTN30-xCSDHBKXzXnSpVflIZIj2NQ8Wos4PhQCzI2mWEMvIms_FAEs7rQdL15MpC_Phmu_fnR9iTg=@protonmail.com/\n                https://github.com/bitcoin/bitcoin/pull/29775\n</pre>\n\n== Abstract ==\n\nA new test network with the goal to replace Testnet 3. This network comes with small but important improvements of the consensus rules, that should make it impractical to attack the network using only CPU mining.\n\n== Motivation ==\n\nQuoting the original mailing list post from Jameson Lopp<ref>https://gnusha.org/pi/bitcoindev/CADL_X_eXjbRFROuJU0b336vPVy5Q2RJvhcx64NSNPH-3fDCUfw@mail.gmail.com/</ref>:\n\n<blockquote><poem>\nTestnet3 has been running for 13 years. It's on block 2.5 million something and the block reward is down to ~0.014 TBTC, so mining is not doing a great job at distributing testnet coins anymore.\n\nThe reason the block height is insanely high is due to a rather amusing edge case bug that causes the difficulty to regularly get reset to 1, which causes a bit of havoc. If you want a deep dive into the quirk: https://blog.lopp.net/the-block-storms-of-bitcoins-testnet/\n\nTestnet3 is being actively used for scammy airdrops; those of us who tend to be generous with our testnet coins are getting hounded by non-developers chasing cheap gains.\n\nAs a result, TBTC is being actively bought and sold; one could argue that the fundamental principle of testnet coins having no value has been broken.\n</poem></blockquote>\n\nSince then the issue with block storms has been further demonstrated on Testnet 3 when three years' worth of blocks were mined in a few weeks while rendering the network practically unusable at the same time.\n\n== Specification ==\n\nTestnet 4 follows the same consensus rules as mainnet with the following three exceptions. Additionally, all soft forks that are active on mainnet as of May 2024 are enforced from genesis.\n\n=== 1. 20-minute Exception Rule ===\n\nThis rule was implemented in Testnet 3<ref>https://github.com/bitcoin/bitcoin/pull/686</ref> and is preserved in Testnet 4.\n\n==== Rule Specification ====\n\n1. For any block except the first block in a difficulty period:\n   a. If the block's timestamp is >20 minutes past the timestamp of the previous block\n   b. Then the block MUST use the minimum difficulty value (<code>nBits</code> = <code>0x1d00ffff</code>), regardless of the network's actual difficulty\n\n2. The first block of each difficulty period MUST use the actual network difficulty.\n\nThis rule enables CPU mining on testnet but has led to block storms<ref>https://blog.lopp.net/the-block-storms-of-bitcoins-testnet/</ref> which rule #2 below addresses.\n\n=== 2. Block Storm Fix ===\n\nThis is a new rule to address block storms caused by the 20-minute exception.\n\n==== Problem Statement ====\n\nIn Mainnet and Testnet 3, the difficulty adjustment calculation uses the difficulty value of the last block in the previous period as its base. When the 20-minute exception is applied to this last block, it is mined at difficulty 1, causing the next period's difficulty to be constrained between 1-4, leading to block storms.\n\n==== Rule Specification ====\n\n1. For difficulty adjustment calculations between periods:\n   a. The base difficulty value MUST be taken from the first block of the previous difficulty period\n   b. NOT from the last block as in previous implementations\n\n2. The adjustment factor calculation remains unchanged:\n   a. Multiplication factor based on the duration of the previous difficulty period\n   b. Limited to no less than 1/4 and no more than 4x\n\nThis change ensures that the actual network difficulty is used for adjustment calculations rather than potentially manipulated values from the last block in a period.\n\n=== 3. Time Warp Attack Prevention ===\n\nThis rule prevents time warp attacks that could otherwise be used to amplify block storms<ref>A perpetual block storm attack with entire difficulty periods being authored in less than 3.5 days that resets the difficulty to the minimum in the last block of every difficulty period would adjust to a new actual difficulty of 4 every period. An attacker that additionally leverages a time warp attack would start their attack by holding back timestamps until the latest block's timestamp is at least two weeks in the past, and then limiting their block rate to six blocks per second, incrementing the timestamp on every sixth block. Only on the last block they would use the current time, which both resets the difficulty to one per the 20-minute exception and would result in a difficulty adjustment keeping the difficulty at the minimum due to the elapsed time exceeding the target. This would allow lower the difficulty for all blocks to difficulty 1 instead of difficulty 4</ref>.\n\n==== Rule Specification ====\n\n1. For any block whose height modulo 2016 equals 0 (i.e., the first block of each difficulty period):\n   a. The block's <code>nTime</code> field MUST be greater than or equal to the <code>nTime</code> field of the immediately prior block minus 600 seconds\n\n2. These blocks MUST still comply with existing Median-Time-Past <code>nTime</code> restrictions\n\nThis rule is based on The Great Consensus Cleanup proposal<ref>https://github.com/TheBlueMatt/bips/blob/cleanup-softfork/bip-XXXX.mediawiki</ref> and prevents miners from manipulating timestamps to artificially lower difficulty.\n\n== Rationale ==\n\nThe applied changes were the result of discussions on the mailing list and the PR. The selected changes try to strike a balance between minimal changes to the network (keeping it as close to mainnet as possible) while making it more robust against attackers that try to disrupt the network. Several alternative designs were considered:\n\n* For the block storm fix an alternative fix could have been to prevent the last block in a difficulty period from applying the existing difficulty exception. Both solutions were deemed acceptable and there was no clear preference among reviewers.\n* Removal of the 20-minute exception was discussed but dismissed since several reviewers insisted that it was a useful feature allowing non-standard transactions to be mined with just a CPU. The 20-minute exception also allows CPU users to move the chain forward (except on the first block that needs to be mined at actual difficulty) in case a large amount of hash power suddenly leaves the network. This would allow the chain to recover to a normal difficulty level faster if left stranded at high difficulty.\n* Increase of minimum difficulty was discussed but dismissed as it would categorically prevent participation in the network using a CPU miner (utilizing the 20-minute exception).\n* Increase of the delay in the 20-minute exception was suggested but did not receive significant support.\n* Re-enabling <code>acceptnonstdtxn</code> in bitcoin core by default was dismissed as it had led to confusion among layer-2s that had used testnet for transaction propagation tests and expected it to behave similarly to mainnet.\n* Motivating miners to re-org min difficulty blocks was suggested, but was considered out of scope for this BIP, since adoption of such a mining policy remains available after Testnet 4 is deployed. As 20-minute exception blocks only contribute work corresponding to difficulty one to the chaintip, and actual difficulty blocks should have a difficulty magnitudes higher, a block mined at actual difficulty could easily replace even multiple 20-minute exception blocks.\n* Persisting the real difficulty in the version field was suggested to robustly prevent exploits of the 20-minute exception while allowing it to be used on any block, but did not receive a sufficient level of support to justify the more invasive change.\n\nOne known downside of the chosen approach is that if the difficulty is gradually raised by a miner with significant hash rate, and this miner disappears, then each difficulty adjustment period requires one block at the actual difficulty.\n\nThis would cause the network to stall once per difficulty adjustment period until the real difficulty is adjusted downwards enough for the remaining hash rate to find this block in reasonable time.\n\n== Network Parameters ==\n\n=== Consensus Rules ===\n\nAll consensus rules active on mainnet at the time of this proposal are enforced from block 1, the newest of these rules being the Taproot softfork.\n\n=== Genesis Block ===\n\n* Message: <code>03/May/2024 000000000000000000001ebd58c244970b3aa9d783bb001011fbe8ea8e98e00e</code>\n* Pubkey: <code>000000000000000000000000000000000000000000000000000000000000000000</code>\n* Time stamp: 1714777860\n* Nonce: 393743547\n* Difficulty: <code>0x1d00ffff</code>\n* Version: 1\n\nThe resulting genesis block hash is <code>00000000da84f2bafbbc53dee25a72ae507ff4914b867c565be350b0da8bf043</code>, and the block hex is <code>0100000000000000000000000000000000000000000000000000000000000000000000004e7b2b9128fe0291db0693af2ae418b767e657cd407e80cb1434221eaea7a07a046f3566ffff001dbb0c78170101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff5504ffff001d01044c4c30332f4d61792f323032342030303030303030303030303030303030303030303165626435386332343439373062336161396437383362623030313031316662653865613865393865303065ffffffff0100f2052a010000002321000000000000000000000000000000000000000000000000000000000000000000ac00000000</code>.\n\n=== Message Start ===\n\nThe message start is defined as <code>0x1c163f28</code>. These four bytes were randomly generated and have no special meaning.\n\n=== Network Parameters ===\n\nThe default p2p port for Testnet 4 is `48333`.\n\n== Backwards Compatibility ==\n\nThe rules used by Testnet 4 are backwards compatible to the rules of Testnet 3. Existing software that implements support for Testnet 3 would only require addition of the network parameters  (magic number, genesis block, etc.) to be able to follow Testnet 4.\n\nHowever, implementations that only implement Testnet 3's rules would accept a chain that violates Testnet 4's rules and are therefore susceptible to being forked off. It is recommended that any implementations check blocks in regard to all the new rules of Testnet 4 and reject blocks that fail to comply.\n\n== Reference implementation ==\n\nPull request at https://github.com/bitcoin/bitcoin/pull/29775\n\n== References ==\n\n<references/>\n\n== Copyright ==\n\nThis document is licensed under the  Creative Commons CC0 1.0 Universal license.", "content_length": 10817}
{"bip_number": 93, "filename": "bip-0093.mediawiki", "content": "<pre>\n  BIP: 93\n  Layer: Applications\n  Title: codex32: Checksummed SSSS-aware BIP32 seeds\n  Author: Leon Olsson Curr and Pearlwort Sneed <pearlwort@wpsoftware.net>\n          Andrew Poelstra <andrew.poelstra@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0093\n  Status: Draft\n  Type: Informational\n  Created: 2023-02-13\n  License: BSD-3-Clause\n  Post-History: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021469.html\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document describes a standard for backing up and restoring the master seed of a\n[https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032] hierarchical deterministic wallet, using Shamir's secret sharing.\nIt includes an encoding format, a BCH error-correcting checksum, and algorithms for share generation and secret recovery.\nSecret data can be split into up to 31 shares.\nA minimum threshold of shares, which can be between 1 and 9, is needed to recover the secret, whereas without sufficient shares, no information about the secret is recoverable.\n\n===Copyright===\n\nThis document is licensed under the 3-clause BSD license.\n\n===Motivation===\n\nBIP-0032 master seed data is the source entropy used to derive all private keys in an HD wallet.\nSafely storing this secret data is the hardest and most important part of self-custody.\nHowever, there is a tension between security, which demands limiting the number of backups, and resilience, which demands widely replicated backups.\nEncrypting the seed does not change this fundamental tradeoff, since it leaves essentially the same problem of how to back up the encryption key(s).\n\nTo allow users freedom to make this tradeoff, we use Shamir's secret sharing, which guarantees that any number of shares less than the threshold leaks no information about the secret.\nThis approach allows increasing safety by widely distributing the generated shares, while also providing security against the compromise of one or more shares (as long as fewer than the threshold have been compromised).\n\n[https://github.com/satoshilabs/slips/blob/master/slip-0039.md SLIP-0039] has essentially the same motivations as this standard.\nHowever, unlike SLIP-0039,\n\n* this standard aims to be simple enough for hand computation\n* we use the bech32 alphabet rather than a word list, resulting in fixed-length compact encodings\n* we do not support multi-level secret sharing (splitting of shares), although it is technically possible and may be added in a future BIP\n* because of the need to support hand computation, we '''do not''' support passphrases or key hardening\n\nUsers who demand a higher level of security for particular secrets, or have a general distrust in digital electronic devices, have the option of using hand computation to backup and restore secret data in an interoperable manner.\nIn particular, all computations can be done with simple lookup tables.\n'''It is therefore possible to compute and verify checksums, and to split and recover seeds, entirely using pen and paper.'''\nFor long-lived rarely-used seeds, the ability to hand-verify checksums has a significant benefit even for users who do not care to do any other part of this process by hand.\nIt means that they can verify the integrity (against non-malicious tampering) of their shares regularly, say, on an annual basis, without needing to continually expose secret data to new hardware.\n\nThe ability to compute properties by hand comes from our choice of a small field and our use of linear error correcting codes.\nIt does not come with any reduction in security, as long as users use high-quality randomness.\nNote that hand computation is optional, the particular details of hand computation are outside the scope of this standard, and implementers do not need to be concerned with this possibility.\n\n[https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki BIP-0039] serves the same purpose as this standard: encoding master seeds for storage by users.\nHowever, BIP-0039 has no error-correcting ability, cannot sensibly be extended to support secret sharing, has no support for versioning or other metadata, and has many technical design decisions that make implementation and interoperability difficult (for example, the use of SHA-512 to derive seeds, or the use of 11-bit words).\n\n==Specification==\n\n===codex32===\n\nA codex32 string is similar to a bech32 string defined in [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP-0173].\nIt reuses the base-32 character set from BIP-0173, and consists of:\n\n* A human-readable part, which is the string \"ms\" (or \"MS\").\n* A separator, which is always \"1\".\n* A data part which is in turn subdivided into:\n** A threshold parameter, which MUST be a single digit between \"2\" and \"9\", or the digit \"0\".\n*** If the threshold parameter is \"0\" then the share index, defined below, MUST have a value of \"s\" (or \"S\").\n** An identifier consisting of 4 bech32 characters.\n** A share index, which is any bech32 character. Note that a share index value of \"s\" (or \"S\") is special and denotes the unshared secret (see section \"Unshared Secret\").\n** A payload which is a sequence of up to 74 bech32 characters. (However, see '''Long codex32 Strings''' below for an exception to this limit.)\n** A checksum which consists of 13 bech32 characters as described below.\n\nAs with bech32 strings, a codex32 string MUST be entirely uppercase or entirely lowercase.\nFor presentation, lowercase is usually preferable, but uppercase SHOULD be used for handwritten codex32 strings.\nIf a codex32 string is encoded in a QR code, it SHOULD use the uppercase form, as this is encoded more compactly.\n\n===Checksum===\n\nThe last thirteen characters of the data part form a checksum and contain no information.\nValid strings MUST pass the criteria for validity specified by the Python 3 code snippet below.\nThe function <code>ms32_verify_checksum</code> must return true when its argument is the data part as a list of integers representing the characters converted using the bech32 character table from BIP-0173.\n\nTo construct a valid checksum given the data-part characters (excluding the checksum), the <code>ms32_create_checksum</code> function can be used.\n\n<source lang=\"python\">\nMS32_CONST = 0x10ce0795c2fd1e62a\n\ndef ms32_polymod(values):\n    GEN = [\n        0x19dc500ce73fde210,\n        0x1bfae00def77fe529,\n        0x1fbd920fffe7bee52,\n        0x1739640bdeee3fdad,\n        0x07729a039cfc75f5a,\n    ]\n    residue = 0x23181b3\n    for v in values:\n        b = (residue >> 60)\n        residue = (residue & 0x0fffffffffffffff) << 5 ^ v\n        for i in range(5):\n            residue ^= GEN[i] if ((b >> i) & 1) else 0\n    return residue\n\ndef ms32_verify_checksum(data):\n    if len(data) >= 96:                      # See Long codex32 Strings\n        return ms32_verify_long_checksum(data)\n    if len(data) <= 93:\n        return ms32_polymod(data) == MS32_CONST\n    return False\n\ndef ms32_create_checksum(data):\n    if len(data) > 80:                       # See Long codex32 Strings\n        return ms32_create_long_checksum(data)\n    values = data\n    polymod = ms32_polymod(values + [0] * 13) ^ MS32_CONST\n    return [(polymod >> 5 * (12 - i)) & 31 for i in range(13)]\n</source>\n\n===Error Correction===\n\nA codex32 string without a valid checksum MUST NOT be used.\nThe checksum is designed to be an error correcting code that can correct up to 4 character substitutions, up to 8 unreadable characters (called erasures), or up to 13 consecutive erasures.\nImplementations SHOULD provide the user with a corrected valid codex32 string if possible.\nHowever, implementations SHOULD NOT automatically proceed with a corrected codex32 string without user confirmation of the corrected string, either by prompting the user, or returning a corrected string in an error message and allowing the user to repeat their action.\nWe do not specify how an implementation should implement error correction. However, we recommend that:\n\n* Implementations make suggestions to substitute non-bech32 characters with bech32 characters in some situations, such as replacing \"B\" with \"8\", \"O\" with \"0\", \"I\" with \"l\", etc.\n* Implementations interpret \"?\" as an erasure.\n* Implementations optionally interpret other non-bech32 characters, or characters with incorrect case, as erasures.\n* If a string with 8 or fewer erasures can have those erasures filled in to make a valid codex32 string, then the implementation suggests such a string as a correction.\n* If a string consisting of valid bech32 characters in the proper case can be made valid by substituting 4 or fewer characters, then the implementation suggests such a string as a correction.\n\n===Unshared Secret===\n\nWhen the share index of a valid codex32 string (converted to lowercase) is the letter \"s\", we call the string a codex32 secret.\nThe payload in a codex32 secret is a direct encoding of a BIP-0032 HD master seed.\n\nThe master seed is decoded by converting the payload to bytes:\n\n* Translate the characters to 5 bits values using the bech32 character table from BIP-0173, most significant bit first.\n* Re-arrange those bits into groups of 8 bits. Any incomplete group at the end MUST be 4 bits or less, and is discarded.\n\nNote that unlike the decoding process in BIP-0173, we do NOT require that the incomplete group be all zeros.\n\nFor an unshared secret, the threshold parameter (the first character of the data part) is ignored (beyond the fact it must be a digit for the codex32 string to be valid).\nWe recommend using the digit \"0\" for the threshold parameter in this case.\nThe 4 character identifier also has no effect beyond aiding users in distinguishing between multiple different master seeds in cases where they have more than one.\n\n===Recovering Master Seed===\n\nWhen the share index of a valid codex32 string (converted to lowercase) is not the letter \"s\", we call the string an codex32 share.\nThe first character of the data part indicates the threshold of the share, and it is required to be a non-\"0\" digit.\n\nIn order to recover a master seed, one needs a set of valid codex32 shares such that:\n\n* All shares have the same threshold value, the same identifier, and the same length.\n* All of the share index values are distinct.\n* The number of codex32 shares is exactly equal to the (common) threshold value.\n\nIf all the above conditions are satisfied, the <code>ms32_recover</code> function will return a codex32 secret when its argument is the list of codex32 shares with each share represented as a list of integers representing the characters converted using the bech32 character table from BIP-0173.\n\n<source lang=\"python\">\nbech32_inv = [\n    0, 1, 20, 24, 10, 8, 12, 29, 5, 11, 4, 9, 6, 28, 26, 31,\n    22, 18, 17, 23, 2, 25, 16, 19, 3, 21, 14, 30, 13, 7, 27, 15,\n]\n\ndef bech32_mul(a, b):\n    res = 0\n    for i in range(5):\n        res ^= a if ((b >> i) & 1) else 0\n        a *= 2\n        a ^= 41 if (32 <= a) else 0\n    return res\n\ndef bech32_lagrange(l, x):\n    n = 1\n    c = []\n    for i in l:\n        n = bech32_mul(n, i ^ x)\n        m = 1\n        for j in l:\n            m = bech32_mul(m, (x if i == j else i) ^ j)\n        c.append(m)\n    return [bech32_mul(n, bech32_inv[i]) for i in c]\n\ndef ms32_interpolate(l, x):\n    w = bech32_lagrange([s[5] for s in l], x)\n    res = []\n    for i in range(len(l[0])):\n        n = 0\n        for j in range(len(l)):\n            n ^= bech32_mul(w[j], l[j][i])\n        res.append(n)\n    return res\n\ndef ms32_recover(l):\n    return ms32_interpolate(l, 16)\n</source>\n\n===Generating Shares===\n\nIf we already have ''t'' valid codex32 strings such that:\n\n* All strings have the same threshold value ''t'', the same identifier, and the same length\n* All of the share index values are distinct\n\nThen we can derive additional shares with the <code>ms32_interpolate</code> function by passing it a list of exactly ''t'' of these codex32 strings, together with a fresh share index distinct from all of the existing share indexes.\nThe newly derived share will have the provided share index.\n\nOnce a user has generated ''n'' codex32 shares, they may discard the codex32 secret (if it exists).\nThe ''n'' shares form a ''t'' of ''n'' Shamir's secret sharing scheme of a codex32 secret.\n\nThere are two ways to create an initial set of ''t'' valid codex32 strings, depending on whether the user already has an existing master seed to split.\n\n====For a fresh master seed====\n\nIn the case that the user wishes to generate a fresh master seed, the user generates random initial shares, as follows:\n\n# Choose a bitsize, between 128 and 512, which must be a multiple of 8.\n# Choose a threshold value ''t'' between 2 and 9, inclusive\n# Choose a 4 bech32 character identifier\n#* We do not define how to choose the identifier, beyond noting that it SHOULD be distinct for every master seed the user may need to disambiguate.\n# ''t'' many times, generate a random share by:\n## Take the next available letter from the bech32 alphabet, in alphabetical order, as <code>a</code>, <code>c</code>, <code>d</code>, ..., to be the share index\n## Set the first nine characters to be the prefix <code>ms1</code>, the threshold value ''t'', the 4-character identifier, and then the share index\n## Choose the next ceil(''bitlength / 5'') characters uniformly at random\n## Generate a valid checksum in accordance with the Checksum section, and append this to the resulting shares\n\nThe result will be ''t'' distinct shares, all with the same initial 8 characters, and a distinct share index as the 9th character.\n\nWith this set of ''t'' codex32 shares, new shares can be derived as discussed above. This process generates a fresh master seed, whose value can be retrieved by running the recovery process on any ''t'' of these shares.\n\n====For an existing master seed====\n\nBefore generating shares for an existing master seed, it first must be converted into a codex32 secret, as described above.\nThe conversion process consists of:\n\n# Choose a threshold value ''t'' between 2 and 9, inclusive\n# Choose a 4 bech32 character identifier\n#* We do not define how to choose the identifier, beyond noting that it SHOULD be distinct for every master seed the user may need to disambiguate.\n# Set the share index to <code>s</code>\n# Set the payload to a bech32 encoding of the master seed, padded with arbitrary bits\n# Generating a valid checksum in accordance with the Checksum section\n\nAlong with the codex32 secret, the user must generate ''t''-1 other codex32 shares, each with the same threshold value, the same identifier, and a distinct share index.\nThese shares should be generated as described in the \"fresh master seed\" section.\n\nThe codex32 secret and the ''t''-1 codex32 shares form a set of ''t'' valid codex32 strings from which additional shares can be derived as described above.\n\n===Long codex32 Strings===\n\nThe 13 character checksum design only supports up to 80 data characters.\nExcluding the threshold, identifier and index characters, this limits the payload to 74 characters or 46 bytes.\nWhile this is enough to support the 32-byte advised size of BIP-0032 master seeds, BIP-0032 allows seeds to be up to 64 bytes in size.\nWe define a long codex32 string format to support these longer seeds by defining an alternative checksum.\n\n<source lang=\"python\">\nMS32_LONG_CONST = 0x43381e570bf4798ab26\n\ndef ms32_long_polymod(values):\n    GEN = [\n        0x3d59d273535ea62d897,\n        0x7a9becb6361c6c51507,\n        0x543f9b7e6c38d8a2a0e,\n        0x0c577eaeccf1990d13c,\n        0x1887f74f8dc71b10651,\n    ]\n    residue = 0x23181b3\n    for v in values:\n        b = (residue >> 70)\n        residue = (residue & 0x3fffffffffffffffff) << 5 ^ v\n        for i in range(5):\n            residue ^= GEN[i] if ((b >> i) & 1) else 0\n    return residue\n\ndef ms32_verify_long_checksum(data):\n    return ms32_long_polymod(data) == MS32_LONG_CONST\n\ndef ms32_create_long_checksum(data):\n    values = data\n    polymod = ms32_long_polymod(values + [0] * 15) ^ MS32_LONG_CONST\n    return [(polymod >> 5 * (14 - i)) & 31 for i in range(15)]\n</source>\n\nA long codex32 string follows the same specification as a regular codex32 string with the following changes.\n\n* The payload is a sequence of between 75 and 103 bech32 characters.\n* The checksum consists of 15 bech32 characters as defined above.\n\nA codex32 string with a data part of 94 or 95 characters is never legal as a regular codex32 string is limited to 93 data characters and a long codex32 string is at least 96 characters.\n\nGeneration of long shares and recovery of the master seed from long shares proceeds in exactly the same way as for regular shares with the <code>ms32_interpolate</code> function.\n\nThe long checksum is designed to be an error correcting code that can correct up to 4 character substitutions, up to 8 unreadable characters (called erasures), or up to 15 consecutive erasures.\nAs with regular checksums we do not specify how an implementation should implement error correction, and all our recommendations for error correction of regular codex32 strings also apply to long codex32 strings.\n\n==Rationale==\n\nThis scheme is based on the observation that the Lagrange interpolation of valid codewords in a BCH code will always be a valid codeword.\nThis means that derived shares will always have valid checksum, and a sufficient threshold of shares with valid checksums will derive a secret with a valid checksum.\n\nThe header system is also compatible with Lagrange interpolation, meaning all derived shares will have the same identifier and will have the appropriate share index.\nThis fact allows the header data to be covered by the checksum.\n\nThe checksum size and identifier size have been chosen so that the encoding of 128-bit seeds and shares fit within 48 characters.\nThis is a standard size for many common seed storage formats, which has been popularized by the 12 four-letter word format of the BIP-0039 mnemonic.\n\nThe 13 character checksum is adequate to correct 4 errors in up to 93 characters (80 characters of data and 13 characters of the checksum).\nWe can correct up to 8 erasures (errors with known locations), and up to 13 consecutive errors (burst errors).\nBeyond that, our code is guaranteed to detect up to 8 errors.\nMore generally, any number of random errors will be detected with overwhelming (1 - 2^65) probability. However, the checksum does not protect against maliciously constructed errors.\nThese parameters are slightly better than those of the checksum used in SLIP-0039.\n\nFor 256-bit seeds and shares our strings are 74 characters, which fits into the 96 character format of the 24 four-letter word format of the BIP-0039 mnemonic, with plenty of room to spare.\n\nA longer checksum is needed to support up to 512-bit seeds, the longest seed length specified in BIP-0032, as the 13 character checksum isn't adequate for more than 80 data characters.\nWhile we could use the 15 character checksum for both cases, we prefer to keep the strings as short as possible for the more common cases of 128-bit and 256-bit master seeds.\nWe only guarantee to correct 4 characters no matter how long the string is.\nLonger strings mean more chances for transcription errors, so shorter strings are better.\n\nThe longest data part using the regular 13 character checksum is 93 characters and corresponds to a 400-bit secret.\nAt this length, the prefix <code>MS1</code> is not covered by the checksum.\nThis is acceptable because the checksum scheme itself requires you to know that the <code>MS1</code> prefix is being used in the first place.\nIf the prefix is damaged and a user is guessing that the data might be using this scheme, then the user can enter the available data explicitly using the suspected <code>MS1</code> prefix.\n\n===Not BIP-0039 Entropy===\n\nInstead of encoding a BIP-0032 master seed, an alternative would be to encode BIP-0039 entropy.\nHowever this alternative approach is fraught with difficulties.\n\nOn approach would be to encode the BIP-0039 entropy along with the BIP-0039 checksum data.\nThis data can directly be recovered from the BIP-0039 mnemonic, and the process can be reversed if one knows the target language.\nHowever, for a 128-bit seed, there is a 4 bit checksum yielding 132 bits of data that needs to be encoded.\nThis exceeds the 130-bits of room that we have for storing 128 bit seeds.\nWe would have to compromise on the 48 character size, or the size of the headers, or the size of the checksum in order to add room for an additional character of data.\n\nThis approach would also eliminate our short cut generation of a fresh master secret from generating random shares.\nOne would be required to first generate BIP-0039 entropy, and then add a BIP-0039 checksum, before adding a Codex32 checksum and then generate other shares.\nIn particular, this process could no longer be performed by hand since it is effectively impossible to hand compute a BIP-0039 checksum.\n\nAn alternative approach is to discard the BIP-0039 checksum, since it is inadequate for error correction anyways, and rely on the Codex32 checksum.\nHowever, this approach ends up eliminating the benefits of BIP-0039 compatibility.\nWhile it is now possible to hand generate fresh shares, it is impossible to recover compatible BIP-0039 words by hand because, again, the BIP-0039 checksum is not hand computable.\nThe only way of generating the compatible BIP-0039 mnemonic is to use wallet software.\nBut if the wallet software is need to support this approach to decoding entropy, we may as well bypass all of the overhead of BIP-0039 and directly encode the entropy of a BIP-0032 master seed, which is what we do in our Codex32 proposal.\n\nBeyond the problems above, BIP-0039 does not define a single transformation from entropy to BIP-0032 master seed.\nInstead every different language has it own word list (or word lists) and each choice of word list yields a different transformation from entropy to master seed.\nWe would need to encode the choice of word list in our share's meta-data, which takes up even more room, and is difficult to specify due to the ever-evolving choice of word lists.\n\nAlternatively we could standardize on the choice of the English word list, something that is nearly a de facto standard, and simply be incompatible with BIP-0039 wallets of other languages.\nSuch a choice also risks users of BIP-0039 recovering their entropy from their language, encoding it in Codex32 and then failing to recover their wallet because the English word lists has replaced their language's word list.\n\nThe main advantage of this alternative approach would be that wallets could give users an option switch between backing up their entropy as a BIP-0039 mnemonic and in Codex32 format, but again, only if their language choice happens to be the English word list.\nIn practice, we do not expect users in switch back and forth between backup formats, and instead just generate a fresh master seed using Codex32.\n\nSeeing little value with BIP-0039 compatibility (English-only), all the difficulties with BIP-0039 language choice, not to mention the PBKDF2 overhead of using BIP-0039, we think it is best to abandon BIP-0039 and encode BIP-0032 master seeds directly.\nOur approach is semi-convertible with BIP-0039's 512-bit master seeds (in all languages, see Backwards Compatibility) and fully interconvertible with SLIP-39 encoded master seeds or any other encoding of BIP-0032 master seeds.\n\n==Backwards Compatibility==\n\ncodex32 is an alternative to BIP-0039 and SLIP-0039.\nIt is technically possible to derive the BIP32 master seed from seed words encoded in one of these schemes, and then to encode this seed in codex32.\nFor BIP-0039 this process is irreversible, since it involves hashing the original words.\nFurthermore, the resulting seed will be 512 bits long, which may be too large to be safely and conveniently handled.\n\nSLIP-0039 seed words can be reversibly converted to master seeds, so it is possible to interconvert between SLIP-0039 and codex32.\nHowever, SLIP-0039 '''shares''' cannot be converted to codex32 shares because the two schemes use a different underlying field.\n\nThe authors of this BIP do not recommend interconversion.\nInstead, users who wish to switch to codex32 should generate a fresh seed and sweep their coins.\n\n==Reference Implementation==\n\nOur [https://github.com/BlockstreamResearch/codex32  reference implementation repository] contains implementations in Rust and PostScript.\nThe inline code in this BIP text can be used as a Python reference.\n\n==Test Vectors==\n\n===Test vector 1===\n\nThis example shows the codex32 format, when used without splitting the secret into any shares.\nThe payload contains 26 bech32 characters, which corresponds to 130 bits. We truncate the last two bits in order to obtain a 128-bit master seed.\n\ncodex32 secret (bech32): <code>ms10testsxxxxxxxxxxxxxxxxxxxxxxxxxx4nzvca9cmczlw</code>\n\nMaster secret (hex): <code>318c6318c6318c6318c6318c6318c631</code>\n\n* human-readable part: <code>ms</code>\n* separator: <code>1</code>\n* k value: <code>0</code> (no secret splitting)\n* identifier: <code>test</code>\n* share index: <code>s</code> (the secret)\n* payload: <code>xxxxxxxxxxxxxxxxxxxxxxxxxx</code>\n* checksum: <code>4nzvca9cmczlw</code>\n* master node xprv: <code>xprv9s21ZrQH143K3taPNekMd9oV5K6szJ8ND7vVh6fxicRUMDcChr3bFFzuxY8qP3xFFBL6DWc2uEYCfBFZ2nFWbAqKPhtCLRjgv78EZJDEfpL</code>\n\n===Test vector 2===\n\nThis example shows generating a new master seed using \"random\" codex32 shares, as well as deriving an additional codex32 share, using ''k''=2 and an identifier of <code>NAME</code>.\nAlthough codex32 strings are canonically all lowercase, it's also valid to use all uppercase.\n\nShare with index <code>A</code>: <code>MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM</code>\n\nShare with index <code>C</code>: <code>MS12NAMECACDEFGHJKLMNPQRSTUVWXYZ023FTR2GDZMPY6PN</code>\n\n* Derived share with index <code>D</code>: <code>MS12NAMEDLL4F8JLH4E5VDVULDLFXU2JHDNLSM97XVENRXEG</code>\n* Secret share with index <code>S</code>: <code>MS12NAMES6XQGUZTTXKEQNJSJZV4JV3NZ5K3KWGSPHUH6EVW</code>\n* Master secret (hex): <code>d1808e096b35b209ca12132b264662a5</code>\n* master node xprv: <code>xprv9s21ZrQH143K2NkobdHxXeyFDqE44nJYvzLFtsriatJNWMNKznGoGgW5UMTL4fyWtajnMYb5gEc2CgaKhmsKeskoi9eTimpRv2N11THhPTU</code>\n\nNote that per BIP-0173, the lowercase form is used when determining a character's value for checksum purposes.\nIn particular, given an all uppercase codex32 string, we still use lowercase <code>ms</code> as the human-readable part during checksum construction.\n\n===Test vector 3===\n\nThis example shows splitting an existing 128-bit master seed into \"random\" codex32 shares, using ''k''=3 and an identifier of <code>cash</code>.\nWe appended two zero bits in order to obtain 26 bech32 characters (130 bits of data) from the 128-bit master seed.\n\nMaster secret (hex): <code>ffeeddccbbaa99887766554433221100</code>\n\nSecret share with index <code>s</code>: <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>\n\nShare with index <code>a</code>: <code>ms13casha320zyxwvutsrqpnmlkjhgfedca2a8d0zehn8a0t</code>\n\nShare with index <code>c</code>: <code>ms13cashcacdefghjklmnpqrstuvwxyz023949xq35my48dr</code>\n\n* Derived share with index <code>d</code>: <code>ms13cashd0wsedstcdcts64cd7wvy4m90lm28w4ffupqs7rm</code>\n* Derived share with index <code>e</code>: <code>ms13casheekgpemxzshcrmqhaydlp6yhms3ws7320xyxsar9</code>\n* Derived share with index <code>f</code>: <code>ms13cashf8jh6sdrkpyrsp5ut94pj8ktehhw2hfvyrj48704</code>\n* master node xprv: <code>xprv9s21ZrQH143K266qUcrDyYJrSG7KA3A7sE5UHndYRkFzsPQ6xwUhEGK1rNuyyA57Vkc1Ma6a8boVqcKqGNximmAe9L65WsYNcNitKRPnABd</code>\n\nAny three of the five shares among <code>acdef</code> can be used to recover the secret.\n\nNote that the choice to append two zero bits was arbitrary, and any of the following four secret shares would have been valid choices.\nHowever, each choice would have resulted in a different set of derived shares.\n\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qqjzqud4m0d6nln</code>\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qpte35dvzkjpt0r</code>\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qzfatvdwq5692k6</code>\n* <code>ms13cashsllhdmn9m42vcsamx24zrxgs3qrsx6ydhed97jx2</code>\n\n===Test vector 4===\n\nThis example shows converting a 256-bit secret into a codex32 secret, without splitting the secret into any shares.\nWe appended four zero bits in order to obtain 52 bech32 characters (260 bits of data) from the 256-bit secret.\n\n256-bit secret (hex): <code>ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221100</code>\n\n* codex32 secret: <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>\n* master node xprv: <code>xprv9s21ZrQH143K3s41UCWxXTsU4TRrhkpD1t21QJETan3hjo8DP5LFdFcB5eaFtV8x6Y9aZotQyP8KByUjgLTbXCUjfu2iosTbMv98g8EQoqr</code>\n\nNote that the choice to append four zero bits was arbitrary, and any of the following sixteen codex32 secrets would have been valid:\n\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqqtum9pgv99ycma</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqpj82dp34u6lqtd</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqzsrs4pnh7jmpj5</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqrfcpap2w8dqezy</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqy5tdvphn6znrf0</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq9dsuypw2ragmel</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqx05xupvgp4v6qx</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq8k0h5p43c2hzsk</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqgum7hplmjtr8ks</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqf9q0lpxzt5clxq</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq28y48pyqfuu7le</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqt7ly0paesr8x0f</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqvrvg7pqydv5uyz</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqd6hekpea5n0y5j</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyqwcnrwpmlkmt9dt</code>\n* <code>ms10leetsllhdmn9m42vcsamx24zrxgs3qrl7ahwvhw4fnzrhve25gvezzyq0pgjxpzx0ysaam</code>\n\n===Test vector 5===\n\nThis example shows generating a new 512-bit master seed using \"random\" codex32 characters and appending a checksum.\nThe payload contains 103 bech32 characters, which corresponds to 515 bits. The last three bits are discarded when converting to a 512-bit master seed.\n\nThis is an example of a '''Long codex32 String'''.\n\n* Secret share with index <code>S</code>: <code>MS100C8VSM32ZXFGUHPCHTLUPZRY9X8GF2TVDW0S3JN54KHCE6MUA7LQPZYGSFJD6AN074RXVCEMLH8WU3TK925ACDEFGHJKLMNPQRSTUVWXY06FHPV80UNDVARHRAK</code>\n* Master secret (hex): <code>dc5423251cb87175ff8110c8531d0952d8d73e1194e95b5f19d6f9df7c01111104c9baecdfea8cccc677fb9ddc8aec5553b86e528bcadfdcc201c17c638c47e9</code>\n* master node xprv: <code>xprv9s21ZrQH143K4UYT4rP3TZVKKbmRVmfRqTx9mG2xCy2JYipZbkLV8rwvBXsUbEv9KQiUD7oED1Wyi9evZzUn2rqK9skRgPkNaAzyw3YrpJN</code>\n\n===Invalid test vectors===\n\nThese examples have incorrect checksums.\n\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghq</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxve740yyge2ghp</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxlk3yepcstwr</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx6pgnv7jnpcsp</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxx0cpvr7n4geq</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxm5252y7d3lr</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxrd9sukzl05ej</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxc55srw5jrm0</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxgc7rwhtudwc</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx4gy22afwghvs</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxe8yfm0</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvm597d</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pe0</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxme084q0vpht7pew</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxqyadsp3nywm8a</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxzvg7ar4hgaejk</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcznau0advgxqe</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxch3jrc6j5040j</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx52gxl6ppv40mcv</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx7g4g2nhhle8fk</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx63m45uj8ss4x8</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy4r708q7kg65x</code>\n\nThese examples use the wrong checksum for their given data sizes.\n\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxurfvwmdcmymdufv</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxcsyppjkd8lz4hx3</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxu6hwvl5p0l9xf3c</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwqey9rfs6smenxa</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxv70wkzrjr4ntqet</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3hmlrmpa4zl0v</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxrfggf88znkaup</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpt7l4aycv9qzj</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxus27z9xtyxyw3</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcwm4re8fs78vn</code>\n\nThese examples have improper lengths.\nThey are either too short, too long, or would decode to byte sequence with an incomplete group greater than 4 bits.\n\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxw0a4c70rfefn4</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxk4pavy5n46nea</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxx9lrwar5zwng4w</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxr335l5tv88js3</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxvu7q9nz8p7dj68v</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpq6k542scdxndq3</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxkmfw6jm270mz6ej</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxzhddxw99w7xws</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx42cux6um92rz</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxarja5kqukdhy9</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxky0ua3ha84qk8</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9eheesxadh2n2n9</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9llwmgesfulcj2z</code>\n* <code>ms12fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx02ev7caq6n9fgkf</code>\n\nThis example uses a \"0\" threshold with a non-\"s\" index\n\n* <code>ms10fauxxxxxxxxxxxxxxxxxxxxxxxxxxxx0z26tfn0ulw3p</code>\n\nThis example has a threshold that is not a digit.\n\n* <code>ms1fauxxxxxxxxxxxxxxxxxxxxxxxxxxxxxda3kr3s0s2swg</code>\n\nThese examples do not begin with the required \"ms\" or \"MS\" prefix and/or are missing the \"1\" separator.\n\n* <code>0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>ms0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>0fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws</code>\n* <code>10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxhkd4f70m8lgws</code>\n* <code>m10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxx8t28z74x8hs4l</code>\n* <code>s10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxh9d0fhnvfyx3x</code>\n\nThese examples all incorrectly mix upper and lower case characters.\n\n* <code>Ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>mS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>MS10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>ms10FAUXsxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>ms10fauxSxxxxxxxxxxxxxxxxxxxxxxxxxxuqxkk05lyf3x2</code>\n* <code>ms10fauxsXXXXXXXXXXXXXXXXXXXXXXXXXXuqxkk05lyf3x2</code>\n* <code>ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxUQXKK05LYF3X2</code>\n\n==Appendix==\n\n===Mathematical Companion===\n\nBelow we use the bech32 character set to denote values in GF[32].\nIn bech32, the letter <code>Q</code> denotes zero and the letter <code>P</code> denotes one.\nThe digits <code>0</code> and <code>2</code> through <code>9</code> do ''not'' denote their numeric values.\nThey are simply elements of GF[32].\n\nThe generating polynomial for our BCH code is as follows.\n\nWe extend GF[32] to GF[1024] by adjoining a primitive cube root of unity, <code>\u03b6</code>, satisfying <code>\u03b6^2 = \u03b6 + P</code>.\n\nWe select <code>\u03b2 := G \u03b6</code> which has order 93, and construct the product <code>(x - \u03b2^i)</code> for <code>i</code> in <code>{17, 20, 46, 49, 52, 77, 78, 79, 80, 81, 82, 83, 84}</code>.\nThe resulting polynomial is our generating polynomial for our 13 character checksum:\n\n    x^13 + E x^12 + M x^11 + 3 x^10 + G x^9 + Q x^8 + E x^7 + E x^6 + E x^5 + L x^4 + M x^3 + C x^2 + S x + S\n\nFor our long checksum, we select <code>\u03b3 := E + X \u03b6</code>, which has order 1023, and construct the product <code>(x - \u03b3^i)</code> for <code>i</code> in <code>{32, 64, 96, 895, 927, 959, 991, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026}</code>.\nThe resulting polynomial is our generating polynomial for our 15 character checksum for long strings:\n\n    x^15 + 0 x^14 + 2 x^13 + E x^12 + 6 x^11 + F x^10 + E x^9 + 4 x^8 + X x^7 + H x^6 + 4 x^5 + X x^4 + 9 x^3 + K x^2 + Y x^1 + H\n\n(Reminder: the character <code>0</code> does ''not'' denote the zero of the field.)\n", "content_length": 39137}
{"bip_number": 91, "filename": "bip-0091.mediawiki", "content": "<pre>\n  BIP: 91\n  Layer: Consensus (soft fork)\n  Title: Reduced threshold Segwit MASF\n  Author: James Hilliard <james.hilliard1@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0091\n  Status: Final\n  Type: Standards Track\n  Created: 2017-05-22\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies a method to activate the existing BIP9 segwit deployment with a majority hashpower less than 95%.\n\n==Definitions==\n\n\"existing segwit deployment\" refer to the BIP9 \"segwit\" deployment using bit 1, between November 15th 2016 and November 15th 2017 to activate BIP141, BIP143 and BIP147.\n\n==Motivation==\n\nSegwit increases the blocksize, fixes transaction malleability, and makes scripting easier to upgrade as well as bringing many other [https://bitcoincore.org/en/2016/01/26/segwit-benefits/ benefits].\n\nThis BIP provides a way for a simple majority of miners to coordinate activation of the existing segwit deployment with less than 95% hashpower. For a number of reasons a complete redeployment of segwit is difficult to do until the existing deployment expires. This is due to 0.13.1+ having many segwit related features active already, including all the P2P components, the new network service flag, the witness-tx and block messages, compact blocks v2 and preferential peering. A redeployment of segwit will need to redefine all these things and doing so before expiry would greatly complicate testing.\n\n==Specification==\n\nWhile this BIP is active, all blocks must set the nVersion header top 3 bits to 001 together with bit field (1<<1) (according to the existing segwit deployment). Blocks that do not signal as required will be rejected.\n\n==Deployment==\n\nThis BIP will be deployed by a \"version bits\" with an 80%(this can be adjusted if desired) 269 block activation threshold and 336 block confirmation window BIP9 with the name \"segsignal\" and using bit 4.\n\nThis BIP will have a start time of midnight June 1st, 2017 (epoch time 1496275200) and timeout on midnight November 15th 2017 (epoch time 1510704000). This BIP will cease to be active when segwit (BIP141) is locked-in, active, or failed\n\n=== Reference implementation ===\n\n<pre>\n// Deployment of SEGSIGNAL\nconsensus.vDeployments[Consensus::DEPLOYMENT_SEGSIGNAL].bit = 4;\nconsensus.vDeployments[Consensus::DEPLOYMENT_SEGSIGNAL].nStartTime = 1496275200; // June 1st, 2017.\nconsensus.vDeployments[Consensus::DEPLOYMENT_SEGSIGNAL].nTimeout = 1510704000; // November 15th, 2017.\nconsensus.vDeployments[Consensus::DEPLOYMENT_SEGSIGNAL].nOverrideMinerConfirmationWindow = 336; // ~2.33 days\nconsensus.vDeployments[Consensus::DEPLOYMENT_SEGSIGNAL].nOverrideRuleChangeActivationThreshold = 269; // 80%\n\nclass VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\nprivate:\n    const Consensus::DeploymentPos id;\n\nprotected:\n    int64_t BeginTime(const Consensus::Params& params) const { return params.vDeployments[id].nStartTime; }\n    int64_t EndTime(const Consensus::Params& params) const { return params.vDeployments[id].nTimeout; }\n    int Period(const Consensus::Params& params) const {\n        if (params.vDeployments[id].nOverrideMinerConfirmationWindow > 0)\n            return params.vDeployments[id].nOverrideMinerConfirmationWindow;\n        return params.nMinerConfirmationWindow;\n    }\n    int Threshold(const Consensus::Params& params) const {\n        if (params.vDeployments[id].nOverrideRuleChangeActivationThreshold > 0)\n            return params.vDeployments[id].nOverrideRuleChangeActivationThreshold;\n        return params.nRuleChangeActivationThreshold;\n    }\n\n    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n    {\n        return (((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) && (pindex->nVersion & Mask(params)) != 0);\n    }\n\npublic:\n    VersionBitsConditionChecker(Consensus::DeploymentPos id_) : id(id_) {}\n    uint32_t Mask(const Consensus::Params& params) const { return ((uint32_t)1) << params.vDeployments[id].bit; }\n};\n\n// SEGSIGNAL mandatory segwit signalling.\nif (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGSIGNAL, versionbitscache) == THRESHOLD_ACTIVE &&\n    VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT,    versionbitscache) == THRESHOLD_STARTED)\n{\n    bool fVersionBits = (pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n    bool fSegbit = (pindex->nVersion & VersionBitsMask(chainparams.GetConsensus(), Consensus::DEPLOYMENT_SEGWIT)) != 0;\n    if (!(fVersionBits && fSegbit)) {\n        return state.DoS(0, error(\"ConnectBlock(): relayed block must signal for segwit, please upgrade\"), REJECT_INVALID, \"bad-no-segwit\");\n    }\n}\n</pre>\n\nhttps://github.com/segsignal/bitcoin\n\n==Backwards Compatibility==\n\nThis deployment is compatible with the existing \"segwit\" bit 1 deployment scheduled between midnight November 15th, 2016 and midnight November 15th, 2017. Miners will need to upgrade their nodes to support segsignal otherwise they may build on top of an invalid block. While this bip is active users should either upgrade to segsignal or wait for additional confirmations when accepting payments.\n\n==Rationale==\n\nHistorically we have used IsSuperMajority() to activate soft forks such as BIP66 which has a mandatory signalling requirement for miners once activated, this ensures that miners are aware of new rules being enforced. This technique can be leveraged to lower the signalling threshold of a soft fork while it is in the process of being deployed in a backwards compatible way.\n\nBy orphaning non-signalling blocks during the BIP9 bit 1 \"segwit\" deployment, this BIP can cause the existing \"segwit\" deployment to activate without needing to release a new deployment.\n\n==References==\n\n*[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013714.html Mailing list discussion]\n*[https://github.com/bitcoin/bitcoin/blob/v0.6.0/src/main.cpp#L1281-L1283 P2SH flag day activation]\n*[[bip-0009.mediawiki|BIP9 Version bits with timeout and delay]]\n*[[bip-0016.mediawiki|BIP16 Pay to Script Hash]]\n*[[bip-0141.mediawiki|BIP141 Segregated Witness (Consensus layer)]]\n*[[bip-0143.mediawiki|BIP143 Transaction Signature Verification for Version 0 Witness Program]]\n*[[bip-0147.mediawiki|BIP147 Dealing with dummy stack element malleability]]\n*[[bip-0148.mediawiki|BIP148 Mandatory activation of segwit deployment]]\n*[[bip-0149.mediawiki|BIP149 Segregated Witness (second deployment)]]\n*[https://bitcoincore.org/en/2016/01/26/segwit-benefits/ Segwit benefits]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n\n", "content_length": 6747}
{"bip_number": 90, "filename": "bip-0090.mediawiki", "content": "<pre>\n  BIP: 90\n  Title: Buried Deployments\n  Author: Suhas Daftuar <sdaftuar@chaincode.com>\n  Comments-Summary: Mostly Recommended for implementation, with some Discouragement\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0090\n  Status: Final\n  Type: Informational\n  Created: 2016-11-08\n  License: PD\n</pre>\n\n\n==Abstract==\n\nPrior soft forks (BIP 34, BIP 65, and BIP 66) were activated via miner signaling in block version numbers.  Now that the chain has long since passed the blocks at which those consensus rules have triggered, we can (as a simplification) replace the trigger mechanism by caching the block heights at which those consensus rules became enforced.\n\n==Motivation==\n\nBIPs 34, 65 and 66 were deployed on mainnet using miner signaling using block version numbers.  In short, new consensus rules were proposed for use in blocks with a higher version number (N+1) than the prevailing block version (N) in use on the network, and those rules became enforced under the following conditions:\n# 75% rule: If 750 of the prior 1000 blocks are version N+1 or higher, then blocks with version N+1 or higher must correctly enforce the new consensus rule.\n# 95% rule: If 950 of the prior 1000 blocks are version N+1 or higher, then blocks with version less than N+1 are invalid.\n\nPlease see those [[#References|BIPs]] for more details.\n\nNote that this trigger mechanism is dependent on the chain history.  To validate a block, we must test whether the trigger was met by looking at the previous 1000 blocks in the chain before it, which can be inefficient.\n\nIn addition, this mechanism for code deployments have been deprecated in favor of BIP 9 deployments, which offer several advantages (please see [https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki BIP 9]).\n\nThus we propose elimination of the logic implementing these kinds of deployments, by replacing the test which governs enforcement of BIP 34, BIP 65, and BIP 66 with simple height checks, which we choose to be the block height triggering the 95% activation rule on mainnet for each of those deployments.  This simplification of the consensus rules would reduce the technical debt associated with deployment of those consensus changes.\n\n==Considerations==\n\nIt is technically possible for this to be a non-backwards compatible change.  For example, if an alternate chain were created in which BIP 34's 95% activation triggered at a lower height (H') than it did on the current mainnet chain (H), then older software would enforce that version 1 blocks were invalid at heights between H' and H, while newer software implementing this change would not.  Similarly, this BIP proposes doing away with the 75% threshold check altogether, which means, for example, that a version 2 block forking off of mainnet at height H-1 which omitted the height in coinbase would be invalid to older software, while accepted by newer software.\n\nHowever, while newer software and older software might validate old blocks differently, that could only cause a consensus split if there were an extremely large blockchain reorganization onto a chain built off such a block.  As of November 2016, the most recent of these changes (BIP 65, enforced since December 2015) has nearly 50,000 blocks built on top of it.  The occurrence of such a reorg that would cause the activating block to be disconnected would raise fundamental concerns about the security assumptions of Bitcoin, a far bigger issue than any non-backwards compatible change.\n\nSo while this proposal could <i>theoretically</i> result in a consensus split, it is extremely unlikely, and in particular any such circumstances would be sufficiently damaging to the Bitcoin network to dwarf any concerns about the effects of this proposed change.\n\n==Specification==\n\nThe BIP 34, 66, and 65 activation heights are set to 227931, 363725, and 388381, respectively.\n\nThe 1000-block lookback test, first described in BIP 34, is no longer performed during validation of any blocks.  Instead, a new check is added:\n\n    if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n       (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n       (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n\nFurthermore, rather than consider the block versions of the prior 1000 blocks to determine whether to enforce BIP 34, BIP 65, or BIP 66 on a given block, we instead just compare the height of the block being validated with the stored activation heights:\n\n    // Enforce rule that the coinbase starts with serialized block height\n    if (nHeight >= consensusParams.BIP34Height)\n    {\n        CScript expect = CScript() << nHeight;\n        if (block.vtx[0].vin[0].scriptSig.size() < expect.size() ||\n            !std::equal(expect.begin(), expect.end(), block.vtx[0].vin[0].scriptSig.begin())) {\n            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n        }\n    }\n\nand\n\n    // Start enforcing the DERSIG (BIP66) rule\n    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {\n        flags |= SCRIPT_VERIFY_DERSIG;\n    }\n\n    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {\n        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n    }\n\nPlease see the implementation for additional details.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/8391.\n\n\n==References==\n\n[https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki BIP34 Block v2, Height in Coinbase]\n\n[https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki BIP66 Strict DER signatures]\n\n[https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki BIP65 OP_CHECKLOCKTIMEVERIFY]\n\n[https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki BIP9 Version bits with timeout and delay]\n\n==Acknowledgements==\n\nThanks to Nicolas Dorier for drafting an initial version of this BIP, and to Alex Morcos, Matt Corallo, and Greg Maxwell for suggestions and feedback.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 6313}
{"bip_number": 88, "filename": "bip-0088.mediawiki", "content": "<pre>\n  BIP: 88\n  Layer: Applications\n  Title: Hierarchical Deterministic Path Templates\n  Author: Dmitry Petukhov <dp@simplexum.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0088\n  Status: Proposed\n  Type: Informational\n  Created: 2020-06-23\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document describes a format for the representation of the templates that specify\nthe constraints that can be imposed on BIP32 derivation paths.\n\nThe constraints specified by the templates allow to easily discern 'valid' paths,\nthat match the constraints, and 'invalid' paths, that exceed the constraints.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nBIP32 derivation path format is universal, and a number of schemes for derivation were proposed\nin BIP43 and other documents, such as BIPs 44,45,49,84. The flexibility of the format also allowed\nindustry participants to implement custom derivation schemes that fit particular purposes,\nbut not necessarily useful in general.\n\nEven when existing BIPs for derivation schemes are used, their usage is not uniform across\nthe different wallets, in part because software vendors might have different considerations\nand priorities when making decisions about derivation paths. This creates friction for users,\nwhich might face problems when they try to access their coins using the wallet that derives\naddresses differently than the one they used before.\n\n===Known solutions===\n\nThe problem is common enough to warrant the creation of a dedicated website\n([https://walletsrecovery.org/ walletsrecovery.org]) that tracks paths used by different wallets.\n\nAt the time of writing, this website has used their own format to succinctly describe multiple\nderivation paths. As far as author knows, it was the only publicly used format to describe\npath templates before introduction of this BIP. The format was not specified anywhere beside\nthe main page of the website. It used <code>|</code> to denote alternative derivation indexes\n(example: <code>m/|44'|49'|84'/0'/0'</code>) or whole alternative paths (<code>m/44'/0'/0'|m/44'/1'/0'</code>).\n\nIt was not declared as a template format to use for processing by software, and seems to be\nan ad-hoc format only intended for illustration. In contrast to this ad-hoc format, the format\ndescribed in this BIP is intended for unambiguous parsing by software, and to be easily read by humans\nat the same time. Humans can visually detect the 'templated' parts of the path more easily than the use\nof <code>|</code> in the template could allow. Wider range of paths can be defined in a single template more\nsuccinctly and unambiguously.\n\n===Intended use and advantages===\n\nWallet software authors can use the proposed format to describe the derivation paths that\ntheir software uses. This can improve user experience when switching to different wallet\nsoftware, restoring access to old wallets, etc.\n\nUnrestricted derivation path usage might be unsafe in certain contexts. In particular, when \"change\"\noutputs of a transaction are sent to the addresses derived via paths unknown to the sender, the sender\nmight lose access to the whole change amount.\n\nA simplistic approach of hard-coding the checks for well-known paths into software and firmware leads\nto reduced interoperability. Vendors cannot choose custom paths that are appropriate for\ntheir particular, non-general-purpose applications, and are forced to shoehorn their solutions\ninto using well-known paths, or convince other vendors to support their custom paths. This approach\nscales poorly.\n\nA flexible approach proposed in this document is to define a standard notation for \"BIP32 path templates\"\nthat succinctly describes the constraints to impose on the derivation path.\n\nWide support for these path templates will increase interoperability and flexibility of solutions,\nand will allow vendors and individual developers to easily define their own custom restrictions.\nThis way, they will be able to deal with the risks of accidental or malicious use of unrestricted\nderivation paths in a more flexible and precise manner.\n\nWell-known path templates can be pre-configured by default on devices and applications,\nbut users can have an option to turn off the templates that are not relevant to their uses.\n\nHaving a standardized format for custom path templates will enable a common approach to be developed\nin the enforcement of application-specific path restrictions in devices and applications.\nOne example of such an approach might be for devices to allow application-specific profiles\nwith path templates and possibly other custom parameters. Care must be taken to prevent the accidental\ninstallation of malicious or incorrect profiles, though.\n\n==Specification==\n\nThe format for the template was chosen to make it easy to read, convenient and visually unambiguous.\n\nTemplate starts with optional prefix <code>m/</code>, and then one or more sections delimited by the slash character (<code>/</code>).\n\nImplementations MAY limit the maximum number of sections.\n\nEach section consists of ''index template'', optionally followed by the hardened marker: either an apostrophe (<code>'</code>) or letter <code>h</code>.\n\nIndex template can be:\n\n* An integer value from 0 to 2147483647 (\"Unit index template\")\n* A single <code>*</code> character, which denotes any value from 0 to 2147483647 (\"Wildcard index template\")\n* The <code>{</code> character, followed by a number of ''index ranges'' delimited by commas (<code>,</code>), followed by <code>}</code> character (\"Ranged index template\")\n\nImplementations MAY limit the maximum number of index ranges within the Ranged index template.\n\nIf an index template is immediately followed by hardened marker, this means that all values specified in this index template is to be increased by 2147483648 for the purposes of matching.\n\nIndex range can be:\n\n* An integer value from 0 to 2147483647 (\"Unit range\")\n* An integer value from 0 to 2147483647, followed by the <code>-</code> character, followed by another integer value from 0 to 2147483647 (\"Non-unit range\")\n\nFor Non-unit range, value on the left side of the <code>-</code> character is the range_start, and the value on the right side of the <code>-</code> character is the range_end.\n\nFor Unit range, we say that range_start is equal to range_end, even though there is no start/end in the Unit range.\n\nUnit index template contains a single index range, which is the Unit range\n\nWildcard index template contains a single index range, and we say that its range_start is set to 0 and its range_end is set to 2147483647\n\nConstraints:\n\n# To avoid ambiguity, whitespace MUST NOT appear within the path template.\n# Commas within the Ranged index template MUST only appear in between index ranges.\n# To avoid ambiguity, an index range that matches a single value MUST be specified as Unit range.\n# To avoid ambiguity, an index range <code>0-2147483647</code> is not allowed, and MUST be specified as Wildcard index template instead\n# For Non-unit range, range_end MUST be larger than range_start.\n# If there is more than one index range within the Ranged index template, range_start of the second and any subsequent range MUST be larger than the range_end of the preceding range.\n# To avoid ambiguity, all representations of integer values larger than 0 MUST NOT start with character <code>0</code> (no leading zeroes allowed).\n# If hardened marker appears within any section in the path template, all preceding sections MUST also specify hardened matching.\n# To avoid ambiguity, if a hardened marker appears within any section in the path template, all preceding sections MUST also use the same hardened marker (either <code>h</code> or <code>'</code>).\n# To avoid ambiguity, trailing slashes (for example, <code>1/2/</code>) and duplicate slashes (for example, <code>0//1</code>) MUST NOT appear in the template.\n\nIt may be desirable to have fully unambiguous encoding, where for each valid path template string, there is no other valid template string that matches the exact same set of paths. This would enable someone to compare templates for equality through a simple string equality check, without any parsing.\n\nTo achieve this, two extra rules are needed:\n\n* Within Ranged index template, subsequent range MUST NOT start with the value that is equal to the end of the previous range plus one. Thus, <code>{1,2,3-5}</code> is not allowed, and should be specified as <code>{1-5}</code> instead. This rule might make templates less convenient for frequent edits, though.\n\n* Only one type of hardened marker should be allowed (either <code>h</code> or <code>'</code>).\n\nInstead of requiring the second extra rule, implementations can simply replace one type of marker with another in the template strings before comparing them.\n\n==Full and partial templates==\n\nIf the template starts with <code>m/</code>, that means that this is the \"full\" template, that matches the whole path.\n\nIf the template does not start with <code>m/</code>, that means that this is a \"partial\" template, and it can be used to match a part of the path, in the contexts where this might be appropriate (for example, when constraints for the suffix of the path might be dynamic, while constraints for the prefix of the path are fixed).\n\nFull template can be combined with partial template, where partial template extends full template,\nresulting in new, longer full template.\n\nPartial template can be combined with another partial template, resulting in new, longer partial template.\n\nFull template can not be combined with another full template.\n\nImplementations MUST support parsing full templates and matching paths against full templates.\n\nImplementations MAY support parsing partial templates and matching portions of the paths against partial templates, as well as combining the templates.\n\n==Parsing result==\n\nThe result of successful parsing of a valid path template can be represented by a list of sections, where each section is a list of index ranges, where index range is a tuple of (range_start, range_end). The length of the list of sections is also referred to as the \"length of the template\".\n\n==Matching==\n\nThe matching is to be performed against a list of integer values that represent a BIP32 path (or a portion of BIP32 path, for partial templates). The length of this list is referred to as the \"length of the path\".\n\nNon-hardened indexes in this list should be represented by values from 0 to 2147483647.\n\nHardened indexes in this list should be represented by values from 2147483648 to 4294967295.\n\nThe matching algorithm:\n\n    1. If the length of the path differs from the length of the template, fail\n    2. For each value V at position N in the path:\n            If for all index ranges within the section at position N in the template,\n            value V is either less than range_start, or greater than range_end, fail\n    3. Otherwise, succeed\n\n==Formal specification==\n\nThe finite state machine (FSM) for the parser of the described template format,\nand the matching formula are specified in TLA+ specification language at https://github.com/dgpv/bip32_template_parse_tplaplus_spec\n\nThe specification can be used with TLC checker and accompanying script to generate test data for the implementations.\n\n==Implementations==\n\nWhile the formal specification specifies an FSM, which would be convenient for implementation without access to rich string handling facilities, when such facilities are available, the implementation might use the whole-string deconstruction approach where the templates are first split into sections, then sections are split into index templates, and then each index template are parsed individually.\n\nA FSM-based approach can be made close to the formal specification, though, and the test data generated with TLC checker would give much better coverage for a FSM based implementation. If the template string contains several errors, an implementation that uses deconstruction approach might detect some of these errors earlier than FSM-based implementation, and vise versa.\n\nAt the moment, three implementations exist:\n\n* FSM implementation in C: https://github.com/dgpv/bip32_template_c_implementation\n* FSM implementation in Python (micropython compatible): https://github.com/dgpv/bip32_template_python_implementation\n* non-FSM implementation in python: BIP32PathTemplate class in bitcointx.core.key module of python-bitcointx library (https://github.com/Simplexum/python-bitcointx)\n\n==Compatibility==\n\nThe full path template that only contains Unit index templates represents a fully valid BIP32 path.\n\nThere's no other path template standards that is known to the author currently.\n\nThere is a discussion on path templating for bitcoin script descriptors at https://github.com/bitcoin/bitcoin/issues/17190, which proposes the format <code>xpub...{0,1}/*</code>, of which the <code>{0,1}/*</code> part would correspond to the partial path template in the format of this BIP.\n\n==Examples==\n\n<code>m/{44,49,84}'/0'/0'/{0-1}/{0-50000}</code> specifies a full template that matches both external and internal chains of BIP44, BIP49 and BIP84 paths, with a constraint that the address index cannot be larger than 50000\n\nIts representation after parsing can be (using Python syntax, ignoring full/partial distinction):\n    [[(2147483692, 2147483692), (2147483697, 2147483697), (2147483732, 2147483732)],\n     [(2147483648, 2147483648)],\n     [(2147483648, 2147483648)],\n     [(0, 1)],\n     [(0, 50000)]]\n\n<code>{0-2,33,123}/*</code> specifies a partial template that matches non-hardened values 0, 1, 2, 33, 123 as first index, and any non-hardened value at second index\n\nIts representation after parsing can be:\n    [[(0, 2), (33, 33), (123, 123)], [(0, 2147483647)]]\n\n<code>*h/0</code> specifies a partial template that matches any hardened index followed by non-hardened index 0\n\nIts representation after parsing can be:\n    [[(2147483648, 4294967295)], [(0, 0)]]\n\n==Acknowledgements==\n\nSpecial thanks to Peter D. Gray, Dr. Maxim Orlovsky, Robert Spigler and others for their feedback on the specification, and to Janine (github:@Enegnei) for the help in preparing the draft.\n", "content_length": 14247}
{"bip_number": 87, "filename": "bip-0087.mediawiki", "content": "<pre>\n  BIP: 87\n  Layer: Applications\n  Title: Hierarchy for Deterministic Multisig Wallets\n  Author: Robert Spigler <RobertSpigler@ProtonMail.ch>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0087\n  Status: Proposed\n  Type: Standards Track\n  Created: 2020-03-11\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP defines a sane hierarchy for deterministic multisig wallets based on an algorithm described in BIP-0032 (BIP32 from now on), purpose scheme described in BIP-0043 (BIP43 from now on), and multi-account hierarchy described in BIP-0044 (BIP44 from now on).\n\nThis BIP is a particular application of BIP43.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nWith the increase of more user friendly (offline) multisignature wallets, and adoption of new technologies such as [https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md the descriptor language] and [https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki BIP-0174 (Partially Signed Bitcoin Transactions)], it is necessary to create a common derivation scheme that makes use of all new technologies.\n\nAs background, BIP 44/49/84 specifies:\n\n<pre>\nm / purpose' / coin_type' / account' / change / address_index\n</pre>\n\nwhere the BIP43 <code>purpose'</code> path is separate for each script (P2PKH, P2WPKH-in-P2SH, and P2WPKH respectively).  Having a script-per-derivation for single sig wallets allows for easy backup and restore, with just the private key information.\n\nMultisignature wallets need more information to backup and restore (such as all cosigner public keys), and these per-script derivations are made redundant with descriptors, which provide that information (while also specifying a collection of output scripts).\nA modern standardization is needed for multisig derivation paths.  There are some in existence, but all have issues.  For example, BIP45 specifies:\n\n<pre>\nm / purpose' / cosigner_index / change / address_index\n</pre>\n\nBIP45 unnecessarily demands a single script type (here, P2SH).  In addition, BIP45 sets <code>cosigner_index</code> in order to sort the <code>purpose'</code> public keys of each cosigner.  This too is redundant, as descriptors can set the order of the public keys with <code>multi</code> or have them sorted lexicographically (as described in [https://github.com/bitcoin/bips/blob/master/bip-0067.mediawiki BIP67]) with <code>sortedmulti</code>.  Sorting public keys between cosigners in order to create the full derivation path, prior to sending the key record to the coordinator to create the descriptor, merely adds additional unnecessary communication rounds.\n\nThe second multisignature \"standard\" in use is m/48', which specifies:\n\n<pre>\nm / purpose' / coin_type' / account' / script_type' / change / address_index\n</pre>\n\nRather than following in BIP 44/49/84's path and having a separate BIP per script after P2SH (BIP45), vendors decided to insert <code>script_type'</code> into the derivation path (where P2SH-P2WSH=1, P2WSH=2, Future_Script=3, etc). As described previously, this is unnecessary, as the descriptor sets the script.  While it attempts to reduce maintenance work by getting rid of new BIPs-per-script, it still requires maintaining an updated, redundant, <code>script_type</code> list.\n\nThe structure proposed later in this paper solves these issues and is quite comprehensive. It allows for the handling of multiple accounts, external and internal chains per account, and millions of addresses per chain, in a multi-party, multisignature, hierarchical deterministic wallet regardless of the script type <ref>'''Why propose this structure only for multisignature wallets?''' Currently, single-sig wallets are able to restore funds using just the master private key data (in the format of BIP39 usually).  Even if the user doesn't recall the derivation used, the wallet implementation can iterate through common schemes (BIP44/49/84).  With this proposed hierarchy, the user would either have to now backup additional data (the descriptor), or the wallet would have to attempt all script types for every account level when restoring.  Because of this, even though the descriptor language handles the signature type just like it does the script type, it is best to restrict this script-agnostic hierarchy to multisignature wallets only.</ref>.\n\nThis paper was inspired from BIP44.\n\n==Specification==\n\n===Key sorting===\n\nAny wallet that supports descriptors inherently supports deterministic key sorting as per BIP67 (through the <code>sortedmulti</code> function) so that all possible multisignature addresses/scripts are derived from deterministically sorted public keys.\n\n===Path levels===\n\nWe should not be mixing keys and scripts in the same layer. The wallet should create extended private/public keys independent of the script type, whereas the descriptor language tells wallets to watch the multisig outputs with the specified public keys.\n\nWe define the following 5 levels in the BIP32 path:\n\n<pre>\nm / purpose' / coin_type' / account' / change / address_index\n</pre>\n\n<code>h</code> or <code>'</code> in the path indicates that BIP32 hardened derivation is used.\n\nEach level has a special meaning, described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set to <code>87'</code> following the BIP43 recommendation.\nIt indicates that the subtree of this node is used according to this specification.\n\nHardened derivation is used at this level.\n\n===Coin type===\n\nOne master node (seed) can be used for multiple Bitcoin networks.\nSharing the same space for various networks has some disadvantages.\n\nThis level creates a separate subtree for every network, avoiding reusing addresses across networks and improving privacy issues.\n\nCoin type <code>0</code> for mainnet and <code>1</code> for testnets (testnet, regtest, and signet).\n\nHardened derivation is used at this level.\n\n===Account===\n\nThis level splits the key space into independent user identities, following the BIP44 pattern, so the wallet never mixes the coins across different accounts.\n\nUsers can use these accounts to organize the funds in the same fashion as bank accounts; for donation purposes (where all addresses are considered public), for saving purposes, for common expenses, etc.\n\nAccounts are numbered from index <code>0</code> in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nHardened derivation is used at this level.\n\nIt is crucial that this level is increased for each new wallet joined or private/public keys created; for both privacy and cryptographic purposes.\nFor example, before sending a new key record to a coordinator, the wallet must increment the <code>account'</code> level.\nThis prevents key reuse - across ECDSA and Schnorr signatures, across different script types, and in between the same wallet types.\n\n===Change===\n\nConstant <code>0</code> is used for external chain and constant <code>1</code> for internal chain (also known as change addresses). External chain is used for addresses that are meant to be visible outside of the wallet (e.g. for receiving payments). Internal chain is used for addresses which are not meant to be visible outside of the wallet and is used for return transaction change.\n\nPublic derivation is used at this level.\n\n===Index===\n\nAddresses are numbered from index <code>0</code> in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nPublic derivation is used at this level.\n\n==Address Discovery==\n\nThe multisig descriptors or descriptor template that is generated from the cosigners' combined key records should be used to generate and discover addresses.\n\nPlease see [https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki BIP-0129 (Bitcoin Secure Multisig Setup)] for an introduction on descriptor templates.\nThe descriptor or descriptor template should contain the key origin information for maximum compatibility with BIP-0174.\n\nFor example:\n\nThe following descriptor template and derivation path restrictions:\n\n<code>wsh(sortedmulti(2,[xfpForA/87'/0'/0']XpubA/**,[xfpForB/87'/0'/0']XpubB/**))</code>\n\n<code>/0/*,/1/*</code>\n\nExpands to the two concrete descriptors:\n\n<code>wsh(sortedmulti(2,[xfpForA/87'/0'/0']XpubA/0/*,[xfpForB/87'/0'/0']XpubB/0/*))</code>\n\n<code>wsh(sortedmulti(2,[xfpForA/87'/0'/0']XpubA/1/*,[xfpForB/87'/0'/0']XpubB/1/*))</code>\n\nTo discover addresses, import both the receiving and change descriptors; respect the gap limit described below.\n\n===Address Gap Limit===\n\nAddress gap limit is currently set to 20. If the software hits 20 unused addresses in a row, it expects there are no used addresses beyond this point and stops searching the address chain.\n\nWallet software should warn when the user is trying to exceed the gap limit on an external descriptor by generating multiple unused addresses.\n\n==Backwards Compatibility==\n\nAny script that is supported by descriptors (and the specific wallet implementation) is compatible with this BIP.\n\nAs wallets complying with this BIP are descriptor wallets, this therefore necessitates that the cosigners backup their private key information and the descriptor, in order to properly restore at a later time.  This shouldn't be a user burden, since (to much user surprise), all cosigner public keys need to be supplied in addition to <code>M</code> seeds in any <code>M</code> of <code>N</code> multisig restore operation. The descriptor provides this information in a standardized format, with key origin information and error detection.\n\n==Rationale==\n\n<references/>\n\n==Examples==\n\n{|\n|network\n|account\n|chain\n|address\n|path\n|-\n|mainnet\n|first\n|external\n|first\n|m / 87' / 0' / 0' / 0 / 0\n|-\n|mainnet\n|first\n|external\n|second\n|m / 87' / 0' / 0' / 0 / 1\n|-\n|mainnet\n|first\n|change\n|first\n|m / 87' / 0' / 0' / 1 / 0\n|-\n|mainnet\n|first\n|change\n|second\n|m / 87' / 0' / 0' / 1 / 1\n|-\n|mainnet\n|second\n|external\n|first\n|m / 87' / 0' / 1' / 0 / 0\n|-\n|mainnet\n|second\n|external\n|second\n|m / 87' / 0' / 1' / 0 / 1\n|-\n|testnet\n|first\n|external\n|first\n|m / 87' / 1' / 0' / 0 / 0\n|-\n|testnet\n|first\n|external\n|second\n|m / 87' / 1' / 0' / 0 / 1\n|-\n|testnet\n|first\n|change\n|first\n|m / 87' / 1' / 0' / 1 / 0\n|-\n|testnet\n|first\n|change\n|second\n|m / 87' / 1' / 0' / 1 / 1\n|-\n|testnet\n|second\n|external\n|first\n|m / 87' / 1' / 1' / 0 / 0\n|-\n|testnet\n|second\n|external\n|second\n|m / 87' / 1' / 1' / 0 / 1\n|-\n|testnet\n|second\n|change\n|first\n|m / 87' / 1' / 1' / 1 / 0\n|-\n|testnet\n|second\n|change\n|second\n|m / 87' / 1' / 1' / 1 / 1\n|}\n\n==Reference Implementation==\n\nNone at the moment.\n\n==Acknowledgement==\n\nSpecial thanks to SomberNight, Craig Raw, David Harding, Jochen Hoenicke, Sjors Provoost, and others for their feedback on the specification.\n\n==References==\n\nOriginal mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-March/018630.html\n\n* [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP-0032 (Hierarchical Deterministic Wallets)]\n* [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP-0043 (Purpose Field for Deterministic Wallets)]\n* [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP-0044 (Multi-Account Hierarchy for Deterministic Wallets)]\n* [https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md Output Descriptors]\n* [https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki BIP-0174 (Partially Signed Bitcoin Transaction Format)]\n* [https://github.com/bitcoin/bips/blob/master/bip-0067.mediawiki BIP-0067 (Deterministic Pay-to-script-hash multi-signature addresses through public key sorting)]\n* [https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki BIP-0129 (Bitcoin Secure Multisig Setup)]\n", "content_length": 11754}
{"bip_number": 86, "filename": "bip-0086.mediawiki", "content": "<pre>\n  BIP: 86\n  Layer: Applications\n  Title: Key Derivation for Single Key P2TR Outputs\n  Author: Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0086\n  Status: Final\n  Type: Standards Track\n  Created: 2021-06-22\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document suggests a derivation scheme for HD wallets whose keys are involved in single key\nP2TR ([[bip-0341.mediawiki|BIP 341]]) outputs as the Taproot internal key.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nWith the usage of single key P2TR transactions, it is useful to have a common derivation scheme so\nthat HD wallets that only have a backup of the HD seed can be likely to recover single key Taproot\noutputs. Although there are now solutions which obviate the need for fixed derivation paths for\nspecific script types, many software wallets and hardware signers still use seed backups which\nlack derivation path and script information. Thus we largely use the same approach used in BIPs\n[[bip-0049.mediawiki|49]] and [[bip-0084.mediawiki|84]] for ease of implementation.\n\n==Specifications==\n\nThis BIP defines the two needed steps to derive multiple deterministic addresses based on a\n[[bip-0032.mediawiki|BIP 32]] master private key.\n\n===Public key derivation===\n\nTo derive a public key from the root account, this BIP uses the same account-structure as\ndefined in BIPs [[bip-0044.mediawiki|44]], [[bip-0049.mediawiki|49]], and [[bip-0084.mediawiki|84]],\nbut with a different purpose value for the script type.\n\n<pre>\nm / purpose' / coin_type' / account' / change / address_index\n</pre>\n\nFor the <tt>purpose</tt>-path level it uses <tt>86'</tt>.\nThe rest of the levels are used as defined in BIPs 44, 49, and 84.\n\nA key derived with this derivation path pattern will be referred to as <tt>derived_key</tt> further\nin this document.\n\n===Address derivation===\n\n\n[[bip-0341.mediawiki#cite_ref-22-0|BIP 341]] states: \"If the spending conditions do not require a\nscript path, the output key should commit to an unspendable script path instead of having no\nscript path. This can be achieved by computing the output key point as\n''Q = P + int(hash<sub>TapTweak</sub>(bytes(P)))G''.\" Thus:\n\n<pre>\ninternal_key:       lift_x(derived_key)\n32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)))G\n</pre>\n\nIn a transaction, the scripts and witnesses are as defined in\n[[bip-0341.mediawiki#specification|BIP 341]]:\n\n<pre>\nwitness:      <signature>\nscriptSig:    (empty)\nscriptPubKey: 1 <32_byte_output_key>\n              (0x5120{32_byte_output_key})\n</pre>\n\n==Backwards Compatibility==\n\nThis BIP is not backwards compatible by design.\nAn incompatible wallet will not discover these accounts at all and the user will notice that\nsomething is wrong.\n\nHowever this BIP uses the same method used in BIPs 44, 49, and 84, so it should not be difficult\nto implement.\n\n==Test vectors==\n\n<pre>\nmnemonic = abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\nrootpriv = xprv9s21ZrQH143K3GJpoapnV8SFfukcVBSfeCficPSGfubmSFDxo1kuHnLisriDvSnRRuL2Qrg5ggqHKNVpxR86QEC8w35uxmGoggxtQTPvfUu\nrootpub  = xpub661MyMwAqRbcFkPHucMnrGNzDwb6teAX1RbKQmqtEF8kK3Z7LZ59qafCjB9eCRLiTVG3uxBxgKvRgbubRhqSKXnGGb1aoaqLrpMBDrVxga8\n\n// Account 0, root = m/86'/0'/0'\nxprv = xprv9xgqHN7yz9MwCkxsBPN5qetuNdQSUttZNKw1dcYTV4mkaAFiBVGQziHs3NRSWMkCzvgjEe3n9xV8oYywvM8at9yRqyaZVz6TYYhX98VjsUk\nxpub = xpub6BgBgsespWvERF3LHQu6CnqdvfEvtMcQjYrcRzx53QJjSxarj2afYWcLteoGVky7D3UKDP9QyrLprQ3VCECoY49yfdDEHGCtMMj92pReUsQ\n\n// Account 0, first receiving address = m/86'/0'/0'/0/0\nxprv         = xprvA449goEeU9okwCzzZaxiy475EQGQzBkc65su82nXEvcwzfSskb2hAt2WymrjyRL6kpbVTGL3cKtp9herYXSjjQ1j4stsXXiRF7kXkCacK3T\nxpub         = xpub6H3W6JmYJXN49h5TfcVjLC3onS6uPeUTTJoVvRC8oG9vsTn2J8LwigLzq5tHbrwAzH9DGo6ThGUdWsqce8dGfwHVBxSbixjDADGGdzF7t2B\ninternal_key = cc8a4bc64d897bddc5fbc2f670f7a8ba0b386779106cf1223c6fc5d7cd6fc115\noutput_key   = a60869f0dbcf1dc659c9cecbaf8050135ea9e8cdc487053f1dc6880949dc684c\nscriptPubKey = 5120a60869f0dbcf1dc659c9cecbaf8050135ea9e8cdc487053f1dc6880949dc684c\naddress      = bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr\n\n// Account 0, second receiving address = m/86'/0'/0'/0/1\nxprv         = xprvA449goEeU9okyiF1LmKiDaTgeXvmh87DVyRd35VPbsSop8n8uALpbtrUhUXByPFKK7C2yuqrB1FrhiDkEMC4RGmA5KTwsE1aB5jRu9zHsuQ\nxpub         = xpub6H3W6JmYJXN4CCKUSnriaiQRCZmG6aq4sCMDqTu1ACyngw7HShf59hAxYjXgKDuuHThVEUzdHrc3aXCr9kfvQvZPit5dnD3K9xVRBzjK3rX\ninternal_key = 83dfe85a3151d2517290da461fe2815591ef69f2b18a2ce63f01697a8b313145\noutput_key   = a82f29944d65b86ae6b5e5cc75e294ead6c59391a1edc5e016e3498c67fc7bbb\nscriptPubKey = 5120a82f29944d65b86ae6b5e5cc75e294ead6c59391a1edc5e016e3498c67fc7bbb\naddress      = bc1p4qhjn9zdvkux4e44uhx8tc55attvtyu358kutcqkudyccelu0was9fqzwh\n\n// Account 0, first change address = m/86'/0'/0'/1/0\nxprv         = xprvA3Ln3Gt3aphvUgzgEDT8vE2cYqb4PjFfpmbiFKphxLg1FjXQpkAk5M1ZKDY15bmCAHA35jTiawbFuwGtbDZogKF1WfjwxML4gK7WfYW5JRP\nxpub         = xpub6GL8SnQwRCGDhB59LEz9HMyM6sRYoByXBzXK3iEKWgCz8XrZNHUzd9L3AUBELW5NzA7dEFvMas1F84TuPH3xqdUA5tumaGWFgihJzWytXe3\ninternal_key = 399f1b2f4393f29a18c937859c5dd8a77350103157eb880f02e8c08214277cef\noutput_key   = 882d74e5d0572d5a816cef0041a96b6c1de832f6f9676d9605c44d5e9a97d3dc\nscriptPubKey = 5120882d74e5d0572d5a816cef0041a96b6c1de832f6f9676d9605c44d5e9a97d3dc\naddress      = bc1p3qkhfews2uk44qtvauqyr2ttdsw7svhkl9nkm9s9c3x4ax5h60wqwruhk7\n</pre>\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[bip-0049.mediawiki|BIP49 - Derivation scheme for P2WPKH-nested-in-P2SH based accounts]]\n* [[bip-0084.mediawiki|BIP84 - Derivation scheme for P2WPKH based accounts]]\n* [[bip-0341.mediawiki|BIP341 - Taproot: SegWit version 1 spending rules]]\n", "content_length": 6001}
{"bip_number": 85, "filename": "bip-0085.mediawiki", "content": "<pre>\n  BIP: 85\n  Layer: Applications\n  Title: Deterministic Entropy From BIP32 Keychains\n  Author: Ethan Kosakovsky <ethankosakovsky@protonmail.com>\n          Aneesh Karve <dowsing.seaport0d@icloud.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0085\n  Status: Final\n  Type: Informational\n  Created: 2020-03-20\n  License: BSD-2-Clause\n           OPL\n</pre>\n\n==Abstract==\n\n''\"One Seed to rule them all,''<br>\n''One Key to find them,''<br>\n''One Path to bring them all,''<br>\n''And in cryptography bind them.\"''\n\nIt is not possible to maintain one single (mnemonic) seed backup for all keychains used across various wallets because there are a variety of incompatible standards. Sharing of seeds across multiple wallets is not desirable for security reasons. Physical storage of multiple seeds is difficult depending on the security and redundancy required.\n\nAs HD keychains are essentially derived from initial entropy, this proposal provides a way to derive entropy from the keychain which can be fed into whatever method a wallet uses to derive the initial mnemonic seed or root key.\n\n==Copyright==\n\nThis BIP is dual-licensed under the Open Publication License and BSD 2-clause license.\n\n==Definitions==\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\nThe terminology related to keychains used in the wild varies widely, for example `seed` has various different meanings. In this document we define the terms\n\n# '''BIP32 root key''' is the root extended private key that is represented as the top root of the keychain in BIP32.\n# '''BIP39 mnemonic''' is the mnemonic phrase that is calculated from the entropy used before hashing of the mnemonic in BIP39.\n# '''BIP39 seed''' is the result of hashing the BIP39 mnemonic seed.\n\nWhen in doubt, assume big endian byte serialization, such that the leftmost\nbyte is the most significant.\n\n==Motivation==\n\nMost wallets implement BIP32 which defines how a BIP32 root key can be used to derive keychains. As a consequence, a backup of just the BIP32 root key is sufficient to include all keys derived from it. BIP32 does not have a human-friendly serialization of the BIP32 root key (or BIP32 extended keys in general), which makes paper backups or manually restoring the key more error-prone. BIP39 was designed to solve this problem, but rather than serialize the BIP32 root key, it takes some entropy, encoded to a \"seed mnemonic\", which is then hashed to derive the BIP39 seed, which can be turned into the BIP32 root key. Saving the BIP39 mnemonic is enough to reconstruct the entire BIP32 keychain, but a BIP32 root key cannot be reversed back to the BIP39 mnemonic.\n\nMost wallets implement BIP39, so on initialization or restoration, the user must interact with a BIP39 mnemonic. Most wallets do not support BIP32 extended private keys, so each wallet must either share the same BIP39 mnemonic, or have a separate BIP39 mnemonic entirely. Neither scenario is particularly satisfactory for security reasons. For example, some wallets may be inherently less secure, like hot wallets on smartphones, JoinMarket servers, or Lightning Network nodes. Having multiple seeds is far from desirable, especially for those who rely on split key or redundancy backups in different geological locations. Adding keys is necessarily difficult and may result in users being more lazy with subsequent keys, resulting in compromised security or loss of keys.\n\nThere is an added complication with wallets that implement other standards, or no standards at all. The Bitcoin Core wallet uses a WIF as the ''hdseed'', and yet other wallets, like Electrum, use different mnemonic schemes to derive the BIP32 root key. Other cryptocurrencies, like Monero, use an entirely different mnemonic scheme.\n\nUltimately, all of the mnemonic/seed schemes start with some \"initial entropy\" to derive a mnemonic/seed, and then process the mnemonic into a BIP32 key, or private key. We can use BIP32 itself to derive the \"initial entropy\" to then recreate the same mnemonic or seed according to the specific application standard of the target wallet. We can use a BIP44-like categorization to ensure uniform derivation according to the target application type.\n\n==Specification==\n\nWe assume a single BIP32 master root key. This specification is not concerned with how this was derived (e.g. directly or via a mnemonic scheme such as BIP39).\n\nFor each application that requires its own wallet, a unique private key is derived from the BIP32 master root key using a fully hardened derivation path. The resulting private key (k) is then processed with HMAC-SHA512, where the key is \"bip-entropy-from-k\", and the message payload is the private key k: <code>HMAC-SHA512(key=\"bip-entropy-from-k\", msg=k)</code>\n<ref name=\"hmac-sha512\">\nThe reason for running the derived key through HMAC-SHA512 and truncating the result as necessary is to prevent leakage of the parent tree should the derived key (''k'') be compromised. While the specification requires the use of hardened key derivation which would prevent this, we cannot enforce hardened derivation, so this method ensures the derived entropy is hardened. Also, from a semantic point of view, since the purpose is to derive entropy and not a private key, we are required to transform the child key. This is done out of an abundance of caution, in order to ward off unwanted side effects should ''k'' be used for a dual purpose, including as a nonce ''hash(k)'', where undesirable and unforeseen interactions could occur.\n</ref>.\nThe result produces 512 bits of entropy. Each application SHOULD use up to the required number of bits necessary for their operation, and truncate the rest.\n\nThe HMAC-SHA512 function is specified in [https://tools.ietf.org/html/rfc4231 RFC 4231].\n\n===Test vectors===\n\n====Test case 1====\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/0'/0'\n\nOUTPUT:\n* DERIVED KEY=cca20ccb0e9a90feb0912870c3323b24874b0ca3d8018c4b96d0b97c0e82ded0\n* DERIVED ENTROPY=efecfbccffea313214232d29e71563d941229afb4338c21f9517c41aaa0d16f00b83d2a09ef747e7a64e8e2bd5a14869e693da66ce94ac2da570ab7ee48618f7\n\n====Test case 2====\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n*PATH: m/83696968'/0'/1'\n\nOUTPUT\n* DERIVED KEY=503776919131758bb7de7beb6c0ae24894f4ec042c26032890c29359216e21ba\n* DERIVED ENTROPY=70c6e3e8ebee8dc4c0dbba66076819bb8c09672527c4277ca8729532ad711872218f826919f6b67218adde99018a6df9095ab2b58d803b5b93ec9802085a690e\n\n==BIP85-DRNG==\n\nBIP85-DRNG-SHAKE256 is a deterministic random number generator for cryptographic functions that require deterministic outputs, but where the input to that function requires more than the 64 bytes provided by BIP85's HMAC output. BIP85-DRNG-SHAKE256 uses BIP85 to seed a SHAKE256 stream (from the SHA-3 standard). The input must be exactly 64 bytes long (from the BIP85 HMAC output).\n\nRSA key generation is an example of a function that requires orders of magnitude more than 64 bytes of random input. Further, it is not possible to precalculate the amount of random input required until the function has completed.\n\n    drng_reader = BIP85DRNG.new(bip85_entropy)\n    rsa_key = RSA.generate_key(4096, drng_reader.read)\n\n===Test Vectors===\nINPUT:\nxprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* MASTER BIP32 ROOT KEY: m/83696968'/0'/0'\n\nOUTPUT\n* DERIVED KEY=cca20ccb0e9a90feb0912870c3323b24874b0ca3d8018c4b96d0b97c0e82ded0\n* DERIVED ENTROPY=efecfbccffea313214232d29e71563d941229afb4338c21f9517c41aaa0d16f00b83d2a09ef747e7a64e8e2bd5a14869e693da66ce94ac2da570ab7ee48618f7\n\n* DRNG(80 bytes)=b78b1ee6b345eae6836c2d53d33c64cdaf9a696487be81b03e822dc84b3f1cd883d7559e53d175f243e4c349e822a957bbff9224bc5dde9492ef54e8a439f6bc8c7355b87a925a37ee405a7502991111\n\n==Applications==\n\nThe Application number defines how entropy will be used post processing. Some basic examples follow:\n\nDerivation paths follow the format <code>m/83696968'/{app_no}'/{index}'</code>, where ''{app_no}'' is the path for the application, and ''{index}'' is the index.\n\nApplication numbers should be semantic in some way, such as a BIP number or ASCII character code sequence.\n\n===BIP39===\nApplication number: 39'\n\nTruncate trailing (least significant) bytes of the entropy to the number of bits required to map to the relevant word length: 128 bits for 12 words, 256 bits for 24 words.\n\nThe derivation path format is: <code>m/83696968'/39'/{language}'/{words}'/{index}'</code>\n\nExample: a BIP39 mnemonic with 12 English words (first index) would have the path <code>m/83696968'/39'/0'/12'/0'</code>, the next key would be <code>m/83696968'/39'/0'/12'/1'</code> etc.\n\nLanguage Table\n\n{|\n!Wordlist\n!Code\n|-\n| English\n| 0'\n|-\n| Japanese\n| 1'\n|-\n| Korean\n| 2'\n|-\n| Spanish\n| 3'\n|-\n| Chinese (Simplified)\n| 4'\n|-\n| Chinese (Traditional)\n| 5'\n|-\n| French\n| 6'\n|-\n| Italian\n| 7'\n|-\n| Czech\n| 8'\n|-\n| Portuguese\n| 9'\n|-\n|}\n\nWords Table\n\n{|\n!Words\n!Entropy\n!Code\n|-\n| 12 words\n| 128 bits\n| 12'\n|-\n| 15 words\n| 160 bits\n| 15'\n|-\n| 18 words\n| 192 bits\n| 18'\n|-\n| 21 words\n| 224 bits\n| 21'\n|-\n| 24 words\n| 256 bits\n| 24'\n|}\n\n====12 English words====\nBIP39 English 12 word mnemonic seed\n\n128 bits of entropy as input to BIP39 to derive 12 word mnemonic\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/39'/0'/12'/0'\n\nOUTPUT:\n* DERIVED ENTROPY=6250b68daf746d12a24d58b4787a714b\n* DERIVED BIP39 MNEMONIC=girl mad pet galaxy egg matter matrix prison refuse sense ordinary nose\n\n====18 English words====\nBIP39 English 18 word mnemonic seed\n\n196 bits of entropy as input to BIP39 to derive 18 word mnemonic\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/39'/0'/18'/0'\n\nOUTPUT:\n* DERIVED ENTROPY=938033ed8b12698449d4bbca3c853c66b293ea1b1ce9d9dc\n* DERIVED BIP39 MNEMONIC=near account window bike charge season chef number sketch tomorrow excuse sniff circle vital hockey outdoor supply token\n\n====24 English words====\nDerives 24 word BIP39 mnemonic seed\n\n256 bits of entropy as input to BIP39 to derive 24 word mnemonic\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/39'/0'/24'/0'\n\nOUTPUT:\n* DERIVED ENTROPY=ae131e2312cdc61331542efe0d1077bac5ea803adf24b313a4f0e48e9c51f37f\n* DERIVED BIP39 MNEMONIC=puppy ocean match cereal symbol another shed magic wrap hammer bulb intact gadget divorce twin tonight reason outdoor destroy simple truth cigar social volcano\n\n===HD-Seed WIF===\nApplication number: 2'\n\nUses the most significant 256 bits<ref name=\"curve-order\">\nThere is a very small chance that you'll make an invalid\nkey that is zero or larger than the order of the curve. If this occurs, software\nshould hard fail (forcing users to iterate to the next index). From BIP32:\n<blockquote>\nIn case parse<sub>256</sub>(I<sub>L</sub>) \u2265 n or k<sub>i</sub> = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2<sup>127</sup>.)\n</blockquote>\n</ref>\nof entropy as the secret exponent to derive a private key and encode as a compressed\nWIF that will be used as the hdseed for Bitcoin Core wallets.\n\nPath format is <code>m/83696968'/2'/{index}'</code>\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/2'/0'\n\nOUTPUT\n* DERIVED ENTROPY=7040bb53104f27367f317558e78a994ada7296c6fde36a364e5baf206e502bb1\n* DERIVED WIF=Kzyv4uF39d4Jrw2W7UryTHwZr1zQVNk4dAFyqE6BuMrMh1Za7uhp\n\n===XPRV===\nApplication number: 32'\n\nTaking 64 bytes of the HMAC digest, the first 32 bytes are the chain code, and the second 32 bytes<ref name=\"curve-order\" /> are the private key for the BIP32 XPRV value. Child number, depth, and parent fingerprint are forced to zero.\n\n''Warning'': The above order reverses the order of BIP32, which takes the first 32 bytes as the private key, and the second 32 bytes as the chain code.\n\nApplications may support Testnet by emitting TPRV keys if and only if the input root key is a Testnet key.\n\nPath format is <code>m/83696968'/32'/{index}'</code>\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/32'/0'\n\nOUTPUT\n* DERIVED ENTROPY=ead0b33988a616cf6a497f1c169d9e92562604e38305ccd3fc96f2252c177682\n* DERIVED XPRV=xprv9s21ZrQH143K2srSbCSg4m4kLvPMzcWydgmKEnMmoZUurYuBuYG46c6P71UGXMzmriLzCCBvKQWBUv3vPB3m1SATMhp3uEjXHJ42jFg7myX\n\n===HEX===\nApplication number: 128169'\n\nThe derivation path format is: <code>m/83696968'/128169'/{num_bytes}'/{index}'</code>\n\n`16 <= num_bytes <= 64`\n\nTruncate trailing (least significant) bytes of the entropy after `num_bytes`.\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/128169'/64'/0'\n\nOUTPUT\n* DERIVED ENTROPY=492db4698cf3b73a5a24998aa3e9d7fa96275d85724a91e71aa2d645442f878555d078fd1f1f67e368976f04137b1f7a0d19232136ca50c44614af72b5582a5c\n\n===PWD BASE64===\nApplication number: 707764'\n\nThe derivation path format is: <code>m/83696968'/707764'/{pwd_len}'/{index}'</code>\n\n`20 <= pwd_len <= 86`\n\n[https://datatracker.ietf.org/doc/html/rfc4648 Base64] encode all 64 bytes of entropy.\nRemove any spaces or new lines inserted by Base64 encoding process. Slice Base64 result string\non index 0 to `pwd_len`. This slice is the password. As `pwd_len` is limited to 86, passwords will not contain padding.\n\nEntropy calculation:<br>\nR = 64  (Base64 - do not count padding)<br>\nL = pwd_len<br>\nEntropy = log2(R ** L)<br>\n\n{| class=\"wikitable\" style=\"margin:auto\"\n! pwd_length !! (cca) entropy\n|-\n| 20 || 120.0\n|-\n| 24 || 144.0\n|-\n| 32 || 192.0\n|-\n| 64 || 384.0\n|-\n| 86 || 516.0\n|}\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/707764'/21'/0'\n\nOUTPUT\n* DERIVED ENTROPY=74a2e87a9ba0cdd549bdd2f9ea880d554c6c355b08ed25088cfa88f3f1c4f74632b652fd4a8f5fda43074c6f6964a3753b08bb5210c8f5e75c07a4c2a20bf6e9\n* DERIVED PWD=dKLoepugzdVJvdL56ogNV\n\n===PWD BASE85===\nApplication number: 707785'\n\nThe derivation path format is: <code>m/83696968'/707785'/{pwd_len}'/{index}'</code>\n\n`10 <= pwd_len <= 80`\n\nBase85 encode all 64 bytes of entropy.\nRemove any spaces or new lines inserted by Base85 encoding process. Slice Base85 result string\non index 0 to `pwd_len`. This slice is the password. `pwd_len` is limited to 80 characters.\n\nEntropy calculation:<br>\nR = 85<br>\nL = pwd_len<br>\nEntropy = log2(R ** L)<br>\n\n{| class=\"wikitable\" style=\"margin:auto\"\n! pwd_length !! (cca) entropy\n|-\n| 10 || 64.0\n|-\n| 15 || 96.0\n|-\n| 20 || 128.0\n|-\n| 30 || 192.0\n|-\n| 80 || 512.0\n|}\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/707785'/12'/0'\n\nOUTPUT\n* DERIVED ENTROPY=f7cfe56f63dca2490f65fcbf9ee63dcd85d18f751b6b5e1c1b8733af6459c904a75e82b4a22efff9b9e69de2144b293aa8714319a054b6cb55826a8e51425209\n* DERIVED PWD=_s`{TW89)i4`\n\n===RSA===\n\nApplication number: 828365'\n\nThe derivation path format is: <code>m/83696968'/828365'/{key_bits}'/{key_index}'</code>\n\nThe RSA key generator should use BIP85-DRNG as the input RNG function.\n\n===RSA GPG===\n\nKeys allocated for RSA-GPG purposes use the following scheme:\n\n - Main key <code>m/83696968'/828365'/{key_bits}'/{key_index}'</code>\n - Sub keys:  <code>m/83696968'/828365'/{key_bits}'/{key_index}'/{sub_key}'</code>\n\n    - key_index is the parent key for CERTIFY capability\n    - sub_key <code>0'</code> is used as the ENCRYPTION key\n    - sub_key <code>1'</code> is used as the AUTHENTICATION key\n    - sub_key <code>2'</code> is usually used as SIGNATURE key\n\nNote on timestamps:\n\nThe resulting RSA key can be used to create a GPG key where the creation date MUST be fixed to UNIX Epoch timestamp 1231006505 (the Bitcoin genesis block time <code>'2009-01-03 18:15:05'</code> UTC)<ref>The human-readable datetime string was incorrectly noted as '2009-01-03 18:05:05' prior to v2.0.0 of this BIP, so implementations that relied on it rather than UNIX Epoch timestamp 1231006505 will produce different key fingerprints.</ref> because the key fingerprint is affected by the creation date (Epoch timestamp 0 was not chosen because of legacy behavior in GNUPG implementations for older keys). Additionally, when importing sub-keys under a key in GNUPG, the system time must be frozen to the same timestamp before importing (e.g. by use of <code>faketime</code>).\n\nNote on GPG key capabilities on smartcard/hardware devices:\n\nGPG capable smart-cards SHOULD be loaded as follows: The encryption slot SHOULD be loaded with the ENCRYPTION capable key; the authentication slot SHOULD be loaded with the AUTHENTICATION capable key. The signature capable slot SHOULD be loaded with the SIGNATURE capable key.\n\nHowever, depending on available slots on the smart-card, and preferred policy, the CERTIFY capable key MAY be flagged with CERTIFY and SIGNATURE capabilities and loaded into the SIGNATURE capable slot (for example where the smart-card has only three slots and the CERTIFY capability is required on the same card). In this case, the SIGNATURE capable sub-key would be disregarded because the CERTIFY capable key serves a dual purpose.\n\n===DICE===\n\nApplication number: 89101'\n\nThe derivation path format is: <code>m/83696968'/89101'/{sides}'/{rolls}'/{index}'</code>\n\n    2 <= sides <= 2^32 - 1\n    1 <= rolls <= 2^32 - 1\n\nUse this application to generate PIN numbers, numeric secrets, and secrets over custom alphabets.\nFor example, applications could generate alphanumeric passwords from a 62-sided die (26 + 26 + 10).\n\nRoll values are zero-indexed, such that an N-sided die produces values in the range\n<code>[0, N-1]</code>, inclusive. Applications should separate printed rolls by a comma or similar.\n\nCreate a BIP85 DRNG whose seed is the derived entropy.\n\nCalculate the following integers:\n\n    bits_per_roll = ceil(log_2(sides))\n    bytes_per_roll = ceil(bits_per_roll / 8)\n\nRead <code>bytes_per_roll</code> bytes from the DRNG.\nTrim any bits in excess of <code>bits_per_roll</code> (retain the most\nsignificant bits). The resulting integer represents a single roll or trial.\nIf the trial is greater than or equal to the number of sides, skip it and\nmove on to the next one. Repeat as needed until all rolls are complete.\n\nINPUT:\n* MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2LBWUUQRFXhucrQqBpKdRRxNVq2zBqsx8HVqFk2uYo8kmbaLLHRdqtQpUm98uKfu3vca1LqdGhUtyoFnCNkfmXRyPXLjbKb\n* PATH: m/83696968'/89101'/6'/10'/0'\nOUTPUT\n* DERIVED ENTROPY=5e41f8f5d5d9ac09a20b8a5797a3172b28c806aead00d27e36609e2dd116a59176a738804236586f668da8a51b90c708a4226d7f92259c69f64c51124b6f6cd2\n* DERIVED ROLLS=1,0,0,2,0,1,5,5,2,4\n\n==Backwards Compatibility==\n\nThis specification is not backwards compatible with any other existing specification.\n\nThis specification relies on BIP32 but is agnostic to how the BIP32 root key is derived. As such, this standard is able to derive wallets with initialization schemes like BIP39 or Electrum wallet style mnemonics.\n\n==References==\n\nBIP32, BIP39\n\n==Reference Implementations==\n\n* 1.3.0 Python 3.x library implementation: [https://github.com/akarve/bipsea]\n* 1.1.0 Python 2.x library implementation: [https://github.com/ethankosakovsky/bip85]\n* 1.0.0 JavaScript library implementation: [https://github.com/hoganri/bip85-js]\n\n==Changelog==\n\n===2.0.0 (2025-09-19)===\n\n====Fixed==== \n\n* Fixed the human-readable datetime string for BIP85 GPG Keys that was incorrectly stated as '2009-01-03 18:05:05' rather than '2009-01-03 18:15:05'. Implementations that relied on the previously incorrect datetime string instead of UNIX Epoch timestamp 1231006505 will produce different key fingerprints.\n\n===1.3.0 (2024-10-22)===\n\n====Added====\n\n* Dice application 89101'\n* Czech language code to application 39'\n* TPRV guidance for application 32'\n* Warning on application 32' key and chain code ordering\n\n===1.2.0 (2022-12-04)===\n\n====Added====\n\n* Base64 application 707764'\n* Base85 application 707785'\n\n===1.1.0 (2020-11-19)===\n\n====Added====\n\n* BIP85-DRNG-SHAKE256\n* RSA application 828365'\n\n===1.0.0 (2020-06-11)===\n\n* Initial version\n\n==Footnotes==\n\n<references />\n\n==Acknowledgements==\n\nMany thanks to Peter Gray and Christopher Allen for their input, and to Peter for suggesting extra application use cases.\n", "content_length": 21094}
{"bip_number": 84, "filename": "bip-0084.mediawiki", "content": "<pre>\n  BIP: 84\n  Layer: Applications\n  Title: Derivation scheme for P2WPKH based accounts\n  Author: Pavol Rusnak <stick@satoshilabs.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0084\n  Status: Final\n  Type: Standards Track\n  Created: 2017-12-28\n  License: CC0-1.0\n</pre>\n\n==Abstract==\n\nThis BIP defines the derivation scheme for HD wallets using the P2WPKH ([[bip-0173.mediawiki|BIP 173]]) serialization format for segregated witness transactions.\n\n==Motivation==\n\nWith the usage of P2WPKH transactions it is necessary to have a common derivation scheme.\nIt allows the user to use different HD wallets with the same masterseed and/or a single account seamlessly.\n\nThus the user needs to create dedicated segregated witness accounts, which ensures that only wallets compatible with this BIP will detect the accounts and handle them appropriately.\n\n===Considerations===\n\nWe use the same rationale as described in Considerations section of [[bip-0049.mediawiki|BIP 49]].\n\n==Specifications==\n\nThis BIP defines the two needed steps to derive multiple deterministic addresses based on a [[bip-0032.mediawiki|BIP 32]] root account.\n\n===Public key derivation===\n\nTo derive a public key from the root account, this BIP uses the same account-structure as defined in [[bip-0044.mediawiki|BIP 44]] and [[bip-0049.mediawiki|BIP 49]], but only uses a different purpose value to indicate the different transaction serialization method.\n\n<pre>\nm / purpose' / coin_type' / account' / change / address_index\n</pre>\n\nFor the <code>purpose</code>-path level it uses <code>84'</code>. The rest of the levels are used as defined in BIP44 or BIP49.\n\n\n===Address derivation===\n\nTo derive the P2WPKH address from the above calculated public key, we use the encapsulation defined in [[bip-0141.mediawiki#p2wpkh|BIP 141]]:\n\n\n    witness:      <signature> <pubkey>\n    scriptSig:    (empty)\n    scriptPubKey: 0 <20-byte-key-hash>\n                  (0x0014{20-byte-key-hash})\n\n\n===Extended Key Version===\n\nWhen serializing extended keys, this scheme uses alternate version bytes. Extended public keys use <code>0x04b24746</code> to produce a \"zpub\" prefix, and private keys use <code>0x04b2430c</code> to produce a \"zprv\" prefix. Testnet uses <code>0x045f1cf6</code> \"vpub\" and <code>0x045f18bc</code> \"vprv.\"\n\nAdditional registered version bytes are listed in [[https://github.com/satoshilabs/slips/blob/master/slip-0132.md|SLIP-0132]].\n\n\n==Backwards Compatibility==\n\nThis BIP is not backwards compatible by design as described under [[#considerations|considerations]]. An incompatible wallet will not discover accounts at all and the user will notice that something is wrong.\n\n==Test vectors==\n\n<pre>\n  mnemonic = abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\n  rootpriv = zprvAWgYBBk7JR8Gjrh4UJQ2uJdG1r3WNRRfURiABBE3RvMXYSrRJL62XuezvGdPvG6GFBZduosCc1YP5wixPox7zhZLfiUm8aunE96BBa4Kei5\n  rootpub  = zpub6jftahH18ngZxLmXaKw3GSZzZsszmt9WqedkyZdezFtWRFBZqsQH5hyUmb4pCEeZGmVfQuP5bedXTB8is6fTv19U1GQRyQUKQGUTzyHACMF\n\n  // Account 0, root = m/84'/0'/0'\n  xpriv = zprvAdG4iTXWBoARxkkzNpNh8r6Qag3irQB8PzEMkAFeTRXxHpbF9z4QgEvBRmfvqWvGp42t42nvgGpNgYSJA9iefm1yYNZKEm7z6qUWCroSQnE\n  xpub  = zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs\n\n  // Account 0, first receiving address = m/84'/0'/0'/0/0\n  privkey = KyZpNDKnfs94vbrwhJneDi77V6jF64PWPF8x5cdJb8ifgg2DUc9d\n  pubkey  = 0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c\n  address = bc1qcr8te4kr609gcawutmrza0j4xv80jy8z306fyu\n\n  // Account 0, second receiving address = m/84'/0'/0'/0/1\n  privkey = Kxpf5b8p3qX56DKEe5NqWbNUP9MnqoRFzZwHRtsFqhzuvUJsYZCy\n  pubkey  = 03e775fd51f0dfb8cd865d9ff1cca2a158cf651fe997fdc9fee9c1d3b5e995ea77\n  address = bc1qnjg0jd8228aq7egyzacy8cys3knf9xvrerkf9g\n\n  // Account 0, first change address = m/84'/0'/0'/1/0\n  privkey = KxuoxufJL5csa1Wieb2kp29VNdn92Us8CoaUG3aGtPtcF3AzeXvF\n  pubkey  = 03025324888e429ab8e3dbaf1f7802648b9cd01e9b418485c5fa4c1b9b5700e1a6\n  address = bc1q8c6fshw2dlwun7ekn9qwf37cu2rn755upcp6el\n</pre>\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[bip-0049.mediawiki|BIP49 - Derivation scheme for P2WPKH-nested-in-P2SH based accounts]]\n* [[bip-0141.mediawiki|BIP141 - Segregated Witness (Consensus layer)]]\n* [[bip-0173.mediawiki|BIP173 - Base32 address format for native v0-16 witness outputs]]\n", "content_length": 4645}
{"bip_number": 83, "filename": "bip-0083.mediawiki", "content": "<pre>\n  BIP: 83\n  Layer: Applications\n  Title: Dynamic Hierarchical Deterministic Key Trees\n  Author: Eric Lombrozo <eric@ciphrex.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0083\n  Status: Rejected\n  Type: Standards Track\n  Created: 2015-11-16\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP defines a scheme for key derivation that allows for dynamic creation of key hierarchies based on the algorithm described in BIP32.\n\n==Motivation==\n\nSeveral proposals have been made to try to standardize a structure for hierarchical deterministic wallets for the sake of interoperability (reference BIP32, BIP44, BIP45). However, all proposals to date have tried to impose a specific structure upfront without providing any flexibility for dynamic creation of new hierarchical levels with different semantics or mapping between different applications that use distinct structures.\n\nInstead of attempting to impose a specific structure upfront, this BIP proposes that we design the derivation in such a way that we can continue extending hierarchies arbitrarily and indefinitely.\n\n==Specification==\n\nBIP32 provides a hierarchical derivation scheme where every node in the tree can be either used to derive child nodes or used as a signing key for ECDSA. This means that as soon as we choose to use a node as a signing key, we can no longer derive children from that node. To draw an analogy to file systems, each node is either a file or a directory but never both. However, given the need to predictably know the location of new children, it is generally not a good idea to mix both signing keys and parent nodes at the same level in the hierarchy. This means that as soon as we've decided that a particular level in the hierarchy is to be used for signing keys, we've lost the ability to nest deeper levels into the tree.\n\nAt every level of the hierarchy, we reserve the child with index 0 to allow further nesting, and for signing key parent nodes use child indices 1 to MAX_INDEX (2<sup>31</sup> - 1) for signing keys. We can use either hardened or nonhardened derivation.\n\nLet p denote a specific signing key parent node and k be an index greater than 0. The children signing keys are then:\n\np / k\n\nwith k > 0.\n\nTo create sublevels, we derive the nested nodes:\n\np / 0 / n\n\nwith n &ge; 0.\n\nEach of these nodes can now contain signing key children of their own, and again we reserve index 0 to allow deeper nesting.\n\n==Notation==\n\nWe propose the following shorthand for writing nested node derivations:\n\np // n instead of p / 0 / n\n\np //' n instead of p / 0' / n\n\n==Mappings==\n\nRather than specifying upfront which path is to be used for a specific purpose (i.e. external invoicing vs. internal change), different applications can specify arbitrary parent nodes and derivation paths. This allows for nesting of sublevels to arbitrary depth with application-specified semantics. Rather than trying to specify use cases upfront, we leave the design completely open-ended. Different applications can exchange these mappings for interoperability. Eventually, if certain mappings become popular, application user interfaces can provide convenient shortcuts or use them as defaults.\n\nNote that BIP32 suggests reserving child 0 for the derivation of signing keys rather than sublevels. It is not really necessary to reserve signing key parents, however, as each key's parent's path can be explicitly stated. But unless we reserve a child for sublevel derivation, we lose the ability to nest deeper levels into the hierarchy. While we could reserve any arbitrary index for nesting sublevels, reserving child 0 seems simplest to implement, leaving all indices > 0 for contiguously indexed signing keys. We could also use MAX_INDEX (2<sup>31</sup> - 1) for this purpose. However, we believe doing so introduces more idiosyncrasies into the semantics and will present a problem if we ever decide to extend the scheme to use indices larger than 31 bits.\n\n==Use Cases==\n\n===Account Hierarchies===\n\nFor all that follows, we assume that key indices k > 0 and parent node indices n &ge; 0.\n\nFrom a master seed m, we can construct a default account using the following derivations for nonhardened signing keys:\n\nm / 1 / k (for change/internal outputs)\n\nm / 2 / k (for invoice/external outputs)\n\nTo create subaccount a<sub>n</sub>, we use:\n\na<sub>n</sub> = m // n\n\nTo generate keys for subaccount a<sub>n</sub>, we use:\n\na<sub>n</sub> / 1 / k (for change/internal outputs)\n\na<sub>n</sub> / 2 / k (for invoice/external outputs)\n\nWe can continue creating subaccounts indefinitely using this scheme.\n\n===Bidirectional Payment Channels===\n\nIn order to create a bidirectional payment channel, it is necessary that previous commitments be revokable. In order to revoke previous commitments, each party reveals a secret to the other that would allow them to steal the funds in the channel if a transaction for a previous commitment is inserted into the blockchain.\n\nBy allowing for arbitrary nesting of sublevels, we can construct decision trees of arbitrary depth and revoke an entire branch by revealing a parent node used to derive all the children.\n\n==References==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[https://lightning.network/lightning-network-paper.pdf|Lightning Network Whitepaper]]\n\n==Copyright==\n\nThis document is placed in the public domain.\n\n", "content_length": 5419}
{"bip_number": 81, "filename": "bip-0081.mediawiki", "content": "<pre>\n  BIP: 81\n  Title: Hierarchy for Colored Voting Pool Deterministic Multisig Wallets\n  Author: Justus Ranvier <justus@opentransactions.org>\n          Jimmy Song <jimmy@monetas.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0081\n  Status: Deferred\n  Type: Informational\n  Created: 2014-08-11\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP defines a logical hierarchy for colored coin voting pool deterministic multisig wallets based on an algorithm described in BIP-0032 (BIP32 from now on) and purpose scheme described in BIP-0043 (BIP43 from now on).\n\nThis BIP is a particular application of BIP43 and is based on BIP44.\n\n==Motivation==\n\nThe hierarchy proposed in this paper allows the handling of multiple color definitions from a single seed.\n\n==Path levels==\n\nWe define the following 8 levels in BIP32 path:\n\n<pre>\nm / purpose' / series' / (5 color definition levels) / address_index\n</pre>\n\nApostrophe in the path indicates that BIP32 hardened derivation is used.\n\nEach level has a special meaning, described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set following the BIP43 recommendation to: the ASCII value of \"81\" with the most significant bit set to indicate hardened derivation (0x80000051). It indicates that the subtree of this node is used according to this specification.\n\nHardened derivation is used at this level.\n\n===Color Definition===\n\nIndex values which can be applied to a BIP32 node are limited to 4 bytes (32 bits).\n\nSince this is not sufficient to identify color definitions without a risk of collision, multiple levels are used.\n\nColor definitions are first shortened to 20 bytes using the Bitcoin hash160 function.\n\nThe resulting 20 bytes are split into five groups in little endian format, and where each group is used as the seed for the five levels of color definition levels\n\nPublic derivation is used at these levels, even when the index exceeds 2^31.\n\n===Index===\n\nPublic/private keypairs are numbered from index 0 in sequentially increasing manner. This number is used as child index in BIP32 derivation.\n\nPublic keys obtained at this level of the hierarchy are used to construct multisig deposit scripts, using a schema that is shared between the members as an out-of-band contract.\n\nPublic derivation is used at this level.\n\n==Compatible wallets==\n\n* [[https://github.com/btcsuite/btcwallet|btcwallet]] is the reference Bitcoin wallet for voting pools.\n\n==Copyright==\n\nThis document is placed in the public domain.\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[bip-0080.mediawiki|BIP80 - Hierarchy for Non-Colored Voting Pool Deterministic Multisig Wallets]]\n", "content_length": 2876}
{"bip_number": 80, "filename": "bip-0080.mediawiki", "content": "<pre>\n  BIP: 80\n  Title: Hierarchy for Non-Colored Voting Pool Deterministic Multisig Wallets\n  Author: Justus Ranvier <justus@opentransactions.org>\n          Jimmy Song <jimmy@monetas.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0080\n  Status: Deferred\n  Type: Informational\n  Created: 2014-08-11\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP defines a logical hierarchy for non-colored voting pool deterministic multisig wallets based on an algorithm described in BIP-0032 (BIP32 from now on) and purpose scheme described in BIP-0043 (BIP43 from now on).\n\nThis BIP is a particular application of BIP43 and is based on BIP44.\n\n==Motivation==\n\nThe hierarchy proposed in this paper allows the handling of multiple coins and multiple series from a single seed.\n\n==Path levels==\n\nWe define the following 4 levels in BIP32 path:\n\n<pre>\nm / purpose' / coin_type' / series' / address_index\n</pre>\n\nApostrophe in the path indicates that BIP32 hardened derivation is used.\n\nEach level has a special meaning, described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set following the BIP43 recommendation to: the ASCII value of \"80\" with the most significant bit set to indicate hardened derivation (0x80000050). It indicates that the subtree of this node is used according to this specification.\n\nHardened derivation is used at this level.\n\n===Coin type===\n\nOne master node (seed) can be used for unlimited number of independent cryptocoins such as Bitcoin, Litecoin or Namecoin. However, sharing the same space for various cryptocoins has some disadvantages.\n\nThis level creates a separate subtree for every cryptocoin, avoiding reusing addresses across cryptocoins and improving privacy issues.\n\nCoin type is a constant, set for each cryptocoin. The list of registered coin type constants should be obtained from BIP44.\n\nHardened derivation is used at this level.\n\n===Series===\n\nSeries are used by voting pools in order to implement FIFO cold storage. By directing deposits into multiple series, the private keys for most of the deposits can be kept offline, and a limited portion can be brought online to process withdrawals.\n\nHardened derivation is used at this level.\n\n===Index===\n\nPublic/private keypairs are numbered from index 0 in sequentially increasing manner. This number is used as child index in BIP32 derivation.\n\nPublic keys obtained at this level of the hierarchy are used to construct multisig deposit scripts, using a schema that is shared between the members as an out-of-band contract.\n\nPublic derivation is used at this level.\n\n==Compatible wallets==\n\n* [[https://github.com/btcsuite/btcwallet|btcwallet]] is the reference Bitcoin wallet for voting pools.\n\n==Copyright==\n\nThis document is placed in the public domain.\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n", "content_length": 3048}
{"bip_number": 79, "filename": "bip-0079.mediawiki", "content": "<pre>\n  BIP: 79\n  Layer: Applications\n  Title: Bustapay :: a practical coinjoin protocol\n  Author: Ryan Havar <rhavar@protonmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0079\n  Status: Replaced\n  Type: Informational\n  Created: 2018-10-05\n  License: CC0-1.0\n  Superseded-By: 78\n</pre>\n\n\n==Abstract==\n\nThe way bitcoin transactions are normally created leaks more information than desirable, and as a result has been exploited by unreasonably effective blockchain analysis techniques to jeopardize important properties that are expected of a useful currency.\n\nBustapay is a simple and practical protocol for the sender and receiver of a payment to collaboratively sign a bitcoin transaction in such a way that busts some analysis assumptions to the immediate benefit of the sender and receiver. Furthermore it does so in such a way that gives a significant amount of control to the receiver to help manage their utxo set size, a constant problem for bitcoin merchants.\n\n==Copyright==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n==Motivation==\n\nOne of the most powerful blockchain analysis heuristics has been to assume all inputs of a transaction are controlled by a single party unless otherwise known (such as by the distinctive structure of a traditional coinjoin, or multisig spends that are validated onchain). Combined with other techniques (notably change-output guessing) this has lead to unexpectedly accurate tracking that has exposed bitcoin participants to unacceptable personal, business and financial risks -- undermining bitcoin's utility and fungibility -- and ultimately jeopardizing its ability to function as useful money.\n\nWe however can bust these assumptions with a sender-receiver coinjoin. To prevent costless spy/DoS attacks, we require the sending party to provide a fully-valid ready-to-propagate transaction to initiate the process, that the receiver can broadcast if the sender never completes the coinjoin thus tying the cost to that of spending a utxo. Most promisingly, bustapay transactions do not have an identifiable structure so any network analysis will be not able to tell if a given transaction is a bustapay transaction or not which erodes the confidence of their entire models, providing positive externalities for the entire bitcoin ecosystem.\n\nBustapay transactions also do not grow the receiver's count of unspent transaction outputs, and in fact gives the receiver an opportunity to better manage their utxo set, something normally only done when sending payments. Large utxo sets are often problematic and expensive, and frequently requiring privacy-destroying consolidation.  Besides busting clustering assumptions, bustapay also provides a layer of obfuscation of send amounts.\n\nIt is worth noting that this specification has eschewed complexity and potentially useful extensions on the assumption that simplicity is of the most important to encourage adoption.\n\n\n==Overview==\n\nA bustapay payment is made from a sender to a receiver.\n\n====Step 1. Sender creates a bitcoin transaction paying the receiver====\n\nThis transaction must use segwit for all inputs, and be fully valid and signed. The transaction must be eligible for propagation on the network (but not done so at this stage)\n\n====Step 2. Sender gives the \"template transaction\" to the receiver====\n\nThis is done via an HTTP POST request, sent to a \"bustapay url\"\n\n====Step 3. Receiver processes the transaction and returns a partially signed coinjoin====\n\nThe receiver validates the transaction, and pays himself. The receiver then adds one or more of his own inputs (known as the ''contributed inputs'') and (optionally) increases the output that pays himself (generally by the sum of the ''contributed inputs''). Doing so creates a ''partial transaction'', which the receiver returns to the sender. It is called such as it requires the sender to re-sign his own inputs.\n\n====Step 4. Sender validates, re-signs, and propagates on the bitcoin network====\n\nThe sender MUST validate the ''partial transaction'' was changed correctly and non-maliciously (to allow using potentially untrusted communication channels), re-sign its original inputs and propagate the final transaction over the bitcoin network.\n\n====Step 5. Receiver observes the finalized transaction on the bitcoin network====\n\nOnce the receiver has seen the finalized transactions on the network (and has enough confirmations) it can process it like a normal payment for the sent amount (as opposed to the amount that it looks like on the network). If the receiver does not see the finalized transaction after a timeout, they will propagate the original \"template transaction\", which ensures the payment happens and functions a strong anti-DoS mechanism.\n\n== Specification ==\n\nThe standard way of letting a sender know where to send a bustapay transaction is done via a bip21 encoded address. The key value \"bpu\" (short for \"BustaPayUrl\") should be used. An example of such address would be bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bpu=https://bp.bustabit.com/submit  It is highly encouraged that urls are kept short.\n\nWhen the sender is creating a \"template transaction\" it is done almost identically to creating a normal send, with the exception that *only* segwit inputs may be used. The sender is also encouraged to use a slightly more aggressive feerate than usual as well as BIP125 (Opt-in Full Replace-by-Fee Signaling), but neither is strictly required.\n\nThe template transaction should be sent to the receiver via an HTTP POST to the bustapay url, with a binary encoded body.\n\nThe receiver is then responsible for validating the template transaction. If there is a problem with the transaction, or the receiver is generally unhappy with the transaction (e.g. fees are too small) the HTTP response code of 422 should be used and a human-readable string containing information on why which can be directly given to the user.\n\nShould the receiver reject a transaction, it should not attempt to propagate it on the network. However it is important for the sender to be aware that the receiver *could* at any time (regardless of which error was given) send this transaction. The client should therefore assume the receiver will, and act accordingly (either retry with adjustments or just propagate the transaction). It is imperative that the sender never finds themselves in a situation where two payments to the sender could be valid.\n\n=== Contributed Input Choice ===\n\nThe receiver must add at least one input to the transaction (the \"contributed inputs\"). If the receiver has no inputs, it should use a 500 internal server error, so the client can send the transaction as per normal (or try again later). Its generally advised to only add a single contributed input, however they are circumstances where adding more than a single input can be useful.\n\nTo prevent an attack where a receiver is continually sent variations of the same transaction to enumerate the receiver's utxo set, it is essential that the receiver always returns the same contributed inputs when it's seen the same inputs.\n\nIt is strongly preferable that the receiver makes an effort to pick a contributed input of the same type as the other transaction inputs if possible.\n\n=== Output Adjustment ===\n\nAfter adding inputs to the transaction, the receiver generally will want to adjust the output that pays himself by increasing it by the sum of the contributed input amounts (minus any fees he wants to contribute). However the only strict requirement is that the receiver *must never* remove inputs, and *must not* ever decrease any output amount.\n\n=== Returning the partial transaction ===\n\nThe receiver must sign all contributed inputs in the partial transaction. The partial transaction should also remove all witnesses from the original template transaction as they are no longer valid, and need to be recalculated by the sender. The receiver returns the partial transaction as a binary-encoded HTTP response with a status code of 200. To ensure compatibility with web-wallets and browser-based-tools, all responses (including errors) must contain the HTTP header \"Access-Control-Allow-Origin: *\"\n\n\n=== Sender Validation ===\n\nThe sender *must* do important validation on the partial transaction. They *must* verify:\n\n* All template transaction inputs are in the partial transaction (but perhaps different order) and have the same sequence numbers.\n* The partial transaction contains at least one new (and signed) segwit input (owned by the receiver)\n* All outputs from the template transaction exist in the partial transaction, except they are allowed to be reordered and have their amounts increased (but *never* decreased)\n\n=== Creating Final Transaction ===\n\nAfter validating the partial transaction, the sender signs all its inputs to create what is now the final transaction. It is important that the sender is careful to not be tricked by the receiver into signing other inputs it owns. The sender must only sign inputs that existed in the template transaction. If the sender is not careful the receiver may \"contribute\" inputs that are actually owned by the sender, with the hope the sender blindly signs everything.\n\n\n=== Transaction Publishing ===\n\nOnce the final transaction is created, the sender should publish it directly onto the bitcoin network. If the sender does not do this after a reasonable time (e.g. 1 minute), the receiver should publish the template transaction as an important anti-spy/anti-DoS tactic . The sender may also choose to publish the template transaction instead of the final transaction if they believe the receiver to have unreasonably lowered the feerate of the transaction (i.e. increased the size of the transaction, but not the feerate enough). And both parties can consider publishing the template transaction even after the finalized transaction is on the network (taking advantage of replace-by-fee) if the final transaction is not confirming and the template transaction has more fees.\n\n\n=== Implementation Notes ===\nFor anyone wanting to implement bustapay payments, here are some notes for receivers:\n\n* A transaction can easily be checked if it's suitable for the mempool with testmempoolaccept in bitcoin core 0.17+\n* Tracking transactions by txid is precarious. To keep your sanity make sure all inputs are segwit. But remember segwit does not prevent txid malleability unless you validate the transaction. So really make sure you're using testmempoolaccept at the very least\n* Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address\n* You will need to keep a mapping of which utxos people have showed you and which you revealed. So if you see them again, you can reveal the same one of your own\n* Check if the transaction was already sorted according to BIP69, if so ensure the result stays that way. Otherwise probably just shuffle the inputs/outputs\n* A reference implementation is maintained at https://github.com/rhavar/bustapay which functions as a wrapper around some RPC calls to bitcoin core's wallet.\n* The sender must be careful of an attack where the receiver tries to add additional inputs that are controlled by the sender, with the hope that the sender blindly signs it.\n\n== Backwards Compatibility ==\n\nBustapay is an optional payment protocol and therefore has no backwards compatibility concerns. It in fact can only be supported in addition to normal transaction processing, as falling back to a normal bitcoin transaction is a required behavior.\n\n\n== Credits ==\nThe idea is obviously based upon Dr. Maxwell's seminal CoinJoin proposal, and reduced scope inspired by a simplification of the \"pay 2 endpoint\" blog post by blockstream.\n", "content_length": 11877}
{"bip_number": 78, "filename": "bip-0078.mediawiki", "content": "<pre>\n  BIP: 78\n  Layer: Applications\n  Title: A Simple Payjoin Proposal\n  Author: Nicolas Dorier <nicolas.dorier@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0078\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-05-01\n  License: BSD-2-Clause\n  Replaces: 79\n</pre>\n\n==Introduction==\n\n===Abstract===\n\nThis document proposes a protocol for two parties\nto negotiate a coinjoin transaction during a payment between them.\n\n===Copyright===\n\nThis BIP is licensed under the 2-clause BSD license.\n\n===Motivation===\n\nWhen two parties (later referred to as sender and receiver) want to transact,\nmost of the time, the sender creates a transaction spending their own Unspent Transaction Outputs (UTXOs), signs\nit and broadcasts it on the network.\n\nThis simple model gave birth to several heuristics impacting the privacy of the parties and of the network as a whole.\n\n* Common input ownership heuristic: In most transactions, all the inputs belong to the same party.\n* Change identification from scriptPubKey type: If all inputs are spending UTXOs of a certain scriptPubKey type, then the change output is likely to have the same scriptPubKey type, too.\n* Change identification from round amount: If an output in the transaction has a round amount, it is likely an output belonging to the receiver.\n\nWe will designate these three heuristics as <code>common-input</code>, <code>change-scriptpubkey</code>, <code>change-round-amount</code>.\n\nThe problems we aim to solve are:\n* For the receiver, there is a missed opportunity to consolidate their own UTXOs or making payment in the sender's transaction.\n* For the sender, there are privacy leaks regarding their wallet that happen when someone applies the heuristics detailed above to their transaction.\n\nOur proposal gives an opportunity for the receiver to consolidate their UTXOs while also batching their own payments, without creating a new transaction. (Saving fees in the process)\nFor the sender, it allows them to invalidate the three heuristics above. With the receiver's involvement, the heuristics can even be poisoned. (ie, using the heuristics to intentionally mislead blockchain analysis)\n\nNote that the existence of this proposal is also improving the privacy of parties who are not using it by making the three heuristics unreliable to the network as a whole.\n\n=== Relation to BIP79 (Bustapay) ===\n\nAnother implementation proposal has been written: [[https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki|BIP79 Bustapay]].\n\nWe decided to deviate from it for several reasons:\n* It was not using PSBT, so if the receiver wanted to bump the fee, they would need the full UTXO set.\n* Inability to change the payment output to match scriptPubKey type.\n* Lack of basic versioning negotiation if the protocol evolves.\n* No standardization of error condition for proper feedback to the sender.\n\nOther than that, our proposal is very similar.\n\n==Specification==\n\n===Protocol===\n\nIn a payjoin payment, the following steps happen:\n\n* The receiver of the payment, presents a [[bip-0021.mediawiki|BIP 21 URI]] to the sender with a parameter <code>pj=</code> describing a payjoin endpoint.\n* The sender creates a signed, finalized PSBT with witness UTXO or previous transactions of the inputs. We call this PSBT the <code>original</code>.\n* The receiver replies back with a signed PSBT containing his own signed inputs/outputs and those of the sender. We call this PSBT <code>Payjoin proposal</code>.\n* The sender verifies the proposal, re-signs his inputs and broadcasts the transaction to the Bitcoin network. We call this transaction <code>Payjoin transaction</code>.\n<pre>\n+----------+                        +--------+         +-----------------+\n| Receiver |                        | Sender |         | Bitcoin Network |\n+----+-----+                        +---+----+         +-------+---------+\n     |       +-----------------+        |                      |\n     +-------+ BIP21 with ?pj= +------->+                      |\n     |       +-----------------+        |                      |\n     |                                  |                      |\n     |        +---------------+         |                      |\n     +<-------+ Original PSBT +---------+                      |\n     |        +---------------+         |                      |\n     |                                  |                      |\n     |       +------------------+       |                      |\n     |       | Payjoin Proposal |       |                      |\n     +-------+      PSBT        +------>+                      |\n     |       +------------------+       |                      |\n     |                                  |   +--------------+   |\n     |                                  |---+ Payjoin      |   |\n     |                                  |   | transaction  +-->+\n     |                                  |   +--------------+   |\n     +                                  +                      +\n</pre>\nThe original PSBT is sent in the HTTP POST request body, base64 serialized, with <code>text/plain</code> in the <code>Content-Type</code> HTTP header and <code>Content-Length</code> set correctly.\nThe payjoin proposal PSBT is sent in the HTTP response body, base64 serialized with HTTP code 200.\n\nTo ensure compatibility with web-wallets and browser-based-tools, all responses (including errors) must contain the HTTP header <code>Access-Control-Allow-Origin: *</code>.\n\nThe sender must ensure that the URL refers to a scheme or protocol using authenticated encryption, for example TLS with certificate validation, or a .onion link to a hidden service whose public key identifier has already been communicated via a TLS connection. Senders SHOULD NOT accept a URL representing an unencrypted or unauthenticated connection.\n\nThe original PSBT MUST:\n* Have all the <code>witnessUTXO</code> or <code>nonWitnessUTXO</code> information filled in.\n* Be finalized.\n* Not include fields unneeded for the receiver such as global xpubs or keypath information.\n* Be broadcastable.\n\nThe original PSBT MAY:\n* Have outputs unrelated to the payment for batching purpose.\n\nThe original PSBT SHOULD NOT:\n* Include mixed input types until September 2024. Mixed inputs were previously completely disallowed so this gives some grace period for receivers to update.\n\nThe payjoin proposal MUST:\n* Use all the inputs from the original PSBT.\n* Use all the outputs which do not belong to the receiver from the original PSBT.\n* Only finalize the inputs added by the receiver. (Referred later as <code>additional inputs</code>)\n* Only fill the <code>witnessUTXO</code> or <code>nonWitnessUTXO</code> for the additional inputs.\n\nThe payjoin proposal MAY:\n* Add, or replace the outputs belonging to the receiver unless output substitution is disabled.\n\nThe payjoin proposal SHOULD NOT:\n* Include mixed input types until September 2024. Mixed inputs were previously completely disallowed so this gives some grace period for senders to update.\n\nThe payjoin proposal MUST NOT:\n* Shuffle the order of inputs or outputs, the additional outputs or additional inputs must be inserted at a random index.\n* Decrease the absolute fee of the original transaction.\n\n===BIP21 payjoin parameters===\n\nThis proposal is defining the following new [[bip-0021.mediawiki|BIP 21 URI]] parameters:\n* <code>pj=</code>: Represents an http(s) endpoint which the sender can POST the original PSBT.\n* <code>pjos=0</code>: Signal to the sender that they MUST disallow [[#output-substitution|payment output substitution]]. (See [[#unsecured-payjoin|Unsecured payjoin server]])\n\nNote: the <code>amount</code> parameter is *not* required.\n\n===<span id=\"optional-params\"></span>Optional parameters===\n\nWhen the payjoin sender posts the original PSBT to the receiver, he can optionally specify the following HTTP query string parameters:\n\n* <code>v=</code>, the version number of the payjoin protocol that the sender is using. The current version is <code>1</code>.\n\nThis can be used in the future so the receiver can reject a payjoin if the sender is using a version which is not supported via an error HTTP 400, <code>version-unsupported</code>.\nIf not specified, the receiver will assume the sender is <code>v=1</code>.\n\nIf the receiver does not support the version of the sender, they should send an error with the list of supported versions:\n<pre>\n{\n    \"errorCode\": \"version-unsupported\",\n    \"supported\" : [ 2, 3, 4 ],\n    \"message\": \"The version is not supported anymore\"\n}\n</pre>\n\n* <code>additionalfeeoutputindex=</code>, if the sender is willing to pay for increased fee, this indicate output can have its value subtracted to pay for it.\n\nIf the <code>additionalfeeoutputindex</code> is out of bounds or pointing to the payment output meant for the receiver, the receiver should ignore the parameter. See [[#fee-output|fee output]] for more information.\n\n* <code>maxadditionalfeecontribution=</code>, if the sender is willing to pay for increased fee, an integer defining the maximum amount in satoshis that the sender is willing to contribute towards fees for the additional inputs. <code>maxadditionalfeecontribution</code> must be ignored if set to less than zero.  See [[#fee-output|fee output]] for more information.\n\nNote that both <code>maxadditionalfeecontribution=</code> and <code>additionalfeeoutputindex=</code> must be specified and valid for the receiver to be allowed to decrease an output belonging to the sender.\nThis fee contribution can't be used to pay for anything else than additional input's weight.\n\n* <code>minfeerate=</code>, a decimal in satoshi per vbyte that the sender can use to constraint the receiver to not drop the minimum fee rate too much.\n\n* <code>disableoutputsubstitution=</code>, a boolean indicating if the sender forbids the receiver to substitute the receiver's output, see [[#output-substitution|payment output substitution]]. (default to <code>false</code>)\n\n===Receiver's well known errors===\n\nIf for some reason the receiver is unable to create a payjoin proposal, it will reply with a HTTP code different than 200.\nThe receiver is not constrained to specific set of errors, some are specified in this proposal.\n\nThe errors have the following format:\n<pre>\n{\n    \"errorCode\": \"leaking-data\",\n    \"message\": \"Key path information or GlobalXPubs should not be included in the original PSBT.\"\n}\n</pre>\n\nThe well-known error codes are:\n{| class=\"wikitable\"\n!Error code\n!Meaning\n|-\n|unavailable\n|The payjoin endpoint is not available for now.\n|-\n|not-enough-money\n|The receiver added some inputs but could not bump the fee of the payjoin proposal.\n|-\n|version-unsupported\n|This version of payjoin is not supported.\n|-\n|original-psbt-rejected\n|The receiver rejected the original PSBT.\n|}\n\nThe receiver is allowed to return implementation-specific errors which may assist the sender to diagnose any issue.\n\nHowever, it is important that error codes that are not well-known and that the message do not appear on the sender's software user interface.\nSuch error codes or messages could be used maliciously to phish a non-technical user.\nInstead those errors or messages can only appear in debug logs.\n\nIt is advised to hard code the description of the well known error codes into the sender's software.\n\n===<span id=\"fee-output\"></span>Fee output===\n\nIn some situation, the sender might want to pay some additional fee in the payjoin proposal.\nIf such is the case, the sender must use both [[#optional-params|optional parameters]] <code>additionalfeeoutputindex=</code> and <code>maxadditionalfeecontribution=</code> to indicate which output and how much the receiver can subtract fee.\n\nThere are several cases where a fee output is useful:\n\n* The sender's original transaction's fee rate is at the minimum accepted by the network, aka <code>minimum relay transaction fee rate</code>, which is typically 1 satoshi per vbyte.\n\nIn such case, the receiver will need to increase the fee of the transaction after adding his own inputs to not drop below the minimum relay transaction fee rate.\n\n* The sender's wallet software is using round fee rate.\n\nIf the sender's fee rate is always round, then a blockchain analyst can easily spot the transactions of the sender involving payjoin by checking if, when removing a single input to the suspected payjoin transaction, the resulting fee rate is round.\nTo prevent this, the sender can agree to pay more fee so the receiver make sure that the payjoin transaction fee is also round.\n\n* The sender's transaction is time sensitive.\n\nWhen a sender picks a specific fee rate, the sender expects the transaction to be confirmed after a specific amount of time. But if the receiver adds an input without bumping the fee of the transaction, the payjoin transaction fee rate will be lower, and thus, longer to confirm.\n\nOur recommendation for <code>maxadditionalfeecontribution=</code> is <code>originalPSBTFeeRate * 110</code>.\n\n===Receiver's original PSBT checklist===\n\nThe receiver needs to do some check on the original PSBT before proceeding:\n\n* Non-interactive receivers (like a payment processor) need to check that the original PSBT is broadcastable. <code>*</code>\n* If the sender included inputs in the original PSBT owned by the receiver, the receiver must either return error <code>original-psbt-rejected</code> or make sure they do not sign those inputs in the payjoin proposal.\n* Make sure that the inputs included in the original transaction have never been seen before.\n** This prevents [[#probing-attack|probing attacks]].\n** This prevents reentrant payjoin, where a sender attempts to use payjoin transaction as a new original transaction for a new payjoin.\n\n<code>*</code>: Interactive receivers are not required to validate the original PSBT because they are not exposed to [[#probing-attack|probing attacks]].\n\n===Sender's payjoin proposal checklist===\n\nThe sender should check the payjoin proposal before signing it to prevent a malicious receiver from stealing money.\n\n* Verify that the absolute fee of the payjoin proposal is equals or higher than the original PSBT.\n* If the receiver's BIP21 signalled <code>pjos=0</code>, disable payment output substitution.\n* Verify that the transaction version, and the nLockTime are unchanged.\n* Check that the sender's inputs' sequence numbers are unchanged.\n* For each input in the proposal:\n** Verify that no keypaths are in the PSBT input\n** Verify that no partial signature has been filled\n** If it is one of the sender's inputs:\n*** Verify that input's sequence is unchanged.\n*** Verify the PSBT input is not finalized\n** If it is one of the receiver's inputs:\n*** Verify the PSBT input is finalized\n*** Verify that <code>non_witness_utxo</code> or <code>witness_utxo</code> are filled in.\n** Verify that the payjoin proposal inputs all specify the same sequence value.\n** Verify that all of sender's inputs from the original PSBT are in the proposal.\n* For each output in the proposal:\n** Verify that no keypaths are in the PSBT output\n** If the output is the [[#fee-output|fee output]]:\n*** The amount that was subtracted from the output's value is less than or equal to <code>maxadditionalfeecontribution</code>. Let's call this amount <code>actual contribution</code>.\n*** Make sure the actual contribution is only going towards fees: The <code>actual contribution</code> is less than or equals to the difference of absolute fee between the payjoin proposal and the original PSBT.\n*** Make sure the actual contribution is only paying for fees incurred by additional inputs: <code>actual contribution</code> is less than or equal to <code>originalPSBTFeeRate * vsize(sender_input_type) * (count(payjoin_proposal_inputs) - count(original_psbt_inputs))</code>. (see [[#fee-output|Fee output]] section)\n** If the output is the payment output and payment output substitution is allowed,\n*** Do not make any check\n** Else\n*** Make sure the output's value did not decrease.\n** Verify that all sender's outputs (ie, all outputs except the output actually paid to the receiver) from the original PSBT are in the proposal.\n* Once the proposal is signed, if <code>minfeerate</code> was specified, check that the fee rate of the payjoin transaction is not less than this value.\n\nThe sender must be careful to only sign the inputs that were present in the original PSBT and nothing else.\n\nNote:\n* The sender must allow the receiver to add/remove or modify the receiver's own outputs. (if payment output substitution is disabled, the receiver's outputs must not be removed or decreased in value)\n* The sender should allow the receiver to not add any inputs. This is useful for the receiver to change the payment output scriptPubKey type.\n* If the receiver added no inputs, the sender's wallet implementation should accept the payjoin proposal, but not mark the transaction as an actual payjoin in the user interface.\n\nOur method of checking the fee allows the receiver and the sender to batch payments in the payjoin transaction.\nIt also allows the receiver to pay the fee for batching adding his own outputs.\n\n==Rationale==\n\nThere are several consequences of our proposal:\n\n* The receiver can bump the fee of the original transaction.\n* The receiver can modify the outputs of the original PSBT.\n* The sender must provide the UTXO information (Witness or previous transaction) in the PSBT.\n\n===Respecting the minimum relay fee policy===\n\nTo be properly relayed, a Bitcoin transaction needs to pay at least 1 satoshi per virtual byte.\nWhen blocks are not full, the original transaction might already at the minimum relay fee rate (currently 1 satoshi per virtual byte), so if the receiver adds their own input, they need to make sure the fee is increased such that the rate does not drop below the minimum relay fee rate.\nIn such case, the sender must set both <code>maxadditionalfeecontribution=</code> and <code>additionalfeeoutputindex=</code>.\n\nSee the [[#fee-output|Fee output]] section for more information.\n\nWe also recommend the sender to set <code>minfeerate=</code>, as the sender's node policy might be different from the receiver's policy.\n\n===Defeating heuristics based on the fee calculation===\n\nMost wallets are creating a round fee rate (like 2 sat/b).\nIf the payjoin transaction's fee was not increased by the added size, then those payjoin transactions could easily be identifiable on the blockchain.\n\nNot only would those transactions stand out by not having a round fee (like 1.87 sat/b), but any suspicion of payjoin could be confirmed by checking if removing one input would create a round fee rate.\nIn such case, the sender must set both <code>maxadditionalfeecontribution=</code> and <code>additionalfeeoutputindex=</code>.\n\nThe recommended value <code>maxadditionalfeecontribution=</code> is explained in the [[#fee-output|Fee output]] section.\nWe also recommend the sender to set <code>minfeerate=</code>, as the sender's node policy might be different from the receiver's policy.\n\n===Receiver does not need to be a full node===\n\nBecause the receiver needs to bump the fee to keep the same fee rate as the original PSBT, it needs the input's UTXO information to know what is the original fee rate. Without PSBT, light wallets like Wasabi Wallet would not be able to receive a payjoin transaction.\n\nThe validation (policy and consensus) of the original transaction is optional: a receiver without a full node can decide to create the payjoin transaction and automatically broadcast the original transaction after a timeout of 1 minute, and only verify that it has been propagated in the network.\n\nHowever, non-interactive receivers (like a payment processor) need to verify the transaction to prevent UTXO probing attacks.\n\nThis is not a concern for interactive receivers like Wasabi Wallet, because those receivers can just limit the number of original PSBT proposals of a specific address to one. With such wallets, the attacker has no way to generate new deposit addresses to probe the UTXOs.\n\n===<span id=\"spare-change\"></span>Spare change donation===\n\nSmall change inside wallets are detrimental to privacy. Mixers like Wasabi wallet, because of its protocol, eventually generate such [[https://docs.wasabiwallet.io/using-wasabi/ChangeCoins.html#first-round-coinjoin-change|small change]].\n\nA common way to protect your privacy is to donate those spare changes, to deposit them in an exchange or on your favorite merchant's store account. Those kind of transactions can easily be spotted on the blockchain: There is only one output.\n\nHowever, if you donate via payjoin, it will look like a normal transaction.\n\nOn top of this the receiver can poison analysis by randomly faking a round amount of satoshi for the additional output.\n\n===<span id=\"output-substitution\"></span>Payment output substitution===\n\nUnless disallowed by the sender explicitly via <code>disableoutputsubstitution=true</code> or by the BIP21 URL via the query parameter <code>pjos=0</code>, the receiver is free to decrease the amount or change the scriptPubKey output paying to himself.\nNote that if payment output substitution is disallowed, the receiver can still increase the amount of the output. (See [[#reference-impl|the reference implementation]])\n\nFor example, if the sender's scriptPubKey type is P2WPKH while the receiver's payment output in the original PSBT is P2SH, then the receiver can substitute the payment output to be P2WPKH to match the sender's scriptPubKey type.\n\n===<span id=\"unsecured-payjoin\"></span>Unsecured payjoin server===\n\nA receiver might run the payment server (generating the BIP21 invoice) on a different server than the payjoin server, which could be less trusted than the payment server.\n\nIn such case, the payment server can signal to the sender, via the BIP21 parameter <code>pjos=0</code>, that they MUST disallow [[#output-substitution|payment output substitution]].\nA compromised payjoin server could steal the hot wallet outputs of the receiver, but would not be able to re-route payment to himself.\n\n===Impacted heuristics===\n\nOur proposal of payjoin breaks the following blockchain heuristics:\n\n* Common inputs heuristics.\n\nBecause payjoin is mixing the inputs of the sender and receiver, this heuristic becomes unreliable.\n\n* Change identification from scriptPubKey type heuristics\n\nWhen Alice pays Bob, if Alice is using P2SH but Bob's deposit address is P2WPKH, the heuristic would assume that the P2SH output is the change address of Alice.\nThis is now however a broken assumption, as the payjoin receiver has the freedom to mislead analytics by purposefully changing the invoice's address in the payjoin transaction.\n\nSee [[#output-substitution|payment output substitution]].\n\n* Change identification from round change amount\n\nIf Alice pays Bob, she might be tempted to pay him a round amount, like <code>1.23000000 BTC</code>. When this happens, blockchain analysis often identifies the output without the round amount as the change of the transaction.\n\nFor this reason, during a [[#spare-change|spare change]] case, the receiver may add an output with a rounded amount randomly.\n\n==Attack vectors==\n\n===<span id=\"probing-attack\"></span>On the receiver side: UTXO probing attack===\n\nWhen the receiver creates a payjoin proposal, they expose one or more inputs belonging to them.\n\nAn attacker could create multiple original transactions in order to learn the UTXOs of the receiver, while not broadcasting the payjoin proposal.\n\nWhile we cannot prevent this type of attack entirely, we implemented the following mitigations:\n\n* When the receiver detects an original transaction being broadcast, or if the receiver detects that the original transaction has been double spent, then they will reuse the UTXO that was exposed for the next payjoin.\n* While the exposed UTXO will be reused in priority to not leak other UTXOs, there is no strong guarantee about it. This prevents the attacker from detecting with certainty the next payjoin of the merchant to another peer.\n\nNote that probing attacks are only a problem for automated payment systems such as BTCPay Server. End-user wallets with payjoin capabilities are not affected, as the attacker can't create multiple invoices to force the receiver to expose their UTXOs.\n\n===On the sender side: Double payment risk for hardware wallets===\n\nFor a successful payjoin to happen, the sender needs to sign two transactions double spending each other: The original transaction and the payjoin proposal.\n\nThe sender's software wallet can verify that the payjoin proposal is legitimate by the sender's checklist.\n\nHowever, a hardware wallet can't verify that this is indeed the case. This means that the security guarantee of the hardware wallet is decreased. If the sender's software is compromised, the hardware wallet would sign two valid transactions, thus sending two payments.\n\nWithout payjoin, the maximum amount of money that could be lost by a compromised software is equal to one payment (via [[#output-substitution|payment output substitution]]).\nNote that the sender can disallow [[#output-substitution|payment output substitution]] by using the optional parameter <code>disableoutputsubstitution=true</code>.\n\nWith payjoin, the maximum amount of money that can be lost is equal to two payments.\n\n==<span id=\"reference-impl\"></span>Reference sender's implementation==\n\nHere is pseudo code of a sender implementation.\n<code>RequestPayjoin</code> takes the BIP21 URI of the payment, the wallet and the <code>signedPSBT</code>.\n\nThe <code>signedPSBT</code> represents a PSBT which has been fully signed, but not yet finalized.\nWe then prepare <code>originalPSBT</code> from the <code>signedPSBT</code> via the <code>CreateOriginalPSBT</code> function and get back the <code>proposal</code>.\n\nWhile we verify the <code>proposal</code>, we also import into it information about our own inputs and outputs from the <code>signedPSBT</code>.\nAt the end of this <code>RequestPayjoin</code>, the proposal is verified and ready to be signed.\n\nWe logged the different PSBT involved, and show the result in our [[#test-vectors|test vectors]].\n<pre>\npublic async Task<PSBT> RequestPayjoin(\n    BIP21Uri bip21,\n    Wallet wallet,\n    PSBT signedPSBT,\n    PayjoinClientParameters optionalParameters)\n{\n    Log(\"Unfinalized signed PSBT\" + signedPSBT);\n    // Extracting the pj link.\n    var endpoint = bip21.ExtractPayjointEndpoint();\n    if (signedPSBT.IsAllFinalized())\n        throw new InvalidOperationException(\"The original PSBT should not be finalized.\");\n    PSBTOutput feePSBTOutput = null;\n\n    bool allowOutputSubstitution = !optionalParameters.DisableOutputSubstitution;\n    if (bip21.Parameters.Contains(\"pjos\") && bip21.Parameters[\"pjos\"] == \"0\")\n        allowOutputSubstitution = false;\n\n    if (optionalParameters.AdditionalFeeOutputIndex != null && optionalParameters.MaxAdditionalFeeContribution != null)\n        feePSBTOutput = signedPSBT.Outputs[optionalParameters.AdditionalFeeOutputIndex];\n    Script paymentScriptPubKey = bip21.Address == null ? null : bip21.Address.ScriptPubKey;\n    decimal originalFee = signedPSBT.GetFee();\n    PSBT originalPSBT = CreateOriginalPSBT(signedPSBT);\n    Transaction originalGlobalTx = signedPSBT.GetGlobalTransaction();\n    TxOut feeOutput = feePSBTOutput == null ? null : originalGlobalTx.Outputs[feePSBTOutput.Index];\n    var originalInputs = new Queue<(TxIn OriginalTxIn, PSBTInput SignedPSBTInput)>();\n    for (int i = 0; i < originalGlobalTx.Inputs.Count; i++)\n    {\n        originalInputs.Enqueue((originalGlobalTx.Inputs[i], signedPSBT.Inputs[i]));\n    }\n    var originalOutputs = new Queue<(TxOut OriginalTxOut, PSBTOutput SignedPSBTOutput)>();\n    for (int i = 0; i < originalGlobalTx.Outputs.Count; i++)\n    {\n      originalOutputs.Enqueue((originalGlobalTx.Outputs[i], signedPSBT.Outputs[i]));\n    }\n    // Add the client side query string parameters\n    endpoint = ApplyOptionalParameters(endpoint, optionalParameters);\n    Log(\"original PSBT\" + originalPSBT);\n    PSBT proposal = await SendOriginalTransaction(endpoint, originalPSBT, cancellationToken);\n    Log(\"payjoin proposal\" + proposal);\n    // Checking that the PSBT of the receiver is clean\n    if (proposal.GlobalXPubs.Any())\n    {\n        throw new PayjoinSenderException(\"GlobalXPubs should not be included in the receiver's PSBT\");\n    }\n    ////////////\n\n    if (proposal.CheckSanity() is List<PSBTError> errors && errors.Count > 0)\n        throw new PayjoinSenderException($\"The proposal PSBT is not sane ({errors[0]})\");\n\n    var proposalGlobalTx = proposal.GetGlobalTransaction();\n    // Verify that the transaction version, and nLockTime are unchanged.\n    if (proposalGlobalTx.Version != originalGlobalTx.Version)\n        throw new PayjoinSenderException($\"The proposal PSBT changed the transaction version\");\n    if (proposalGlobalTx.LockTime != originalGlobalTx.LockTime)\n        throw new PayjoinSenderException($\"The proposal PSBT changed the nLocktime\");\n\n    HashSet<Sequence> sequences = new HashSet<Sequence>();\n    // For each inputs in the proposal:\n    foreach (PSBTInput proposedPSBTInput in proposal.Inputs)\n    {\n        if (proposedPSBTInput.HDKeyPaths.Count != 0)\n            throw new PayjoinSenderException(\"The receiver added keypaths to an input\");\n        if (proposedPSBTInput.PartialSigs.Count != 0)\n            throw new PayjoinSenderException(\"The receiver added partial signatures to an input\");\n        PSBTInput proposedTxIn = proposalGlobalTx.Inputs.FindIndexedInput(proposedPSBTInput.PrevOut).TxIn;\n        bool isOurInput = originalInputs.Count > 0 && originalInputs.Peek().OriginalTxIn.PrevOut == proposedPSBTInput.PrevOut;\n        // If it is one of our input\n        if (isOurInput)\n        {\n            OutPoint inputPrevout = ourPrevouts.Dequeue();\n            TxIn originalTxin = originalGlobalTx.Inputs.FromOutpoint(inputPrevout);\n            PSBTInput originalPSBTInput = originalPSBT.Inputs.FromOutpoint(inputPrevout);\n            // Verify that sequence is unchanged.\n            if (input.OriginalTxIn.Sequence != proposedTxIn.Sequence)\n                throw new PayjoinSenderException(\"The proposedTxIn modified the sequence of one of our inputs\")\n            // Verify the PSBT input is not finalized\n            if (proposedPSBTInput.IsFinalized())\n                throw new PayjoinSenderException(\"The receiver finalized one of our inputs\");\n            sequences.Add(proposedTxIn.Sequence);\n\n            // Fill up the info from the original PSBT input so we can sign and get fees.\n            proposedPSBTInput.NonWitnessUtxo = input.SignedPSBTInput.NonWitnessUtxo;\n            proposedPSBTInput.WitnessUtxo = input.SignedPSBTInput.WitnessUtxo;\n            // We fill up information we had on the signed PSBT, so we can sign it.\n            foreach (var hdKey in input.SignedPSBTInput.HDKeyPaths)\n            proposedPSBTInput.HDKeyPaths.Add(hdKey.Key, hdKey.Value);\n            proposedPSBTInput.RedeemScript = signedPSBTInput.RedeemScript;\n            proposedPSBTInput.RedeemScript = input.SignedPSBTInput.RedeemScript;\n        }\n        else\n        {\n            // Verify the PSBT input is finalized\n            if (!proposedPSBTInput.IsFinalized())\n                throw new PayjoinSenderException(\"The receiver did not finalized one of their input\");\n            // Verify that non_witness_utxo or witness_utxo are filled in.\n            if (proposedPSBTInput.NonWitnessUtxo == null && proposedPSBTInput.WitnessUtxo == null)\n                throw new PayjoinSenderException(\"The receiver did not specify non_witness_utxo or witness_utxo for one of their inputs\");\n            sequences.Add(proposedTxIn.Sequence);\n        }\n    }\n\n    // Verify that all of sender's inputs from the original PSBT are in the proposal.\n    if (originalInputs.Count != 0)\n        throw new PayjoinSenderException(\"Some of our inputs are not included in the proposal\");\n\n    // Verify that the payjoin proposal did not introduced mixed inputs' sequence.\n    if (sequences.Count != 1)\n        throw new PayjoinSenderException(\"Mixed sequence detected in the proposal\");\n\n    decimal newFee = proposal.GetFee();\n    decimal additionalFee = newFee - originalFee;\n    if (additionalFee < 0)\n      throw new PayjoinSenderException(\"The receiver decreased absolute fee\");\n    // For each outputs in the proposal:\n    foreach (PSBTOutput proposedPSBTOutput in proposal.Outputs)\n    {\n        // Verify that no keypaths is in the PSBT output\n        if (proposedPSBTOutput.HDKeyPaths.Count != 0)\n            throw new PayjoinSenderException(\"The receiver added keypaths to an output\");\n        if (originalOutputs.Count == 0)\n                continue;\n        var originalOutput = originalOutputs.Peek();\n        bool isOriginalOutput = originalOutput.OriginalTxOut.ScriptPubKey == proposedPSBTOutput.ScriptPubKey;\n        bool substitutedOutput = !isOriginalOutput &&\n                                allowOutputSubstitution &&\n                                originalOutput.OriginalTxOut.ScriptPubKey == paymentScriptPubKey;\n        if (isOriginalOutput || substitutedOutput)\n        {\n            originalOutputs.Dequeue();\n            if (originalOutput.OriginalTxOut == feeOutput)\n            {\n                var actualContribution = feeOutput.Value - proposedPSBTOutput.Value;\n                // The amount that was subtracted from the output's value is less than or equal to maxadditionalfeecontribution\n                if (actualContribution > optionalParameters.MaxAdditionalFeeContribution)\n                    throw new PayjoinSenderException(\"The actual contribution is more than maxadditionalfeecontribution\");\n                // Make sure the actual contribution is only paying fee\n                if (actualContribution > additionalFee)\n                    throw new PayjoinSenderException(\"The actual contribution is not only paying fee\");\n                // Make sure the actual contribution is only paying for fee incurred by additional inputs\n                // This assumes an additional input can be up to 110 bytes.\n                int additionalInputsCount = proposalGlobalTx.Inputs.Count - originalGlobalTx.Inputs.Count;\n                if (actualContribution > originalFeeRate * 110 * additionalInputsCount)\n                    throw new PayjoinSenderException(\"The actual contribution is not only paying for additional inputs\");\n            }\n            else if (allowOutputSubstitution && output.OriginalTxOut.ScriptPubKey == paymentScriptPubKey)\n            {\n                // That's the payment output, the receiver may have changed it.\n            }\n            else\n            {\n                if (originalOutput.OriginalTxOut.Value > proposedPSBTOutput.Value)\n                    throw new PayjoinSenderException(\"The receiver decreased the value of one of the outputs\");\n            }\n            // We fill up information we had on the signed PSBT, so we can sign it.\n            foreach (var hdKey in output.SignedPSBTOutput.HDKeyPaths)\n                proposedPSBTOutput.HDKeyPaths.Add(hdKey.Key, hdKey.Value);\n            proposedPSBTOutput.RedeemScript = output.SignedPSBTOutput.RedeemScript;\n        }\n    }\n    // Verify that all of sender's outputs from the original PSBT are in the proposal.\n    if (originalOutputs.Count != 0)\n    {\n        // The payment output may have been substituted\n        if (!allowOutputSubstitution ||\n            originalOutputs.Count != 1 ||\n            originalOutputs.Dequeue().OriginalTxOut.ScriptPubKey != paymentScriptPubKey)\n            {\n                throw new PayjoinSenderException(\"Some of our outputs are not included in the proposal\");\n            }\n    }\n\n    // After signing this proposal, we should check if minfeerate is respected.\n    Log(\"payjoin proposal filled with sender's information\" + proposal);\n    return proposal;\n}\n\n// Finalize the signedPSBT and remove confidential information\nPSBT CreateOriginalPSBT(PSBT signedPSBT)\n{\n    var original = signedPSBT.Clone();\n    original = original.Finalize();\n    foreach (var input in original.Inputs)\n    {\n        input.HDKeyPaths.Clear();\n        input.PartialSigs.Clear();\n        input.Unknown.Clear();\n    }\n    foreach (var output in original.Outputs)\n    {\n        output.Unknown.Clear();\n        output.HDKeyPaths.Clear();\n    }\n    original.GlobalXPubs.Clear();\n    return original;\n}\n</pre>\n\n==<span id=\"test-vectors\"></span>Test vectors==\n\nA successful exchange with:\n\n{| class=\"wikitable\"\n!InputScriptType\n!Original PSBT Fee rate\n!maxadditionalfeecontribution\n!additionalfeeoutputindex\n|-\n|P2SH-P2WPKH\n|2 sat/vbyte\n|0.00000182\n|0\n|}\n\n<code>Unfinalized signed PSBT</code>\n<pre>cHNidP8BAHMCAAAAAY8nutGgJdyYGXWiBEb45Hoe9lWGbkxh/6bNiOJdCDuDAAAAAAD+////AtyVuAUAAAAAF6kUHehJ8GnSdBUOOv6ujXLrWmsJRDCHgIQeAAAAAAAXqRR3QJbbz0hnQ8IvQ0fptGn+votneofTAAAAAAEBIKgb1wUAAAAAF6kU3k4ekGHKWRNbA1rV5tR5kEVDVNCHAQQWABTHikVyU1WCjVZYB03VJg1fy2mFMCICAxWawBqg1YdUxLTYt9NJ7R7fzws2K09rVRBnI6KFj4UWRzBEAiB8Q+A6dep+Rz92vhy26lT0AjZn4PRLi8Bf9qoB/CMk0wIgP/Rj2PWZ3gEjUkTlhDRNAQ0gXwTO7t9n+V14pZ6oljUBIgYDFZrAGqDVh1TEtNi300ntHt/PCzYrT2tVEGcjooWPhRYYSFzWUDEAAIABAACAAAAAgAEAAAAAAAAAAAEAFgAURvYaK7pzgo7lhbSl/DeUan2MxRQiAgLKC8FYHmmul/HrXLUcMDCjfuRg/dhEkG8CO26cEC6vfBhIXNZQMQAAgAEAAIAAAACAAQAAAAEAAAAAAA==</pre>\n\n<code>Original PSBT</code>\n<pre>cHNidP8BAHMCAAAAAY8nutGgJdyYGXWiBEb45Hoe9lWGbkxh/6bNiOJdCDuDAAAAAAD+////AtyVuAUAAAAAF6kUHehJ8GnSdBUOOv6ujXLrWmsJRDCHgIQeAAAAAAAXqRR3QJbbz0hnQ8IvQ0fptGn+votneofTAAAAAAEBIKgb1wUAAAAAF6kU3k4ekGHKWRNbA1rV5tR5kEVDVNCHAQcXFgAUx4pFclNVgo1WWAdN1SYNX8tphTABCGsCRzBEAiB8Q+A6dep+Rz92vhy26lT0AjZn4PRLi8Bf9qoB/CMk0wIgP/Rj2PWZ3gEjUkTlhDRNAQ0gXwTO7t9n+V14pZ6oljUBIQMVmsAaoNWHVMS02LfTSe0e388LNitPa1UQZyOihY+FFgABABYAFEb2Giu6c4KO5YW0pfw3lGp9jMUUAAA=</pre>\n\n<code>payjoin proposal</code>\n<pre>cHNidP8BAJwCAAAAAo8nutGgJdyYGXWiBEb45Hoe9lWGbkxh/6bNiOJdCDuDAAAAAAD+////jye60aAl3JgZdaIERvjkeh72VYZuTGH/ps2I4l0IO4MBAAAAAP7///8CJpW4BQAAAAAXqRQd6EnwadJ0FQ46/q6NcutaawlEMIcACT0AAAAAABepFHdAltvPSGdDwi9DR+m0af6+i2d6h9MAAAAAAQEgqBvXBQAAAAAXqRTeTh6QYcpZE1sDWtXm1HmQRUNU0IcAAQEggIQeAAAAAAAXqRTI8sv5ymFHLIjkZNRrNXSEXZHY1YcBBxcWABRfgGZV5ZJMkgTC1RvlOU9L+e2iEAEIawJHMEQCIGe7e0DfJaVPRYEKWxddL2Pr0G37BoKz0lyNa02O2/tWAiB7ZVgBoF4s8MHocYWWmo4Q1cyV2wl7MX0azlqa8NBENAEhAmXWPPW0G3yE3HajBOb7gO7iKzHSmZ0o0w0iONowcV+tAAAA</pre>\n\n<code>payjoin proposal filled with sender's information</code>\n<pre>cHNidP8BAJwCAAAAAo8nutGgJdyYGXWiBEb45Hoe9lWGbkxh/6bNiOJdCDuDAAAAAAD+////jye60aAl3JgZdaIERvjkeh72VYZuTGH/ps2I4l0IO4MBAAAAAP7///8CJpW4BQAAAAAXqRQd6EnwadJ0FQ46/q6NcutaawlEMIcACT0AAAAAABepFHdAltvPSGdDwi9DR+m0af6+i2d6h9MAAAAAAQEgqBvXBQAAAAAXqRTeTh6QYcpZE1sDWtXm1HmQRUNU0IcBBBYAFMeKRXJTVYKNVlgHTdUmDV/LaYUwIgYDFZrAGqDVh1TEtNi300ntHt/PCzYrT2tVEGcjooWPhRYYSFzWUDEAAIABAACAAAAAgAEAAAAAAAAAAAEBIICEHgAAAAAAF6kUyPLL+cphRyyI5GTUazV0hF2R2NWHAQcXFgAUX4BmVeWSTJIEwtUb5TlPS/ntohABCGsCRzBEAiBnu3tA3yWlT0WBClsXXS9j69Bt+waCs9JcjWtNjtv7VgIge2VYAaBeLPDB6HGFlpqOENXMldsJezF9Gs5amvDQRDQBIQJl1jz1tBt8hNx2owTm+4Du4isx0pmdKNMNIjjaMHFfrQABABYAFEb2Giu6c4KO5YW0pfw3lGp9jMUUIgICygvBWB5prpfx61y1HDAwo37kYP3YRJBvAjtunBAur3wYSFzWUDEAAIABAACAAAAAgAEAAAABAAAAAAA=</pre>\n\n==Implementations==\n\n* [[https://github.com/BlueWallet/BlueWallet|BlueWallet]] is in the process of implementing the protocol.\n* [[https://github.com/btcpayserver/btcpayserver|BTCPay Server]] has implemented sender and receiver side of this protocol.\n* [[https://github.com/zkSNACKs/WalletWasabi/|Wasabi Wallet]] has merged sender's support.\n* [[https://github.com/JoinMarket-Org/joinmarket-clientserver|Join Market]] has implemented sender and receiver side of this protocol.\n* [[https://github.com/bitcoinjs/payjoin-client|JavaScript sender implementation]].\n\n==Backward compatibility==\n\nThe receivers advertise payjoin capabilities through [[bip-0021.mediawiki|BIP21's URI Scheme]].\n\nSenders not supporting payjoin will just ignore the <code>pj</code> variable and thus, will proceed to normal payment.\n\n==Special thanks==\n\nSpecial thanks to Kukks for developing the initial support to BTCPay Server, to junderw, AdamISZ, lukechilds, ncoelho, nopara73, lontivero, yahiheb, SomberNight, andrewkozlik, instagibbs, RHavar for all the feedback we received since our first implementation.\nThanks again to RHavar who wrote the [[bip-0079.mediawiki|BIP79 Bustapay]] proposal, this gave a good starting point for our proposal.\n", "content_length": 40342}
{"bip_number": 75, "filename": "bip-0075.mediawiki", "content": "<pre>\n  BIP: 75\n  Layer: Applications\n  Title: Out of Band Address Exchange using Payment Protocol Encryption\n  Author: Justin Newton <justin@netki.com>\n          Matt David <mgd@mgddev.com>\n          Aaron Voisine <voisine@gmail.com>\n          James MacWhyte <macwhyte@gmail.com>\n  Comments-Summary: Recommended for implementation (one person)\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0075\n  Status: Final\n  Type: Standards Track\n  Created: 2015-11-20\n  License: CC-BY-4.0\n</pre>\n\n==Abstract==\n\nThis BIP is an extension to BIP 70 that provides two enhancements to the existing Payment Protocol.\n\n# It allows the requester (Sender) of a PaymentRequest to voluntarily sign the original request and provide a certificate to allow the payee to know the identity of who they are transacting with.\n\n# It encrypts the PaymentRequest that is returned, before handing it off to the SSL/TLS layer to prevent man in the middle viewing of the Payment Request details.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\n\"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n==Copyright==\n\n<img src=\"https://licensebuttons.net/l/by/4.0/88x31.png\">\n\nThis work is licensed under a [[http://creativecommons.org/licenses/by/4.0/|Creative Commons Attribution 4.0 International License]].\n\n==Definitions==\n{| class=\"wikitable\"\n| Sender    || Entity wishing to transfer value that they control\n|-\n| Receiver  || Entity receiving a value transfer\n|}\n\n==Motivation==\n\nThe motivation for defining this extension to the [[bip-0070.mediawiki|BIP70]] Payment Protocol is to allow two parties to exchange payment information in a permissioned and encrypted way, such that wallet address communication can become a more automated process. This extension also expands the types of PKI (public-key infrastructure) data that is supported, and allows it to be shared by both parties (with [[bip-0070.mediawiki|BIP70]], only the receiver could provide PKI information). This allows for automated creation of off-blockchain transaction logs that are human readable, now including information about the sender and not just the recipient.\n\nThe motivation for this extension to [[bip-0070.mediawiki|BIP70]] is threefold:\n\n# Ensure that the payment details can only be seen by the participants in the transaction, and not by any third party.\n\n# Enhance the Payment Protocol to allow for store and forward servers in order to allow, for example, mobile wallets to sign and serve Payment Requests.\n\n# Allow a sender of funds the option of sharing their identity with the receiver. This information could then be used to:\n\n#* Make Bitcoin logs (wallet transaction history) more human readable\n#* Give the user the ability to decide whether or not they share their Bitcoin address and other payment details when requested\n#* Allow for an open standards based way for businesses to keep verifiable records of their financial transactions, to better meet the needs of accounting practices or other reporting and statutory requirements\n#* Automate the active exchange of payment addresses, so static addresses and BIP32 X-Pubs can be avoided to maintain privacy and convenience\n\nIn short we wanted to make Bitcoin more human, while at the same time improving transaction privacy.\n\n==Example Use Cases==\n\n1. Address Book\n\nA Bitcoin wallet developer would like to offer the ability to store an \"address book\" of payees, so users could send multiple payments to known entities without having to request an address every time. Static addresses compromise privacy, and address reuse is considered a security risk. BIP32 X-Pubs allow the generation of unique addresses, but watching an X-Pub chain for each person you wish to receive funds from is too resource-intensive for mobile applications, and there is always a risk of unknowingly sending funds to an X-Pub address after the owner has lost access to the corresponding private key.\n\nWith this BIP, Bitcoin wallets could maintain an \"address book\" that only needs to store each payee's public key. Adding an entry to one's address book could be done by using a Wallet Name, scanning a QR code, sending a URI through a text message or e-mail, or searching a public repository. When the user wishes to make a payment, their wallet would do all the work in the background to communicate with the payee's wallet to receive a unique payment address. If the payee's wallet has been lost, replaced, or destroyed, no communication will be possible, and the sending of funds to a \"dead\" address is prevented.\n\n2. Individual Permissioned Address Release\n\nA Bitcoin wallet developer would like to allow users to view a potential sending party's identifying information before deciding whether or not to share payment information with them. Currently, [[bip-0070.mediawiki|BIP70]] shares the receiver\u2019s payment address and identity information with anyone who requests it.\n\nWith this BIP, Bitcoin wallets could use the sender\u2019s identifying information to make a determination of whether or not to share their own information. This gives the receiving party more control over who receives their payment and identity information. Additionally, this could be used to automatically provide new payment addresses to whitelisted senders, or to protect users\u2019 privacy from unsolicited payment requests.\n\n3. Using Store & Forward Servers\n\nA Bitcoin wallet developer would like to use a public Store & Forward service for an asynchronous address exchange. This is a common case for mobile and offline wallets.\n\nWith this BIP, returned payment information is encrypted with an ECDH-computed shared key before sending to a Store & Forward service. In this case, a successful attack against a Store & Forward service would not be able to read or modify wallet address or payment information, only delete encrypted messages.\n\n==Modifying BIP70 pki_type==\nThis BIP adds additional possible values for the pki_type variable in the PaymentRequest message. The complete list is now as follows:\n\n{| class=\"wikitable\"\n! pki_type !! Description\n|-\n| x509+sha256           || A x.509 certificate, as described in BIP70\n|-\n| pgp+sha256            || An [[https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP|OpenPGP]] certificate\n|-\n| ecdsa+sha256          || A [[https://en.bitcoin.it/wiki/Secp256k1|secp256k1]] [[https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm|ECDSA]] public key\n|}\n\n'''NOTE''': Although SHA1 was supported in BIP70, it has been deprecated and BIP75 only supports SHA256. The hashing algorithm is still specified in the values listed above for forward and backwards compatibility.\n\n==New Messages==\nUpdated [/bip-0075/paymentrequest.proto paymentrequest.proto] contains the existing PaymentRequest Protocol Buffer messages as well as the messages newly defined in this BIP.\n\n'''NOTE''': Public keys from both parties must be known to each other in order to facilitate encrypted communication. Although including both public keys in every message may get redundant, it provides the most flexibility as each message is completely self-contained.\n\n===InvoiceRequest===\nThe '''InvoiceRequest''' message allows a Sender to send information to the Receiver such that the Receiver can create and return a PaymentRequest.\n\n<pre>\nmessage InvoiceRequest {\n        required bytes  sender_public_key = 1;\n        optional uint64 amount = 2 [default = 0];\n        optional string pki_type = 3 [default = \"none\"];\n        optional bytes  pki_data = 4;\n        optional string memo = 5;\n        optional string notification_url = 6;\n        optional bytes  signature = 7;\n}\n</pre>\n\n{| class=\"wikitable\"\n! Field Name !! Description\n|-\n| sender_public_key     || Sender's SEC-encoded EC public key\n|-\n| amount                || amount is integer-number-of-satoshis (default: 0)\n|-\n| pki_type              || none / x509+sha256 / pgp+sha256 / ecdsa+sha256 (default: \"none\")\n|-\n| pki_data              || Depends on pki_type\n|-\n| memo                  || Human-readable description of invoice request for the receiver\n|-\n| notification_url      || Secure (usually TLS-protected HTTP) location where an [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] SHOULD be sent when ready\n|-\n| signature             || PKI-dependent signature\n|}\n\n===ProtocolMessageType Enum===\nThis enum is used in the newly defined [[#ProtocolMessage|ProtocolMessage]] and [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] messages to define the serialized message type. The '''ProtocolMessageType''' enum is defined in an extensible way to allow for new message type additions to the Payment Protocol.\n<pre>\nenum ProtocolMessageType {\n    UNKNOWN_MESSAGE_TYPE = 0;\n    INVOICE_REQUEST = 1;\n    PAYMENT_REQUEST = 2;\n    PAYMENT = 3;\n    PAYMENT_ACK = 4;\n}\n</pre>\n\n===ProtocolMessage===\nThe '''ProtocolMessage''' message is an encapsulating wrapper for any Payment Protocol message. It allows two-way, non-encrypted communication of Payment Protocol messages. The message also includes a status code and a status message that is used for error communication such that the protocol does not rely on transport-layer error handling.\n<pre>\nmessage ProtocolMessage {\n    required uint64 version = 1\n    required uint64 status_code = 2;\n    required ProtocolMessageType message_type = 3;\n    required bytes serialized_message = 4;\n    optional string status_message = 5;\n    required bytes identifier = 6;\n}\n</pre>\n\n{| class=\"wikitable\"\n! Field Name !! Description\n|-\n|version                    || Protocol version number (Currently 1)\n|-\n|status_code                || Payment Protocol Status Code\n|-\n|message_type               || Message Type of serialized_message\n|-\n|serialized_message         || Serialized Payment Protocol Message\n|-\n|status_message             || Human-readable Payment Protocol status message\n|-\n|identifier                 || Unique key to identify this entire exchange on the server. Default value SHOULD be SHA256(Serialized Initial InvoiceRequest + Current Epoch Time in Seconds as a String)\n|}\n\n===Versioning===\nThis BIP introduces version 1 of this protocol. All messages sent using these base requirements MUST use a value of 1 for the version number. Any future BIPs that modify this protocol (encryption schemes, etc) MUST each increment the version number by 1.\n\nWhen initiating communication, the version field of the first message SHOULD be set to the highest version number the sender understands. All clients MUST be able to understand all version numbers less than the highest number they support. If a client receives a message with a version number higher than they understand, they MUST send the message back to the sender with a status code of 101 (\"version too high\") and the version field set to the highest version number the recipient understands. The sender must then resend the original message using the same version number returned by the recipient or abort.\n\n===EncryptedProtocolMessage===\nThe '''EncryptedProtocolMessage''' message is an encapsulating wrapper for any Payment Protocol message. It allows two-way, authenticated and encrypted communication of Payment Protocol messages in order to keep their contents secret. The message also includes a status code and status message that is used for error communication such that the protocol does not rely on transport-layer error handling.\n<pre>\nmessage EncryptedProtocolMessage {\n    required uint64 version = 1 [default = 1];\n    required uint64 status_code = 2 [default = 1];\n    required ProtocolMessageType message_type = 3;\n    required bytes encrypted_message = 4;\n    required bytes receiver_public_key = 5;\n    required bytes sender_public_key = 6;\n    required uint64 nonce = 7;\n    required bytes identifier = 8;\n    optional string status_message = 9;\n    optional bytes signature = 10;\n}\n</pre>\n{| class=\"wikitable\"\n! Field Name   !!  Description\n|-\n| version               || Protocol version number\n|-\n| status_code           || Payment Protocol Status Code\n|-\n| message_type          || Message Type of Decrypted encrypted_message\n|-\n| encrypted_message     || AES-256-GCM Encrypted (as defined in BIP75) Payment Protocol Message\n|-\n| receiver_public_key   || Receiver's SEC-encoded EC Public Key\n|-\n| sender_public_key     || Sender's SEC-encoded EC Public Key\n|-\n| nonce                 || Microseconds since epoch\n|-\n| identifier            || Unique key to identify this entire exchange on the server. Default value SHOULD be SHA256(Serialized Initial InvoiceRequest + Current Epoch Time in Seconds as a String)\n|-\n| status_message        || Human-readable Payment Protocol status message\n|-\n| signature             || DER-encoded Signature over the full EncryptedProtocolMessage with EC Key Belonging to Sender / Receiver, respectively\n|}\n\n==Payment Protocol Process with InvoiceRequests==\nThe full process overview for using '''InvoiceRequests''' in the Payment Protocol is defined below.\n<br/><br/>\nAll Payment Protocol messages MUST be encapsulated in either a [[#ProtocolMessage|ProtocolMessage]] or [[#EncryptedProtocolMessage|EncryptedProtocolMessage]]. Once the process begins using [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] messages, all subsequent communications MUST use [[#EncryptedProtocolMessage|EncryptedProtocolMessages]].\n<br/><br/>\nAll Payment Protocol messages SHOULD be communicated using [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] encapsulating messages with the exception that an [[#InvoiceRequest|InvoiceRequest]] MAY be communicated using the [[#ProtocolMessage|ProtocolMessage]] if the receiver's public key is unknown.\n<br/><br/>\n\nThe process of creating encrypted Payment Protocol messages is enumerated in [[#Sending_Encrypted_Payment_Protocol_Messages_using_EncryptedProtocolMessages|Sending Encrypted Payment Protocol Messages using EncryptedProtocolMessages]], and the process of decrypting encrypted messages can be found under [[#Validating_and_Decrypting_Payment_Protocol_Messages_using_EncryptedProtocolMessages|Validating and Decrypting Payment Protocol Messages using EncryptedProtocolMessages]].\n\nA standard exchange from start to finish would look like the following:\n\n# Sender creates InvoiceRequest\n# Sender encapsulates InvoiceRequest in (Encrypted)ProtocolMessage\n# Sender sends (Encrypted)ProtocolMessage to Receiver\n# Receiver retrieves InvoiceRequest in (Encrypted)ProtocolMessage from Sender\n# Receiver creates PaymentRequest\n# Receiver encapsulates PaymentRequest in EncryptedProtocolMessage\n# Receiver transmits EncryptedProtocolMessage to Sender\n# Sender validates PaymentRequest retrieved from the EncryptedProtocolMessage\n# The PaymentRequest is processed according to [[bip-0070.mediawiki|BIP70]], including optional Payment and PaymentACK messages encapsulated in EncryptedProtocolMessage messages.\n\n'''NOTE:''' See [[#Initial_Public_Key_Retrieval_for_InvoiceRequest_Encryption|Initial Public Key Retrieval for InvoiceRequest Encryption]] for possible options to retrieve Receiver's public key.\n\n<img src=\"bip-0075/encrypted-invoice-request-process.png\" alt=\"Flow diagram of Encrypted InvoiceRequest\">\n\n==Message Interaction Details==\n\n===HTTP Content Types for New Message Types===\nWhen communicated via '''HTTP''', the listed messages MUST be transmitted via TLS-protected HTTP using the appropriate Content-Type header as defined here per message:\n<br/>\n{| class=\"wikitable\"\n! Message Type !! Content Type\n|-\n| ProtocolMessage                   || application/bitcoin-paymentprotocol-message\n|-\n| EncryptedProtocolMessage          || application/bitcoin-encrypted-paymentprotocol-message\n|}\n\n===Payment Protocol Status Communication===\n\nEvery [[#ProtocolMessage|ProtocolMessage]] or [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] MUST include a status code which conveys information about the last message received, if any (for the first message sent, use a status of 1 \"OK\" even though there was no previous message). In the case of an error that causes the Payment Protocol process to be stopped or requires that message be retried, a ProtocolMessage or EncryptedProtocolMessage SHOULD be returned by the party generating the error. The content of the message MUST contain the same '''serialized_message''' or '''encrypted_message''' and identifier (if present) and MUST have the status_code set appropriately.\n<br/><br/>\nThe status_message value SHOULD be set with a human readable explanation of the status code.\n\n====Payment Protocol Status Codes====\n{| class=\"wikitable\"\n! Status Code !! Description\n|-\n| 1     || OK\n|-\n| 2     || Cancel\n|-\n| 100   || General / Unknown Error\n|-\n| 101   || Version Too High\n|-\n| 102   || Authentication Failed\n|-\n| 103   || Encrypted Message Required\n|-\n| 200   || Amount Too High\n|-\n| 201   || Amount Too Low\n|-\n| 202   || Amount Invalid\n|-\n| 203   || Payment Does Not Meet PaymentRequest Requirements\n|-\n| 300   || Certificate Required\n|-\n| 301   || Certificate Expired\n|-\n| 302   || Certificate Invalid for Transaction\n|-\n| 303   || Certificate Revoked\n|-\n| 304   || Certificate Not Well Rooted\n|-\n|}\n\n+==Canceling A Message==+\nIf a participant to a transaction would like to inform the other party that a previous message should be canceled, they can send the same message with a status code of 2 (\"Cancel\") and, where applicable, an updated nonce. How recipients make use of the \"Cancel\" message is up to developers. For example, wallet developers may want to offer users the ability to cancel payment requests they have sent to other users, and have that change reflected in the recipient's UI. Developers using the non-encrypted ProtocolMessage may want to ignore \"Cancel\" messages, as it may be difficult to authenticate that the message originated from the same user.\n\n===Transport Layer Communication Errors===\nCommunication errors MUST be communicated to the party that initiated the communication via the communication layer's existing error messaging facilities. In the case of TLS-protected HTTP, this SHOULD be done through standard HTTP Status Code messaging ([https://tools.ietf.org/html/rfc7231 RFC 7231 Section 6]).\n\n==Extended Payment Protocol Process Details==\nThis BIP extends the Payment Protocol as defined in [[bip-0070.mediawiki|BIP70]].\n\nFor the following we assume the Sender already knows the Receiver's public key, and the exchange is being facilitated by a Store & Forward server which requires valid signatures for authentication.\n\n'''nonce''' MUST be set to a non-repeating number '''and''' MUST be chosen by the encryptor. The current epoch time in microseconds SHOULD be used, unless the creating device doesn't have access to a RTC (in the case of a smart card, for example). The service receiving the message containing the '''nonce''' MAY use whatever method to make sure that the '''nonce''' is never repeated.\n\n===InvoiceRequest Message Creation===\n* Create an [[#InvoiceRequest|InvoiceRequest]] message\n* '''sender_public_key''' MUST be set to the public key of an EC keypair\n* '''amount''' is optional. If the amount is not specified by the [[#InvoiceRequest|InvoiceRequest]], the Receiver MAY specify the amount in the returned PaymentRequest. If an amount is specified by the [[#InvoiceRequest|InvoiceRequest]] and a PaymentRequest cannot be generated for that amount, the [[#InvoiceRequest|InvoiceRequest]] SHOULD return the same [[#InvoiceRequest|InvoiceRequest]] in a [[#ProtocolMessage|ProtocolMessage]] or [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] with the status_code and status_message fields set appropriately.\n* '''memo''' is optional. This MAY be set to a human readable description of the InvoiceRequest\n* Set '''notification_url''' to URL that the Receiver will submit completed PaymentRequest (encapsulated in an [[#EncryptedProtocolMessage|EncryptedProtocolMessage]]) to\n* If NOT including certificate, set '''pki_type''' to \"none\"\n* If including certificate:\n** Set '''pki_type''' to \"x509+sha256\"\n** Set '''pki_data''' as it would be set in BIP-0070 ([https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki#Certificates Certificates])\n** Sign [[#InvoiceRequest|InvoiceRequest]] with signature = \"\" using the X509 Certificate's private key\n** Set '''signature''' value to the computed signature\n\n===InvoiceRequest Validation===\n* Validate '''sender_public_key''' is a valid EC public key\n* Validate '''notification_url''', if set, contains characters deemed valid for a URL (avoiding XSS related characters, etc).\n* If '''pki_type''' is None, [[#InvoiceRequest|InvoiceRequest]] is VALID\n* If '''pki_type''' is x509+sha256 and '''signature''' is valid for the serialized [[#InvoiceRequest|InvoiceRequest]] where signature is set to \"\", [[#InvoiceRequest|InvoiceRequest]] is VALID\n\n===Sending Encrypted Payment Protocol Messages using EncryptedProtocolMessages===\n* Encrypt the serialized Payment Protocol message using AES-256-GCM setup as described in [[#ECDH_Point_Generation_and_AES256_GCM_Mode_Setup|ECDH Point Generation and AES-256 (GCM Mode) Setup]]\n* Create [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] message\n* Set '''encrypted_message''' to be the encrypted value of the Payment Protocol message\n* '''version''' SHOULD be set to the highest version number the client understands (currently 1)\n* '''sender_public_key''' MUST be set to the public key of the Sender's EC keypair\n* '''receiver_public_key''' MUST be set to the public key of the Receiver's EC keypair\n* '''nonce''' MUST be set to the nonce used in the AES-256-GCM encryption operation\n* Set '''identifier''' to the identifier value received in the originating InvoiceRequest's ProtocolMessage or EncryptedProtocolMessage wrapper message\n* Set '''signature''' to \"\"\n* Sign the serialized [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] message with the communicating party's EC public key\n* Set '''signature''' to the result of the signature operation above\n\n'''SIGNATURE NOTE:''' [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] messages are signed with the public keys of the party transmitting the message. This allows a Store & Forward server or other transmission system to prevent spam or other abuses. For those who are privacy conscious and don't want the server to track the interactions between two public keys, the Sender can generate a new public key for each interaction to keep their identity anonymous.\n\n===Validating and Decrypting Payment Protocol Messages using EncryptedProtocolMessages===\n* The '''nonce''' MUST not be repeated. The service receiving the [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] MAY use whatever method to make sure that the nonce is never repeated.\n* Decrypt the serialized Payment Protocol message using AES-256-GCM setup as described in [[#ECDH_Point_Generation_and_AES256_GCM_Mode_Setup|ECDH Point Generation and AES-256 (GCM Mode) Setup]]\n* Deserialize the serialized Payment Protocol message\n\n===ECDH Point Generation and AES-256 (GCM Mode) Setup===\n'''NOTE''': AES-256-GCM is used because it provides authenticated encryption facilities, thus negating the need for a separate message hash for authentication.\n\n* Generate the '''secret point''' using [https://en.wikipedia.org/wiki/Elliptic_curve_Diffie\u2013Hellman ECDH] using the local entity's private key and the remote entity's public key as inputs\n* Initialize [http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf HMAC_DRBG]\n** Use '''SHA512(secret point's X value in Big-Endian bytes)''' for Entropy\n** Use the given message's '''nonce''' field for Nonce, converted to byte string (Big Endian)\n\n* Initialize AES-256 in GCM Mode\n** Initialize HMAC_DRBG with Security Strength of 256 bits\n** Use HMAC_DRBG.GENERATE(32) as the Encryption Key (256 bits)\n** Use HMAC_DRBG.GENERATE(12) as the Initialization Vector (IV) (96 bits)\n\n====AES-256 GCM Authentication Tag Use====\nThe 16 byte authentication tag resulting from the AES-GCM encrypt operation MUST be prefixed to the returned ciphertext. The decrypt operation will use the first 16 bytes of the ciphertext as the GCM authentication tag and the remainder of the ciphertext as the ciphertext in the decrypt operation.\n\n====AES-256 GCM Additional Authenticated Data====\nWhen either '''status_code''' OR '''status_message''' are present, the AES-256 GCM authenticated data used in both the encrypt and decrypt operations MUST be: STRING(status_code) || status_message. Otherwise, there is no additional authenticated data. This provides that, while not encrypted, the status_code and status_message are authenticated.\n\n===Initial Public Key Retrieval for InvoiceRequest Encryption===\nInitial public key retrieval for [[#InvoiceRequest|InvoiceRequest]] encryption via [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] encapsulation can be done in a number of ways including, but not limited to, the following:\n# Wallet Name public key asset type resolution - DNSSEC-validated name resolution returns Base64 encoded DER-formatted EC public key via TXT Record [https://www.ietf.org/rfc/rfc5480.txt RFC 5480]\n# Key Server lookup - Key Server lookup (similar to PGP's pgp.mit.edu) based on key server identifier (i.e., e-mail address) returns Base64 encoded DER-formatted EC public key [https://www.ietf.org/rfc/rfc5480.txt RFC 5480]\n# QR Code - Use of QR-code to encode SEC-formatted EC public key [https://www.ietf.org/rfc/rfc5480.txt RFC 5480]\n# Address Service Public Key Exposure\n\n==Payment / PaymentACK Messages with a HTTP Store & Forward Server==\nIf a Store & Forward server wishes to protect themselves from spam or abuse, they MAY enact whatever rules they deem fit, such as the following:\n\n* Once an InvoiceRequest or PaymentRequest is received, all subsequent messages using the same identifier must use the same Sender and Receiver public keys.\n* For each unique identifier, only one message each of type InvoiceRequest, PaymentRequest, and PaymentACK may be submitted. Payment messages may be submitted/overwritten multiple times. All messages submitted after a PaymentACK is received will be rejected.\n* Specific messages are only saved until they have been verifiably received by the intended recipient or a certain amount of time has passed, whichever comes first.\n\n<br/><br/>\nClients SHOULD keep in mind Receivers can broadcast a transaction without returning an ACK. If a Payment message needs to be updated, it SHOULD include at least one input referenced in the original transaction to prevent the Receiver from broadcasting both transactions and getting paid twice.\n\n==Public Key & Signature Encoding==\n* All x.509 certificates included in any message defined in this BIP MUST be DER [ITU.X690.1994] encoded.\n* All EC public keys ('''sender_public_key''', '''receiver_public_key''') in any message defined in this BIP MUST be [[SECP256k1|http://www.secg.org/sec2-v2.pdf]] ECDSA Public Key ECPoints encoded using [[SEC 2.3.3 Encoding|http://www.secg.org/sec1-v2.pdf]]. Encoding MAY be compressed.\n* All ECC signatures included in any message defined in this BIP MUST use the SHA-256 hashing algorithm and MUST be DER [ITU.X690.1994] encoded.\n* All OpenPGP certificates must follow [[https://tools.ietf.org/html/rfc4880|RFC4880]], sections 5.5 and 12.1.\n\n==Implementation==\nA reference implementation for a Store & Forward server supporting this proposal can be found here:\n\n[https://github.com/netkicorp/addressimo Addressimo]\n\nA reference client implementation can be found in the InvoiceRequest functional testing for Addressimo here:\n\n[https://github.com/netkicorp/addressimo/blob/master/functest/functest_bip75.py BIP75 Client Reference Implementation]\n\n==BIP70 Extension==\nThe following flowchart is borrowed from [[bip-0070.mediawiki|BIP70]] and expanded upon in order to visually describe how this BIP is an extension to [[bip-0070.mediawiki|BIP70]].\n\n<img src=\"bip-0075/bip70-extension.png\" alt=\"Flowchart explaining how this BIP extends BIP 70\">\n\n==Mobile to Mobile Examples==\n\n===Full Payment Protocol===\nThe following diagram shows a sample flow in which one mobile client is sending value to a second mobile client with the use of an InvoiceRequest, a Store & Forward server, PaymentRequest, Payment and PaymentACK. In this case, the PaymentRequest, Payment and PaymentACK messages are encrypted using [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] '''and''' the Receiver submits the transaction to the Bitcoin network.\n\n<img src=\"bip-0075/mobile-sf-ir-with-payment.png\" alt=\"Payment Required flow diagram\">\n\n===Encrypting Initial InvoiceRequest via EncryptedProtocolMessage===\nThe following diagram shows a sample flow in which one mobile client is sending value to a second mobile client using an [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] to transmit the InvoiceRequest using encryption, Store & Forward server, and PaymentRequest. In this case, all Payment Protocol messages are encrypting using [[#EncryptedProtocolMessage|EncryptedProtocolMessage]] '''and''' the Sender submits the transaction to the Bitcoin network.\n\n<img src=\"bip-0075/mobile-sf-encrypted-ir-without-payment.png\" alt=\"Encrypted InvoiceRequest without payment\">\n\n==References==\n\n* [[bip-0070.mediawiki|BIP70 - Payment Protocol]]\n* [https://en.wikipedia.org/wiki/Elliptic_curve_Diffie\u2013Hellman ECDH]\n* [http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf HMAC_DRBG]\n* [http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf NIST Special Publication 800-38D - Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC]\n* [https://tools.ietf.org/html/rfc6979 RFC6979]\n* [https://en.bitcoin.it/wiki/Address_reuse Address Reuse]\n* [http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf FIPS 180-4 (Secure Hash Standard)]\n", "content_length": 29799}
{"bip_number": 74, "filename": "bip-0074.mediawiki", "content": "<pre>\n  BIP: 74\n  Layer: Applications\n  Title: Allow zero value OP_RETURN in Payment Protocol\n  Author: Toby Padilla <tobypadilla@gmail.com>\n  Comments-Summary: Unanimously Discourage for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0074\n  Status: Rejected\n  Type: Standards Track\n  Created: 2016-01-29\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP alters the Payment Protocol to allow for zero value OP_RETURN outputs in serialized PaymentRequests.\n\n==Motivation==\n\nThe Payment Protocol (defined in BIP70) gives merchants a way to build sophisticated transactions by serializing one or more outputs in the form of a PaymentRequest. The PaymentRequest is then served over http/https to a customer's wallet where the serialized transaction can be executed.\n\nWhile the Payment Protocol allows for any valid script in its outputs, it also ignores outputs with zero value. This means BIP70 implementations can encode an OP_RETURN script but must provide a greater than dust value for that output. The end result is a successful PaymentRequest transaction with an OP_RETURN but the value assigned to that output is lost forever.\n\nThis BIP allows for zero value OP_RETURN outputs in serialized PaymentRequests. The change means that OP_RETURN scripts will work as they were originally intended from within PaymentRequests without permanently destroying Bitcoin value. Zero value non-OP_RETURN scripts should continue to be ignored.\n\nIn addition to fixing the issue of destroyed value, this change opens up new use cases that were previously impossible.\n\nWhile storing data on the blockchain is controversial, when used responsibly OP_RETURN provides a powerful mechanism for attaching metadata to a transaction. This BIP effectively decouples the creation of transactions containing OP_RETURN data from the execution of those transactions. The result are positive benefits for both merchants and wallets/customers.\n\nBy supporting this BIP, wallets can participate in current and future, unforeseen use cases that benefit from metadata stored in OP_RETURN. Until now OP_RETURN transactions have typically been created and submitted by custom software. If a wallet can process a PaymentRequest with OP_RETURN data as proposed by this BIP, it will support potentially sophisticated Bitcoin applications without the wallet developer having to have prior knowledge of that application.\n\nAn example might be a merchant that adds the hash of a plain text invoice to the checkout transaction. The merchant could construct the PaymentRequest with the invoice hash in an OP_RETURN and pass it to the customer's wallet. The wallet could then submit the transaction, including the invoice hash from the PaymentRequest. The wallet will have encoded a proof of purchase to the blockchain without the wallet developer having to coordinate with the merchant software or add features beyond this BIP.\n\nMerchants and Bitcoin application developers benefit from this BIP because they can now construct transactions that include OP_RETURN data in a keyless environment. Again, prior to this BIP, transactions that used OP_RETURN (with zero value) needed to be constructed and executed in the same software. By separating the two concerns, this BIP allows merchant software to create transactions with OP_RETURN metadata on a server without storing public or private Bitcoin keys. This greatly enhances security where OP_RETURN applications currently need access to a private key to sign transactions.\n\n==Specification==\n\nThe specification for this BIP is straightforward. BIP70 should be fully implemented with the following changes:\n\n* Outputs where the script is an OP_RETURN and the value is zero should be accepted by the wallet.\n\nBIP70 has special handling for the case with multiple zero value outputs:\n\n<blockquote>\nIf the sum of outputs.amount is zero, the customer will be asked how much to pay, and the bitcoin client may choose any or all of the Outputs (if there are more than one) for payment. If the sum of outputs.amount is non-zero, then the customer will be asked to pay the sum, and the payment shall be split among the Outputs with non-zero amounts (if there are more than one; Outputs with zero amounts shall be ignored).\n</blockquote>\n\nThis behavior should be retained with the exception of OP_RETURN handling. In the case of a multiple output transaction where the sum of the output values is zero, the user should be prompted for a value and that value should be distributed over any or all outputs ''except'' the OP_RETURN output. In the case where the sum of outputs.amount is non-zero then any OP_RETURN outputs should not be ignored but no value should be assigned to them.\n\nPayment requests also must contain at least one payable output (i.e. no payment requests with ''just'' an OP_RETURN).\n\n==Rationale==\n\nAs with the discussion around vanilla OP_RETURN, the practice of storing data on the blockchain is controversial. While blockchain and network bloat is an undeniable issue, the benefits that come from attaching metadata to transactions has proven to be too powerful to dismiss entirely. In the absence of OP_RETURN support the Bitcoin ecosystem has seen alternative, less elegant and more wasteful methods employed for Blockchain data storage.\n\nAs it exists today, BIP70 allows for OP_RETURN data storage at the expense of permanently destroyed Bitcoin. Even fully removing support for OP_RETURN values in the Payment Protocol would still leave the door open to suboptimal data encoding via burning a larger than dust value to an output with a false address designed to encode data.\n\nThis BIP offers all of the same benefits that come from the OP_RETURN compromise. Mainly that OP_RETURN scripts are provably unspendable and thus can be pruned from the UTXO pool. Without supporting this BIP, wallets that support BIP70 will allow for wasteful data storage.\n\n==Compatibility==\n\nSince this BIP still supports OP_RETURN statements with a greater than zero value, it should be fully backwards compatible with any existing implementations.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 6143}
{"bip_number": 73, "filename": "bip-0073.mediawiki", "content": "<pre>\n  BIP: 73\n  Layer: Applications\n  Title: Use \"Accept\" header for response type negotiation with Payment Request URLs\n  Author: Stephen Pair <stephen@bitpay.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0073\n  Status: Final\n  Type: Standards Track\n  Created: 2013-08-27\n</pre>\n\n==Abstract==\n\nThis BIP describes an enhancement to the payment protocol ([[bip-0070.mediawiki|BIP 70]])\nthat addresses the need for short URLs when scanning from QR codes.  It\ngeneralizes the specification for the behavior of a payment request URL in a\nway that allows the client and server to negotiate the content of the\nresponse using the HTTP Accept: header field.  Specifically, the client\ncan indicate to the server whether it prefers to receive a bitcoin URI or\na payment request.\n\nImplementation of this BIP does not require full payment request ([[bip-0070.mediawiki|BIP 70]]) support.\n\n==Motivation==\n\nThe payment protocol augments the bitcoin: uri scheme with an additional\n\"payment\" parameter that specifies a URL where a payment request can be\ndownloaded.  This creates long URIs that, when rendered as a QR code, have\na high information density.  Dense QR codes can be difficult to scan resulting\nin a more frustrating user experience.  The goal is to create a standard that\nwould allow QR scanning wallets to use less dense QR codes.  It also makes\ngeneral purpose QR code scanners more usable with bitcoin accepting\nwebsites.\n\n==Specification==\n\nQR scanning wallets will consider a non bitcoin URI scanned from a QR code to\nbe an end point where either a bitcoin URI or a payment request can be obtained.\n\nA wallet client uses the Accept: HTTP header to specify whether it can accept\na payment request, a URI, or both.  A media type of text/uri-list specifies that\nthe client accepts a bitcoin URI. A media type of application/bitcoin-paymentrequest\nspecifies that the client can process a payment request.  In the absence of an\nAccept: header, the server is expected to respond with text/html suitable for\nrendering in a browser.  An HTML response will ensure that QR codes scanned\nby non Bitcoin wallet QR scanners are useful (they could render an HTML page\nwith a payment link that when clicked would open a wallet on the device).\n\nIt is not required that the client and server support the full semantics of an\nHTTP Accept header.  If application/bitcoin-paymentrequest is specified in the\nheader, the server should send a payment request regardless of anything else\nspecified in the Accept header.  If text/uri-list is specified (but not\napplication/bitcoin-paymentrequest), a valid Bitcoin URI should be returned.  If\nneither is specified, the server can return an HTML page.  When a uri-list is returned\nonly the first item in the list is used (and expected to be a bitcoin URI), any additional\nURIs should be ignored.\n\n==Compatibility==\n\nOnly QR scanning wallets that implement this BIP will be able to process QR\ncodes containing payment request URLs.  There are two possible workarounds for QR\nscanning wallets that do not implement this BIP: 1) the server gives the user an\noption to change the QR code to a bitcoin: URI or 2) the user scans the code with\na generic QR code scanner.\n\nIn the second scenario, if the server responds with a webpage containing a link\nto a bitcoin URI, the user can complete the payment by clicking that link provided\nthe user has a wallet installed on their device and it supports bitcoin URIs.  If the\nwallet/device does not have support for bitcoin URIs, the user can fall back on\naddress copy/paste.\n\nThis BIP should be fully compatible with BIP 70 assuming it is required that wallets\nimplementing BIP 70 make use of the Accept: HTTP header when retrieving a\npayment request.\n\n==Examples==\nThe first image below is of a bitcoin URI with an amount and payment request\nspecified (note, this is a fairly minimal URI as it does not contain a\nlabel and the request URL is of moderate size).  The second image is a QR\ncode with only the payment request url specified.\n\n<img src=bip-0073/a.png></img><img src=bip-0073/b.png></img>\n", "content_length": 4129}
{"bip_number": 72, "filename": "bip-0072.mediawiki", "content": "<pre>\n  BIP: 72\n  Layer: Applications\n  Title: bitcoin: uri extensions for Payment Protocol\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0072\n  Status: Final\n  Type: Standards Track\n  Created: 2013-07-29\n</pre>\n\n==Abstract==\n\nThis BIP describes an extension to the bitcoin: URI scheme (BIP 21) to\nsupport the payment protocol (BIP 70).\n\n==Motivation==\n\nAllow users to click on a link in a web page or email to initiate the\npayment protocol, while being backwards-compatible with existing\nbitcoin wallets.\n\n==Specification==\n\nThe bitcoin: URI scheme is extended with an additional, optional\n\"r\" parameter, whose value is a URL from which a PaymentRequest\nmessage should be fetched (characters not allowed within the scope\nof a query parameter must be percent-encoded as described in RFC 3986\nand bip-0021).\n\nIf the \"r\" parameter is provided and backwards compatibility\nis not required, then the bitcoin address portion of the URI may be\nomitted (the URI will be of the form: bitcoin:?r=... ).\n\nWhen Bitcoin wallet software that supports this BIP receives a\nbitcoin: URI with a request parameter, it should ignore the bitcoin\naddress/amount/label/message in the URI and instead fetch a\nPaymentRequest message and then follow the payment protocol, as\ndescribed in BIP 70.\n\nBitcoin wallets must support fetching PaymentRequests via http and\nhttps protocols; they may support other protocols. Wallets must\ninclude an \"Accept\" HTTP header in HTTP(s) requests (as defined\nin RFC 2616):\n\n<pre>Accept: application/bitcoin-paymentrequest</pre>\n\nIf a PaymentRequest cannot be obtained (perhaps the server is\nunavailable), then the customer should be informed that the merchant's\npayment processing system is unavailable. In the case of an HTTP\nrequest, status codes which are neither success nor error (such as\nredirect) should be handled as outlined in RFC 2616.\n\n==Compatibility==\n\nWallet software that does not support this BIP will simply ignore the\nr parameter and will initiate a payment to bitcoin address.\n\n==Examples==\nA backwards-compatible request:\n<pre>\nbitcoin:mq7se9wy2egettFxPbmn99cK8v5AFq55Lx?amount=0.11&r=https://merchant.com/pay.php?h%3D2a8628fc2fbe\n</pre>\nNon-backwards-compatible equivalent:\n<pre>\nbitcoin:?r=https://merchant.com/pay.php?h%3D2a8628fc2fbe\n</pre>\n\n==References==\n\n[[http://www.w3.org/Protocols/rfc2616/rfc2616.html|RFC 2616]] : Hypertext Transfer Protocol -- HTTP/1.1\n", "content_length": 2502}
{"bip_number": 71, "filename": "bip-0071.mediawiki", "content": "<pre>\n  BIP: 71\n  Layer: Applications\n  Title: Payment Protocol MIME types\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0071\n  Status: Final\n  Type: Standards Track\n  Created: 2013-07-29\n</pre>\n\n==Abstract==\n\nThis BIP defines a MIME (RFC 2046) Media Type for Bitcoin payment\nrequest messages.\n\n==Motivation==\n\nWallet or server software that sends payment protocol messages over\nemail or http should follow Internet standards for properly\nencapsulating the messages.\n\n==Specification==\n\nThe Media Type (Content-Type in HTML/email headers) for bitcoin\nprotocol messages shall be:\n\n{|\n| Message || Type/Subtype\n|-\n| PaymentRequest || application/bitcoin-paymentrequest\n|-\n| Payment || application/bitcoin-payment\n|-\n| PaymentACK || application/bitcoin-paymentack\n|}\n\nPayment protocol messages are encoded in binary.\n\n==Example==\n\nA web server generating a PaymentRequest message to initiate the\npayment protocol would precede the binary message data with the\nfollowing headers:\n<pre>\nContent-Type: application/bitcoin-paymentrequest\nContent-Transfer-Encoding: binary\n</pre>\n", "content_length": 1180}
{"bip_number": 70, "filename": "bip-0070.mediawiki", "content": "<pre>\n  BIP: 70\n  Layer: Applications\n  Title: Payment Protocol\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n          Mike Hearn <mhearn@bitcoinfoundation.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0070\n  Status: Final\n  Type: Standards Track\n  Created: 2013-07-29\n</pre>\n\n==Abstract==\n\nThis BIP describes a protocol for communication between a merchant and their customer, enabling\nboth a better customer experience and better security against man-in-the-middle attacks on\nthe payment process.\n\n==Motivation==\n\nThe current, minimal Bitcoin payment protocol operates as follows:\n\n# Customer adds items to an online shopping basket, and decides to pay using Bitcoin.\n# Merchant generates a unique payment address, associates it with the customer's order, and asks the customer to pay.\n# Customer copies the Bitcoin address from the merchant's web page and pastes it into whatever wallet they are using OR follows a bitcoin: link and their wallet is launched with the amount to be paid.\n# Customer authorizes payment to the merchant's address and broadcasts the transaction through the Bitcoin p2p network.\n# Merchant's server detects payment and after sufficient transaction confirmations considers the transaction final.\n\nThis BIP extends the above protocol to support several new features:\n\n# Human-readable, secure payment destinations-- customers will be asked to authorize payment to \"example.com\" instead of an inscrutable, 34-character bitcoin address.\n# Secure proof of payment, which the customer can use in case of a dispute with the merchant.\n# Resistance from man-in-the-middle attacks that replace a merchant's bitcoin address with an attacker's address before a transaction is authorized with a hardware wallet.\n# Payment received messages, so the customer knows immediately that the merchant has received, and has processed (or is processing) their payment.\n# Refund addresses, automatically given to the merchant by the customer's wallet software, so merchants do not have to contact customers before refunding overpayments or orders that cannot be fulfilled for some reason.\n\n==Protocol==\n\nThis BIP describes payment protocol messages encoded using Google's Protocol\nBuffers, authenticated using X.509 certificates, and communicated over\nhttp/https. Future BIPs might extend this payment protocol to other\nencodings, PKI systems, or transport protocols.\n\nThe payment protocol consists of three messages; PaymentRequest, Payment,\nand PaymentACK, and begins with the customer somehow indicating that\nthey are ready to pay and the merchant's server responding with a\nPaymentRequest message:\n\n<img src=bip-0070/Protocol_Sequence.png></img>\n\n==Messages==\n\nThe Protocol Buffers messages are defined in [[bip-0070/paymentrequest.proto|paymentrequest.proto]].\n\n===Output===\n\nOutputs are used in PaymentRequest messages to specify where a payment (or\npart of a payment) should be sent. They are also used in Payment messages\nto specify where a refund should be sent.\n<pre>\n    message Output {\n\toptional uint64 amount = 1 [default = 0];\n        optional bytes script = 2;\n    }\n</pre>\n{|\n| amount || Number of satoshis (0.00000001 BTC) to be paid\n|-\n| script || a \"TxOut\" script where payment should be sent. This will normally be one of the standard Bitcoin transaction scripts (e.g. pubkey OP_CHECKSIG). This is optional to enable future extensions to this protocol that derive Outputs from a master public key and the PaymentRequest data itself.\n|}\n\n===PaymentDetails/PaymentRequest===\n\nPayment requests are split into two messages to support future extensibility.\nThe bulk of the information is contained in the PaymentDetails message. It is\nwrapped inside a PaymentRequest message, which contains meta-information\nabout the merchant and a digital signature.\n<pre>\n    message PaymentDetails {\n        optional string network = 1 [default = \"main\"];\n        repeated Output outputs = 2;\n        required uint64 time = 3;\n        optional uint64 expires = 4;\n        optional string memo = 5;\n        optional string payment_url = 6;\n        optional bytes merchant_data = 7;\n    }\n</pre>\n{|\n| network || either \"main\" for payments on the production Bitcoin network, or \"test\" for payments on test network. If a client receives a PaymentRequest for a network it does not support it must reject the request.\n|-\n| outputs || one or more outputs where Bitcoins are to be sent. If the sum of outputs.amount is zero, the customer will be asked how much to pay, and the bitcoin client may choose any or all of the Outputs (if there are more than one) for payment. If the sum of outputs.amount is non-zero, then the customer will be asked to pay the sum, and the payment shall be split among the Outputs with non-zero amounts (if there are more than one; Outputs with zero amounts shall be ignored).\n|-\n| time || Unix timestamp (seconds since 1-Jan-1970 UTC) when the PaymentRequest was created.\n|-\n| expires || Unix timestamp (UTC) after which the PaymentRequest should be considered invalid.\n|-\n| memo || UTF-8 encoded, plain-text (no formatting) note that should be displayed to the customer, explaining what this PaymentRequest is for.\n|-\n| payment_url || Secure (usually https) location where a Payment message (see below) may be sent to obtain a PaymentACK.\n|-\n| merchant_data || Arbitrary data that may be used by the merchant to identify the PaymentRequest. May be omitted if the merchant does not need to associate Payments with PaymentRequest or if they associate each PaymentRequest with a separate payment address.\n|}\n\nThe payment_url specified in the PaymentDetails should remain valid at least until the PaymentDetails\nexpires (or as long as possible if the PaymentDetails does not expire). Note that this is irrespective of\nany state change in the underlying payment request; for example cancellation of an order should not\ninvalidate the payment_url, as it is important that the merchant's server can record mis-payments\nin order to refund the payment.\n\nA PaymentRequest is PaymentDetails optionally tied to a merchant's identity:\n<pre>\n    message PaymentRequest {\n        optional uint32 payment_details_version = 1 [default = 1];\n        optional string pki_type = 2 [default = \"none\"];\n        optional bytes pki_data = 3;\n        required bytes serialized_payment_details = 4;\n        optional bytes signature = 5;\n    }\n</pre>\n{|\n| payment_details_version || See below for a discussion of versioning/upgrading.\n|-\n| pki_type  || public-key infrastructure (PKI) system being used to identify the merchant. All implementation should support \"none\", \"x509+sha256\" and \"x509+sha1\".\n|-\n| pki_data || PKI-system data that identifies the merchant and can be used to create a digital signature. In the case of X.509 certificates, pki_data contains one or more X.509 certificates (see Certificates section below).\n|-\n| serialized_payment_details || A protocol-buffer serialized PaymentDetails message.\n|-\n| signature || digital signature over a hash of the protocol buffer serialized variation of the PaymentRequest message,\nwith all serialized fields serialized in numerical order (all current protocol buffer implementations serialize\nfields in numerical order) and signed using the private key that corresponds to the public key in pki_data. Optional fields that are not set\nare not serialized (however, setting a field to its default value will cause it to be serialized and will affect\nthe signature). Before serialization, the signature field must be set to an empty value so that the field is included in the signed PaymentRequest hash but contains no data.\n|}\nWhen a Bitcoin wallet application receives a PaymentRequest, it must authorize payment by doing the following:\n\n# Validate the merchant's identity and signature using the PKI system, if the pki_type is not \"none\".\n# Validate that customer's system unix time (UTC) is before PaymentDetails.expires. If it is not, then the payment request must be rejected.\n# Display the merchant's identity and ask the customer if they would like to submit payment (e.g. display the \"Common Name\" in the first X.509 certificate).\n\nPaymentRequest messages larger than 50,000 bytes should be rejected by\nthe wallet application, to mitigate denial-of-service attacks.\n\n===Payment===\n\nPayment messages are sent after the customer has authorized payment:\n<pre>\n    message Payment {\n        optional bytes merchant_data = 1;\n        repeated bytes transactions = 2;\n        repeated Output refund_to = 3;\n        optional string memo = 4;\n    }\n</pre>\n{|\n| merchant_data || copied from PaymentDetails.merchant_data. Merchants may use invoice numbers or any other data they require to match Payments to  PaymentRequests. Note that malicious clients may modify the merchant_data, so should be authenticated in some way (for example, signed with a merchant-only key).\n|-\n| transactions || One or more valid, signed Bitcoin transactions that fully pay the PaymentRequest\n|-\n| refund_to || One or more outputs where the merchant may return funds, if necessary. The merchant may return funds using these outputs for up to 2 months\nafter the time of the payment request. After that time has expired, parties must negotiate if returning of funds becomes necessary.\n|-\n| memo || UTF-8 encoded, plain-text note from the customer to the merchant.\n|}\nIf the customer authorizes payment, then the Bitcoin client:\n\n# Creates and signs one or more transactions that satisfy (pay in full) PaymentDetails.outputs\n# Validate that customer's system unix time (UTC) is still before PaymentDetails.expires. If it is not, the payment should be cancelled.\n# Broadcast the transactions on the Bitcoin p2p network.\n# If PaymentDetails.payment_url is specified, POST a Payment message to that URL. The Payment message is serialized and sent as the body of the POST request.\n\nErrors communicating with the payment_url server should be communicated to the user.\nIn the scenario where the merchant's server receives multiple identical Payment\nmessages for an individual PaymentRequest, it must acknowledge each. The second\nand further PaymentACK messages sent from the merchant's server may vary by memo\nfield to indicate current state of the Payment (for example number of confirmations\nseen on the network). This is required in order to ensure that in case of a transport\nlevel failure during transmission, recovery is possible by the Bitcoin client\nre-sending the Payment message.\n\nPaymentDetails.payment_url should be secure against man-in-the-middle\nattacks that might alter Payment.refund_to (if using HTTP, it must be\nTLS-protected).\n\nWallet software sending Payment messages via HTTP must set appropriate\nContent-Type and Accept headers, as specified in BIP 71:\n<pre>Content-Type: application/bitcoin-payment\nAccept: application/bitcoin-paymentack\n</pre>\n\nWhen the merchant's server receives the Payment message, it must\ndetermine whether or not the transactions satisfy conditions of\npayment. If and only if they do, it should broadcast the\ntransaction(s) on the Bitcoin p2p network.\n\nPayment messages larger than 50,000 bytes should be rejected by\nthe merchant's server, to mitigate denial-of-service attacks.\n\n===PaymentACK===\n\nPaymentACK is the final message in the payment protocol; it is sent\nfrom the merchant's server to the bitcoin wallet in response to a\nPayment message:\n<pre>\n    message PaymentACK {\n        required Payment payment = 1;\n        optional string memo = 2;\n    }\n</pre>\n{|\n| payment || Copy of the Payment message that triggered this PaymentACK. Clients may ignore this if they implement another way of associating Payments with PaymentACKs.\n|-\n| memo || UTF-8 encoded note that should be displayed to the customer giving the status of the transaction (e.g. \"Payment of 1 BTC for eleven tribbles accepted for processing.\")\n|}\n\nPaymentACK messages larger than 60,000 bytes should be rejected by\nthe wallet application, to mitigate denial-of-service attacks. This\nis larger than the limits on Payment and PaymentRequest messages\nas PaymentACK contains a full Payment message within it.\n\n==Localization==\n\nMerchants that support multiple languages should generate\nlanguage-specific PaymentRequests, and either associate the language\nwith the request or embed a language tag in the request's\nmerchant_data. They should also generate a language-specific\nPaymentACK based on the original request.\n\nFor example: A greek-speaking customer browsing the Greek version of a\nmerchant's website clicks on a \"\u0391\u03b3\u03bf\u03c1\u03ac \u03c4\u03ce\u03c1\u03b1\" link, which generates a\nPaymentRequest with merchant_data set to \"lang=el&basketId=11252\". The\ncustomer pays, their bitcoin client sends a Payment message, and the\nmerchant's website responds with PaymentACK.message \"\u03c3\u03b1\u03c2 \u03b5\u03c5\u03c7\u03b1\u03c1\u03b9\u03c3\u03c4\u03bf\u03cd\u03bc\u03b5\".\n\n==Certificates==\n\nThe default PKI system is X.509 certificates (the same system used to\nauthenticate web servers). The format of pki_data when pki_type is\n\"x509+sha256\" or \"x509+sha1\" is a protocol-buffer-encoded certificate\nchain:\n<pre>\n    message X509Certificates {\n        repeated bytes certificate = 1;\n    }\n</pre>\nIf pki_type is \"x509+sha256\", then the PaymentRequest message is hashed using\nthe SHA256 algorithm to produce the message digest that is\nsigned. If pki_type is \"x509+sha1\", then the SHA1 algorithm is\nused.\n\nEach certificate is a DER [ITU.X690.1994] PKIX certificate value. The\ncertificate containing the public key of the entity that digitally\nsigned the PaymentRequest must be the first certificate. This MUST be\nfollowed by additional certificates, with each subsequent certificate\nbeing the one used to certify the previous one, up to (but not\nincluding) a trusted root authority. The trusted root authority MAY be\nincluded. The recipient must verify the certificate chain according to\n[RFC5280] and reject the PaymentRequest if any validation failure\noccurs.\n\nTrusted root certificates may be obtained from the operating system;\nif validation is done on a device without an operating system, the\n[https://www.mozilla.org/about/governance/policies/security-group/certs/policy/ Mozilla root store] is recommended.\n\n==Extensibility==\n\nThe protocol buffers serialization format is designed to be\nextensible. In particular, new, optional fields can be added to a\nmessage and will be ignored (but saved/re-transmitted) by old\nimplementations.\n\nPaymentDetails messages may be extended with new optional fields and\nstill be considered \"version 1.\" Old implementations will be able to\nvalidate signatures against PaymentRequests containing the new fields,\nbut (obviously) will not be able to display whatever information is\ncontained in the new, optional fields to the user.\n\nIf it becomes necessary at some point in the future for merchants to\nproduce PaymentRequest messages that are accepted *only* by new\nimplementations, they can do so by defining a new PaymentDetails\nmessage with version=2. Old implementations should let the user know\nthat they need to upgrade their software when they get an up-version\nPaymentDetails message.\n\nImplementations that need to extend messages in this specification shall use\ntags starting at 1000, and shall update the\n[[bip-0070/extensions.mediawiki|extensions page]] via pull-req to avoid\nconflicts with other extensions.\n\n==References==\n\n[[bip-0071.mediawiki|BIP 0071]] : Payment Protocol mime types\n\n[[bip-0072.mediawiki|BIP 0072]] : Payment Protocol bitcoin: URI extensions\n\nPublic-Key Infrastructure (X.509) working group :\nhttp://datatracker.ietf.org/wg/pkix/charter/\n\nProtocol Buffers : https://developers.google.com/protocol-buffers/\n\n==Reference implementation==\n\nCreate Payment Request generator : https://developer.bitcoin.org/examples/payment_processing.html ([[https://github.com/gavinandresen/paymentrequest|source]])\n\nBitcoinJ : https://bitcoinj.github.io/payment-protocol#introduction\n\n==See Also==\n\nJavascript Object Signing and Encryption working group :\nhttp://datatracker.ietf.org/wg/jose/\n\nWikipedia's page on Invoices: http://en.wikipedia.org/wiki/Invoice\nespecially the list of Electronic Invoice standards\n\nsipa's payment protocol proposal: https://gist.github.com/sipa/1237788\n\nThomasV's \"Signed Aliases\" proposal : http://ecdsa.org/bitcoin_URIs.html\n\nHomomorphic Payment Addresses and the Pay-to-Contract Protocol :\nhttp://arxiv.org/abs/1212.3257\n", "content_length": 16314}
{"bip_number": 69, "filename": "bip-0069.mediawiki", "content": "<pre>\n  BIP: 69\n  Layer: Applications\n  Title: Lexicographical Indexing of Transaction Inputs and Outputs\n  Author: Kristov Atlas <kristov@openbitcoinprivacyproject.org>\n  Editor: Daniel Cousens <bips@dcousens.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0069\n  Status: Proposed\n  Type: Informational\n  Created: 2015-06-12\n  License: PD\n</pre>\n\n==Abstract==\n\nCurrently there is no standard for bitcoin wallet clients when ordering transaction inputs and outputs.\nAs a result, wallet clients often have a discernible blockchain fingerprint, and can leak private information about their users.\nBy contrast, a standard for non-deterministic sorting could be difficult to audit.\nThis document proposes deterministic lexicographical sorting, using hashes of previous transactions and output indices to sort transaction inputs, as well as values and scriptPubKeys to sort transaction outputs.\n\n==Copyright==\n\nThis BIP is in the public domain.\n\n==Motivation==\n\nCurrently, there is no clear standard for how wallet clients ought to order transaction inputs and outputs.\nSince wallet clients are left to their own devices to determine this ordering, they often leak information about their users\u2019 finances.\nFor example, a wallet client might naively order inputs based on when addresses were added to a wallet by the user through importing or random generation.\nMany wallets will place spending outputs first and change outputs second, leaking information about both the sender and receiver\u2019s finances to passive blockchain observers.\nSuch information should remain private not only for the benefit of consumers, but in higher order financial systems must be kept secret to prevent fraud.\nA researcher recently demonstrated this principle when he detected that Bitstamp leaked information when creating exchange transactions, enabling potential espionage among traders. [1]\n\nOne way to address these privacy weaknesses is by randomizing the order of inputs and outputs. [2]\nAfter all, the order of inputs and outputs does not impact the function of the transaction they belong to, making random sorting viable.\nUnfortunately, it can be difficult to prove that this sorting process is genuinely randomly sorted based on code or run-time analysis, especially if the software is closed source.\nA malicious software developer can abuse the ordering of inputs and outputs as a side channel of leaking information.\nFor example, if an attacker can patch a victim\u2019s HD wallet client to order inputs and outputs based on the bits of a master private key, then the attacker can eventually steal all of the victim\u2019s funds by monitoring the blockchain.\nNon-deterministic methods of sorting are difficult to audit because they are not repeatable.\n\nThe lack of standardization between wallet clients when ordering inputs and outputs can yield predictable quirks that characterize particular wallet clients or services.\nSuch quirks create unique fingerprints that a privacy attacker can employ through simple passive blockchain observation.\n\nThe solution is to create an algorithm for sorting transaction inputs and outputs that is deterministic.\nSince it is deterministic, it should also be unambiguous \u2014 that is, given a particular transaction, the proper order of inputs and outputs should be obvious.\nTo make this standard as widely applicable as possible, it should rely on information that is downloaded by both full nodes (with or without typical efficiency techniques such as pruning) and SPV nodes.\nIn order to ensure that it does not leak confidential data, it must rely on information that is publicly accessible through the blockchain.\nThe use of public blockchain information also allows a transaction to be sorted even when it is a multi-party transaction, such as in the example of a CoinJoin.\n\n==Specification==\n\n===Applicability===\n\nThis BIP applies to any transaction for which the order of its inputs and outputs does not impact the transaction\u2019s function.\nCurrently, this refers to any transaction that employs the SIGHASH_ALL signature hash type, in which signatures commit to the exact order of inputs and outputs.\nTransactions that use SIGHASH_ANYONECANPAY and/or SIGHASH_NONE may include inputs and/or outputs that are not signed; however, compliant software should still emit transactions with lexicographically sorted inputs and outputs, even though they may later be modified by others.\n\nIn the event that future protocol upgrades introduce new signature hash types, compliant software should apply the lexicographical ordering principle analogously.\n\nWhile out of scope of this BIP, protocols that do require a specified order of inputs/outputs (e.g. due to use of SIGHASH_SINGLE) should consider the goals of this BIP and how best to adapt them to the specific needs of those protocols.\n\n===Lexicographical Ordering===\n\nLexicographical ordering is an algorithm for comparison used to sort two sets based on their cartesian order within their common superset.\nLexicographic order is also often known as alphabetical order, or dictionary order.\n\nCommon implementations include:\n\n* `std::lexicographical_compare` in C++ [5]\n* `cmp` in Python 2.7\n* `memcmp` in C [6]\n* `Buffer.compare` in Node.js [7]\n\nFor more information, see the wikipedia entry on Lexicographical order. [8]\n\nN.B. All comparisons do not need to operate in constant time since they are not processing secret information.\n\n===Transaction Inputs===\n\nTransaction inputs are defined by the hash of a previous transaction, the output index of a UTXO from that previous transaction, the size of an unlocking script, the unlocking script, and a sequence number. [3]\nFor sorting inputs, the hash of the previous transaction and the output index within that transaction are sufficient for sorting purposes; each transaction hash has an extremely high probability of being unique in the blockchain \u2014 this is enforced for coinbase transactions by BIP30 \u2014 and output indices within a transaction are unique.\nFor the sake of efficiency, transaction hashes should be compared first before output indices, since output indices from different transactions are often equivalent, while all bytes of the transaction hash are effectively random variables.\n\nPrevious transaction hashes (in reversed byte-order) are to be sorted in ascending order, lexicographically.\nIn the event of two matching transaction hashes, the respective previous output indices will be compared by their integer value, in ascending order.\nIf the previous output indices match, the inputs are considered equal.\n\nTransaction malleability will not negatively impact the correctness of this process.\nEven if a wallet client follows this process using unconfirmed UTXOs as inputs and an attacker modifies the blockchain\u2019s record of the hash of the previous transaction, the wallet client will include the invalidated previous transaction hash in its input data, and will still correctly sort with respect to that invalidated hash.\n\n===Transaction Outputs===\n\nA transaction output is defined by its scriptPubKey and amount. [3]\nFor the sake of efficiency, amounts should be compared first for sorting, since they contain fewer bytes of information (8 bytes) compared to a standard P2PKH scriptPubKey (25 bytes). [4]\n\nTransaction output amounts (as 64-bit unsigned integers) are to be sorted in ascending order.\nIn the event of two matching output amounts, the respective output scriptPubKeys (as a byte-array) will be compared lexicographically, in ascending order.\nIf the scriptPubKeys match, the outputs are considered equal.\n\n===Examples===\n\nTransaction 0a6a357e2f7796444e02638749d9611c008b253fb55f5dc88b739b230ed0c4c3:\n\nInputs:\n\n <nowiki>0: 0e53ec5dfb2cb8a71fec32dc9a634a35b7e24799295ddd5278217822e0b31f57[0]\n 1: 26aa6e6d8b9e49bb0630aac301db6757c02e3619feb4ee0eea81eb1672947024[1]\n 2: 28e0fdd185542f2c6ea19030b0796051e7772b6026dd5ddccd7a2f93b73e6fc2[0]\n 3: 381de9b9ae1a94d9c17f6a08ef9d341a5ce29e2e60c36a52d333ff6203e58d5d[1]\n 4: 3b8b2f8efceb60ba78ca8bba206a137f14cb5ea4035e761ee204302d46b98de2[0]\n 5: 402b2c02411720bf409eff60d05adad684f135838962823f3614cc657dd7bc0a[1]\n 6: 54ffff182965ed0957dba1239c27164ace5a73c9b62a660c74b7b7f15ff61e7a[1]\n 7: 643e5f4e66373a57251fb173151e838ccd27d279aca882997e005016bb53d5aa[0]\n 8: 6c1d56f31b2de4bfc6aaea28396b333102b1f600da9c6d6149e96ca43f1102b1[1]\n 9: 7a1de137cbafb5c70405455c49c5104ca3057a1f1243e6563bb9245c9c88c191[0]\n 10: 7d037ceb2ee0dc03e82f17be7935d238b35d1deabf953a892a4507bfbeeb3ba4[1]\n 11: a5e899dddb28776ea9ddac0a502316d53a4a3fca607c72f66c470e0412e34086[0]\n 12: b4112b8f900a7ca0c8b0e7c4dfad35c6be5f6be46b3458974988e1cdb2fa61b8[0]\n 13: bafd65e3c7f3f9fdfdc1ddb026131b278c3be1af90a4a6ffa78c4658f9ec0c85[0]\n 14: de0411a1e97484a2804ff1dbde260ac19de841bebad1880c782941aca883b4e9[1]\n 15: f0a130a84912d03c1d284974f563c5949ac13f8342b8112edff52971599e6a45[0]\n 16: f320832a9d2e2452af63154bc687493484a0e7745ebd3aaf9ca19eb80834ad60[0]</nowiki>\n\nOutputs:\n\n <nowiki>0:    400057456    76a9144a5fba237213a062f6f57978f796390bdcf8d01588ac\n 1:    40000000000    76a9145be32612930b8323add2212a4ec03c1562084f8488ac</nowiki>\n\nTransaction 28204cad1d7fc1d199e8ef4fa22f182de6258a3eaafe1bbe56ebdcacd3069a5f\n\nInputs:\n\n <nowiki>0: 35288d269cee1941eaebb2ea85e32b42cdb2b04284a56d8b14dcc3f5c65d6055[0]\n 1: 35288d269cee1941eaebb2ea85e32b42cdb2b04284a56d8b14dcc3f5c65d6055[1]</nowiki>\n\nOutputs:\n\n <nowiki>0:    100000000    41046a0765b5865641ce08dd39690aade26dfbf5511430ca428a3089261361cef170e3929a68aee3d8d4848b0c5111b0a37b82b86ad559fd2a745b44d8e8d9dfdc0cac\n 1:    2400000000    41044a656f065871a353f216ca26cef8dde2f03e8c16202d2e8ad769f02032cb86a5eb5e56842e92e19141d60a01928f8dd2c875a390f67c1f6c94cfc617c0ea45afac</nowiki>\n\n==Discussion==\n\n* [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/008484.html|<nowiki>[Bitcoin-development]</nowiki> Lexicographical Indexing of Transaction Inputs and Outputs]]\n* [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/008487.html|<nowiki>[Bitcoin-development] [RFC]</nowiki> Canonical input and output ordering in transactions]]\n\n==References==\n\n* [[https://bitcoinmagazine.com/20273/bitstamp-exchange-activity-trackable-due-multisig-wallet-implementation/|1: Bitstamp Info Leak]]\n* [[https://github.com/OpenBitcoinPrivacyProject/wallet-ratings/blob/5a7e2e1555e91bb48edeca3aa710272777d98c2a/2015-1/criteria.md|2: OBPP Random Indexing as Countermeasure]]\n* [[https://github.com/aantonop/bitcoinbook/blob/develop/ch05.asciidoc|3: Mastering Bitcoin]]\n* [[https://en.bitcoin.it/wiki/Script|4: Bitcoin Wiki on Script]]\n* [[http://www.cplusplus.com/reference/algorithm/lexicographical_compare|5: std::lexicographical_compare]]\n* [[http://www.cplusplus.com/reference/cstring/memcmp|6: memcmp]]\n* [[https://nodejs.org/api/buffer.html#buffer_class_method_buffer_compare_buf1_buf2|7: Buffer.compare]]\n* [[https://en.wikipedia.org/wiki/Lexicographical_order|8: Lexicographical order]]\n\n==Implementations==\n\n* [[https://github.com/spesmilo/electrum/blob/2af670ea2b92e835919b745d94afcb8b4ec32fda/lib/transaction.py#L648|Electrum]]\n* [[https://github.com/bitcoinjs/bip69/blob/master/index.js|BitcoinJS]]\n* [[https://github.com/bitcoinjs/bip69/blob/master/test/fixtures.json|BitcoinJS Test Fixtures]]\n* [[https://www.npmjs.com/package/bip69|NodeJS]]\n* [[https://github.com/blockchain/My-Wallet-V3/blob/v3.8.0/src/transaction.js#L120-L142|Blockchain.info public beta]]\n* [[https://github.com/btcsuite/btcd/blob/master/btcutil/txsort/txsort.go|Btcsuite]]\n\n==Acknowledgements==\n\nDanno Ferrin &lt;danno@numisight.com&gt;, Sergio Demian Lerner &lt;sergiolerner@certimix.com&gt;, Justus Ranvier &lt;justus@openbitcoinprivacyproject.org&gt;, and Peter Todd &lt;pete@petertodd.org&gt; contributed to the design and motivations for this BIP.\nA similar proposal was submitted to the Bitcoin-dev mailing list independently by Rusty Russell &lt;rusty@rustcorp.com.au&gt;\n", "content_length": 11919}
{"bip_number": 68, "filename": "bip-0068.mediawiki", "content": "<pre>\n  BIP: 68\n  Layer: Consensus (soft fork)\n  Title: Relative lock-time using consensus-enforced sequence numbers\n  Author: Mark Friedenbach <mark@friedenbach.org>\n          BtcDrak <btcdrak@gmail.com>\n          Nicolas Dorier <nicolas.dorier@gmail.com>\n          kinoshitajona <kinoshitajona@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0068\n  Status: Final\n  Type: Standards Track\n  Created: 2015-05-28\n</pre>\n\n==Abstract==\n\nThis BIP introduces relative lock-time (RLT) consensus-enforced semantics of the sequence number field to enable a signed transaction input to remain invalid for a defined period of time after confirmation of its corresponding outpoint.\n\n==Motivation==\n\nBitcoin transactions have a sequence number field for each input. The original idea appears to have been that a transaction in the mempool would be replaced by using the same input with a higher sequence value. Although this was not properly implemented, it assumes miners would prefer higher sequence numbers even if the lower ones were more profitable to mine. However, a miner acting on profit motives alone would break that assumption completely. The change described by this BIP repurposes the sequence number for new use cases without breaking existing functionality. It also leaves room for future expansion and other use cases.\n\nThe transaction nLockTime is used to prevent the mining of a transaction until a certain date. nSequence will be repurposed to prevent mining of a transaction until a certain age of the spent output in blocks or timespan. This, among other uses, allows bi-directional payment channels as used in [https://github.com/ElementsProject/lightning/raw/master/doc/miscellaneous/deployable-lightning.pdf Hashed Timelock Contracts (HTLCs)] and [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki#Bidirectional_Payment_Channels BIP112].\n\n==Specification==\n\nThis specification defines the meaning of sequence numbers for transactions with an nVersion greater than or equal to 2 for which the rest of this specification relies on.\n\nAll references to median-time-past (MTP) are as defined by BIP113.\n\nIf bit (1 << 31) of the sequence number is set, then no consensus meaning is applied to the sequence number and can be included in any block under all currently possible circumstances.\n\nIf bit (1 << 31) of the sequence number is not set, then the sequence number is interpreted as an encoded relative lock-time.\n\nThe sequence number encoding is interpreted as follows:\n\nBit (1 << 22) determines if the relative lock-time is time-based or block based: If the bit is set, the relative lock-time specifies a timespan in units of 512 seconds granularity. The timespan starts from the median-time-past of the output\u2019s previous block, and ends at the MTP of the previous block. If the bit is not set, the relative lock-time specifies a number of blocks.\n\nThe flag (1<<22) is the highest order bit in a 3-byte signed integer for use in bitcoin scripts as a 3-byte PUSHDATA with OP_CHECKSEQUENCEVERIFY (BIP 112).\n\nThis specification only interprets 16 bits of the sequence number as relative lock-time, so a mask of 0x0000ffff MUST be applied to the sequence field to extract the relative lock-time. The 16-bit specification allows for a year of relative lock-time and the remaining bits allow for future expansion.\n\n<img src=bip-0068/encoding.png></img>\n\nFor time based relative lock-time, 512 second granularity was chosen because bitcoin blocks are generated every 600 seconds. So when using block-based or time-based, the same amount of time can be encoded with the available number of bits. Converting from a sequence number to seconds is performed by multiplying by 512 = 2^9, or equivalently shifting up by 9 bits.\n\nWhen the relative lock-time is time-based, it is interpreted as a minimum block-time constraint over the input's age. A relative time-based lock-time of zero indicates an input which can be included in any block. More generally, a relative time-based lock-time n can be included into any block produced 512 * n seconds after the mining date of the output it is spending, or any block thereafter.\nThe mining date of the output is equal to the median-time-past of the previous block which mined it.\n\nThe block produced time is equal to the median-time-past of its previous block.\n\nWhen the relative lock-time is block-based, it is interpreted as a minimum block-height constraint over the input's age. A relative block-based lock-time of zero indicates an input which can be included in any block. More generally, a relative block lock-time n can be included n blocks after the mining date of the output it is spending, or any block thereafter.\n\nThe new rules are not applied to the nSequence field of the input of the coinbase transaction.\n\n==Implementation==\n\nA reference implementation is provided by the following pull request\n\nhttps://github.com/bitcoin/bitcoin/pull/7184\n\n<pre>\nenum {\n    /* Interpret sequence numbers as relative lock-time constraints. */\n    LOCKTIME_VERIFY_SEQUENCE = (1 << 0),\n};\n\n/* Setting nSequence to this value for every input in a transaction\n * disables nLockTime. */\nstatic const uint32_t SEQUENCE_FINAL = 0xffffffff;\n\n/* Below flags apply in the context of BIP 68*/\n/* If this flag set, CTxIn::nSequence is NOT interpreted as a\n * relative lock-time. */\nstatic const uint32_t SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31);\n\n/* If CTxIn::nSequence encodes a relative lock-time and this flag\n * is set, the relative lock-time has units of 512 seconds,\n * otherwise it specifies blocks with a granularity of 1. */\nstatic const uint32_t SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22);\n\n/* If CTxIn::nSequence encodes a relative lock-time, this mask is\n * applied to extract that lock-time from the sequence field. */\nstatic const uint32_t SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\n/* In order to use the same number of bits to encode roughly the\n * same wall-clock duration, and because blocks are naturally\n * limited to occur every 600s on average, the minimum granularity\n * for time-based relative lock-time is fixed at 512 seconds.\n * Converting from CTxIn::nSequence to seconds is performed by\n * multiplying by 512 = 2^9, or equivalently shifting up by\n * 9 bits. */\nstatic const int SEQUENCE_LOCKTIME_GRANULARITY = 9;\n\n/**\n * Calculates the block height and previous block's median time past at\n * which the transaction will be considered final in the context of BIP 68.\n * Also removes from the vector of input heights any entries which did not\n * correspond to sequence locked inputs as they do not affect the calculation.\n */\nstatic std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n{\n    assert(prevHeights->size() == tx.vin.size());\n\n    // Will be set to the equivalent height- and time-based nLockTime\n    // values that would be necessary to satisfy all relative lock-\n    // time constraints given our view of block chain history.\n    // The semantics of nLockTime are the last invalid height/time, so\n    // use -1 to have the effect of any height or time being valid.\n    int nMinHeight = -1;\n    int64_t nMinTime = -1;\n\n    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n    // we would be doing a signed comparison and half the range of nVersion\n    // wouldn't support BIP 68.\n    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n\n    // Do not enforce sequence numbers as a relative lock time\n    // unless we have been instructed to\n    if (!fEnforceBIP68) {\n        return std::make_pair(nMinHeight, nMinTime);\n    }\n\n    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n        const CTxIn& txin = tx.vin[txinIndex];\n\n        // Sequence numbers with the most significant bit set are not\n        // treated as relative lock-times, nor are they given any\n        // consensus-enforced meaning at this point.\n        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n            // The height of this input is not relevant for sequence locks\n            (*prevHeights)[txinIndex] = 0;\n            continue;\n        }\n\n        int nCoinHeight = (*prevHeights)[txinIndex];\n\n        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n            // NOTE: Subtract 1 to maintain nLockTime semantics\n            // BIP 68 relative lock times have the semantics of calculating\n            // the first block or time at which the transaction would be\n            // valid. When calculating the effective block time or height\n            // for the entire transaction, we switch to using the\n            // semantics of nLockTime which is the last invalid block\n            // time or height.  Thus we subtract 1 from the calculated\n            // time or height.\n\n            // Time-based relative lock-times are measured from the\n            // smallest allowed timestamp of the block containing the\n            // txout being spent, which is the median time past of the\n            // block prior.\n            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n        } else {\n            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n        }\n    }\n\n    return std::make_pair(nMinHeight, nMinTime);\n}\n\nstatic bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n{\n    assert(block.pprev);\n    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n        return false;\n\n    return true;\n}\n\nbool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n{\n    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n}\n\nbool CheckSequenceLocks(const CTransaction &tx, int flags)\n{\n    AssertLockHeld(cs_main);\n    AssertLockHeld(mempool.cs);\n\n    CBlockIndex* tip = chainActive.Tip();\n    CBlockIndex index;\n    index.pprev = tip;\n    // CheckSequenceLocks() uses chainActive.Height()+1 to evaluate\n    // height based locks because when SequenceLocks() is called within\n    // ConnectBlock(), the height of the block *being*\n    // evaluated is what is used.\n    // Thus if we want to know if a transaction can be part of the\n    // *next* block, we need to use one more than chainActive.Height()\n    index.nHeight = tip->nHeight + 1;\n\n    // pcoinsTip contains the UTXO set for chainActive.Tip()\n    CCoinsViewMemPool viewMemPool(pcoinsTip, mempool);\n    std::vector<int> prevheights;\n    prevheights.resize(tx.vin.size());\n    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n        const CTxIn& txin = tx.vin[txinIndex];\n        CCoins coins;\n        if (!viewMemPool.GetCoins(txin.prevout.hash, coins)) {\n            return error(\"%s: Missing input\", __func__);\n        }\n        if (coins.nHeight == MEMPOOL_HEIGHT) {\n            // Assume all mempool transactions are confirmed in the next block\n            prevheights[txinIndex] = tip->nHeight + 1;\n        } else {\n            prevheights[txinIndex] = coins.nHeight;\n        }\n    }\n\n    std::pair<int, int64_t> lockPair = CalculateSequenceLocks(tx, flags, &prevheights, index);\n    return EvaluateSequenceLocks(index, lockPair);\n}\n</pre>\n\n==Acknowledgments==\n\nCredit goes to Gregory Maxwell for providing a succinct and clear description of the behavior of this change, which became the basis of this BIP text.\n\nThis BIP was edited by BtcDrak, Nicolas Dorier and kinoshitajona.\n\n==Deployment==\n\nThis BIP is to be deployed by \"versionbits\" BIP9 using bit 0.\n\nFor Bitcoin '''mainnet''', the BIP9 '''starttime''' will be midnight 1st May 2016 UTC (Epoch timestamp 1462060800) and BIP9 '''timeout''' will be midnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nFor Bitcoin '''testnet''', the BIP9 '''starttime''' will be midnight 1st March 2016 UTC (Epoch timestamp 1456790400) and BIP9 '''timeout''' will be midnight 1st May 2017 UTC (Epoch timestamp 1493596800).\n\nThis BIP must be deployed simultaneously with BIP112 and BIP113 using the same deployment mechanism.\n\n==Compatibility==\n\nThe only use of sequence numbers by the Bitcoin Core reference client software is to disable checking the nLockTime constraints in a transaction. The semantics of that application are preserved by this BIP.\n\nAs can be seen from the specification section, a number of bits are undefined by this BIP to allow for other use cases by setting bit (1 << 31) as the remaining 31 bits have no meaning under this BIP. Additionally, bits (1 << 23) through (1 << 30) inclusive have no meaning at all when bit (1 << 31) is unset.\n\nAdditionally, this BIP specifies only 16 bits to actually encode relative lock-time meaning a further 6 are unused (1 << 16 through 1 << 21 inclusive). This allows the possibility to increase granularity by soft-fork, or for increasing the maximum possible relative lock-time in the future.\n\nThe most efficient way to calculate sequence number from relative lock-time is with bit masks and shifts:\n\n<pre>\n    // 0 <= nHeight < 65,535 blocks (1.25 years)\n    nSequence = nHeight;\n    nHeight = nSequence & 0x0000ffff;\n\n    // 0 <= nTime < 33,554,431 seconds (1.06 years)\n    nSequence = (1 << 22) | (nTime >> 9);\n    nTime = (nSequence & 0x0000ffff) << 9;\n</pre>\n\n==References==\n\nBitcoin mailing list discussion: https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg07864.html\n\nBIP9: https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki\n\nBIP112: https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki\n\nBIP113: https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki\n\nHashed Timelock Contracts (HTLCs): https://github.com/ElementsProject/lightning/raw/master/doc/miscellaneous/deployable-lightning.pdf\n\n", "content_length": 14154}
{"bip_number": 67, "filename": "bip-0067.mediawiki", "content": "<pre>\n  BIP: 67\n  Layer: Applications\n  Title: Deterministic Pay-to-script-hash multi-signature addresses through public key sorting\n  Author: Thomas Kerin <me@thomaskerin.io>\n          Jean-Pierre Rupp <root@haskoin.com>\n          Ruben de Vries <ruben@rubensayshi.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0067\n  Status: Proposed\n  Type: Standards Track\n  Created: 2015-02-08\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP describes a method to deterministically generate multi-signature pay-to-script-hash transaction scripts.  It focuses on defining how the public keys must be encoded and sorted so that the redeem script and corresponding P2SH address are always the same for a given set of keys and number of required signatures.\n\n==Motivation==\n\nPay-to-script-hash (BIP-0011<ref>[https://github.com/bitcoin/bips/blob/master/bip-0011.mediawiki BIP-0011]</ref>) is a transaction type that allows funding of arbitrary scripts, where the recipient carries the cost of fee's associated with using longer, more complex scripts.\n\nMulti-signature pay-to-script-hash transactions are defined in BIP-0016<ref>[https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki BIP-0016]</ref>. The redeem script does not require a particular ordering or encoding for public keys.  This means that for a given set of keys and number of required signatures, there are as many as 2(n!) possible standard redeem scripts, each with its separate P2SH address.  Adhering to an ordering and key encoding would ensure that a multi-signature \u201caccount\u201d (set of public keys and required signature count) has a canonical P2SH address.\n\nBy adopting a sorting and encoding standard, compliant wallets will always produce the same P2SH address for the same given set of keys and required signature count, making it easier to recognize transactions involving that multi-signature account.  This is particularly attractive for multisignature hierarchical-deterministic wallets, as less state is required to setup multi-signature accounts:  only the number of required signatures and master public keys of participants need to be shared, and all wallets will generate the same addresses.\n\nWhile most web wallets do not presently facilitate the setup of multisignature accounts with users of a different service, conventions which ensure cross-compatibility should make it easier to achieve this.\n\nMany wallet as a service providers use a 2of3 multi-signature schema where the user stores 1 of the keys (offline) as backup while using the other key for daily use and letting the service cosign his transactions.\nThis standard will help in enabling a party other than the service provider to recover the wallet without any help from the service provider.\n\n==Specification==\n\nFor a set of public keys, ensure that they have been received in compressed form:\n\n    022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da\n    03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9\n    021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18\n\nSort them lexicographically according to their binary representation:\n\n    021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18\n    022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da\n    03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9\n\n..before using the resulting list of keys in a standard multisig redeem script:\n\n    OP_2 021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18 022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da 03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9 OP_3 OP_CHECKMULTISIG\n\nHash the redeem script according to BIP-0016 to get the P2SH address.\n\n    3Q4sF6tv9wsdqu2NtARzNCpQgwifm2rAba\n\n==Compatibility==\n* Uncompressed keys are incompatible with this specification. A compatible implementation should not automatically compress keys.  Receiving an uncompressed key from a multisig participant should be interpreted as a sign that the user has an incompatible implementation.\n* P2SH addresses do not reveal information about the script that is receiving the funds. For this reason it is not technically possible to enforce this BIP as a rule on the network.  Also, it would cause a hard fork.\n* Implementations that do not conform with this BIP will have compatibility issues with strictly-compliant wallets.\n* Implementations which do adopt this standard will be cross-compatible when choosing multisig addresses.\n* If a group of users were not entirely compliant, there is the possibility that a participant will derive an address that the others will not recognize as part of the common multisig account.\n\n==Test vectors==\nTwo signatures are required in each of these test vectors.\n\nVector 1\n* List\n** 02ff12471208c14bd580709cb2358d98975247d8765f92bc25eab3b2763ed605f8\n** 02fe6f0a5a297eb38c391581c4413e084773ea23954d93f7753db7dc0adc188b2f\n* Sorted\n** 02fe6f0a5a297eb38c391581c4413e084773ea23954d93f7753db7dc0adc188b2f\n** 02ff12471208c14bd580709cb2358d98975247d8765f92bc25eab3b2763ed605f8\n* Script\n** 522102fe6f0a5a297eb38c391581c4413e084773ea23954d93f7753db7dc0adc188b2f2102ff12471208c14bd580709cb2358d98975247d8765f92bc25eab3b2763ed605f852ae\n* Address\n** 39bgKC7RFbpoCRbtD5KEdkYKtNyhpsNa3Z\n\nVector 2 (Already sorted, no action required)\n* List:\n** 02632b12f4ac5b1d1b72b2a3b508c19172de44f6f46bcee50ba33f3f9291e47ed0\n** 027735a29bae7780a9755fae7a1c4374c656ac6a69ea9f3697fda61bb99a4f3e77\n** 02e2cc6bd5f45edd43bebe7cb9b675f0ce9ed3efe613b177588290ad188d11b404\n* Sorted:\n** 02632b12f4ac5b1d1b72b2a3b508c19172de44f6f46bcee50ba33f3f9291e47ed0\n** 027735a29bae7780a9755fae7a1c4374c656ac6a69ea9f3697fda61bb99a4f3e77\n** 02e2cc6bd5f45edd43bebe7cb9b675f0ce9ed3efe613b177588290ad188d11b404\n* Script\n** 522102632b12f4ac5b1d1b72b2a3b508c19172de44f6f46bcee50ba33f3f9291e47ed021027735a29bae7780a9755fae7a1c4374c656ac6a69ea9f3697fda61bb99a4f3e772102e2cc6bd5f45edd43bebe7cb9b675f0ce9ed3efe613b177588290ad188d11b40453ae\n* Address\n** 3CKHTjBKxCARLzwABMu9yD85kvtm7WnMfH\n\nVector 3:\n* List:\n** 030000000000000000000000000000000000004141414141414141414141414141\n** 020000000000000000000000000000000000004141414141414141414141414141\n** 020000000000000000000000000000000000004141414141414141414141414140\n** 030000000000000000000000000000000000004141414141414141414141414140\n* Sorted:\n** 020000000000000000000000000000000000004141414141414141414141414140\n** 020000000000000000000000000000000000004141414141414141414141414141\n** 030000000000000000000000000000000000004141414141414141414141414140\n** 030000000000000000000000000000000000004141414141414141414141414141\n* Script\n** 522102000000000000000000000000000000000000414141414141414141414141414021020000000000000000000000000000000000004141414141414141414141414141210300000000000000000000000000000000000041414141414141414141414141402103000000000000000000000000000000000000414141414141414141414141414154ae\n* Address\n** 32V85igBri9zcfBRVupVvwK18NFtS37FuD\n\nVector 4: (from bitcore)\n* List:\n** 022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da\n** 03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9\n** 021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18\n* Sorted:\n** 021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc18\n** 022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da\n** 03e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e9\n* Script\n** 5221021f2f6e1e50cb6a953935c3601284925decd3fd21bc445712576873fb8c6ebc1821022df8750480ad5b26950b25c7ba79d3e37d75f640f8e5d9bcd5b150a0f85014da2103e3818b65bcc73a7d64064106a859cc1a5a728c4345ff0b641209fba0d90de6e953ae\n* Address\n** 3Q4sF6tv9wsdqu2NtARzNCpQgwifm2rAba\n\n==Acknowledgements==\nThe authors wish to thank BtcDrak and Luke-Jr for their involvement & contributions in the early discussions of this BIP.\n\n==Usage & Implementations==\n* [[https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki#address-generation-procedure|BIP-0045]] - Structure for Deterministic P2SH Multisignature Wallets\n* [[https://github.com/bitpay/bitcore/blob/50a868cb8cdf2be04bb1c5bf4bcc064cc06f5888/lib/script/script.js#L541|Bitcore]]\n* [[https://github.com/haskoin/haskoin-core/blob/b41b1deb0989334a7ead6fc993fb8b02f0c00810/haskoin-core/Network/Haskoin/Script/Parser.hs#L112-L122|Haskoin]] - Bitcoin implementation in Haskell\n* [[https://github.com/etotheipi/BitcoinArmory/blob/268db0f3fa20c989057bd43343a43b2edbe89aeb/armoryengine/ArmoryUtils.py#L1441|Armory]]\n* [[https://github.com/bitcoinj/bitcoinj/blob/f7ea0b92a619800c143b0142dc70306da33119a9/core/src/main/java/org/bitcoinj/script/ScriptBuilder.java#L331|BitcoinJ]]\n\n== References ==\n<references>\n\n\n== Copyright ==\nThis document is placed in the public domain.\n\n", "content_length": 8788}
{"bip_number": 66, "filename": "bip-0066.mediawiki", "content": "<pre>\n  BIP: 66\n  Layer: Consensus (soft fork)\n  Title: Strict DER signatures\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0066\n  Status: Final\n  Type: Standards Track\n  Created: 2015-01-10\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules to restrict signatures to strict DER encoding.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nBitcoin's reference implementation currently relies on OpenSSL for signature validation, which means it is implicitly defining Bitcoin's block validity rules. Unfortunately, OpenSSL is not designed for consensus-critical behaviour (it does not guarantee bug-for-bug compatibility between versions), and thus changes to it can - and have - affected Bitcoin software.\n\nOne specifically critical area is the encoding of signatures. Until recently, OpenSSL's releases would accept various deviations from the DER standard and accept signatures as valid. When this changed in OpenSSL 1.0.0p and 1.0.1k, it made some nodes reject the chain.\n\nThis document proposes to restrict valid signatures to exactly what is mandated by DER, to make the consensus rules not depend on OpenSSL's signature parsing. A change like this is required if implementations would want to remove all of OpenSSL from the consensus code.\n\n==Specification==\n\nEvery signature passed to OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, or OP_CHECKMULTISIGVERIFY, to which ECDSA verification is applied, must be encoded using strict DER encoding (see further).\n\nThese operators all perform ECDSA verifications on pubkey/signature pairs, iterating from the top of the stack backwards. For each such verification, if the signature does not pass the <code>IsValidSignatureEncoding</code> check below, the entire script evaluates to false immediately. If the signature is valid DER, but does not pass ECDSA verification, opcode execution continues as it used to, causing opcode execution to stop and push false on the stack (but not immediately fail the script) in some cases, which potentially skips further signatures (and thus does not subject them to <code>IsValidSignatureEncoding</code>).\n\n===DER encoding reference===\n\nThe following code specifies the behaviour of strict DER checking. Note that this function tests a signature byte vector which includes the 1-byte sighash flag that Bitcoin adds, even though that flag falls outside of the DER specification, and is unaffected by this proposal. The function is also not called for cases where the length of sig is 0, in order to provide a simple, short and efficiently-verifiable encoding for deliberately invalid signatures.\n\nDER is specified in https://www.itu.int/rec/T-REC-X.690/en .\n\n<pre>\nbool static IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n    // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash]\n    // * total-length: 1-byte length descriptor of everything that follows,\n    //   excluding the sighash byte.\n    // * R-length: 1-byte length descriptor of the R value that follows.\n    // * R: arbitrary-length big-endian encoded R value. It must use the shortest\n    //   possible encoding for a positive integers (which means no null bytes at\n    //   the start, except a single one when the next byte has its highest bit set).\n    // * S-length: 1-byte length descriptor of the S value that follows.\n    // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n    // * sighash: 1-byte value indicating what data is hashed (not part of the DER\n    //   signature)\n\n    // Minimum and maximum size constraints.\n    if (sig.size() < 9) return false;\n    if (sig.size() > 73) return false;\n\n    // A signature is of type 0x30 (compound).\n    if (sig[0] != 0x30) return false;\n\n    // Make sure the length covers the entire signature.\n    if (sig[1] != sig.size() - 3) return false;\n\n    // Extract the length of the R element.\n    unsigned int lenR = sig[3];\n\n    // Make sure the length of the S element is still inside the signature.\n    if (5 + lenR >= sig.size()) return false;\n\n    // Extract the length of the S element.\n    unsigned int lenS = sig[5 + lenR];\n\n    // Verify that the length of the signature matches the sum of the length\n    // of the elements.\n    if ((size_t)(lenR + lenS + 7) != sig.size()) return false;\n\n    // Check whether the R element is an integer.\n    if (sig[2] != 0x02) return false;\n\n    // Zero-length integers are not allowed for R.\n    if (lenR == 0) return false;\n\n    // Negative numbers are not allowed for R.\n    if (sig[4] & 0x80) return false;\n\n    // Null bytes at the start of R are not allowed, unless R would\n    // otherwise be interpreted as a negative number.\n    if (lenR > 1 && (sig[4] == 0x00) && !(sig[5] & 0x80)) return false;\n\n    // Check whether the S element is an integer.\n    if (sig[lenR + 4] != 0x02) return false;\n\n    // Zero-length integers are not allowed for S.\n    if (lenS == 0) return false;\n\n    // Negative numbers are not allowed for S.\n    if (sig[lenR + 6] & 0x80) return false;\n\n    // Null bytes at the start of S are not allowed, unless S would otherwise be\n    // interpreted as a negative number.\n    if (lenS > 1 && (sig[lenR + 6] == 0x00) && !(sig[lenR + 7] & 0x80)) return false;\n\n    return true;\n}\n</pre>\n\n===Examples===\n\nNotation: P1 and P2 are valid, serialized, public keys. S1 and S2 are valid signatures using respective keys P1 and P2. S1' and S2' are non-DER but otherwise valid signatures using those same keys. F is any invalid but DER-compliant signature (including 0, the empty string). F' is any invalid and non-DER-compliant signature.\n\n# <code>S1' P1 CHECKSIG</code> fails (<b>changed</b>)\n# <code>S1' P1 CHECKSIG NOT</code> fails (unchanged)\n# <code>F P1 CHECKSIG</code> fails (unchanged)\n# <code>F P1 CHECKSIG NOT</code> can succeed (unchanged)\n# <code>F' P1 CHECKSIG</code> fails (unchanged)\n# <code>F' P1 CHECKSIG NOT</code> fails (<b>changed</b>)\n\n# <code>0 S1' S2 2 P1 P2 2 CHECKMULTISIG</code> fails (<b>changed</b>)\n# <code>0 S1' S2 2 P1 P2 2 CHECKMULTISIG NOT</code> fails (unchanged)\n# <code>0 F S2' 2 P1 P2 2 CHECKMULTISIG</code> fails (unchanged)\n# <code>0 F S2' 2 P1 P2 2 CHECKMULTISIG NOT</code> fails (<b>changed</b>)\n# <code>0 S1' F 2 P1 P2 2 CHECKMULTISIG</code> fails (unchanged)\n# <code>0 S1' F 2 P1 P2 2 CHECKMULTISIG NOT</code> can succeed (unchanged)\n\nNote that the examples above show that only additional failures are required by this change, as required for a soft forking change.\n\n==Deployment==\n\nWe reuse the double-threshold switchover mechanism from BIP 34, with the same thresholds, but for nVersion = 3. The new rules are in effect for every block (at height H) with nVersion = 3 and at least 750 out of 1000 blocks preceding it (with heights H-1000..H-1) also have nVersion = 3. Furthermore, when 950 out of the 1000 blocks preceding a block do have nVersion = 3, nVersion = 2 blocks become invalid, and all further blocks enforce the new rules.\n\n==Compatibility==\n\nThe requirement to have signatures that comply strictly with DER has been enforced as a relay policy by the reference client since v0.8.0, and very few transactions violating it are being added to the chain as of January 2015. In addition, every non-compliant signature can trivially be converted into a compliant one, so there is no loss of functionality by this requirement. This proposal has the added benefit of reducing transaction malleability (see BIP 62).\n\n==Implementation==\n\nAn implementation for the reference client is available at https://github.com/bitcoin/bitcoin/pull/5713\n\n==Acknowledgements==\n\nThis document is extracted from the previous BIP62 proposal, which had input from various people, in particular Greg Maxwell and Peter Todd, who gave feedback about this document as well.\n\n==Disclosures==\n\n* Subsequent to the network-wide adoption and enforcement of this BIP, the author [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-July/009697.html disclosed] that strict DER signatures provided an indirect solution to a consensus bug he had previously discovered.\n", "content_length": 8256}
{"bip_number": 65, "filename": "bip-0065.mediawiki", "content": "<pre>\n  BIP: 65\n  Layer: Consensus (soft fork)\n  Title: OP_CHECKLOCKTIMEVERIFY\n  Author: Peter Todd <pete@petertodd.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0065\n  Status: Final\n  Type: Standards Track\n  Created: 2014-10-01\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\nscripting system that allows a transaction output to be made unspendable until\nsome point in the future.\n\n\n==Summary==\n\nCHECKLOCKTIMEVERIFY redefines the existing NOP2 opcode. When executed, if\nany of the following conditions are true, the script interpreter will terminate\nwith an error:\n\n* the stack is empty; or\n* the top item on the stack is less than 0; or\n* the lock-time type (height vs. timestamp) of the top stack item and the nLockTime field are not the same; or\n* the top stack item is greater than the transaction's nLockTime field; or\n* the nSequence field of the txin is 0xffffffff;\n\nOtherwise, script execution will continue as if a NOP had been executed.\n\nThe nLockTime field in a transaction prevents the transaction from being mined\nuntil either a certain block height, or block time, has been reached. By\ncomparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\nindirectly verify that the desired block height or block time has been reached;\nuntil that block height or block time has been reached the transaction output\nremains unspendable.\n\n\n==Motivation==\n\nThe nLockTime field in transactions can be used to prove that it is\n''possible'' to spend a transaction output in the future, by constructing a\nvalid transaction spending that output with the nLockTime field set.\n\nHowever, the nLockTime field can't prove that it is ''impossible'' to spend a\ntransaction output until some time in the future, as there is no way to know if\na valid signature for a different transaction spending that output has been\ncreated.\n\n\n===Escrow===\n\nIf Alice and Bob jointly operate a business they may want to\nensure that all funds are kept in 2-of-2 multisig transaction outputs that\nrequire the co-operation of both parties to spend. However, they recognise that\nin exceptional circumstances such as either party getting \"hit by a bus\" they\nneed a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\nto act as a third-party.\n\nWith a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\neither Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\nnot to have immediate access to the funds to discourage bad actors from\nattempting to get the secret keys from him by force.\n\nHowever, with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\nthe form:\n\n    IF\n        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n        <Lenny's pubkey> CHECKSIGVERIFY\n        1\n    ELSE\n        2\n    ENDIF\n    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n\nAt any time the funds can be spent with the following scriptSig:\n\n    0 <Alice's signature> <Bob's signature> 0\n\nAfter 3 months have passed Lenny and one of either Alice or Bob can spend the\nfunds with the following scriptSig:\n\n    0 <Alice/Bob's signature> <Lenny's signature> 1\n\n\n===Non-interactive time-locked refunds===\n\nThere exist a number of protocols where a transaction output is created that\nrequires the co-operation of both parties to spend the output. To ensure the\nfailure of one party does not result in the funds becoming lost, refund\ntransactions are setup in advance using nLockTime. These refund transactions\nneed to be created interactively, and additionally, are currently vulnerable to\ntransaction malleability. CHECKLOCKTIMEVERIFY can be used in these protocols,\nreplacing the interactive setup with a non-interactive setup, and additionally,\nmaking transaction malleability a non-issue.\n\n\n====Two-factor wallets====\n\nServices like GreenAddress store bitcoins with 2-of-2 multisig scriptPubKey's\nsuch that one keypair is controlled by the user, and the other keypair is\ncontrolled by the service. To spend funds the user uses locally installed\nwallet software that generates one of the required signatures, and then uses a\n2nd-factor authentication method to authorize the service to create the second\nSIGHASH_NONE signature that is locked until some time in the future and sends\nthe user that signature for storage. If the user needs to spend their funds and\nthe service is not available, they wait until the nLockTime expires.\n\nThe problem is there exist numerous occasions the user will not have a valid\nsignature for some or all of their transaction outputs. With\nCHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\nscriptPubKeys of the following form are used instead:\n\n    IF\n        <service pubkey> CHECKSIGVERIFY\n    ELSE\n        <expiry time> CHECKLOCKTIMEVERIFY DROP\n    ENDIF\n    <user pubkey> CHECKSIG\n\nNow the user is always able to spend their funds without the co-operation of\nthe service by waiting for the expiry time to be reached.\n\n\n====Payment Channels====\n\nJeremy Spilman style payment channels first setup a deposit controlled by\n2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\nthe output of tx1 to payor and payee. Prior to publishing tx1 a refund\ntransaction is created, tx3, to ensure that should the payee vanish the payor\ncan get their deposit back. The process by which the refund transaction is\ncreated is currently vulnerable to transaction malleability attacks, and\nadditionally, requires the payor to store the refund. Using the same\nscriptPubKey form as in the Two-factor wallets example solves both these issues.\n\n\n===Trustless Payments for Publishing Data===\n\nThe PayPub protocol makes it possible to pay for information in a trustless way\nby first proving that an encrypted file contains the desired data, and secondly\ncrafting scriptPubKeys used for payment such that spending them reveals the\nencryption keys to the data. However the existing implementation has a\nsignificant flaw: the publisher can delay the release of the keys indefinitely.\n\nThis problem can be solved interactively with the refund transaction technique;\nwith CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\nscriptPubKeys of the following form:\n\n    IF\n        HASH160 <Hash160(encryption key)> EQUALVERIFY\n        <publisher pubkey> CHECKSIG\n    ELSE\n        <expiry time> CHECKLOCKTIMEVERIFY DROP\n        <buyer pubkey> CHECKSIG\n    ENDIF\n\nThe buyer of the data is now making a secure offer with an expiry time. If the\npublisher fails to accept the offer before the expiry time is reached the buyer\ncan cancel the offer by spending the output.\n\n\n===Proving sacrifice to miners' fees===\n\nProving the sacrifice of some limited resource is a common technique in a\nvariety of cryptographic protocols. Proving sacrifices of coins to mining fees\nhas been proposed as a ''universal public good'' to which the sacrifice could\nbe directed, rather than simply destroying the coins. However doing so is\nnon-trivial, and even the best existing technique - announce-commit sacrifices\n- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\ncreate outputs that are provably spendable by anyone (thus to mining fees\nassuming miners behave optimally and rationally) but only at a time\nsufficiently far into the future that large miners can't profitably sell the\nsacrifices at a discount.\n\n\n===Freezing Funds===\n\nIn addition to using cold storage, hardware wallets, and P2SH multisig outputs\nto control funds, now funds can be frozen in UTXOs directly on the blockchain.\nWith the following scriptPubKey, nobody will be able to spend the encumbered\noutput until the provided expiry time. This ability to freeze funds reliably may\nbe useful in scenarios where reducing duress or confiscation risk is desired.\n\n    <expiry time> CHECKLOCKTIMEVERIFY DROP DUP HASH160 <pubKeyHash> EQUALVERIFY CHECKSIG\n\n\n===Replacing the nLockTime field entirely===\n\nAs an aside, note how if the SignatureHash() algorithm could optionally cover\npart of the scriptSig the signature could require that the scriptSig contain\nCHECKLOCKTIMEVERIFY opcodes, and additionally, require that they be executed.\n(the CODESEPARATOR opcode came very close to making this possible in v0.1 of\nBitcoin) This per-signature capability could replace the per-transaction\nnLockTime field entirely as a valid signature would now be the proof that a\ntransaction output ''can'' be spent.\n\n\n==Detailed Specification==\n\nRefer to the reference implementation, reproduced below, for the precise\nsemantics and detailed rationale for those semantics.\n\n\n    case OP_NOP2:\n    {\n        // CHECKLOCKTIMEVERIFY\n        //\n        // (nLockTime -- nLockTime )\n\n        if (!(flags & SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY))\n            break; // not enabled; treat as a NOP\n\n        if (stack.size() < 1)\n            return false;\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**32-1, the\n        // same limit as the nLockTime field itself.\n        const CScriptNum nLockTime(stacktop(-1), 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime < 0)\n            return false;\n\n        // There are two types of nLockTime: lock-by-blockheight\n        // and lock-by-blocktime, distinguished by whether\n        // nLockTime < LOCKTIME_THRESHOLD.\n        //\n        // We want to compare apples to apples, so fail the script\n        // unless the type of nLockTime being tested is the same as\n        // the nLockTime in the transaction.\n        if (!(\n              (txTo.nLockTime <  LOCKTIME_THRESHOLD && nLockTime <  LOCKTIME_THRESHOLD) ||\n              (txTo.nLockTime >= LOCKTIME_THRESHOLD && nLockTime >= LOCKTIME_THRESHOLD)\n             ))\n            return false;\n\n        // Now that we know we're comparing apples-to-apples, the\n        // comparison is a simple numeric one.\n        if (nLockTime > (int64_t)txTo.nLockTime)\n            return false;\n\n        // Finally the nLockTime feature can be disabled and thus\n        // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n        // finalized by setting nSequence to maxint. The\n        // transaction would be allowed into the blockchain, making\n        // the opcode ineffective.\n        //\n        // Testing if this vin is not final is sufficient to\n        // prevent this condition. Alternatively we could test all\n        // inputs, but testing just this input minimizes the data\n        // required to prove correct CHECKLOCKTIMEVERIFY execution.\n        if (txTo.vin[nIn].IsFinal())\n            return false;\n\n        break;\n\n    }\n\nhttps://github.com/petertodd/bitcoin/commit/ab0f54f38e08ee1e50ff72f801680ee84d0f1bf4\n\n\n==Deployment==\n\nWe reuse the double-threshold IsSuperMajority() switchover mechanism used in\nBIP66 with the same thresholds, but for nVersion = 4. The new rules are\nin effect for every block (at height H) with nVersion = 4 and at least\n750 out of 1000 blocks preceding it (with heights H-1000..H-1) also\nhave nVersion >= 4. Furthermore, when 950 out of the 1000 blocks\npreceding a block do have nVersion >= 4, nVersion < 4 blocks become\ninvalid, and all further blocks enforce the new rules.\n\nIt should be noted that BIP9 involves permanently setting a high-order bit to\n1 which results in nVersion >= all prior IsSuperMajority() soft-forks and thus\nno bits in nVersion are permanently lost.\n\n\n===SPV Clients===\n\nWhile SPV clients are (currently) unable to validate blocks in general,\ntrusting miners to do validation for them, they are able to validate block\nheaders and thus can validate a subset of the deployment rules. SPV clients\nshould reject nVersion < 4 blocks if 950 out of 1000 preceding blocks have\nnVersion >= 4 to prevent false confirmations from the remaining 5% of\nnon-upgraded miners when the 95% threshold has been reached.\n\n\n==Credits==\n\nThanks goes to Gregory Maxwell for suggesting that the argument be compared\nagainst the per-transaction nLockTime, rather than the current block height and\ntime.\n\n\n==References==\n\nPayPub\n\n* https://github.com/unsystem/paypub\n\nJeremy Spilman Payment Channels\n\n* https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html\n\n\n==Implementations==\n\nPython / python-bitcoinlib\n\n* https://github.com/petertodd/checklocktimeverify-demos\n\nJavaScript / Node.js / bitcore\n\n* https://github.com/mruddy/bip65-demos\n\n\n==Copyright==\n\nThis document is placed in the public domain.\n\n", "content_length": 13159}
{"bip_number": 64, "filename": "bip-0064.mediawiki", "content": "<pre>\n  BIP: 64\n  Layer: Peer Services\n  Title: getutxo message\n  Author: Mike Hearn <hearn@vinumeris.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0064\n  Status: Obsolete\n  Type: Standards Track\n  Created: 2014-06-10\n</pre>\n\n==Abstract==\n\nThis document describes a small P2P protocol extension that performs UTXO lookups given a set of outpoints.\n\n==Motivation==\n\nAll full Bitcoin nodes maintain a database called the unspent transaction output set. This set is\nhow double spending is checked for: to be valid a transaction must identify unspent outputs in this\nset using an identifier called an \"outpoint\", which is merely the hash of the output's containing\ntransaction plus an index.\n\nThe ability to query this can sometimes be useful for a lightweight/SPV client which does not have\nthe full UTXO set at hand. For example, it can be useful in applications implementing assurance\ncontracts to do a quick check when a new pledge becomes visible to test whether that pledge was\nalready revoked via a double spend. Although this message is not strictly necessary because e.g.\nsuch an app could be implemented by fully downloading and storing the block chain, it is useful for\nobtaining acceptable performance and resolving various UI cases.\n\nAnother example of when this data can be useful is for performing floating fee calculations in an\nSPV wallet. This use case requires some other changes to the Bitcoin protocol however, so we will\nnot dwell on it here.\n\n==Specification==\n\nTwo new messages are defined. The \"getutxos\" message has the following structure:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 1 || check mempool || bool || Whether to apply mempool transactions during the calculation, thus exposing their UTXOs and removing outputs that they spend.\n|-\n| ? || outpoints || vector<COutPoint> || The list of outpoints to be queried. Each outpoint is serialized in the same way it is in a tx message.\n|}\n\nThe response message \"utxos\" has the following structure:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 4 || chain height || uint32 || The height of the chain at the moment the result was calculated.\n|-\n| 32 || chain tip hash || uint256 || Block hash of the top of the chain at the moment the result was calculated.\n|-\n| ? || hit bitmap || byte[] || An array of bytes encoding one bit for each outpoint queried. Each bit indicates whether the queried outpoint was found in the UTXO set or not.\n|-\n| ? || result utxos || result[] || A list of result objects (defined below), one for each outpoint that is unspent (i.e. has a bit set in the bitmap).\n|}\n\nThe result object is defined as:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 4 || tx version || uint32 || The version number of the transaction the UTXO was found in.\n|-\n| 4 || height || uint32 || The height of the block containing the defining transaction, or 0x7FFFFFFF if the tx is in the mempool.\n|-\n| ? || output || CTxOut || The output itself, serialized in the same way as in a tx message.\n|}\n\n==Backward compatibility==\n\nNodes indicate support by advertising a protocol version above 70003 and by setting a new\nNODE_GETUTXO flag in their nServices field, which has a value of 2 (the second bit of the field).\n\n==Authentication==\n\nThe UTXO set is not currently authenticated by anything. There are proposals to resolve this by\nintroducing a new consensus rule that commits to a root hash of the UTXO set in blocks, however this\nfeature is not presently available in the Bitcoin protocol. Once it is, the utxos message could be\nupgraded to include Merkle branches showing inclusion of the UTXOs in the committed sets.\n\nIf the requesting client is looking up outputs for a signed transaction that they have locally, the\nclient can partly verify the returned output by running the input scripts with it. Currently this\nverifies only that the script is correct. A future version of the Bitcoin protocol is likely to also\nallow the value to be checked in this way. It does not show that the output is really unspent or was\never actually created in the block chain however. Additionally, the form of the provided scriptPubKey\nshould be checked before execution to ensure the remote peer doesn't just set the script to OP_TRUE.\n\nIf the requesting client has a mapping of chain heights to block hashes in the best chain e.g.\nobtained via getheaders, then they can obtain a proof that the output did at one point exist by\nrequesting the block and searching for the output within it. When combined with Bloom filtering this\ncan be reasonably efficient.\n\nNote that even when the outputs are being checked against something this protocol has the same\nsecurity model as Bloom filtering: a remote node can lie through omission by claiming the requested\nUTXO does not exist / was already spent (they are the same, from the perspective of a full node).\nQuerying multiple nodes and combining their answers can be a partial solution to this, although as\nnothing authenticates the Bitcoin P2P network a man in the middle could still yield incorrect\nresults.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/4351/files\n", "content_length": 5250}
{"bip_number": 62, "filename": "bip-0062.mediawiki", "content": "'''NOTICE: This document is a work in progress and is not complete, implemented, or otherwise suitable for deployment.'''\n\n<pre>\n  BIP: 62\n  Layer: Consensus (soft fork)\n  Title: Dealing with malleability\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0062\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2014-03-12\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document specifies proposed changes to the Bitcoin transaction validity rules in order to make malleability of transactions impossible (at least when the sender doesn't choose to avoid it).\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nAs of february 2014, Bitcoin transactions are malleable in multiple ways. This means a (valid) transaction can be modified in-flight, without invalidating it, but without access to the relevant private keys.\n\nThis is a problem for multiple reasons:\n* The sender may not recognize his own transaction after being modified.\n* The sender may create transactions that spend change created by the original transaction. In case the modified transaction gets mined, this becomes invalid.\n* Modified transactions are effectively double-spends which can be created without malicious intent (of the sender), but can be used to make other attacks easier.\n\nSeveral sources of malleability are known:\n\n# '''Non-DER encoded ECDSA signatures''' Right now, the Bitcoin reference client uses OpenSSL to validate signatures. As OpenSSL accepts more than serializations that strictly adhere to the DER standard, this is a source of malleability. Since v0.8.0, non-DER signatures are no longer relayed already.\n# '''Non-push operations in scriptSig''' Any sequence of script operations in scriptSig that results in the intended data pushes, but is not just a push of that data, results in an alternative transaction with the same validity.\n# '''Push operations in scriptSig of non-standard size type''' The Bitcoin scripting language has several push operators (OP_0, single-byte pushes, data pushes of up to 75 bytes, OP_PUSHDATA1, OP_PUSHDATA2, OP_PUSHDATA4). As the latter ones have the same result as the former ones, they result in additional possibilities.\n# '''Zero-padded number pushes''' In cases where scriptPubKey opcodes use inputs that are interpreted as numbers, they can be zero padded.\n# '''Inherent ECDSA signature malleability''' ECDSA signatures themselves are already malleable: taking the negative of the number S inside (modulo the curve order) does not invalidate it.\n# '''Superfluous scriptSig operations''' Adding extra data pushes at the start of scripts, which are not consumed by the corresponding scriptPubKey, is also a source of malleability.\n# '''Inputs ignored by scripts''' If a scriptPubKey starts with an OP_DROP, for example, the last data push of the corresponding scriptSig will always be ignored.\n# '''Sighash flags based masking''' Sighash flags can be used to ignore certain parts of a script when signing.\n# '''New signatures by the sender''' The sender (or anyone with access to the relevant private keys) is always able to create new signatures that spend the same inputs to the same outputs.\nThe first six and part of the seventh can be fixed by extra consensus rules, but the last two can't. Not being able to fix #7 means that even with these new consensus rules, it will always be possible to create outputs whose spending transactions will all be malleable. However, when restricted to using a safe set of output scripts, extra consensus rules can make spending transactions optionally non-malleable (if the spender chooses to; as he can always bypass #8 and #9 himself).\n\n==Specification==\n\n===New rules===\n\nSeven extra rules are introduced, to combat exactly the seven first sources of malleability listed above:\n# '''Canonically encoded ECDSA signatures''' An ECDSA signature passed to OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG or OP_CHECKMULTISIGVERIFY must be encoded using strict DER encoding. To provide a compact way to deliberately create an invalid signature for OP_CHECKSIG and OP_CHECKMULTISIG, an empty byte array (i.e., the result of OP_0) is also allowed. Doing a verification with a non-DER signature makes the entire script evaluate to False (not just the signature verification). See reference: [[#der-encoding|DER encoding]].\n# '''Non-push operations in scriptSig''' Only data pushes are allowed in scriptSig. Evaluating any other operation makes the script evaluate to false. See reference: [[#push-operators|Push operators]].\n# '''Push operations in scriptSig of non-standard size type''' The smallest possible push operation must be used when possible. Pushing data using an operation that could be encoded in a shorter way makes the script evaluate to false. See reference: [[#push-operators|Push operators]].\n# '''Zero-padded number pushes''' Any time a script opcode consumes a stack value that is interpreted as a number, it must be encoded in its shortest possible form. 'Negative zero' is not allowed. See reference: [[#numbers|Numbers]].\n# '''Inherent ECDSA signature malleability''' We require that the S value inside ECDSA signatures is at most the curve order divided by 2 (essentially restricting this value to its lower half range). See reference: [[#low-s-values-in-signatures|Low S values in signatures]].\n# '''Superfluous scriptSig operations''' scriptPubKey evaluation will be required to result in a single non-zero value. If any extra data elements remain on the stack, the script evaluates to false.\n# '''Inputs ignored by scripts''' The (unnecessary) extra stack element consumed by OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY must be the empty byte array (the result of OP_0). Anything else makes the script evaluate to false.\n\n===Block validity===\n\nTo introduce these new rules in the network, we add both v3 blocks and v3 transactions. v2 is skipped for transactions to keep the version numbers between transaction and block rules in sync. v2 transactions are treated identically to v1 transactions.\nThe same mechanism as in BIP 0034 is used to introduce v3 blocks. When 75% of the past 1000 blocks are v3, a new consensus rule is activated:\n* All transactions in v3 blocks are required to follow rules #1-#2.\n* v3 (and higher) transactions in v3 blocks are required to follow rules #3-#7 as well.\n\nWhen 95% of the past 1000 blocks are v3 or higher, v2 blocks become invalid entirely. Note however that v1 (and v2) transactions remain valid forever.\n\n===References===\n\nBelow is a summary of the effects on signatures, their encoding and data pushes.\n\n====Low S values in signatures====\n\nThe value S in signatures must be between 0x1 and 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0 (inclusive). If S is too high, simply replace it by S' = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S.\n\nSignatures produced by the OpenSSL library are not guaranteed to be consistent with this constraint. Version 0.9.3 of the reference client provides [https://github.com/bitcoin/bitcoin/blob/v0.9.3/src/key.cpp#L202-L227 an example] for detection and correction.\n\nThe constraints on the value R are unchanged w.r.t. ECDSA, and values can be between 0x1 and 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140 (inclusive).\n\n====DER encoding====\nFor reference, here is how to encode signatures correctly in DER format.\n\n0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S] [sighash-type]\n* total-length: 1-byte length descriptor of everything that follows, excluding the sighash byte.\n* R-length: 1-byte length descriptor of the R value that follows.\n* R: arbitrary-length big-endian encoded R value. It cannot start with any 0x00 bytes, unless the first byte that follows is 0x80 or higher, in which case a single 0x00 is required.\n* S-length: 1-byte length descriptor of the S value that follows.\n* S: arbitrary-length big-endian encoded S value. The same rules apply as for R.\n* sighash-type: 1-byte hashtype flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed).\nThis is already enforced by the reference client as of version 0.8.0 (only as relay policy, not as a consensus rule).\n\nThis rule, combined with the low S requirement above, results in S-length being at most 32 (and R-length at most 33), and the total signature size being at most 72 bytes (and on average 71.494 bytes).\n\n====Push operators====\n\n* Pushing an empty byte sequence must use OP_0.\n* Pushing a 1-byte sequence of byte 0x01 through 0x10 must use OP_n.\n* Pushing the byte 0x81 must use OP_1NEGATE.\n* Pushing any other byte sequence up to 75 bytes must use the normal data push (opcode byte n, with n the number of bytes, followed n bytes of data being pushed).\n* Pushing 76 to 255 bytes must use OP_PUSHDATA1.\n* Pushing 256 to 520 bytes must use OP_PUSHDATA2.\n* OP_PUSHDATA4 can never be used, as pushes over 520 bytes are not allowed, and those below can be done using other operators.\n* Any other operation is not considered to be a push.\n\n====Numbers====\n\nThe native data type of stack elements is byte arrays, but some operations interpret arguments as integers. The used encoding is little endian with an explicit sign bit (the highest bit of the last byte). The shortest encodings for numbers are (with the range boundaries encodings given in hex between ()).\n* 0: OP_0; (00)\n* 1..16: OP_1..OP_16; (51)..(60)\n* -1: OP_1NEGATE; (79)\n* -127..-2 and 17..127: normal 1-byte data push; (01 FF)..(01 82) and (01 11)..(01 7F)\n* -32767..-128 and 128..32767: normal 2-byte data push; (02 FF FF)..(02 80 80) and (02 80 00)..(02 FF 7F)\n* -8388607..-32768 and 32768..8388607: normal 3-byte data push; (03 FF FF FF)..(03 00 80 80) and (03 00 80 00)..(03 FF FF 7F)\n* -2147483647..-8388608 and 8388608..2147483647: normal 4-byte data push; (04 FF FF FF FF)..(04 00 00 80 80) and (04 00 00 80 00)..(04 FF FF FF 7F)\n* Any other numbers cannot be encoded.\n\nIn particular, note that zero could be encoded as (01 80) (negative zero) if using the non-shortest form is allowed.\n\n==Compatibility==\n\n'''Relay of transactions''' A new node software version is released which makes v3 transactions standard, and relays them when their scriptSigs satisfy the above rules. Relaying of v1 transactions is unaffected. A v1 transaction spending an output created by a v3 transaction is also unaffected.\n\n'''Wallet updates''' As v3 transactions are non-standard currently, it is not possible to start creating them immediately. Software can be checked to confirm to the new rules of course, but using v3 should only start when a significant part of the network's nodes has upgraded to compatible code. Its intended meaning is \"I want this transaction protected from malleability\", and remains a choice of the wallet software.\n", "content_length": 10894}
{"bip_number": 61, "filename": "bip-0061.mediawiki", "content": "<pre>\n  BIP: 61\n  Layer: Peer Services\n  Title: Reject P2P message\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: Controversial; some recommendation, and some discouragement\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0061\n  Status: Final\n  Type: Standards Track\n  Created: 2014-06-18\n</pre>\n\n==Abstract==\n\nThis BIP describes a new message type for the Bitcoin peer-to-peer network.\n\n==Motivation==\n\nGiving peers feedback about why their blocks or transactions are rejected, or\nwhy they are being banned for not following the protocol helps\ninteroperability between different implementations.\n\nIt also gives SPV (simplified payment verification) clients a hint that something\nmay be wrong when their transactions are rejected due to insufficient priority\nor fees.\n\n==Specification==\n\nData types in this specification are as described at https://en.bitcoin.it/wiki/Protocol_specification\n\n===reject===\n\nOne new message type \"reject\" is introduced. It is sent directly to a peer in response to a \"version\", \"tx\" or \"block\" message.\n\nFor example, the message flow between two peers for a relayed transaction that is rejected for some reason would be:\n\n --> inv\n <-- getdata\n --> tx\n <-- reject\n\nAll implementations of the P2P protocol version 70,002 and later should support the reject message.\n\n====common payload====\n\n\nEvery reject message begins with the following fields. Some messages append extra, message-specific data.\n\n{|\n| Field Size || Name || Data type || Comments\n|-\n| variable || response-to-msg || var_str || Message that triggered the reject\n|-\n| 1 || reject-code || uint8_t || 0x01 through 0x4f (see below)\n|-\n| variable || reason || var_string || Human-readable message for debugging\n|}\n\nThe human-readable string is intended only for debugging purposes; in particular, different implementations may\nuse different strings. The string should not be shown to users or used for anything besides diagnosing\ninteroperability problems.\n\nThe following reject code categories are used; in the descriptions below, \"server\" is the peer generating\nthe reject message, \"client\" is the peer that will receive the message.\n\n{|\n| Range || Category\n|-\n| 0x01-0x0f || Protocol syntax errors\n|-\n| 0x10-0x1f || Protocol semantic errors\n|-\n| 0x40-0x4f || Server policy rule\n|}\n\n==== rejection codes common to all message types ====\n\n{|\n| Code || Description\n|-\n| 0x01 || Message could not be decoded\n|}\n\n==== reject version codes ====\n\nCodes generated during the initial connection process in response to a \"version\" message:\n\n{|\n| Code || Description\n|-\n| 0x11 || Client is an obsolete, unsupported version\n|-\n| 0x12 || Duplicate version message received\n|}\n\n==== reject tx payload, codes ====\n\nTransaction rejection messages extend the basic message with the transaction id hash:\n\n{|\n| Field Size || Name || Data type || Comments\n|-\n| 32 || hash || char[32] || transaction that is rejected\n|}\n\nThe following codes are used:\n\n{|\n| Code || Description\n|-\n| 0x10 || Transaction is invalid for some reason (invalid signature, output value greater than input, etc.)\n|-\n| 0x12 || An input is already spent\n|-\n| 0x40 || Not mined/relayed because it is \"non-standard\" (type or version unknown by the server)\n|-\n| 0x41 || One or more output amounts are below the 'dust' threshold\n|-\n| 0x42 || Transaction does not have enough fee/priority to be relayed or mined\n|}\n\n==== payload, reject block ====\n\nBlock rejection messages extend the basic message with the block header hash:\n\n{|\n| Field Size || Name || Data type || Comments\n|-\n| 32 || hash || char[32] || block (hash of block header) that is rejected\n|}\n\nRejection codes:\n\n{|\n| code || description\n|-\n| 0x10 || Block is invalid for some reason (invalid proof-of-work, invalid signature, etc)\n|-\n| 0x11 || Block's version is no longer supported\n|-\n| 0x43 || Inconsistent with a compiled-in checkpoint\n|}\n\nNote: blocks that are not part of the server's idea of the current best chain, but are otherwise valid, should not trigger reject messages.\n\n== Compatibility ==\n\nThe reject message is backwards-compatible; older peers that do not recognize the reject message will ignore it.\n\n== Implementation notes ==\n\nImplementers must consider what happens if an attacker either sends them\nreject messages for valid transactions/blocks or sends them random\nreject messages, and should beware of possible denial-of-service attacks.\nFor example, notifying the user of every reject message received\nwould make it trivial for an attacker to mount an annoy-the-user attack.\nEven merely writing every reject message to a debugging log could make\nan implementation vulnerable to a fill-up-the-users-disk attack.\n", "content_length": 4683}
{"bip_number": 60, "filename": "bip-0060.mediawiki", "content": "<pre>\n  BIP: 60\n  Layer: Peer Services\n  Title: Fixed Length \"version\" Message (Relay-Transactions Field)\n  Author: Amir Taaki <genjix@riseup.net>\n  Comments-Summary: Discouraged for implementation (one person)\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0060\n  Status: Rejected\n  Type: Standards Track\n  Created: 2013-06-16\n  License: PD\n</pre>\n\n==Abstract==\n\n[[BIP 0037]] introduced a new flag to version messages which says whether to relay new transaction messages to that node.\n\nThe protocol version was upgraded to 70001, and the (now accepted) BIP 0037 became implemented.\n\nThe implementation is problematic because the RelayTransactions flag is an optional part of the version message stream.\n\n==Motivation==\n\nOne property of Bitcoin messages is their fixed number of fields. This keeps the format simple and easily understood. Adding optional fields to messages will cause deserialisation issues when other fields come after the optional one.\n\nAs an example, the length of version messages might be checked to ensure the byte stream is consistent. With optional fields, this checking is no longer possible. This is desirable to check for consistency inside internal deserialization code, and proper formatting of version messages originating from other nodes. In the future with diversification of the Bitcoin network, it will become desirable to enforce this kind of strict adherence to standard messages with field length compliance with every protocol version.\n\nAnother property of fixed-length field messages is the ability to pass stream operators around for deserialization. This property is also lost, as now the deserialisation code must know the remaining length of bytes to parse. The parser now requires an additional piece of information (remaining size of the stream) for parsing instead of being a dumb reader.\n\n==Specification==\n=== version ===\n\nWhen a node creates an outgoing connection, it will immediately advertise its version. The remote node will respond with its version. No further communication is possible until both peers have exchanged their version.\n\nPayload:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 4 || version || int32_t || Identifies protocol version being used by the node\n|-\n| 8 || services || uint64_t || bitfield of features to be enabled for this connection\n|-\n| 8 || timestamp || int64_t || standard UNIX timestamp in seconds\n|-\n| 26 || addr_recv || net_addr || The network address of the node receiving this message\n|-\n|colspan=\"4\"| version >= 106\n|-\n| 26 || addr_from || net_addr || The network address of the node emitting this message\n|-\n| 8 || nonce || uint64_t || Node random nonce, randomly generated every time a version packet is sent. This nonce is used to detect connections to self.\n|-\n| ? || user_agent || var_str || [[bip-0014.mediawiki|User Agent]] (0x00 if string is 0 bytes long)\n|-\n| 4 || start_height || int32_t || The last block received by the emitting node\n|-\n| 1 || relay || bool || Whether the remote peer should announce relayed transactions or not, see [[bip-0037.mediawiki|BIP 0037]], since version >= 70001\n|}\n\nA \"verack\" packet shall be sent if the version packet was accepted.\n\nThe following services are currently assigned:\n\n{|class=\"wikitable\"\n! Value !! Name !! Description\n|-\n| 1 || NODE_NETWORK || This node can be asked for full blocks instead of just headers.\n|}\n\n=== Code Updates ===\n\nfRelayTx is added to the PushMessage() call inside PushVersion() (net.cpp)\n\n<pre>\nvoid CNode::PushVersion()\n{\n    /// when NTP implemented, change to just nTime = GetAdjustedTime()\n    int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n    CAddress addrMe = GetLocalAddress(&addr);\n    RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n    printf(\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n    PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()),\n                nBestHeight, true);\n}\n</pre>\n\nAdditionally the protocol version is increased from 70001 to 70002.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 4460}
{"bip_number": 53, "filename": "bip-0053.mediawiki", "content": "<pre>\n  BIP: 53\n  Layer: Consensus (soft fork)\n  Title: Disallow 64-byte transactions\n  Author: Chris Stewart <stewart.chris1234@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0053\n  Status: Draft\n  Type: Standards Track\n  Created: 2025-04-11\n  License: BSD-3-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes the rationale for disallowing transactions that are serialized to 64 bytes without the transaction's witness.\nWe describe the weaknesses to the Merkle tree included in Bitcoin block headers, and various exploits for those weaknesses.\n\n==Specification==\n\nThis BIP disallows Bitcoin transactions that are serialized to 64 bytes in length without their witness.\n\n==Motivation==\n\nBitcoin block headers include a commitment to the set of transactions in a given\nblock, which is implemented by constructing a Merkle tree of transaction ids\n(double-SHA256 hash of a transaction) and including the root of the tree in the\nblock header. This in turn allows for proving to a Bitcoin light client that a\ngiven transaction is in a given block by providing a path through the tree to the\ntransaction. However, Bitcoin\u2019s particular construction of the Merkle tree has\nseveral security weaknesses, including at least two forms of block malleability\nthat have an impact on the consensus logic of Bitcoin Core, and an attack on\nlight clients, where an invalid transaction could be \u201dproven\u201d to appear in a block\nby doing substantially less work than a SHA256 hash collision would require.\nThis has been mitigated by Bitcoin Core's relay policy and the RPC interface since 2018<ref>[https://github.com/bitcoin/bitcoin/pull/11423/commits/7485488e907e236133a016ba7064c89bf9ab6da3 PR #11423 disallows transactions that are less than 82 bytes in size from Bitcoin Core relay and RPC interface]</ref><ref>[https://github.com/bitcoin/bitcoin/commit/8c5b3646b5afe8a61f5c66478d8e11f0d2ce5108 Reduces the minimum transaction size required for a transaction to be considered standard from 82 bytes to 65 bytes]</ref>.\n\n=== Block malleability ===\n\n64-byte transactions introduce block malleability. Malicious peers can construct consensus valid and invalid 64-byte\ntransactions that have the same serialization as the concatenation of 2 hashes in the Merkle tree.\n\nAssume we have a valid Bitcoin block with 2 transactions in it with Txid<sub>0</sub> and Txid<sub>1</sub>.\nThe Merkle root for this block is H(Txid<sub>0</sub>||Txid<sub>1</sub>).\nA malicious user could find a 64-byte transaction T<sub>m</sub> that serializes to Txid<sub>0</sub>||Txid<sub>1</sub>.\nNext that user relays the block containing the malicious T<sub>m</sub> rather than the\nvalid Bitcoin transactions that correspond to Txid<sub>0</sub> and Txid<sub>1</sub>.\n\n==== Block malleability with consensus INVALID transactions ====\n\nThe peer receiving the malicious block marks the block as invalid, as T<sub>m</sub>\nis not a valid transaction according to network consensus rules.\nOther peers on the network receive the valid block containing T<sub>0</sub> and T<sub>1</sub>\nand add the block to their blockchain. Peers that receive the invalid block before the valid block\nwill never come to consensus with their peers due to the malicious user finding a collision\nwithin the block's Merkle root. Finding this collision is approximately 22 bits worth of work.<ref>[[bip-0053/2-BitcoinMerkle.pdf|to produce a block having a Merkle root that\nis a hash of a 64-byte quantity that deserializes validly, it\u2019s enough\nto just do 8 bits of work to find a workable coinbase (which will hash to the first\n32 bytes), plus another \u224822 bits of work ((1/5) \u2217224, so slightly less) to find\na workable second transaction that will hash to the second 32 bytes)\u2013 a very\nsmall amount of computation.]]</ref>\n\nThis attack vector was fixed in Bitcoin Core 0.6.2<ref>[https://bitcoin.org/en/alert/2012-05-14-dos#risks CVE-2012-2459]</ref>, re-introduced in 0.13.x<ref>[https://github.com/bitcoin/bitcoin/pull/7225 #7225]</ref> and patched again in\n0.14<ref>[https://github.com/bitcoin/bitcoin/pull/9765 #9765]</ref>.\n\n==== Block malleability with consensus VALID transactions ====\n\nProducing a valid Bitcoin transaction T<sub>m</sub> that adheres to network consensus\nrules requires 224 bits of work<ref>[[bip-0053/2-BitcoinMerkle.pdf|Note that the first transaction in a block must be a coinbase, and as discussed\nabove, that largely constrains the first 32 bytes of the first transaction: only\nthe 4 version bytes are unconstrained. So it would take at least 28*8= 224 bits\nof work to find the first node in a given row of the tree that would match the\nfirst half of a coinbase, in addition to the amount of work required to grind the\nsecond half of the transaction to something meaningful (which is much easier \u2013\nonly 16 bytes or so are constrained, so approximately 128 bits of work to find a collision). Of course, any of the rows in the Merkle tree could be used, but it nevertheless seems clear that this should be computationally infeasible.]]</ref>.\nThis is computationally and financially expensive but theoretically possible. This can lead to a persistent chain split on the network.\n\n=== Attack on SPV clients ===\n\nBIP37<ref>[https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki BIP37]</ref>provides a partial Merkle tree format<ref>[https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#partial-merkle-branch-format Partial Merkle Tree Format]</ref>\nthat allows you to verify that your Bitcoin transaction is included in a Merkle root embedded in a Bitcoin block header.\nNotably this format does not commit to the height of the Merkle tree.\n\nSuppose a (valid) 64-byte transaction T is included in a block with the property that the second 32 bytes (which\nare less constrained than the first 32 bytes) are constructed so that they collide\nwith the hash of some other fake, invalid transaction F. The attacker can fool the SPV client into believing that F\nwas included in a Bitcoin block rather than T with 81 bits<ref>[[bip-0053/2-BitcoinMerkle.pdf|An attacker who can do 81 bits of work (followed by another 40 bits of work, to\nconstruct the funding transaction whose coins will be spent by this one) is able\nto fool an SPV client in this way.]]</ref> of work. Disallowing 64-byte transactions reduces implementation complexity for SPV wallets<ref>[https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/43 The steps needed to make sure a Merkle proof for a 64-byte transaction is secure.]</ref>.\n\n==Rationale==\n\n===SPV clients===\n\nAttacks on SPV clients could be mitigated by knowing the depth of the Merkle tree. Requiring SPV clients to request both the coinbase and payment transaction could mitigate this attack.\nTo produce a valid coinbase transaction at the same depth that our fake transaction F occurs at would require 224 bits of work.\nAs mentioned above, this is computationally and financially expensive, but theoretically possible. This design would increase the size\nof SPV proofs by 70%.<ref>[https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/29 Base proof: 80-byte header + 448-byte partial Merkle tree = 528 bytes. Proof with coinbase tx, assuming the coinbase tx is in the left half of the tree and the tx to prove is in the right half of the tree: 80-byte header + 416 bytes partial Merkle tree for coinbase tx + 416 bytes partial Merkle tree for tx = 912 bytes.]</ref>\n\n==Backward compatibility==\n\nThere have been 5 64-byte transactions that have occurred in the Bitcoin blockchain as of this\nwriting <ref>[[bip-0053/64byte-tx-mainnet.txt|64-byte transactions in the Bitcoin blockchain]]</ref>\nwith the last transaction 7f2efc6546011ad3227b2da678be0d30c7f4b08e2ce57b5edadd437f9e27a612<ref>[https://mempool.space/tx/7f2efc6546011ad3227b2da678be0d30c7f4b08e2ce57b5edadd437f9e27a612 Last 64-byte transaction in the Bitcoin blockchain]</ref>\noccurring at block height 419,606<ref>[https://mempool.space/block/000000000000000000308f1efc24419f34a3bafcc2b53c32dd57e4502865fd84 Block 419,606]</ref>.\n\n====Pre-segwit 64-byte transactions====\n\nPre-segwit 64-byte transactions cannot spend a UTXO protected by a digital signature.<ref>[https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki After BIP66 was activated on the Bitcoin network, Bitcoin transactions cannot have a digital signature smaller than 9 bytes.]</ref>\nThe largest scriptSig a pre-segwit 64-byte transaction can have is 4 bytes.<ref>[https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/73]</ref>\n\nThere are 6<ref>[[bip-0053/non-standard-hashlock-utxos.txt|As of block `00000000000000000001194ae6be942619bf61aa70822b9643d01c1a441bf2b7` there exist 6 non-standard hashlock UTXOs that could theoretically have a 0-3 byte pre-image. None of them have a 0-3 byte pre-image.]]</ref>\nnon standard hashlock UTXOs in the Bitcoin blockchain. None of them have a 0-3 byte pre-image. This means they cannot be spent by a 64-byte transaction.\n\nPre-segwit 64-byte transactions that spend a non-standard UTXO that are inherently malleable.<ref>[https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#trust-free-unconfirmed-transaction-dependency-chain Details on how to malleate a pre-segwit transaction]</ref>\nPolicy rules such as CLEANSTACK, MINIMALDATA, PUSHONLY are not consensus rules. If a user has a way to confirm an already non-standard\n64-byte transaction - they can malleate the transaction by violating policy rules to change the size of the transaction to a size other than 64 bytes.\n\n====Segwit 64-byte transactions====\n\nThis BIP disallows single-input single-output segwit transactions that pay to a 2-byte witness program.<ref>[https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/73#p-4382-future-segwit-versions-10 BIP141 says witness programs can be 2 bytes in size, which makes the scriptPubKey a total of 4 bytes]</ref>\nThe only known use case<ref>[https://bitcoin.stackexchange.com/a/110664 Why do we have 2-byte witness programs? The original rationale for the lower end of the range of valid witness program lengths is that 2 bytes is enough to guarantee no ambiguity of how the program would be pushed (some 1-byte values can - and according to standardness, must - be pushed with OP_n, and dealing with those would have complicated the matter).]</ref>\nfor this type of transaction is ephemeral anchor outputs.<ref>[https://bitcoinops.org/en/topics/ephemeral-anchors/ What are ephemeral anchor outputs? This allows anyone on the network to use that output as the input to a child transaction. This allows anyone to create the fee-paying child, even if they don\u2019t receive any of the other outputs from the parent transaction. This allows ephemeral anchors to function as fee sponsorship but without requiring any consensus changes.]</ref>\n\n==Reference implementation==\n\n<source lang=\"cpp\">\n/**\n * We want to enforce certain rules (specifically the 64-byte transaction check)\n * before we call CheckBlock to check the Merkle root. This allows us to enforce\n * malleability checks which may interact with other CheckBlock checks.\n * This is currently called both in AcceptBlock prior to writing the block to\n * disk and in ConnectBlock.\n * Note that as this function is called before merkle-tree checks, it must never return a\n * non-malleable error condition.\n */\nstatic bool ContextualBlockPreCheck(const CBlock& block, BlockValidationState& state, const ChainstateManager& chainman, const CBlockIndex* pindexPrev)\n{\n    if (DeploymentActiveAfter(pindexPrev, chainman, Consensus::DEPLOYMENT_64BYTETX)) {\n      for (const auto& tx : block.vtx) {\n            if (::GetSerializeSize(TX_NO_WITNESS(tx)) == 64) {\n                return state.Invalid(BlockValidationResult::BLOCK_MUTATED, \"64-byte-transaction\", strprintf(\"size of tx %s without witness is 64 bytes\", tx->GetHash().ToString()));\n            }\n        }\n    }\n\n    return true;\n}\n</source>\n\nThe sample implementation is currently open here:\n\nhttps://github.com/bitcoin-inquisition/bitcoin/pull/24/files\n\n<references />\n\n==Copyright==\nThis BIP is licensed under the [https://opensource.org/license/BSD-3-Clause BSD-3-Clause License].\n\n==Acknowledgements==\n\nSuhas Daftuar, AJ Towns, Sergio Demian Lerner, Greg Maxwell, Matt Corallo, Antoine Poinsot, Dave Harding and Eric Voskuil\n", "content_length": 12281}
{"bip_number": 52, "filename": "bip-0052.mediawiki", "content": "<pre>\n  BIP: 52\n  Layer: Consensus (hard fork)\n  Title: Durable, Low Energy Bitcoin PoW\n  Author: Michael Dubrovsky <mike+bip@powx.org>\n          Bogdan Penkovsky <bogdan+bip@powx.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0052\n  Status: Draft\n  Type: Standards Track\n  Created: 2021-05-13\n  License: BSD-2-Clause\n           OPL\n</pre>\n\n\n== Simple Summary ==\n\nBitcoin's energy consumption is growing with its value (see Figure below).\nAlthough scaling PoW is necessary to maintain the security of the network,\nreliance on massive energy consumption has scaling drawbacks and leads to mining\ncentralization. A major consequence of the central role of local electricity\ncost in mining is that today, most existing and potential participants in the\nBitcoin network cannot profitably mine Bitcoin even if they have the capital to\ninvest in mining hardware. From a practical perspective, Bitcoin adoption by\ncompanies like Tesla (which recently rescinded its acceptance of Bitcoin as\npayment) has been hampered by its massive energy consumption and perceived\nenvironmental impact.\n\n<img src=\"bip-0052/btc_energy-small.png\"></img>\n\nFigure. Bitcoin price and estimated Bitcoin energy consumption.\nData sources: [https://cbeci.org Cambridge Bitcoin Electricity Consumption Index], [https://www.coindesk.com CoinDesk].\n\nWe propose a novel proof-of-work paradigm for Bitcoin--Optical proof-of-work. It\nis designed to decouple Bitcoin mining from energy and make it feasible outside\nof regions with low electricity costs. ''Optical proof-of-work'' (oPoW) is a\nmodification of Hashcash that is most efficiently computed using a new class of\nphotonic processors. Without compromising the cryptographic or game-theoretical\nsecurity of Hashcash, oPoW shifts the operating expenses of mining (OPEX), to\ncapital expenses (CAPEX)--i.e. electricity to hardware. oPoW makes it possible\nfor billions of new miners to enter the market simply by investing in a\nlow-energy photonic miner. Shifting to a high-CAPEX PoW has the added benefit of\nmaking the hashrate resilient to Bitcoin's price fluctuations - once low-OPEX\nhardware is operating there is no reason to shut it down even if the value of\nmining rewards diminishes. oPoW is hardware-compatible with GPUs, FPGAs, and\nASICs meaning that a transitional period of optical and traditional hardware\nmining in parallel on the network is feasible\n\nMore information is available here: [https://www.powx.org/opow].\n\n== Abstract ==\n\nAs Bitcoin gained utility and value over the preceding decade, the network incentivized the purchase of billions of dollars in mining equipment and electricity. With the growth of competition, home mining became unprofitable. Even the most sophisticated special-purpose hardware (ASIC miners) doesn\u2019t cover its energy costs unless the miner also has direct access to very cheap electricity. This heavy reliance on energy makes it difficult for new miners to enter the market and leads to hashrate instability as miners shut off their machines when the price of Bitcoin falls. Additionally as the network stores ever more value, the percentage of world energy consumption that is associated with Bitcoin continues to grow, creating the potential for scaling failure and a general backlash. To ensure that Bitcoin can continue scaling and reach its full potential as a world currency and store of value, we propose a low-energy proof-of-work paradigm for Bitcoin. ''Optical proof of work (oPoW)'' is designed to decouple Bitcoin\u2019s security from massive energy use and make bitcoin mining feasible outside of regions with low electricity costs. ''Optical proof-of-work'' is a modification of Hashcash that is most efficiently computed using a new class of photonic processors that has emerged as a leading solution for ultra-low energy computing over the last 5 years. oPoW shifts the operating expenses of mining (OPEX), to capital expenses (CAPEX)\u2013i.e.\u00a0electricity to hardware, without compromising the cryptographic or game-theoretical security of Hashcash. We provide an example implementation of oPoW, briefly discuss its cryptographic construction as well as the working principle of photonic processors. Additionally, we outline the potential benefits of oPoW to the bitcoin network, including geographic decentralization and democratization of mining as well as hashrate resilience to price fluctuations.\n\n== Copyright ==\n\nThis BIP is dual-licensed under the Open Publication License and BSD 2-clause license.\n\n== Motivation ==\n\nAs Bitcoin has grown over the past decade from a small network run by hobbyists to a global currency, the underlying Proof of Work protocol has not been updated. Initially pitched as a global decentralized network (\u201cone CPU-one vote\u201d), Bitcoin transactions today are secured by a small group of corporate entities. In practice, it is only feasible for [http://archive.is/YeDwh entities that can secure access to abundant, inexpensive energy]. The economics of mining limit profitability to places like Iceland, Texas, or Western China. Besides the negative environmental externalities, which may be significant, mining today is performed primarily with the consent (and in many cases, partnership) of large public utilities and the governments that control them. Although this may not be a problem in the short term, in the long term it stands to erode the censorship resistance and security of Bitcoin and other public blockchains through potential regulation or [https://arxiv.org/pdf/1605.07524.pdf partitioning attacks].\n\nRecent events, such as the [https://twitter.com/MustafaYilham/status/1384278267067203590 ~25% hashrate crash due to coal-powered grid failure in china] and Tesla\u2019s rescinding of its acceptance of Bitcoin as a form of payment, show that there are practical real-world downsides to Proof of Works\u2019s massive reliance on energy.\n\n<img src=\"bip-0052/emusk_tweet.png\"></img>\n\nWhether or not the Bitcoin community accepts this common criticism as entirely valid, it has real-world effects which will only get worse over time. Eliminating the exponentially growing energy use currently built into Bitcoin without eliminating the security of PoW would be ideal and should not be a partisan issue.\n\nNew consensus mechanisms have been proposed as a means of securing cryptocurrencies whilst reducing energy cost, such as various forms of Proof of Stake and Proof of Space-Time. While many of these alternative mechanisms offer compelling guarantees, they generally require new security assumptions, which have not been stress-tested by live deployments at any adequate scale. Consequently, we still have relatively little empirical understanding of their safety. Completely changing the Bitcoin paradigm is likely to introduce new unforeseen problems. We believe that the major issues discussed above can be resolved by improving rather than eliminating Bitcoin\u2019s fundamental security layer\u2014Proof of Work. Instead of devising a new consensus architecture to fix these issues, it is sufficient to shift the economics of PoW. The financial cost imposed on miners need not be primarily composed of electricity. The situation can be significantly improved by reducing the operating expense (OPEX)\u2014energy\u2014as a major mining component. Then, by shifting the cost towards capital expense (CAPEX)\u2014mining hardware\u2014the dynamics of the mining ecosystem becomes much less dependent on electricity prices, and much less electricity is consumed as a whole.\n\nMoreover, a reduction in energy consumption automatically leads to\ngeographically distributed mining, as mining becomes profitable even in regions\nwith expensive electricity. Additionally, lower energy consumption will\neliminate heating issues experienced by today\u2019s mining operations, which will\nfurther decrease operating cost as well as noise associated with fans and\ncooling systems. All of this means that individuals and smaller entities would\nbe able to enter the mining ecosystem simply for the cost of a miner, without\nfirst gaining access to cheap energy or a dedicated, temperature-controlled data\ncenter. To a degree, memory-hard PoW schemes like\n[https://github.com/tromp/cuckoo Cuckoo Cycle], which increase the use of SRAM\nin lieu of pure computation, push the CAPEX/OPEX ratio in the right direction by\noccupying ASIC chip area with memory. To maximize the CAPEX to OPEX ratio of the\nOptical Proof of Work algorithm, we developed\n[https://assets.pubpub.org/xi9h9rps/01581688887859.pdf ''HeavyHash''] [1].\nHeavyHash is a cryptographic construction that takes the place of SHA256 in\nHashcash. Our algorithm is hardware-compatible with ultra-energy-efficient photonic co-processors that have been developed for machine learning hardware accelerators.\n\nHeavyHash uses a proven digital hash (SHA3) packaged with a large amount of MAC (Multiply-and-Accumulate) computation into a Proof of Work puzzle. Although HeavyHash can be computed on any standard digital hardware, it becomes hardware efficient only when a small digital core is combined with a low-power photonic co-processor for performing MAC operations. oPoW mining machines will have a small digital core flip-chipped onto a large, low-power photonic chip. This core will be bottlenecked by the throughput of the digital to analog and analog to digital converters. A prototype of such analogue optical matrix multiplier can be seen in the figure below.\n\n<img src=\"bip-0052/optical_chip.png\"></img>\n\nFigure. TOP: Photonic Circuit Diagram, A. Laser input (1550nm, common telecom wavelength) B. Metal pads for controlling modulators to transduce electrical data to optical C. Metal pads for tuning mesh of directional couplers D. Optical signal exits here containing the results of the computation and is output to fibers via a grating coupler the terminus of each waveguide. E. Alignment circuit for aligning fiber coupling stage. Bottom: a photograph of a bare oPoW miner prototype chip before wire and fiber bonding. On the right side of the die are test structures (F).\n\nThe ''HeavyHash'' derives its name from the fact that it is bloated or weighted with additional computation. This means that a cost comparable oPoW miner will have a much lower nominal hashrate compared to a Bitcoin ASIC (HeavyHashes/second vs.\u00a0SHA256 Hashes/second in equivalent ASIC). We provide the cryptographic security argument of the HeavyHash function in Section 3 in [https://assets.pubpub.org/xi9h9rps/01581688887859.pdf Towards Optical Proof of Work] [1]. In the article, we also provide a game-theoretic security argument for CAPEX-heavy PoW. For additional information, we recommend reading [https://uncommoncore.co/wp-content/uploads/2019/10/A-model-for-Bitcoins-security-and-the-declining-block-subsidy-v1.02.pdf this article].\n\nWhile traditional digital hardware relies on electrical currents, optical\ncomputing uses light as the basis for some of or all of its operations. Building\non the development and commercialization of silicon photonic chips for telecom\nand datacom applications, modern photonic co-processors are silicon chips made\nusing well-established and highly scalable silicon CMOS processes. However,\nunlike cutting edge electronics which require ever-smaller features (e.g.\u00a05 nm),\nfabricated by exponentially more complex and expensive machinery, silicon\nphotonics uses old fabrication nodes (90 nm). Due to the large de Broglie\nwavelength of photons, as compared to electrons, there is no benefit to using\nthe small feature sizes. The result is that access to silicon photonic wafer\nfabrication is readily available, in contrast to the notoriously difficult\nprocess of accessing advanced nodes. Moreover, the overall cost of entry is\nlower as lithography masks for silicon photonics processes are an order of\nmagnitude cheaper ($500k vs.\u00a0$5M). Examples of companies developing optical\nprocessors for AI, which will be hardware-compatible with oPoW include [https://lightmatter.co/ Lightmatter], [https://www.lightelligence.ai/ Lightelligence], [https://luminous.co/ Luminous], [https://www.intel.com/content/www/us/en/architecture-and-technology/silicon-photonics/silicon-photonics-overview.html Intel], and other more recent entrants.\n\n== Specification ==\n\n=== HeavyHash ===\n\nThe HeavyHash is performed in three stages:\n\n# Keccak hash\n# Matrix-vector multiplication\n# Keccak of the result xored with the hashed input\n\nNote that the most efficient matrix-vector multiplication is performed on a\nphotonic miner. However, this linear algebra operation can be performed on any\nconventional computing hardware (CPU, GPU, etc.), therefore making the HeavyHash\nhardware-compatible with any digital device.\n\nThe algorithm\u2019s pseudo-code:\n\n<pre>// M is a Matrix 64 x 64 of Unsigned 4 values\n\n// 256-bitVector\nx1 <- keccak(input)\n\n// Reshape the obtained bitvector\n// into a 64-vector of unsigned 4-bit values\nx2 <- reshape(x1, 64)\n\n// Perform a matrix-vector multiplication.\n// The result is 64-vector of 14-bit unsigned.\nx3 <- vector_matrix_mult(x2, M)\n\n// Truncate all values to 4 most significant bits.\n// This is due to the specifics of analog\n// computing by the photonic accelerator.\n// Obtain a 64-vector of 4-bit unsigned.\nx4 <- truncate_to_msb(x3, 4)\n\n// Interpret as a 256-bitvector\nx5 <- flatten(x4)\n\n// 256-bitVector\nresult <- keccak(xor(x5, x1))</pre>\n\nWhich in C can be implemented as:\n\n<pre>\nstatic void heavyhash(const uint16_t matrix[64][64], void* pdata, size_t pdata_len, void* output)\n{\n    uint8_t hash_first[32] __attribute__((aligned(32)));\n    uint8_t hash_second[32] __attribute__((aligned(32)));\n    uint8_t hash_xored[32] __attribute__((aligned(32)));\n\n    uint16_t vector[64] __attribute__((aligned(64)));\n    uint16_t product[64] __attribute__((aligned(64)));\n\n    sha3_256((uint8_t*) hash_first, 32, (const uint8_t*)pdata, pdata_len);\n\n    for (int i = 0; i < 32; ++i) {\n        vector[2*i] = (hash_first[i] >> 4);\n        vector[2*i+1] = hash_first[i] & 0xF;\n    }\n\n    for (int i = 0; i < 64; ++i) {\n        uint16_t sum = 0;\n        for (int j = 0; j < 64; ++j) {\n            sum += matrix[i][j] * vector[j];\n        }\n        product[i] = (sum >> 10);\n    }\n\n    for (int i = 0; i < 32; ++i) {\n        hash_second[i] = (product[2*i] << 4) | (product[2*i+1]);\n    }\n\n    for (int i = 0; i < 32; ++i) {\n        hash_xored[i] = hash_first[i] ^ hash_second[i];\n    }\n    sha3_256((uint8_t*)output, 32, (const uint8_t*)hash_xored, 32);\n}\n</pre>\n=== Random matrix generation ===\n\nThe random matrix M (which is a HeavyHash parameter) is obtained in a deterministic way and is changed every block. Matrix M coefficients are generated using a pseudo-random number generation algorithm (xoshiro) from the previous block header. If the matrix is not full rank, it is repeatedly generated again.\n\nAn example code to obtain the matrix M:\n\n<pre>\nvoid generate_matrix(uint16_t matrix[64][64], struct xoshiro_state *state) {\n    do {\n        for (int i = 0; i < 64; ++i) {\n            for (int j = 0; j < 64; j += 16) {\n                uint64_t value = xoshiro_gen(state);\n                for (int shift = 0; shift < 16; ++shift) {\n                    matrix[i][j + shift] = (value >> (4*shift)) & 0xF;\n                }\n            }\n        }\n    } while (!is_full_rank(matrix));\n}\n\nstatic inline uint64_t xoshiro_gen(struct xoshiro_state *state) {\n    const uint64_t result = rotl64(state->s[0] + state->s[3], 23) + state->s[0];\n\n    const uint64_t t = state->s[1] << 17;\n\n    state->s[2] ^= state->s[0];\n    state->s[3] ^= state->s[1];\n    state->s[1] ^= state->s[2];\n    state->s[0] ^= state->s[3];\n\n    state->s[2] ^= t;\n\n    state->s[3] = rotl64(state->s[3], 45);\n\n    return result;\n}\n</pre>\n\n== Discussion ==\n\n=== Geographic Distribution of Mining Relative to CAPEX-OPEX Ratio of Mining Costs ===\n\nBelow is a simple model showing several scenarios for the geographic distribution of mining activity relative to the CAPEX/OPEX ratio of the cost of operating a single piece of mining hardware. As the ratio of energy consumption to hardware cost decreases, geographic variations in energy cost cease to be a determining factor in miner distribution.\n\nUnderlying assumptions: 1. Electricity price y is fixed in time but varies geographically. 2. Every miner has access to the same hardware. 3. Each miner\u2019s budget is limited by both the cost of mining equipment as well as the local cost of the electricity they consume\n\nbudget = a(p+ey),\n\nwhere a is the number of mining machines, p is the machine price, e is the total energy consumption over machine lifetime, and y is electricity price.\n\nNote that in locations where mining is not profitable, hashrate is zero.\n\n<img src=\"bip-0052/sim1.png\"></img>\n\n<img src=\"bip-0052/sim2.png\"></img>\n\n<img src=\"bip-0052/sim3.png\"></img>\n\nAn interactive version of this diagram can be found [https://www.powx.org/opow here].\n\n=== Why does CAPEX to OPEX shift lead to lower energy consumption? ===\n\nA common misconception about oPoW is that it makes mining \u201ccheaper\u201d by enabling energy-efficient hardware. There is no impact on the dollar cost of mining a block, rather the mix of energy vs.\u00a0hardware investment changes from about 50/50 to 10/90 or better. We discuss this at length and rigorously in our paper[1].\n\n=== Working Principles of Photonic Processors ===\n\nPhotonics accelerators are made by fabricating waveguides in silicon using standard lithography processes. Silicon is transparent to infrared light and can act as a tiny on-chip fiber optical cable. Silicon photonics found its first use during the 2000s in transceivers for sending and receiving optical signals via fiber and has advanced tremendously over the last decade.\n\nBy encoding a vector into optical intensities passing through a series of parallel waveguides, interfering these signals in a mesh of tunable interferometers (acting as matrix coefficients), and then detecting the output using on-chip Germanium photodetectors, a matrix-vector multiplication is achieved. A generalized discussion of matrix multiplication setups using photonics/interference can be found in [https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.73.58 Reck et al.] and [https://arxiv.org/abs/1506.06220 Russell et al.] A detailed discussion of several integrated photonic architectures for matrix multiplication and corresponding tuning algorithms can be found in [https://arxiv.org/pdf/1909.06179.pdf Pai et al.]\n\nBelow is a conceptual representation of a 3D-packaged oPoW mining chip. Note that the majority of the real estate and cost comes from the photonic die and the laser, with only a small digital SHA3 die needed (as opposed to a conventional miner of the same cost, which would have many copies of this die running in parallel).\n\n<img src=\"bip-0052/optminer.png\"></img>\n\n=== Block Reward Considerations ===\n\nAlthough it is out of the scope of this proposal, the authors strongly recommend the consideration of a change in the block reward schedule currently implemented in Bitcoin. There is no clear way to incentivize miners with transaction fees only, as has been successfully shown in [https://www.cs.princeton.edu/~smattw/CKWN-CCS16.pdf On the Instability of Bitcoin Without the Block Reward] and other publications, therefore looking a decade or two ahead it will be important to implement a fixed block reward or to slow the decay of the block reward to maintain the security of the network. Given that oPoW miners have low operating costs, once a large number of machines are running the reward level sufficient to keep them in operation and providing robust security can potentially be significantly smaller than in the case of the current SHA256 ASICs securing Bitcoin.\n\n=== Implementation on the Bitcoin Network ===\n\nA hard fork is not necessarily required for the Bitcoin network to test and eventually implement oPoW. It\u2019s possible to add oPoW as a dual PoW to Bitcoin as a soft fork. Tuning the parameters to ensure that, for example, 99.9% of the security budget would be earned by miners via the SHA256 Hashcash PoW and 0.1% via oPoW would create sufficient incentive for oPoW to be stress-tested and to incentivize the manufacture of dedicated oPoW miners. If this test is successful, the parameters can be tuned continuously over time, e.g.\u00a0oPoW share doubling at every halving, such that oPoW accounts for some target percentage (up to 100% in a complete SHA256 phase-out).\n\n\n==== Reverse compatibility ====\n\nOur understanding is that oPoW will not be reverse compatible.\n\n\n=== ASICBOOST ===\n\nAny new PoW algorithm carries the risk of hardware developers discovering and patenting an architecture with a significant speedup, as happened in the case of ASICBOOST for SHA256. HeavyHash is comprised of an SHA hash and 4-bit linear matrix-vector operations. The intent is for the matrix-vector multiplications to account for the majority of the work involved in computing a single HeavyHash operation. As we show in the Minimum Effective Hardness section of Towards Optical Proof of Work[1], there is no workaround to performing the matrix operations when computing HeavyHash, and since the SHA hashes are negligible, a true ASICBOOST-type speed up would require a speed up in linear matrix processing. Since matrix-vector multiplication is at the heart of neural networks and many other common computational workloads, it has been optimized very heavily and is generally very well understood. The acceleration of matrix-vector multiplication hardware (e.g. photonic coprocessors, memristors, etc.) is a very general problem and there are dozens of companies working on it, making it very unlikely for a single party to corner the market.\n\n== Endnotes ==\n\nWith significant progress in optical and analog matrix-vector-multiplication chipsets over the last year, we hope to demonstrate commercial low-energy mining on our network in the next 6 months. The current generation of optical matrix processors under development is expected to have 10x better energy consumption per MAC operation than digital implementations, and we expect this to improve by another order of magnitude in future generations.\n\nPoWx will also be publishing the designs of the current optical miner prototypes in the near term under an open-source hardware license.\n\n== Acknowledgments ==\n\nWe thank all the members of the Bitcoin community who have already given us feedback over the last several years as well as others in the optical computing community and beyond that have given their input.\n\n\n\n\n[1] M. Dubrovsky et al.\u00a0Towards Optical Proof of Work, CES conference (2020) https://assets.pubpub.org/xi9h9rps/01581688887859.pdf\n\n[2] https://sciencex.com/news/2020-05-powering-bitcoin-silicon-photonics-power.html\n\n[3] KISS random number generator http://www.cse.yorku.ca/~oz/marsaglia-rng.html\n\n", "content_length": 22804}
{"bip_number": 50, "filename": "bip-0050.mediawiki", "content": "<pre>\n  BIP: 50\n  Title: March 2013 Chain Fork Post-Mortem\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0050\n  Status: Final\n  Type: Informational\n  Created: 2013-03-20\n  License: PD\n</pre>\n\n==What went wrong==\nA block that had a larger number of total transaction inputs than previously seen was mined and broadcasted. Bitcoin 0.8 nodes were able to handle this, but some pre-0.8 Bitcoin nodes rejected it, causing an unexpected fork of the blockchain. The pre-0.8-incompatible chain (from here on, the 0.8 chain) at that point had around 60% of the mining hash power ensuring the split did not automatically resolve (as would have occurred if the pre-0.8 chain outpaced the 0.8 chain in total work, forcing 0.8 nodes to reorganise to the pre-0.8 chain).\n\nIn order to restore a canonical chain as soon as possible, BTCGuild and Slush downgraded their Bitcoin 0.8 nodes to 0.7 so their pools would also reject the larger block. This placed majority hashpower on the chain without the larger block, thus eventually causing the 0.8 nodes to reorganise to the pre-0.8 chain.\n\nDuring this time there was at least [https://bitcointalk.org/index.php?topic=152348.0 one large double spend].  However, it was done by someone experimenting to see if it was possible and was not intended to be malicious.\n\n==What went right==\n* The split was detected very quickly.\n* The right people were online and available in IRC or could be contacted directly.\n* Marek Palatinus (Slush) and Michael Marsee (Eleuthria of BTCGuild) quickly downgraded their nodes to restore a pre-0.8 chain as canonical, despite the fact that this caused them to sacrifice significant amounts of money.\n* Deposits to the major exchanges and payments via BitPay were also suspended (and then un-suspended) very quickly.\n* Fortunately, the only attack on a merchant was done by someone who was not intending to actually steal money.\n\n==Root cause==\nBitcoin versions prior to 0.8 configure an insufficient number of Berkeley DB locks to process large but otherwise valid blocks. Berkeley DB locks have to be manually configured by API users depending on anticipated load. The manual says this:\n\n:The recommended algorithm for selecting the maximum number of locks, lockers, and lock objects is to run the application under stressful conditions and then review the lock system's statistics to determine the maximum number of locks, lockers, and lock objects that were used. Then, double these values for safety.\n\nWith the insufficiently high BDB lock configuration, it implicitly had become a network consensus rule determining block validity (albeit an inconsistent and unsafe rule, since the lock usage could vary from node to node).\n\nBecause max-sized blocks had been successfully processed on the testnet, it did not occur to anyone that there could be blocks that were smaller but require more locks than were available. Prior to 0.7 unmodified mining nodes self-imposed a maximum block size of 500,000 bytes, which further prevented this case from being triggered. 0.7 made the target size configurable and miners had been encouraged to increase this target in the week prior to the incident.\n\nBitcoin 0.8 did not use Berkeley DB. It switched to LevelDB instead, which did not implement the same locking limits as BDB. Therefore it was able to process the forking block successfully.\n\nNote that BDB locks are also required during processing of re-organizations. Versions prior to 0.8 may be unable to process some valid re-orgs.\n\nThis would be an issue even if the entire network was running version 0.7.2. It is theoretically possible for one 0.7.2 node to create a block that others are unable to validate, or for 0.7.2 nodes to create block re-orgs that peers cannot validate, because the contents of each node's blkindex.dat database is not identical, and the number of locks required depends on the exact arrangement of the blkindex.dat on disk (locks are acquired per-page).\n\n==Action items==\n\n===Immediately===\n\n'''Done''': Release a version 0.8.1, forked directly from 0.8.0, that, for the next two months has the following new rules:\n# Reject blocks that would probably cause more than 10,000 locks to be taken.\n# Limit the maximum block-size created to 500,000 bytes\n# Release a patch for older versions that implements the same rules, but also increases the maximum number of locks to 537,000\n# Create a web page on bitcoin.org that will urge users to upgrade to 0.8.1, but will tell them how to set DB_CONFIG to 537,000 locks if they absolutely cannot.\n# Over the next 2 months, send a series of alerts to users of older versions, pointing to the web page.\n\n===Alert system===\n\n'''Done''': Review who has access to the alert system keys, make sure they all have contact information for each other, and get good timezone overlap by people with access to the keys.\n\n'''Done''': Implement a new bitcoind feature so services can get timely notification of alerts:  -alertnotify=<command>   Run command when an AppliesToMe() alert is received.\n\n'''Done''': Pre-generate 52 test alerts, and set a time every week when they are broadcast on -testnet (so -alertnotify scripts can be tested in as-close-to-real-world conditions as possible).\n\nIdea from Michael Gronager: encourage merchants/exchanges (and maybe pools) to run new code behind a bitcoind running the network-majority version.\n\n===Safe mode===\n\n'''Done''': Perhaps trigger an alert if there is a long enough side chain detected, even if it is not the main chain. Pools could use this to automatically suspend payouts if a long side-chain suddenly appeared out of nowhere (it\u2019s hard for an attacker to mine such a thing).\n\n===Testing===\n\nStart running bots on the testnet that grab some coins from a testnet faucet, generate large numbers of random transactions that split/recombine them and then send them back to the faucet. Randomized online testing on the testnet might have revealed the pathological block type earlier.\n\n===Double spending===\n\nA double spend attack was successful, despite that both sides of the chain heard about the transactions in the same order. The reason is most likely that the memory pools were cleared when the mining pool nodes were downgraded. A solution is for nodes to sync their mempools to each other at startup, however, this requires a memory pool expiry policy to be implemented as currently node restarts are the only way for unconfirmed transactions to be evicted from the system.\n\n===Resolution===\n\nOn 16 August, 2013 block 252,451 (0x0000000000000024b58eeb1134432f00497a6a860412996e7a260f47126eed07) was accepted by the main network, forking unpatched nodes off the network.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 6817}
{"bip_number": 49, "filename": "bip-0049.mediawiki", "content": "<pre>\n  BIP: 49\n  Layer: Applications\n  Title: Derivation scheme for P2WPKH-nested-in-P2SH based accounts\n  Author: Daniel Weigl <DanielWeigl@gmx.at>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0049\n  Status: Final\n  Type: Standards Track\n  Created: 2016-05-19\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP defines the derivation scheme for HD wallets using the P2WPKH-nested-in-P2SH ([[bip-0141.mediawiki|BIP 141]]) serialization format for segregated witness transactions.\n\n==Motivation==\n\nWith the usage of P2WPKH-nested-in-P2SH ([[bip-0141.mediawiki#p2wpkh-nested-in-bip16-p2sh|BIP 141]]) transactions it is necessary to have a common derivation scheme.\nIt allows the user to use different HD wallets with the same masterseed and/or a single account seamlessly.\n\nThus the user needs to create dedicated segregated witness accounts, which ensures that only wallets compatible with this BIP\nwill detect the accounts and handle them appropriately.\n\n===Considerations===\nTwo generally different approaches are possible for current BIP44 capable wallets:\n\n1) Allow the user to use the same account(s) that they already use, but add segregated witness encoded addresses to it.\n\n1.1) Use the same public keys as defined in BIP44, but in addition to the normal P2PKH address also derive the P2SH address from it.\n\n1.2) Use the same account root, but branch off and derive different external and internal chain roots to derive dedicated public keys for the segregated witness addresses.\n\n2) Create dedicated accounts used only for segregated witness addresses.\n\nThe solutions from point 1 have a common disadvantage: if a user imports/recovers a BIP49-compatible wallet masterseed into/in a non-BIP49-compatible wallet, the account might show up but also it might miss some UTXOs.\n\nTherefore this BIP uses solution 2, which fails in a more visible way. Either the account shows up or not at all. The user does not have to check his balance after using the same seed in different wallets.\n\n\n==Specifications==\n\nThis BIP defines the two needed steps to derive multiple deterministic addresses based on a [[bip-0032.mediawiki|BIP 32]] root account.\n\n===Public key derivation===\n\nTo derive a public key from the root account, this BIP uses the same account-structure as defined in\n[[bip-0044.mediawiki|BIP 44]], but only uses a different purpose value to indicate the different transaction\nserialization method.\n\n<pre>\nm / purpose' / coin_type' / account' / change / address_index\n</pre>\n\nFor the `purpose`-path level it uses `49'`. The rest of the levels are used as defined in BIP44.\n\n\n===Address derivation===\n\nTo derive the P2SH address from the above calculated public key, we use the encapsulation defined in [[bip-0141.mediawiki#p2wpkh-nested-in-bip16-p2sh|BIP 141]]:\n\n    witness:      <signature> <pubkey>\n    scriptSig:    <0 <20-byte-key-hash>>\n                  (0x160014{20-byte-key-hash})\n    scriptPubKey: HASH160 <20-byte-script-hash> EQUAL\n                  (0xA914{20-byte-script-hash}87)\n\n\n===Extended Key Version===\n\nWhen serializing extended keys, this scheme uses alternate version bytes. Extended public keys use <code>0x049d7cb2</code> to produce a \"ypub\" prefix, and private keys use <code>0x049d7878</code> to produce a \"yprv\" prefix. Testnet uses <code>0x044a5262</code> \"upub\" and <code>0x044a4e28</code> \"uprv.\"\n\nAdditional registered version bytes are listed in [[https://github.com/satoshilabs/slips/blob/master/slip-0132.md|SLIP-0132]].\n\n\n==Backwards Compatibility==\n\nThis BIP is not backwards compatible by design as described under [[#considerations|considerations]]. An incompatible wallet will not discover accounts at all and the user will notice that something is wrong.\n\n\n==Test vectors==\n\n<pre>\n  masterseedWords = abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\n  masterseed = uprv8tXDerPXZ1QsVNjUJWTurs9kA1KGfKUAts74GCkcXtU8GwnH33GDRbNJpEqTvipfCyycARtQJhmdfWf8oKt41X9LL1zeD2pLsWmxEk3VAwd (testnet)\n\n  // Account 0, root = m/49'/1'/0'\n  account0Xpriv = uprv91G7gZkzehuMVxDJTYE6tLivdF8e4rvzSu1LFfKw3b2Qx1Aj8vpoFnHdfUZ3hmi9jsvPifmZ24RTN2KhwB8BfMLTVqaBReibyaFFcTP1s9n (testnet)\n  account0Xpub = upub5EFU65HtV5TeiSHmZZm7FUffBGy8UKeqp7vw43jYbvZPpoVsgU93oac7Wk3u6moKegAEWtGNF8DehrnHtv21XXEMYRUocHqguyjknFHYfgY (testnet)\n\n  // Account 0, first receiving private key = m/49'/1'/0'/0/0\n  account0recvPrivateKey = cULrpoZGXiuC19Uhvykx7NugygA3k86b3hmdCeyvHYQZSxojGyXJ\n  account0recvPrivateKeyHex = 0xc9bdb49cfbaedca21c4b1f3a7803c34636b1d7dc55a717132443fc3f4c5867e8\n  account0recvPublicKeyHex = 0x03a1af804ac108a8a51782198c2d034b28bf90c8803f5a53f76276fa69a4eae77f\n\n  // Address derivation\n  keyhash = HASH160(account0recvPublicKeyHex) = 0x38971f73930f6c141d977ac4fd4a727c854935b3\n  scriptSig = <0 <keyhash>> = 0x001438971f73930f6c141d977ac4fd4a727c854935b3\n  addressBytes = HASH160(scriptSig) = 0x336caa13e08b96080a32b5d818d59b4ab3b36742\n\n  // addressBytes base58check encoded for testnet\n  address = base58check(prefix | addressBytes) = 2Mww8dCYPUpKHofjgcXcBCEGmniw9CoaiD2 (testnet)\n</pre>\n\n\n==Reference==\n\n* [[bip-0016.mediawiki|BIP16 - Pay to Script Hash]]\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[bip-0141.mediawiki|BIP141 - Segregated Witness (Consensus layer)]]\n\n== Copyright ==\n\nThis document is placed in the public domain.\n", "content_length": 5543}
{"bip_number": 48, "filename": "bip-0048.mediawiki", "content": "<pre>\n  BIP: 48\n  Layer: Applications\n  Title: Multi-Script Hierarchy for Multi-Sig Wallets\n  Author: Fontaine <dentondevelopment@protonmail.com>\n  Comments-Summary: No comments\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0048\n  Status: Final\n  Type: Standards Track\n  Created: 2020-12-16\n  License: MIT\n</pre>\n\n==Abstract==\n\nThis BIP defines a logical hierarchy for deterministic multi-sig wallets based on an algorithm\ndescribed in BIP-0067 (BIP67 from now on), BIP-0032 (BIP32 from now on), purpose scheme described in\nBIP-0043 (BIP43 from now on), and multi-account hierarchy described in\nBIP-0044 (BIP44 from now on).\n\nThis BIP is a particular application of BIP43.\n\n==Copyright==\n\nThis BIP falls under the MIT License.\n\n==Motivation==\n\nThe motivation of this BIP is to define the existing industry wide practice of utilizing  m/48'\nderivation paths in hierarchical deterministic multi-sig wallets so that other developers may\nbenefit from a standard. This BIP allows for future script types to easily be appended to the\nspecification so that a new BIP is not required for every future script type.\n\nThe hierarchy proposed in this paper is quite comprehensive. It allows the handling of\nmultiple accounts, external and internal chains per account, multiple script types and\nmillions of addresses per chain.\n\nThis paper was inspired from BIP44.\n\n==Backwards compatibility==\n\nCurrently a number of wallets utilize the \u200e<code>m/48'</code> derivation scheme for HD multi-sig accounts.\nThis BIP is intended to maintain the *existing* real world use of the \u200e<code>m/48'</code> derivation.\nNo breaking changes are made so as to avoid \"loss of funds\" to existing users.\nWallets which currently support the \u200e<code>m/48'</code> derivation will not need to make any changes\nto comply with this BIP.\n\n==Specification==\n\n===Key sorting===\n\nAny wallet that supports BIP48 inherently supports deterministic key sorting as per BIP67 so that all possible\nmulti-signature addresses/scripts are derived from deterministically sorted public keys.\n\n===Path levels===\n\nWe define the following 6 levels in BIP32 path:\n\n<pre>\nm / purpose' / coin_type' / account' / script_type' / change / address_index\n</pre>\n\n<code>h</code> or <code>'</code> in the path indicates that BIP32 hardened derivation is used.\n\nEach level has a special meaning, described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set to 48' following the BIP43 recommendation.\nIt indicates that the subtree of this node is used according to this specification.\n\nHardened derivation is used at this level.\n\n===Coin type===\n\nOne master node (seed) can be used for multiple Bitcoin networks.\nSharing the same space for various networks has some disadvantages.\n\nAvoiding reusing addresses across networks and improving privacy issues.\n\nCoin type <code>0</code> for mainnet and <code>1</code> for testnet.\n\nHardened derivation is used at this level.\n\n===Account===\n\nThis level splits the key space into independent user identities, following the BIP44 pattern,\nso the wallet never mixes the coins across different accounts.\n\nUsers can use these accounts to organize the funds in the same\nfashion as bank accounts; for donation purposes (where all\naddresses are considered public), for saving purposes,\nfor common expenses etc.\n\nAccounts are numbered from index 0 in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nHardened derivation is used at this level.\n\n===Script===\n\nThis level splits the key space into two separate <code>script_type</code>(s). To provide\nforward compatibility for future script types this specification can be easily extended.\n\nCurrently the only script types covered by this BIP are Native Segwit (p2wsh) and\nNested Segwit (p2sh-p2wsh).\n\nThe following path represents Nested Segwit (p2sh-p2wsh) mainnet, account 0:\n<code>1'</code>: Nested Segwit (p2sh-p2wsh) <code>m/48'/0'/0'/1'</code></br>\n\nThe following path represents Native Segwit (p2wsh) mainnet, account 0:\n<code>2'</code>: Native Segwit (p2wsh) <code>m/48'/0'/0'/2'</code></br>\n\nThe recommended default for wallets is pay to witness script hash <code>m/48'/0'/0'/2'</code>.\n\n===Change===\n\nConstant 0 is used for external chain and constant 1 for internal chain (also\nknown as change addresses). External chain is used for addresses that are meant\nto be visible outside of the wallet (e.g. for receiving payments). Internal\nchain is used for addresses which are not meant to be visible outside of the\nwallet and is used for return transaction change.\n\nPublic derivation is used at this level.\n\n===Index===\n\nAddresses are numbered from index 0 in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nPublic derivation is used at this level.\n\n==Examples==\n\n{|\n|network\n|account\n|script\n|chain\n|address\n|path\n|-\n|mainnet\n|first\n|p2sh-p2wsh\n|external\n|first\n|m / 48' / 0' / 0' / 1' / 0 / 0\n|-\n|mainnet\n|first\n|p2wsh\n|external\n|first\n|m / 48' / 0' / 0' / 2' / 0 / 0\n|-\n|mainnet\n|first\n|p2wsh\n|external\n|second\n|m / 48' / 0' / 0' / 2' / 0 / 1\n|-\n|mainnet\n|first\n|p2wsh\n|change\n|first\n|m / 48' / 0' / 0' / 2' / 1 / 0\n|-\n|mainnet\n|first\n|p2wsh\n|change\n|second\n|m / 48' / 0' / 0' / 2' / 1 / 1\n|-\n|mainnet\n|second\n|p2wsh\n|external\n|first\n|m / 48' / 0' / 1' / 2' / 0 / 0\n|-\n|mainnet\n|second\n|p2wsh\n|external\n|second\n|m / 48' / 0' / 1' / 2' / 0 / 1\n|-\n|testnet\n|first\n|p2sh-p2wsh\n|external\n|first\n|m / 48' / 1' / 0' / 1' / 0 / 0\n|-\n|testnet\n|first\n|p2wsh\n|external\n|second\n|m / 48' / 1' / 0' / 2' / 0 / 1\n|-\n|testnet\n|first\n|p2wsh\n|change\n|first\n|m / 48' / 1' / 0' / 2' / 1 / 0\n|-\n|testnet\n|first\n|p2wsh\n|change\n|second\n|m / 48' / 1' / 0' / 2' / 1 / 1\n|-\n|testnet\n|second\n|p2wsh\n|external\n|first\n|m / 48' / 1' / 1' / 2' / 0 / 0\n|-\n|testnet\n|second\n|p2wsh\n|external\n|second\n|m / 48' / 1' / 1' / 2' / 0 / 1\n|-\n|testnet\n|second\n|p2wsh\n|change\n|first\n|m / 48' / 1' / 1' / 2' / 1 / 0\n|-\n|testnet\n|second\n|p2wsh\n|change\n|second\n|m / 48' / 1' / 1' / 2' / 1 / 1\n|}\n\n\n==Reference==\n\n* [[bip-0067.mediawiki|BIP67 - Deterministic Pay-to-script-hash multi-signature addresses through public key sorting]]\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n", "content_length": 6345}
{"bip_number": 47, "filename": "bip-0047.mediawiki", "content": "RECENT CHANGES:\n* (15 Feb 2021) Finalize specification\n* (28 Sep 2017) Adjust text to match test vectors\n* (19 Apr 2016) Define version 2 payment codes\n\n<pre>\n  BIP: 47\n  Layer: Applications\n  Title: Reusable Payment Codes for Hierarchical Deterministic Wallets\n  Author: Justus Ranvier <justus@openbitcoinprivacyproject.org>\n  Comments-Summary: Unanimously Discourage for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0047\n  Status: Final\n  Type: Informational\n  Created: 2015-04-24\n</pre>\n\n==Status==\n\nThis BIP can be considered final in terms of enabling compatibility with wallets that implement version 1 and version 2 reusable payment codes, however future developments of the reusable payment codes specification will not be distributed via the BIP process.\n\nThe Open Bitcoin Privacy Project RFC repo should be consulted for specifications related to version 3 or higher payment codes: https://github.com/OpenBitcoinPrivacyProject/rfc\n\n==Abstract==\n\nThis BIP defines a technique for creating a payment code which can be publicly advertised and associated with a real-life identity without creating the loss of security or privacy inherent to P2PKH address reuse.\n\nThis BIP is a particular application of BIP43 and is intended to supplement HD wallets which implement BIP44.\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n==Motivation==\n\nPayment codes add identity information to transactions which is useful in a merchant-customer interaction while protecting the privacy of users. Payment codes provide the privacy benefits of Darkwallet-style Stealth Addresses to SPV clients without requiring the assistance of a trusted full node and while greatly reducing reliance on blockchain storage.\n\n==Path levels==\n\nWe define the following 3 levels in BIP32 path:\n\n<code>\nm / purpose' / coin_type' / identity'\n</code>\n\nThe child keys derived from an identity are used in different ways:\n\n<code>\nm / purpose' / coin_type' / identity' / 0\n</code>\n\nThe 0th (non-hardened) child is the notification key.\n\n<code>\nm / purpose' / coin_type' / identity' / 0 through 2147483647\n</code>\n\nThese (non-hardened) keypairs are used for ECDH to generate deposit addresses.\n\n<code>\nm / purpose' / coin_type' / identity' / 0' through 2147483647'\n</code>\n\nThese (hardened) keypairs are ephemeral payment codes.\n\nApostrophe in the path indicates that BIP32 hardened derivation is used.\n\nEach level has a special meaning, described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set to 47' (or 0x8000002F) following the BIP43 recommendation. It indicates that the subtree of this node is used according to this specification.\n\n===Coin type===\n\nThe coin type field is identical to the same field in BIP44\n\nHardened derivation is used at this level.\n\n===Identity===\n\nThe identity derivation level produces an extended public key and its associated extended private key.\n\nWhen the extended public key at this level is combined with the metadata specified in the Representation section below, the resulting entity is called a \"payment code.\"\n\nThis derivation level is equivalent to the Account level in BIP-44. Wallets SHOULD treat payment codes as intrinsically part of the BIP-44 account at the same index and create payment codes and accounts as pairs.\n\nFor example, the payment code created represented by (m / 47' / 0' / 0') is part of the account represented by (m / 44' / 0' / 0').\n\nThe second account in a wallet consists of the new account/payment code pair created by using an index of 1 in as the account/identity level of both paths.\n\nIncoming payments received via this specification are equivalent to payments received to BIP-44 addresses, and unspent outputs from both types of addresses can be used as inputs in the same outgoing transaction.\n\nHardened derivation is used at this level.\n\nExcept where noted, all keys derived from a payment code use the public derivation method.\n\n==Versions==\n\nPayment codes contain a version byte which identifies a specific set of behavior.\n\nUnless otherwise specified, payment codes of different versions are interoperable. If Alice uses a version x payment code, and Bob uses a version y payment code, they can still send and receive transactions between each other.\n\nCurrently specified versions:\n\n* Version 1\n** Address type: P2PKH\n** Notification type: address\n* Version 2\n** Address type: P2PKH\n** Notification type: bloom-multisig\n\n===Recommended Versions===\n\n* Wallets which have bloom filtering capabilities SHOULD create version 2 payment codes instead of version 1 payment codes.\n* Version 1 payment codes are only recommended for wallets which lack access to bloom filtering capability.\n\n==Version 1==\n\n===Representation===\n\n====Binary Serialization====\n\nA payment code contains the following elements:\n\n* Byte 0: version. required value: 0x01\n* Byte 1: features bit field. All bits must be zero except where specified elsewhere in this specification\n** Bit 0: Bitmessage notification\n** Bits 1-7: reserved\n* Byte 2: sign. required value: 0x02 or 0x03\n* Bytes 3 - 34: x value, must be a member of the secp256k1 group\n* Bytes 35 - 66: chain code\n* Bytes 67 - 79: reserved for future expansion, zero-filled unless otherwise noted\n\n====Base58 Serialization====\n\nWhen a payment code is presented to the user, it SHOULD be presented encoded in Base58Check form.\n\n* The version byte is: 0x47 (produces a \"P\" as the first character of the serialized form)\n* The payload is the binary serialization of the payment code\n\n===Protocol===\n\nIn the following examples, Alice and Bob are identities with a corresponding payment codes. Alice initiates a Bitcoin transaction, and Bob is the recipient of the transaction.\n\nIt is assumed that Alice can easily obtain Bob's payment code via a suitable method outside the scope of the payment code protocol.\n\n====Definitions====\n\n* Payment code: an extended public key and associated metadata which is associated with a particular identity/account\n* Notification address: the P2PKH address associated with the 0<sup>th</sup> public key derived from a payment code\n* Notification transaction: a transaction which sends an output to a notification address which includes an embedded payment code\n* Designated input: the first input in the notification transaction which exposes an secp256k1 pubkey in either its signature script, or in the redeem script or pubkey script of the output being spent\n* Designated pubkey: the first secp256k1 pubkey pushed to the stack during script execution for the designated input\n* Outpoint: the specific output of a previous transaction which is being spent. See the Reference section for the binary serialization\n\n====Notification Transaction====\n\nPrior to the first time Alice initiates a transaction to Bob, Alice MUST inform Bob of her payment code via the following procedure:\n\nNote: this procedure is used if Bob uses a version 1 payment code (regardless of the version of Alice's payment code). If Bob's payment code is not version 1, see the appropriate section in this specification.\n\n# Alice constructs a transaction which sends a small quantity of bitcoins to Bob's notification address (notification transaction)\n## The inputs selected for this transaction MUST NOT be easily associated with Alice's notification address\n# Alice derives a unique shared secret using ECDH:\n## Alice selects the private key corresponding to the designated pubkey: <pre>a</pre>\n## Alice selects the public key associated with Bob's notification address: <pre>B, where B = bG</pre>\n## Alice calculates a secret point: <pre>S = aB</pre>\n## Alice calculates a 64 byte blinding factor: <pre>s = HMAC-SHA512(o, x)</pre>\n### \"x\" is the x value of the secret point\n### \"o\" is the outpoint being spent by the designated input\n# Alice serializes her payment code in binary form.\n# Alice renders her payment code (P) unreadable to anyone except Bob:\n## Replace the x value with x': <pre>x' = x XOR (first 32 bytes of s)</pre>\n## Replace the chain code with c': <pre>c' = c XOR (last 32 bytes of s)</pre>\n# Alice adds an OP_RETURN output to her transaction which consists of P.\n<img src=\"bip-0047/reusable_payment_codes-01.png\" />\n\n# Bob watches for any transactions which create an output at his notification address.\n# When a transaction is received, the client examines it to determine if it contains a standard OP_RETURN output with an 80 byte payload (notification transactions).\n# If the first byte of the payload in a notification transaction is 0x01:\n## Bob selects the designated pubkey: <pre>A, where A = aG</pre>\n## Bob selects the private key associated with his notification address: <pre>b</pre>\n## Bob calculates a secret point: <pre>S = bA</pre>\n## Bob calculates the blinding factor: <pre>s = HMAC-SHA512(x, o)</pre>\n### \"x\" is the x value of the secret point\n### \"o\" is the outpoint being spent by the designated input.\n## Bob interprets the 80 byte payload as a payment code, except:\n### Replace the x value with x': <pre>x' = x XOR (first 32 bytes of s)</pre>\n### Replace the chain code with c': <pre>c' = c XOR (last 32 bytes of s)</pre>\n## If the updated x value is a member of the secp256k1 group, the payment code is valid.\n## If the updated x value is not a member of the secp256k1 group, the payment code is ignored.\n\nNow that Bob's client has received Alice's payment code, it is possible for Alice to send payments (up to 2<sup>32</sup> payments) to Bob.\n\nAlice will never again need to send a notification transaction to Bob.\n\nBitcoins received via notification transactions require special handling in order to avoid privacy leaks:\n\n# The value of outputs received to notification addresses MUST NOT be displayed to the user as part of their spendable balance.\n# Outputs received to notification addresses MUST NOT be used as inputs for any transaction that involve ECDH calculations using any of the user's payment codes.\n# Outputs received to notification addresses MAY be passed through a mixing service before being added to the user's spendable balance.\n# Outputs received to notification addresses MAY be donated to miners using dust-b-gone or an equivalent procedure.\n\n=====Standard Notification Transaction Scripts=====\n\nAlice SHOULD use an input script in one of the following standard forms to expose a public key, and compliant applications SHOULD recognize all of these forms.\n\n* P2PK (pay to pubkey)\n* P2PKH (pay to pubkey hash)\n* Multisig (bare multisig, without P2SH)\n* a script which spends any of the above script forms via P2SH (pay to script hash)\n\nCompatible wallets MAY provide a method for a user to manually specify the public key associated with a notification transaction in order to recover payment codes sent via non-standard notification transactions.\n\n=====Post-Notification Privacy Considerations=====\n\nIncautious handling of change outputs from notification transactions may cause unintended loss of privacy.\n\nThe recipient of a transaction which spends a change output from a prior notification transaction will learn about the potential connection between the sender and the recipient of the notification transaction.\n\nThe following actions are recommended to reduce this risk:\n\n* Wallets which support mixing SHOULD mix change outputs from notification transactions prior to spending them\n* Wallets which do not support mixing MAY simulate mixing by creating a transaction which spends the change output to the next external BIP44 address\n\n====Sending====\n\n# Each time Alice wants to initiate a transaction to Bob, Alice derives a unique P2PKH address for the transaction using ECDH as follows:\n## Alice selects the 0th private key derived from her payment code: <pre>a</pre>\n## Alice selects the next unused public key derived from Bob's payment code, starting from zero: <pre>B, where B = bG</pre>\n### The \"next unused\" public key is based on an index specific to the Alice-Bob context, not global to either Alice or Bob\n## Alice calculates a secret point: <pre>S = aB</pre>\n## Alice calculates a scalar shared secret using the x value of S: <pre>s = SHA256(Sx)</pre>\n### If the value of s is not in the secp256k1 group, Alice MUST increment the index used to derive Bob's public key and try again.\n## Alice uses the scalar shared secret to calculate the ephemeral public key used to generate the P2PKH address for this transaction: <pre>B' = B + sG</pre>\n<img src=\"bip-0047/reusable_payment_codes-04.png\" />\n<img src=\"bip-0047/reusable_payment_codes-05.png\" />\n# Bob is watching for incoming payments on B' ever since he received the notification transaction from Alice.\n## Bob calculates n shared secrets with Alice, using the 0<sup>th</sup> public key derived from Alice's payment code, and private keys 0 - n derived from Bob's payment code, where n is his desired lookahead window.\n## Bob calculates the ephemeral deposit addresses using the same procedure as Alice: <pre>B' = B + sG</pre>\n## Bob calculate the private key for each ephemeral address as: <pre>b' = b + s</pre>\n<img src=\"bip-0047/reusable_payment_codes-02.png\" />\n<img src=\"bip-0047/reusable_payment_codes-03.png\" />\n\n====Refunds====\n\nBecause Bob learns Alice's payment code as part of the process of receiving a payment, Bob has all the information he needs in order to send a refund to Alice.\n\nA refund transaction is identical to a payment transactions, with only the roles of the participants switches.\n\nBob MUST send a notification transaction to Alice prior to the first time he sends funds to Alice, even if he has received transactions from her in the past.\n\n<img src=\"bip-0047/reusable_payment_codes-06.png\" />\n\n====Anonymous Payments====\n\nIf Alice does not want her payment to Bob to be associated with her identity, she generates an ephemeral payment code to use for the transaction.\n\n* Ephemeral payment codes are the hardened children of a payment code, starting from an index of zero.\n* An ephemeral payment code SHOULD only be used for a single outgoing payment.\n* The notification address of an ephemeral payment code MUST be monitored for notification transactions in order to detect incoming refund payments\n* The correspondence between BIP44 accounts and ephemeral payment codes is 1:many\n\n====Cold Storage====\n\n* Unlike traditional watching-only wallets, those associated with payment codes held in cold storage can not detect incoming payments immediately.\n* When the watching-only wallet detects an incoming notification transaction, it packages the transaction in an implementation-specific format suitable for transfer to the offline device.\n* The offline device recovers the payment code, then pre-generates a large number of relevant keypairs (example: 10000) in order to minimize the need for air gap round trips.\n* The offline device then packages the relevant public keys in an implementation-specific format suitable for transfer to the online device.\n* The online device can then watch for incoming payments using a suitable lookahead window.\n* If the lookahead window reaches the end of the pre-generated public keys, the user must generate more keys on the offline device and transfer them to the online device.\n\n====Wallet Recovery====\n\nNormal operation of a payment code-enabled wallet can be performed by an SPV client and does not require access to a complete copy of the blockchain.\n\nRecovering a wallet from a seed, however, does require access to a fully-indexed blockchain.\n\nThe required data may be obtained from copy of the blockchain under the control of the user, or via a publicly-queryable blockchain explorer.\n\nWhen querying a public blockchain explorer, wallets SHOULD connect to the explorer through Tor (or equivalent) and SHOULD avoid grouping queries in a manner that associates ephemeral addresses with each other.\n\nPreviously-spendable funds will generally not be lost or become inaccessible after a recovery from a seed, but all information regarding previous outgoing payments will be lost.\n\nIn order to recover received funds from a seed, the wallet must obtain every notification it has ever received to its notification address, including all spent transactions. It then re-establishes its lookahead window for each subchain by scanning every derived address sequentially until it locates a contiguous block of unused addresses of a user-specified length.\n\nThe metadata which a wallet must store to properly process outgoing transactions consists of:\n\n# A list of every payment code to which the identity has sent a notification transaction.\n## This list is lost if a wallet must be recovered from a seed.\n## The recovered wallet MUST send notification transactions as if it was a newly-created wallet\n# The index value corresponding to the next unused pubkey for each payment code on the previous list\n## This value can be recovered by checking each ephemeral deposit address in sequence for transactions.\n## Wallets MAY use a lookahead window capable of detecting gaps in the address sequence during this recovery operation.\n# The index value of the next unused ephemeral payment code.\n## Recovering all incoming funds associated with ephemeral payment codes with 100% certainty requires exhausting the entire 2<sup>32</sup> address space of potential ephemeral payment codes.\n### In most cases, less than 100% certainty is acceptable as long as a fallback \"deep scan\" is available as an option to the user.\n## The wallet checks the notification address for each ephemeral payment code for notification transactions in order to recover associated funds.\n## Since most ephemeral payment codes will not receive a refund transaction wallets SHOULD use a large lookahead window for this recovery operation.\n## The recovered value MUST be chosen as a number higher than any ephemeral payment code which has received a notification transaction.\n\n===Wallet Sharing===\n\nWallets using payment codes generally should not be shared across multiple devices, given the need to synchronize metadata between each instance.\n\nIf wallets are shared between devices without a synchronization mechanism, undesirable address reuse can occur.\n\nWallets may perform an OPTIONAL check for existing transactions to an ephemeral deposit addresses prior to sending a transaction by checking a local copy of the blockchain or querying a public blockchain explorer via Tor or equivalent.\n\n===Alternate Notification Methods===\n\nIn order to ensure that no funds will be lost in the event the recipient must recover their wallet from a seed, the sender MUST send a notification transaction the first time the sender interacts with a particular recipient.\n\nA recipient MAY choose to designate alternate notification methods which the sender may use in addition to a notification transaction.\n\nIf the recipient specifies an alternate notification method, a compliant implementation MAY refrain from continually monitoring the notification address and SHOULD check the notification address periodically to detect payments sent by users who can not employ the alternate method.\n\nA recipient specifies their preference for alternate notification by setting the appropriate bits in the feature byte of their payment code.\n\n===Bitmessage Notification===\n\nA recipient which prefers to receive notifications via Bitmessage indicates this preference by:\n\n* Setting bit 0 of the features byte to 1\n* Setting byte 67 of the serialized payment code to the desired Bitmessage address version\n* Setting byte 68 of the serialized payment code to the desired Bitmessage stream number\n\nThe sender uses this information to construct a valid notification Bitmessage address:\n\n# Derive a Bitmessage signing key as: <pre>B = payment code / 0 / 0</pre>\n# Initialize a counter at 1: <pre>n</pre>\n# Derive a candidate encryption key as: <pre>B' = payment code / 0 / n</pre>\n# If the combination of B and B` do not form a valid Bitmessage address, increment n by one and try again\n# Use the address version, signing key, encryption key, and stream number to construct a Bitmessage address per the Bitmessage protocol\n\nThe sender transmits their payment code in base58 form to the calculated Bitmessage address.\n\nIn order to use Bitmessage notification, the recipient must have a Bitmessage client which listens at the address which the senders will derive and is capable of relaying received payment codes to the Bitcoin wallet.\n\n==Version 2==\n\nVersion 2 payment codes behave identifically to version 1 payment codes, except as modified below.\n\n===Representation===\n\n====Binary Serialization====\n\n* Byte 0: version. required value: 0x02\n\n===Protocol===\n\n====Definitions====\n\n* Notification change output: the change output from a notification transaction which resides in the sender's wallet, but can be automatically located by the intended recipient\n* Payment code identifier: a 33 byte representation of a payment code constructed by prepending 0x02 to the SHA256 hash of the binary serialization of the payment code\n\n====Notification Transaction====\n\nNote: this procedure is used if Bob uses a version 2 payment code (regardless of the version of Alice's payment code). If Bob's payment code is not version 2, see the appropriate section in this specification.\n\n# Construct a notification transaction as per the version 1 instructions, except do not create the output to Bob's notification address\n# Create a notification change address as follows:\n## Obtain the pubkey corresponding to the next change address\n## Construct a multisig output in the form:\n<pre>OP_1 <Bob's payment code identifier> <change address pubkey> OP_2 OP_CHECKMULTISIG</pre>\n\nThe relative ordering of the payment code identifier and change address pubkey in the above script MAY be randomized\n\nBob detects notification transactions by adding his payment code identifier to his bloom filter.\n\n# When the filter returns a notification transaction, the sender's payment code is unblinded using the same procedure as for version 1 notification transactions.\n\nAlice's wallet should spend the notification change output at the next appropriate opportunity.\n\n==Test Vectors==\n\n* [[https://gist.github.com/SamouraiDev/6aad669604c5930864bd|BIP47 Reusable Payment Codes Test Vectors]]\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[https://bitcoin.org/en/developer-reference#outpoint|Outpoint]]\n* [[https://github.com/petertodd/dust-b-gone|dust-b-gone]]\n* [[https://en.bitcoin.it/wiki/Base58Check_encoding|Base58Check encoding]]\n* [[https://bitmessage.org/bitmessage.pdf|Bitmessage]]\n* [[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-April/007812.html|Mailing list discussion]]\n", "content_length": 22879}
{"bip_number": 46, "filename": "bip-0046.mediawiki", "content": "<pre>\n  BIP: 46\n  Layer: Applications\n  Title: Address Scheme for Timelocked Fidelity Bonds\n  Author: Chris Belcher <belcher@riseup.net>\n          Thebora Kompanioni <theborakompanioni+bip46@gmail.com>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0046\n  Status: Draft\n  Type: Standards Track\n  Created: 2022-04-01\n  License: CC0-1.0\n  Post-History: 2022-05-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020389.html\n</pre>\n\n== Abstract ==\n\nThis BIP defines the derivation scheme for HD wallets which create timelocked addresses used for creating fidelity bonds. It also gives advice to wallet developers on how to use fidelity bonds to sign over messages, such as certificates, which are needed when using fidelity bonds that are stored offline.\n\n== Copyright ==\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n== Motivation ==\n\nFidelity bonds are used to resist sybil attacks in certain decentralized anonymous protocols. They are created by locking up bitcoins using the `OP_CHECKLOCKTIMEVERIFY` opcode.\n\nHaving a common derivation scheme allows users of wallet software to have a backup of their fidelity bonds by storing only the HD seed and a reference to this BIP. Importantly the user does not need to backup any timelock values.\n\nWe largely use the same approach used in BIPs 49, 84 and 86 for ease of implementation.\n\nThis allows keeping the private keys of fidelity bonds in cold storage, which increases the sybil resistance of a system without hot wallet risk.\n\n== Backwards Compatibility ==\n\nThis BIP is not backwards compatible by design as described in the Considerations section of [[bip-0049.mediawiki|BIP 49]]. An incompatible wallet will not discover fidelity bonds at all and the user will notice that something is wrong.\n\n== Background ==\n\n=== Fidelity bonds ===\n\nA fidelity bond is a mechanism where bitcoin value is deliberately sacrificed to make a cryptographic identity expensive to obtain. A way to create a fidelity bond is to lock up bitcoins by sending them to a timelocked address. The valuable thing being sacrificed is the time-value-of-money.\n\nThe sacrifice must be done in a way that can be proven to a third party. This proof can be made by showing the UTXO outpoint, the address redeemscript and a signature which signs a message using the private key corresponding to the public key in the redeemscript.\n\nThe sacrificed value is an objective measurement that can't be faked and which can be verified by anybody (just like, for example PoW mining). Sybil attacks can be made very expensive by forcing a hypothetical sybil attacker to lock up many bitcoins for a long time. JoinMarket implements fidelity bonds for protection from sybil attackers. At the time of writing over 600 BTC in total have been locked up with some for many years. Their UTXOs and signatures have been advertised to the world as proof. We can calculate that for a sybil attacker to succeed in unmixing all the CoinJoins, they would have to lock up over 100k BTC for several years.\n\n=== Fidelity bonds in cold storage ===\n\nTo allow for holding fidelity bonds in cold storage, there is an intermediate keypair called the certificate.\n\n    UTXO key ---signs---> certificate ---signs---> endpoint\n\nWhere the endpoint might be a IRC nickname or Tor onion hostname. The certificate keypair can be kept online and used to prove ownership of the fidelity bond. Even if the hot wallet private keys are stolen, the coins in the timelocked address will still be safe, although the thief will be able to impersonate the fidelity bond until the expiry.\n\n== Rationale ==\n\nIt is useful for the user to avoid having to keep a record of the timelocks in the time-locked addresses. So only a limited small set of timelocks are defined by this BIP. This way the user must only store their seed phrase, and knowledge that they have coins stored using this BIP standard. The user doesn't need to remember or store any dates.\n\nThis standard is already implemented and deployed in JoinMarket. As most changes would require a protocol change of a live system, there is limited scope for changing this standard in review. This BIP is more about documenting something which already exists, warts and all.\n\n== Specifications ==\n\nThis BIP defines the two needed steps to derive multiple deterministic addresses based on a [[bip-0032.mediawiki|BIP 32]] master private key. It also defines the format of the certificate that can be signed by the deterministic address key.\n\n=== Public key derivation ===\n\nTo derive a public key from the root account, this BIP uses a similar account-structure as defined in BIP [[bip-0084.mediawiki|44]] but with <tt>change</tt> set to <tt>2</tt>.\n\n<pre>\nm / 84' / 0' / 0' / 2 / index\n</pre>\n\nA key derived with this derivation path pattern will be referred to as <tt>derived_key</tt> further\nin this document.\n\nFor <tt>index</tt>, addresses are numbered from 0 in a sequentially increasing manner with a fixed upper bound: The index only goes up to <tt>959</tt> inclusive. Only 960 addresses can be derived for a given BIP32 master key. Furthermore there is no concept of a gap limit, instead wallets must always generate all 960 addresses and check for all of them if they have a balance and history.\n\n=== Timelock derivation ===\n\nThe timelock used in the time-locked address is derived from the <tt>index</tt>. The timelock is a unix time. It is always at the start of the first second at the beginning of the month (see [[#Test vectors|Test vectors]]). The <tt>index</tt> counts upwards the months from January 2020, ending in December 2099. At 12 months per year for 80 years this totals 960 timelocks. Note that care must be taken with the year 2038 problem on 32-bit systems.\n\n<pre>\nyear = 2020 + index // 12\nmonth = 1 + index % 12\n</pre>\n\n\n=== Address derivation ===\n\nTo derive the address from the above calculated public key and timelock, we create a <tt>witness script</tt> which locks the funds until the <tt>timelock</tt>, and then checks the signature of the <tt>derived_key</tt>. The <tt>witness script</tt> is hashed with SHA256 to produce a 32-byte hash value that forms the <tt>witness program</tt> in the output script of the P2WSH address.\n\n    witnessScript: <timelock> OP_CHECKLOCKTIMEVERIFY OP_DROP <derived_key> OP_CHECKSIG\n    witness:      <signature> <witnessScript>\n    scriptSig:    (empty)\n    scriptPubKey: 0 <32-byte-hash>\n                  (0x0020{32-byte-hash})\n\n=== Message signing ===\n\nIn order to support signing of certificates, implementers should support signing ASCII messages.\n\nThe certificate message is defined as `\"fidelity-bond-cert\" || \"|\" || cert_pubkey || \"|\" || cert_expiry`.\n\nThe certificate expiry `cert_expiry` is the number of the 2016-block period after which the certificate is no longer valid. For example, if `cert_expiry` is 330 then the certificate will become invalid after block height 665280 (:=330x2016). The purpose of the expiry parameter is so that in case the certificate keypair is compromised, the attacker can only impersonate the fidelity bond for a limited amount of time.\n\nA certificate message can be created by another application external to this standard. It is then prepended with the string `0x18 || \"Bitcoin Signed Message:\\n\"` and a byte denoting the length of the certificate message. The whole thing is then signed with the private key of the <tt>derived_key</tt>. This part is identical to the \"Sign Message\" function which many wallets already implement.\n\nAlmost all wallets implementing this standard can use their already-existing \"Sign Message\" function to sign the certificate message. As the certificate message itself is always an ASCII string, the wallet may not need to specially implement this section at all but just rely on users copypasting their certificate message into the already-existing \"Sign Message\" user interface. This works as long as the wallet knows how to use the private key of the timelocked address for signing messages.\n\nIt is most important for wallet implementations of this standard to support creating the certificate signature. Verifying the certificate signature is less important.\n\n\n== Test vectors ==\n\n<pre>\nmnemonic = abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about\nrootpriv = xprv9s21ZrQH143K3GJpoapnV8SFfukcVBSfeCficPSGfubmSFDxo1kuHnLisriDvSnRRuL2Qrg5ggqHKNVpxR86QEC8w35uxmGoggxtQTPvfUu\nrootpub  = xpub661MyMwAqRbcFkPHucMnrGNzDwb6teAX1RbKQmqtEF8kK3Z7LZ59qafCjB9eCRLiTVG3uxBxgKvRgbubRhqSKXnGGb1aoaqLrpMBDrVxga8\n\n// First timelocked address = m/84'/0'/0'/2/0\nderived private_key = L2tQBEdhC48YLeEWNg3e4msk94iKfyVa9hdfzRwUERabZ53TfH3d\nderived public_key  = 02a1b09f93073c63f205086440898141c0c3c6d24f69a18db608224bcf143fa011\nunix locktime       = 1577836800\nstring locktime     = 2020-01-01 00:00:00\nredeemscript        = 0400e10b5eb1752102a1b09f93073c63f205086440898141c0c3c6d24f69a18db608224bcf143fa011ac\nscriptPubKey        = 0020bdee9515359fc9df912318523b4cd22f1c0b5410232dc943be73f9f4f07e39ad\naddress             = bc1qhhhf29f4nlyalyfrrpfrknxj9uwqk4qsyvkujsa7w0ulfur78xkspsqn84\n\n// Test certificate using the first timelocked address\n// Note that as signatures contains a random nonce, it might not be exactly the same when your code generates it\n// p2pkh address is the p2pkh address corresponding to the derived public key, it can be used to verify the message\n//  signature in any wallet that supports Verify Message.\n// As mentioned before, it is more important for implementers of this standard to support signing such messages, not verifying them\nmessage       = fidelity-bond-cert|020000000000000000000000000000000000000000000000000000000000000001|375\naddress       = bc1qhhhf29f4nlyalyfrrpfrknxj9uwqk4qsyvkujsa7w0ulfur78xkspsqn84\np2pkh address = 16vmiGpY1rEaYnpGgtG7FZgr2uFCpeDgV6\nsignature     = H2b/90XcKnIU/D1nSCPhk8OcxrHebMCr4Ok2d2yDnbKDTSThNsNKA64CT4v2kt+xA1JmGRG/dMnUUH1kKqCVSHo=\n\n// 2nd timelocked address = m/84'/0'/0'/2/1\nderived private_key = KxctaFBzetyc9KXeUr6jxESCZiCEXRuwnQMw7h7hroP6MqnWN6Pf\nderived public_key  = 02599f6db8b33265a44200fef0be79c927398ed0b46c6a82fa6ddaa5be2714002d\nunix locktime       = 1580515200\nstring locktime     = 2020-02-01 00:00:00\nredeemscript        = 0480bf345eb1752102599f6db8b33265a44200fef0be79c927398ed0b46c6a82fa6ddaa5be2714002dac\nscriptPubKey        = 0020b8f898643991608524ed04e0c6779f632a57f1ffa3a3a306cd81432c5533e9ae\naddress             = bc1qhrufsepej9sg2f8dqnsvvaulvv490u0l5w36xpkds9pjc4fnaxhq7pcm4h\n\n// timelocked address after the year 2038 = m/84'/0'/0'/2/240\nderived private_key = L3SYqae23ZoDDcyEA8rRBK83h1MDqxaDG57imMc9FUx1J8o9anQe\nderived public_key  = 03ec8067418537bbb52d5d3e64e2868e67635c33cfeadeb9a46199f89ebfaab226\nunix locktime       = 2208988800\nstring locktime     = 2040-01-01 00:00:00\nredeemscript        = 05807eaa8300b1752103ec8067418537bbb52d5d3e64e2868e67635c33cfeadeb9a46199f89ebfaab226ac\nscriptPubKey        = 0020e7de0ad2720ae1d6cc9b6ad91af57eb74646762cf594c91c18f6d5e7a873635a\naddress             = bc1qul0q45njptsadnymdtv34at7karyva3v7k2vj8qc7m2702rnvddq0z20u5\n\n// last timelocked address = m/84'/0'/0'/2/959\nderived private_key = L5Z9DDMnj5RZMyyPiQLCvN48Xt7GGmev6cjvJXD8uz5EqiY8trNJ\nderived public_key  = 0308c5751121b1ae5c973cdc7071312f6fc10ab864262f0cbd8134f056166e50f3\nunix locktime       = 4099766400\nstring locktime     = 2099-12-01 00:00:00\nredeemscript        = 0580785df400b175210308c5751121b1ae5c973cdc7071312f6fc10ab864262f0cbd8134f056166e50f3ac\nscriptPubKey        = 0020803268e042008737cf439748cbb5a4449e311da9aa64ae3ac56d84d059654f85\naddress             = bc1qsqex3czzqzrn0n6rjayvhddygj0rz8df4fj2uwk9dkzdqkt9f7zs5c493u\n\n// Test certificate and endpoint signing using the first timelocked address = m/84'/0'/0'/2/0 (see above)\nbond private_key          = L2tQBEdhC48YLeEWNg3e4msk94iKfyVa9hdfzRwUERabZ53TfH3d\nbond p2pkh address        = 16vmiGpY1rEaYnpGgtG7FZgr2uFCpeDgV6\n\ncertificate private_key   = KyZpNDKnfs94vbrwhJneDi77V6jF64PWPF8x5cdJb8ifgg2DUc9d\ncertificate public_key    = 0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c\ncertificate p2pkh address = 1JaUQDVNRdhfNsVncGkXedaPSM5Gc54Hso\n\ncertificate message       = fidelity-bond-cert|0330d54fd0dd420a6e5f8d3624f5f3482cae350f79d5f0753bf5beef9c2d91af3c|375\ncertificate signature     = INOP3cB9UW7F1e1Aglj8rI9QhnyxmgWDEPt+nOMvl7hJJne7rH/KCNDYvLiqNuB9qWaWUojutjRsgPJrvyDQ+0Y=\n\n// example endpoint signing two IRC nicknames (used in JoinMarket)\nendpoint message          = J54LS6YyJPoseqFS|J55VZ6U6ZyFDNeuv\nendpoint signature        = H18WE4MugDNoWZIf9jU0njhQptdUyBDUf7lToG9bpMKmeJK0lOoABaDs5bKnohSuZ0e9gnSco5OL9lXdKU7gP5E=\n</pre>\n\nCode generating these test vectors can be found here: https://github.com/chris-belcher/timelocked-addresses-fidelity-bond-bip-testvectors\n\n== Reference ==\n\n* [[https://gist.github.com/chris-belcher/18ea0e6acdb885a2bfbdee43dcd6b5af/|Design for improving JoinMarket's resistance to sybil attacks using fidelity bonds]]\n* [[https://github.com/JoinMarket-Org/joinmarket-clientserver/blob/master/docs/fidelity-bonds.md|JoinMarket fidelity bonds doc page]]\n* [[bip-0065.mediawiki|BIP65 - OP_CHECKLOCKTIMEVERIFY]]\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic Wallets]]\n* [[bip-0049.mediawiki|BIP49 - Derivation scheme for P2WPKH-nested-in-P2SH based accounts]]\n* [[bip-0084.mediawiki|BIP84 - Derivation scheme for P2WPKH based accounts]]\n* [[bip-0086.mediawiki|BIP86 - Key Derivation for Single Key P2TR Outputs]]\n", "content_length": 13569}
{"bip_number": 45, "filename": "bip-0045.mediawiki", "content": "<pre>\n  BIP: 45\n  Layer: Applications\n  Title: Structure for Deterministic P2SH Multisignature Wallets\n  Author: Manuel Araoz <manu@bitpay.com>\n          Ryan X. Charles <ryan@bitpay.com>\n          Matias Alejo Garcia <matias@bitpay.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0045\n  Status: Proposed\n  Type: Standards Track\n  Created: 2014-04-25\n</pre>\n\n==Abstract==\n\nThis BIP defines a structure for hierarchical deterministic P2SH multi-party\nmulti-signature wallets (HDPM wallets from now on) based on the algorithm\ndescribed in BIP-0032 (BIP32 from now on) and purpose scheme described in\nBIP-0043 (BIP43 from now on).\nThis BIP is a particular application of BIP43.\n\n==Motivation==\n\nThe structure proposed in this document allows for standard ways to create,\nuse, import, and store HDPM wallets. It allows to handle multiple parties sharing\nan m-of-n wallet, on the following assumptions:\n* n parties share an m-of-n wallet.\n* Each party generates their master private keys independently.\n* Multisig P2SH is used for all addresses.\n* BIP32 is used to derive public keys, then create a multisig script, and the corresponding P2SH address for that script.\n* Address generation should not require communication between parties. (Thus, all parties must be able to generate all public keys)\n* Transaction creation and signing requires communication between parties.\n\nThis BIP will allow interoperability between various HDPM wallet implementations.\n\n==Specification==\n\nWe define the following levels in BIP32 path:\n\n<code>\nm / purpose' / cosigner_index / change / address_index\n</code>\n\nApostrophe in the path indicates that BIP32 hardened derivation is used.\n\nEach level has special meaning described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set to 45, following the BIP43 recommendation.\nIt indicates that the subtree of this node is used according to this specification.\n\n<code>\nm / 45' / *\n</code>\n\nHardened derivation is used at this level.\n\n\n===Cosigner Index===\n\nThe index of the party creating a P2SH multisig address. The indices can\nbe determined independently by lexicographically sorting the purpose public\nkeys of each cosigner. Each cosigner creates addresses on its own branch,\neven though they have independent extended master public key, as explained\nin the \"Address generation\" section.\n\nNote that the master public key is not shared amongst the cosigners. Only the\nhardened purpose extended public key is shared, and this is what is used to\nderive child extended public keys.\n\nSoftware should only use indices corresponding to each of the N cosigners\nsequentially. For example, for a 2-of-3 HDPM wallet, having the following\npurpose public keys:\n<pre>\n03a473275a750a20b7b71ebeadfec83130c014da4b53f1c4743fcf342af6589a38\n039863fb5f07b667d9b1ca68773c6e6cdbcac0088ffba9af46f6f6acd153d44463\n03f76588e06c0d688617ef365d1e58a7f1aa84daa3801380b1e7f12acc9a69cd13\n</pre>\n\nit should use <code>m / 45 ' / 0 / *</code> for\n<code>039863fb5f07b667d9b1ca68773c6e6cdbcac0088ffba9af46f6f6acd153d44463</code>,\n<code>m / 45 ' / 1 / *</code> for\n<code>03a473275a750a20b7b71ebeadfec83130c014da4b53f1c4743fcf342af6589a38</code>,\nand <code>m / 45 ' / 2 / *</code> for\n<code>03f76588e06c0d688617ef365d1e58a7f1aa84daa3801380b1e7f12acc9a69cd13</code>,\nas dictated by their lexicographical order.\n\n\nSoftware needs to discover all used indexes when importing the seed from\nan external source. Such algorithm is described in \"Address discovery\" chapter.\n\nNon-hardened derivation is used at this level.\n\n===Change===\n\nConstant 0 is used for external chain and constant 1 for internal chain (also\nknown as change addresses). External chain is used for addresses that are meant\nto be visible outside of the wallet (e.g. for receiving payments). Internal\nchain is used for addresses which are not meant to be visible outside of the\nwallet and is used for return transaction change.\n\nFor example, if cosigner 2 wants to generate a change address, he would use\n<code>m / 45 ' / 2 / 1 / *</code>, and <code>m / 45 ' / 2 / 0 / *</code> for a receive\naddress.\n\nNon-hardened derivation is used at this level.\n\n===Address Index===\n\nAddresses are numbered from index 0 in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nNon-hardened derivation is used at this level.\n\n===HDPM Wallet High-level Description===\nEach party generates their own extended master keypair and shares the\nextended purpose' public key with the others, which is stored encrypted.\nEach party can generate any of the other's derived public keys, but only\nhis own private keys.\n\n===Address Generation Procedure===\nWhen generating an address, each party can independently generate the N needed\npublic keys. They do this by deriving the public key in each of the different\ntrees, but using the same path. They can then generate the multisig script (by\nlexicographically sorting the public keys) and the corresponding p2sh address.\nIn this way, each path corresponds to an address, but the public keys for that\naddress come from different trees.\n\n====Receive address case====\nEach cosigner generates addresses only on his own branch. One of the n\ncosigners wants to receive a payment, and the others are offline. He\nknows the last used index in his own branch, because only he generates\naddresses there. Thus, he can generate the public keys for all of the\nothers using the next index, and calculate the needed script for the address.\n\nExample: Cosigner #2 wants to receive a payment to the shared wallet. His last\nused index on his own branch is 4. Then, the path for the next receive\naddress is <code>m/45'/2/0/5</code>. He uses this same path in all of the cosigners\ntrees to generate a public key for each one, and from that he gets the new\np2sh address.\n====Change address case====\nAgain, each cosigner generates addresses only on his own branch. One of the\nn cosigners wants to create an outgoing payment, for which he'll need a change\naddress. He generates a new address using the same procedure as above, but\nusing a separate index to track the used change addresses.\n\nExample: Cosigner #5 wants to send a payment from the shared wallet, for which\nhe'll need a change address. His last used change index on his own branch is\n11. Then, the path for the next change address is <code>m/45'/5/1/12</code>. He uses\nthis same path in all of the cosigners trees to generate a public key for each\none, and from that he gets the new p2sh address.\n\n\n===Transaction creation and signing===\nWhen creating a transaction, first one of the parties creates a Transaction\nProposal. This is a transaction that spends some output stored in any of the\np2sh multisig addresses (corresponding to any of the copayers' branches).\nThis proposal is sent to the other parties, who decide if they want to sign.\nIf they approve the proposal, they can generate their needed private key for\nthat specific address (using the same path that generated the public key in\nthat address, but deriving the private key instead), and sign it. Once the\nproposal reaches m signatures, any cosigner can broadcast it to the network,\nbecoming final. The specifics of how this proposal is structured, and the\nprotocol to accept or reject it, belong to another BIP, in my opinion.\n\n===Address discovery===\n\nWhen the master seed is imported from an external source the software should\nstart to discover the addresses in the following manner:\n\n# for each cosigner:\n# derive the cosigner's node (<code>m / 45' / cosigner_index</code>)\n# for both the external and internal chains on this node (<code>m / 45' / cosigner_index / 0</code> and <code>m / 45' / cosigner_index / 1</code>):\n# scan addresses of the chain; respect the gap limit described below\n\nPlease note that the algorithm uses the transaction history, not address\nbalances, so even if the address has 0 coins, the program should continue with discovery.\nOpposite to BIP44, each cosigner branch needs to be checked,\neven if the earlier ones don't have transactions\n\n===Address gap limit===\n\nAddress gap limit is currently set to 20. If the software hits 20 unused\naddresses (no transactions associated with that address) in a row, it expects\nthere are no used addresses beyond this point and stops searching the address chain.\n\nWallet software should warn when user is trying to exceed the gap limit on\nan external chain by generating a new address.\n\n\n===Rationale===\n\nThis structure provides a general way of doing HDPM wallets between m-of-n\nparties. Here are some explanations about the design decisions made.\n\nThe reason for using separate branches for each cosigner is we don't want\ntwo of them generating the same address and receiving simultaneous payments\nto it. The ideal case is that each address receives at most one payment,\nrequested by the corresponding cosigner.\n\n==Examples==\n\n{|\n!cosigner_index\n!change\n!address_index\n!path\n|-\n|first\n|receive\n|first\n| m / 45' / 0 / 0 / 0\n|-\n|first\n|receive\n|second\n| m / 45' / 0 / 0 / 1\n|-\n|first\n|receive\n|fifth\n| m / 45' / 0 / 0 / 4\n|-\n|first\n|change\n|first\n| m / 45' / 0 / 1 / 0\n|-\n|first\n|change\n|second\n| m / 45' / 0 / 1 / 1\n|-\n|second\n|receive\n|first\n| m / 45' / 1 / 0 / 0\n|-\n|third\n|change\n|tenth\n| m / 45' / 2 / 1 / 9\n|}\n\n==Compatible wallets==\n\n* [[https://copay.io|Copay wallet]] ([[https://github.com/bitpay/copay|source]])\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n* [[https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg05156.html|Original mailing list discussion]]\n", "content_length": 9652}
{"bip_number": 44, "filename": "bip-0044.mediawiki", "content": "<pre>\n  BIP: 44\n  Layer: Applications\n  Title: Multi-Account Hierarchy for Deterministic Wallets\n  Author: Marek Palatinus <slush@satoshilabs.com>\n          Pavol Rusnak <stick@satoshilabs.com>\n  Comments-Summary: Mixed review (one person)\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0044\n  Status: Final\n  Type: Standards Track\n  Created: 2014-04-24\n</pre>\n\n==Abstract==\n\nThis BIP defines a logical hierarchy for deterministic wallets based on an algorithm\ndescribed in BIP-0032 (BIP32 from now on) and purpose scheme described in\nBIP-0043 (BIP43 from now on).\n\nThis BIP is a particular application of BIP43.\n\n==Motivation==\n\nThe hierarchy proposed in this paper is quite comprehensive. It allows the handling of\nmultiple coins, multiple accounts, external and internal chains per account and\nmillions of addresses per chain.\n\n==Path levels==\n\nWe define the following 5 levels in BIP32 path:\n\n<pre>\nm / purpose' / coin_type' / account' / change / address_index\n</pre>\n\nApostrophe in the path indicates that BIP32 hardened derivation is used.\n\nEach level has a special meaning, described in the chapters below.\n\n===Purpose===\n\nPurpose is a constant set to 44' (or 0x8000002C) following the BIP43 recommendation.\nIt indicates that the subtree of this node is used according to this specification.\n\nHardened derivation is used at this level.\n\n===Coin type===\n\nOne master node (seed) can be used for unlimited number of independent\ncryptocoins such as Bitcoin, Litecoin or Namecoin. However, sharing the same\nspace for various cryptocoins has some disadvantages.\n\nThis level creates a separate subtree for every cryptocoin, avoiding\nreusing addresses across cryptocoins and improving privacy issues.\n\nCoin type is a constant, set for each cryptocoin. Cryptocoin developers may ask\nfor registering unused number for their project.\n\nThe list of already allocated coin types is in the chapter\n\"Registered coin types\" below.\n\nHardened derivation is used at this level.\n\n===Account===\n\nThis level splits the key space into independent user identities,\nso the wallet never mixes the coins across different accounts.\n\nUsers can use these accounts to organize the funds in the same\nfashion as bank accounts; for donation purposes (where all\naddresses are considered public), for saving purposes,\nfor common expenses etc.\n\nAccounts are numbered from index 0 in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nHardened derivation is used at this level.\n\nSoftware should prevent a creation of an account if a previous account does not\nhave a transaction history (meaning none of its addresses have been used before).\n\nSoftware needs to discover all used accounts after importing the seed from\nan external source. Such an algorithm is described in \"Account discovery\" chapter.\n\n===Change===\n\nConstant 0 is used for external chain and constant 1 for internal chain (also\nknown as change addresses). External chain is used for addresses that are meant\nto be visible outside of the wallet (e.g. for receiving payments). Internal\nchain is used for addresses which are not meant to be visible outside of the\nwallet and is used for return transaction change.\n\nPublic derivation is used at this level.\n\n===Index===\n\nAddresses are numbered from index 0 in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.\n\nPublic derivation is used at this level.\n\n==Account discovery==\n\nWhen the master seed is imported from an external source the software should\nstart to discover the accounts in the following manner:\n\n# derive the first account's node (index = 0)\n# derive the external chain node of this account\n# scan addresses of the external chain; respect the gap limit described below\n# if no transactions are found on the external chain, stop discovery\n# if there are some transactions, increase the account index and go to step 1\n\nThis algorithm is successful because software should disallow creation of new\naccounts if previous one has no transaction history, as described in chapter\n\"Account\" above.\n\nPlease note that the algorithm works with the transaction history, not account\nbalances, so you can have an account with 0 total coins and the algorithm will\nstill continue with discovery.\n\n===Address gap limit===\n\nAddress gap limit is currently set to 20. If the software hits 20 unused\naddresses in a row, it expects there are no used addresses beyond this point\nand stops searching the address chain. We scan just the external chains, because\ninternal chains receive only coins that come from the associated external chains.\n\nWallet software should warn when the user is trying to exceed the gap limit on\nan external chain by generating a new address.\n\n==Registered coin types==\n\nThese are the default registered coin types for usage in level 2 of BIP44\ndescribed in chapter \"Coin type\" above.\n\nAll these constants are used as hardened derivation.\n\n{|\n!index\n!hexa\n!coin\n|-\n|0\n|0x80000000\n|Bitcoin\n|-\n|1\n|0x80000001\n|Bitcoin Testnet\n|}\n\nThis BIP is not a central directory for the registered coin types, please\nvisit SatoshiLabs that maintains the full list:\n\n[[https://github.com/satoshilabs/slips/blob/master/slip-0044.md|SLIP-0044 : Registered coin types for BIP-0044]]\n\nTo register a new coin type, an existing wallet that implements the standard\nis required and a pull request to the above file should be created.\n\n==Examples==\n\n{|\n!coin\n!account\n!chain\n!address\n!path\n|-\n|Bitcoin\n|first\n|external\n|first\n|m / 44' / 0' / 0' / 0 / 0\n|-\n|Bitcoin\n|first\n|external\n|second\n|m / 44' / 0' / 0' / 0 / 1\n|-\n|Bitcoin\n|first\n|change\n|first\n|m / 44' / 0' / 0' / 1 / 0\n|-\n|Bitcoin\n|first\n|change\n|second\n|m / 44' / 0' / 0' / 1 / 1\n|-\n|Bitcoin\n|second\n|external\n|first\n|m / 44' / 0' / 1' / 0 / 0\n|-\n|Bitcoin\n|second\n|external\n|second\n|m / 44' / 0' / 1' / 0 / 1\n|-\n|Bitcoin\n|second\n|change\n|first\n|m / 44' / 0' / 1' / 1 / 0\n|-\n|Bitcoin\n|second\n|change\n|second\n|m / 44' / 0' / 1' / 1 / 1\n|-\n|Bitcoin Testnet\n|first\n|external\n|first\n|m / 44' / 1' / 0' / 0 / 0\n|-\n|Bitcoin Testnet\n|first\n|external\n|second\n|m / 44' / 1' / 0' / 0 / 1\n|-\n|Bitcoin Testnet\n|first\n|change\n|first\n|m / 44' / 1' / 0' / 1 / 0\n|-\n|Bitcoin Testnet\n|first\n|change\n|second\n|m / 44' / 1' / 0' / 1 / 1\n|-\n|Bitcoin Testnet\n|second\n|external\n|first\n|m / 44' / 1' / 1' / 0 / 0\n|-\n|Bitcoin Testnet\n|second\n|external\n|second\n|m / 44' / 1' / 1' / 0 / 1\n|-\n|Bitcoin Testnet\n|second\n|change\n|first\n|m / 44' / 1' / 1' / 1 / 0\n|-\n|Bitcoin Testnet\n|second\n|change\n|second\n|m / 44' / 1' / 1' / 1 / 1\n|}\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n* [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]\n", "content_length": 6687}
{"bip_number": 43, "filename": "bip-0043.mediawiki", "content": "<pre>\n  BIP: 43\n  Layer: Applications\n  Title: Purpose Field for Deterministic Wallets\n  Author: Marek Palatinus <slush@satoshilabs.com>\n          Pavol Rusnak <stick@satoshilabs.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0043\n  Status: Final\n  Type: Standards Track\n  Created: 2014-04-24\n</pre>\n\n==Abstract==\n\nThis BIP introduces a \"Purpose Field\" for use in deterministic wallets\nbased on algorithm described in BIP-0032 (BIP32 from now on).\n\n==Motivation==\n\nAlthough Hierarchical Deterministic Wallet structure as described by BIP32\nis an important step in user experience and security of the cryptocoin wallets,\nthe BIP32 specification offers implementers too many degrees of freedom.\nMultiple implementations may claim they are BIP32 compatible, but in fact\nthey can produce wallets with different logical structures making them\nnon-interoperable. This situation unfortunately renders \"BIP32 compatible\"\nstatement rather useless.\n\n\n==Purpose==\n\nWe propose the first level of BIP32 tree structure to be used as \"purpose\".\nThis purpose determines the further structure beneath this node.\n\n<pre>\nm / purpose' / *\n</pre>\n\nApostrophe indicates that BIP32 hardened derivation is used.\n\nWe encourage different schemes to apply for assigning a separate BIP number\nand use the same number for purpose field, so addresses won't be generated\nfrom overlapping BIP32 spaces.\n\nPurpose codes from 10001 to 19999 are reserved for [[https://github.com/satoshilabs/slips|SLIPs]].\n\nExample: Scheme described in BIP44 should use 44' (or 0x8000002C) as purpose.\n\nNote that m / 0' / * is already taken by BIP32 (default account), which\npreceded this BIP.\n\nNot all wallets may want to support the full range of features and possibilities\ndescribed in these BIPs. Instead of choosing arbitrary subset of defined features\nand calling themselves BIPxx compatible, we suggest that software which needs\nonly a limited structure should describe such structure in another BIP and use\ndifferent \"purpose\" value.\n\n\n==Node serialization==\n\nBecause this scheme can be used to generate nodes for more cryptocurrencies\nat once, or even something totally unrelated to cryptocurrencies, there's no\npoint in using a special version magic described in section \"Serialization\nformat\" of BIP32. We suggest to use always 0x0488B21E for public and 0x0488ADE4\nfor private nodes (leading to prefixes \"xpub\" and \"xprv\" respectively).\n\n==Reference==\n\n* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]\n", "content_length": 2541}
{"bip_number": 42, "filename": "bip-0042.mediawiki", "content": "<pre>\n  BIP: 42\n  Layer: Consensus (soft fork)\n  Title: A finite monetary supply for Bitcoin\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: Unanimously Recommended for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0042\n  Status: Final\n  Type: Standards Track\n  Created: 2014-04-01\n  License: PD\n</pre>\n\n==Abstract==\n\nAlthough it is widely believed that Satoshi was an inflation-hating goldbug he never said this, and in fact programmed Bitcoin's money supply to grow indefinitely, forever. He modeled the monetary supply as 4 gold mines being discovered per mibillennium (1024 years), with equal intervals between them, each one being depleted over the course of 140 years.\n\nThis poses obvious problems, however. Prominent among them is the discussion on what to call 1 billion bitcoin, which symbol color to use for it, and when wallet clients should switch to it by default.\n\nTo combat this, this document proposes a controversial change: making Bitcoin's monetary supply finite.\n\n==Details==\n\nAs is well known, Satoshi was a master programmer whose knowledge of C++ was surpassed only by his knowledge of Japanese culture. The code below:\n\n    int64_t nSubsidy = 50 * COIN;\n    // Subsidy is cut in half every 210,000 blocks\n    // which will occur approximately every 4 years.\n    nSubsidy >>= (nHeight / 210000);\n\nis carefully written to rely on undefined behaviour in the C++ specification - perhaps so it can be hardware accelerated in future.\n\nThe block number is divided by 210000 (the \"apparent\" subsidy halving interval in blocks), and the result is used as input for a binary shift, applied to the original payout (50 BTC), expressed in base units. Thanks to the new-goldmine interval being exactly 64 times the halving interval, and 64 being the size in bits of the currency datatype, the cycle repeats itself every 64 halvings on all currently supported platforms.\n\nDespite the nice showoff of underhanded programming skills - we want Bitcoin to be well-specified. Otherwise, we're clearly in for a bumpy ride:\n\n<img src=\"bip-0042/inflation.png\"></img>\n\nNote that several other programming languages do not exhibit this behaviour, making new implementations likely to be slower and generally more bogus than Bitcoin Core. For example, Python unexpectedly returns 0 when shifting an integer beyond its size.\n\n==Other solutions==\n\n===Floating-point approximation===\n\nAn obvious solution would be to reimplement the shape of the subsidy curve using floating-point approximations, such as simulated annealing or quantitative easing, which have already proven their worth in consensus systems. Unfortunately, since the financial crisis everyone considers numbers with decimal points in them fishy, and integers are not well supported by Javascript.\n\n===Truncation===\n\nAn alternative solution would be to represent the total number of bitcoins as a string:\n\n    \"21000000000000000000000\"\n\nand then use string manipulation to remove the rightmost zero every 4 years, give or take a leap-year:\n\n    strSubsidy = strSubsidy.substr(0, strSubsidy.size() - 2);\n\nThis style relies less heavily on clever C++ and is more familiar to the Core Dev Team who are primarily PHP programmers.\n\n==Proposal==\n\nInstead, how about we stop thinking about long term issues when we'll all be dead (barring near lightspeed travel, cryogenic revival, or other technology\u2014 like cryptocurrency\u2014 which only exists in science fiction).\n\nA softfork (see BIP16, BIP34, BIP62) will take place on april 1st 2214, permanently setting the subsidy to zero. The result of this will be that the total currency supply will be limited to 42 halfmillion (including the genesis coinbase output, which is not actually spendable).\n\n==Implementation==\n\nAn implementation for the reference client can be found on https://github.com/bitcoin/bitcoin/pull/3842 .\n\n==Compatibility==\n\nGiven the moderate time frame over which this change is to be implemented, we expect all miners to choose to screw themselves and deploy this change before 2214.\n\nIf they don't, and a minority remains on the old code base, a fork may occur. Essentially, they'll be mining fool's gold after that time.\n\n==Acknowledgements==\n\nThanks to Gregory Maxwell for proposing this solution, and to Mike Hearn for insights into web development. Also thanks to \"ditto-b\" on github to implement a prototype ahead of time.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 4470}
{"bip_number": 39, "filename": "bip-0039.mediawiki", "content": "<pre>\n  BIP: 39\n  Layer: Applications\n  Title: Mnemonic code for generating deterministic keys\n  Author: Marek Palatinus <slush@satoshilabs.com>\n          Pavol Rusnak <stick@satoshilabs.com>\n          Aaron Voisine <voisine@gmail.com>\n          Sean Bowe <ewillbefull@gmail.com>\n  Comments-Summary: Unanimously Discourage for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0039\n  Status: Final\n  Type: Standards Track\n  Created: 2013-09-10\n  License: MIT\n</pre>\n\n==Abstract==\n\nThis BIP describes the implementation of a mnemonic code or mnemonic sentence --\na group of easy to remember words -- for the generation of deterministic wallets.\n\nIt consists of two parts: generating the mnemonic and converting it into a\nbinary seed. This seed can be later used to generate deterministic wallets using\nBIP-0032 or similar methods.\n\n==Copyright==\n\nThis BIP falls under the MIT License.\n\n==Motivation==\n\nA mnemonic code or sentence is superior for human interaction compared to the\nhandling of raw binary or hexadecimal representations of a wallet seed. The\nsentence could be written on paper or spoken over the telephone.\n\nThis guide is meant to be a way to transport computer-generated randomness with\na human-readable transcription. It's not a way to process user-created\nsentences (also known as brainwallets) into a wallet seed.\n\n==Generating the mnemonic==\n\nThe mnemonic must encode entropy in a multiple of 32 bits. With more entropy\nsecurity is improved but the sentence length increases. We refer to the\ninitial entropy length as ENT. The allowed size of ENT is 128-256 bits.\n\nFirst, an initial entropy of ENT bits is generated. A checksum is generated by\ntaking the first <code>ENT / 32</code> bits of its SHA256 hash. This checksum is\nappended to the end of the initial entropy. Next, these concatenated bits\nare split into groups of 11 bits, each encoding a number from 0-2047, serving\nas an index into a wordlist. Finally, we convert these numbers into words and\nuse the joined words as a mnemonic sentence.\n\nThe following table describes the relation between the initial entropy\nlength (ENT), the checksum length (CS), and the length of the generated mnemonic\nsentence (MS) in words.\n\n<pre>\nCS = ENT / 32\nMS = (ENT + CS) / 11\n\n|  ENT  | CS | ENT+CS |  MS  |\n+-------+----+--------+------+\n|  128  |  4 |   132  |  12  |\n|  160  |  5 |   165  |  15  |\n|  192  |  6 |   198  |  18  |\n|  224  |  7 |   231  |  21  |\n|  256  |  8 |   264  |  24  |\n</pre>\n\n==Wordlist==\n\nAn ideal wordlist has the following characteristics:\n\na) smart selection of words\n   - the wordlist is created in such a way that it's enough to type the first four\n     letters to unambiguously identify the word\n\nb) similar words avoided\n   - word pairs like \"build\" and \"built\", \"woman\" and \"women\", or \"quick\" and \"quickly\"\n     not only make remembering the sentence difficult but are also more error\n     prone and more difficult to guess\n\nc) sorted wordlists\n   - the wordlist is sorted which allows for more efficient lookup of the code words\n     (i.e. implementations can use binary search instead of linear search)\n   - this also allows trie (a prefix tree) to be used, e.g. for better compression\n\nThe wordlist can contain native characters, but they must be encoded in UTF-8\nusing Normalization Form Compatibility Decomposition (NFKD).\n\n==From mnemonic to seed==\n\nA user may decide to protect their mnemonic with a passphrase. If a passphrase is not\npresent, an empty string \"\" is used instead.\n\nTo create a binary seed from the mnemonic, we use the PBKDF2 function with a mnemonic\nsentence (in UTF-8 NFKD) used as the password and the string \"mnemonic\" + passphrase (again\nin UTF-8 NFKD) used as the salt. The iteration count is set to 2048 and HMAC-SHA512 is used as\nthe pseudo-random function. The length of the derived key is 512 bits (= 64 bytes).\n\nThis seed can be later used to generate deterministic wallets using BIP-0032 or\nsimilar methods.\n\nThe conversion of the mnemonic sentence to a binary seed is completely independent\nfrom generating the sentence. This results in a rather simple code; there are no\nconstraints on sentence structure and clients are free to implement their own\nwordlists or even whole sentence generators, allowing for flexibility in wordlists\nfor typo detection or other purposes.\n\nAlthough using a mnemonic not generated by the algorithm described in \"Generating the\nmnemonic\" section is possible, this is not advised and software must compute a\nchecksum for the mnemonic sentence using a wordlist and issue a warning if it is\ninvalid.\n\nThe described method also provides plausible deniability, because every passphrase\ngenerates a valid seed (and thus a deterministic wallet) but only the correct one\nwill make the desired wallet available.\n\n==Wordlists==\n\nSince the vast majority of BIP39 wallets supports only the English wordlist,\nit is '''strongly discouraged''' to use non-English wordlists for generating\nthe mnemonic sentences.\n\nIf you still feel your application really needs to use a localized wordlist,\nuse one of the following instead of inventing your own.\n\n* [[bip-0039/bip-0039-wordlists.md|Wordlists]]\n\n==Test vectors==\n\nThe test vectors include input entropy, mnemonic and seed. The\npassphrase \"TREZOR\" is used for all vectors.\n\nhttps://github.com/trezor/python-mnemonic/blob/master/vectors.json\n\nAlso see https://github.com/bip32JP/bip32JP.github.io/blob/master/test_JP_BIP39.json\n\n(Japanese wordlist test with heavily normalized symbols as passphrase)\n\n==Reference Implementation==\n\nReference implementation including wordlists is available from\n\nhttp://github.com/trezor/python-mnemonic\n", "content_length": 5662}
{"bip_number": 38, "filename": "bip-0038.mediawiki", "content": "<pre>\n  BIP: 38\n  Layer: Applications\n  Title: Passphrase-protected private key\n  Author: Mike Caldwell <mcaldwell@swipeclock.com>\n          Aaron Voisine <voisine@gmail.com>\n  Comments-Summary: Unanimously Discourage for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0038\n  Status: Draft (Some confusion applies: The announcements for this never made it to the list, so it hasn't had public discussion)\n  Type: Standards Track\n  Created: 2012-11-20\n  License: PD\n</pre>\n\n==Abstract==\nA method is proposed for encrypting and encoding a passphrase-protected Bitcoin private key record in the form of a 58-character Base58Check-encoded printable string.  Encrypted private key records are intended for use on paper wallets and physical Bitcoins.  Each record string contains all the information needed to reconstitute the private key except for a passphrase, and the methodology uses salting and ''scrypt'' to resist brute-force attacks.\n\nThe method provides two encoding methodologies - one permitting any known private key to be encrypted with any passphrase, and another permitting a shared private key generation scheme where the party generating the final key string and its associated Bitcoin address (such as a physical bitcoin manufacturer) knows only a string derived from the original passphrase, and where the original passphrase is needed in order to actually redeem funds sent to the associated Bitcoin address.\n\nA 32-bit hash of the resulting Bitcoin address is encoded in plaintext within each encrypted key, so it can be correlated to a Bitcoin address with reasonable probability by someone not knowing the passphrase.  The complete Bitcoin address can be derived through successful decryption of the key record.\n\n==Motivation==\nThe motivation to make this proposal stems from observations of the way physical bitcoins and paper wallets are used.\n\nAn issuer of physical bitcoins must be trustworthy and trusted.  Even if trustworthy, users are rightful to be skeptical about a third party with theoretical access to take their funds.  A physical bitcoin that cannot be compromised by its issuer is always more intrinsically valuable than one that can.\n\nA two-factor physical bitcoin solution is highly useful to individuals and organizations wishing to securely own bitcoins without any risk of electronic theft and without the responsibility of climbing the technological learning curve necessary to produce such an environment themselves.  Two-factor physical bitcoins allow a secure storage solution to be put in a box and sold on the open market, greatly enlarging the number of people who are able to securely store bitcoins.\n\nExisting methodologies for creating two-factor physical bitcoins are limited and cumbersome.  At the time of this proposal, a user could create their own private key, submit the public key to the physical bitcoin issuer, and then receive a physical bitcoin that must be kept together with some sort of record of the user-generated private key, and finally, must be redeemed through a tool.  The fact that the physical bitcoin must be kept together with a user-produced private key negates much of the benefit of the physical bitcoin - the user may as well just print and maintain a private key.\n\nA standardized password-protected private key format makes acquiring and redeeming two-factor physical bitcoins simpler for the user.  Instead of maintaining a private key that cannot be memorized, the user may choose a passphrase of their choice.  The passphrase may be much shorter than the length of a typical private key, short enough that they could use a label or engraver to permanently commit their passphrase to their physical Bitcoin piece once they have received it.  By adopting a standard way to encrypt a private key, we maximize the possibility that they'll be able to redeem their funds in the venue of their choice, rather than relying on an executable redemption tool they may not wish to download.\n\nPassword and passphrase-protected private keys enable new practical use cases for sending bitcoins from person to person.  Someone wanting to send bitcoins through postal mail could send a password-protected paper wallet and give the recipient the passphrase over the phone or e-mail, making the transfer safe from interception of either channel.  A user of paper wallets or Bitcoin banknote-style vouchers (\"cash\") could carry funded encrypted private keys while leaving a copy at home as an element of protection against accidental loss or theft.  A user of paper wallets who leaves bitcoins in a bank vault or safety deposit box could keep the password at home or share it with trusted associates as protection against someone at the bank gaining access to the paper wallets and spending from them.  The foreseeable and unforeseeable use cases for password-protected private keys are numerous.\n\n==Copyright==\nThis proposal is hereby placed in the public domain.\n\n==Rationale==\n:'' '''User story:''' As a Bitcoin user who uses paper wallets, I would like the ability to add encryption, so that my Bitcoin paper storage can be two factor: something I have plus something I know.''\n:'' '''User story:''' As a Bitcoin user who would like to pay a person or a company with a private key, I do not want to worry that any part of the communication path may result in the interception of the key and theft of my funds.  I would prefer to offer an encrypted private key, and then follow it up with the password using a different communication channel (e.g. a phone call or SMS).''\n:'' '''User story:''' (EC-multiplied keys) As a user of physical bitcoins, I would like a third party to be able to create password-protected Bitcoin private keys for me, without them knowing the password, so I can benefit from the physical bitcoin without the issuer having access to the private key.  I would like to be able to choose a password whose minimum length and required format does not preclude me from memorizing it or engraving it on my physical bitcoin, without exposing me to an undue risk of password cracking and/or theft by the manufacturer of the item.''\n:'' '''User story:''' (EC-multiplied keys) As a user of paper wallets, I would like the ability to generate a large number of Bitcoin addresses protected by the same password, while enjoying a high degree of security (highly expensive scrypt parameters), but without having to incur the scrypt delay for each address I generate.''\n\n==Specification==\nThis proposal makes use of the following functions and definitions:\n\n*'''AES256Encrypt, AES256Decrypt''': the simple form of the well-known AES block cipher without consideration for initialization vectors or block chaining.  Each of these functions takes a 256-bit key and 16 bytes of input, and deterministically yields 16 bytes of output.\n*'''SHA256''', a well-known hashing algorithm that takes an arbitrary number of bytes as input and deterministically yields a 32-byte hash.\n*'''scrypt''': A well-known key derivation algorithm.  It takes the following parameters: (string) password, (string) salt, (int) n, (int) r, (int) p, (int) length, and deterministically yields an array of bytes whose length is equal to the length parameter.\n*'''ECMultiply''': Multiplication of an elliptic curve point by a scalar integer with respect to the secp256k1 elliptic curve.\n*'''G, N''': Constants defined as part of the secp256k1 elliptic curve.  G is an elliptic curve point, and N is a large positive integer.\n*'''Base58Check''': a method for encoding arrays of bytes using 58 alphanumeric characters commonly used in the Bitcoin ecosystem.\n\n===Prefix===\nIt is proposed that the resulting Base58Check-encoded string start with a '6'.  The number '6' is intended to represent, from the perspective of the user, \"a private key that needs something else to be usable\" - an umbrella definition that could be understood in the future to include keys participating in multisig transactions, and was chosen with deference to the existing prefix '5' most commonly observed in Wallet Import Format which denotes an unencrypted private key.\n\nIt is proposed that the second character ought to give a hint as to what is needed as a second factor, and for an encrypted key requiring a passphrase, the uppercase letter P is proposed.\n\nTo keep the size of the encrypted key down, no initialization vectors (IVs) are used in the AES encryption.  Rather, suitable values for IV-like use are derived using scrypt from the passphrase and from using a 32-bit hash of the resulting Bitcoin address as salt.\n\n===Proposed specification===\n\n* Object identifier prefix: 0x0142 (non-EC-multiplied) or 0x0143 (EC-multiplied).  These are constant bytes that appear at the beginning of the Base58Check-encoded record, and their presence causes the resulting string to have a predictable prefix.\n* How the user sees it: 58 characters always starting with '6P'\n** Visual cues are present in the third character for visually identifying the EC-multiply and compress flag.\n* Count of payload bytes (beyond prefix): 37\n** 1 byte (''flagbyte''):\n*** the most significant two bits are set as follows to preserve the visibility of the compression flag in the prefix, as well as to keep the payload within the range of allowable values that keep the \"6P\" prefix intact.  For non-EC-multiplied keys, the bits are 11.  For EC-multiplied keys, the bits are 00.\n*** the bit with value 0x20 when set indicates the key should be converted to a base58check encoded P2PKH bitcoin address using the DER compressed public key format. When not set, it should be a base58check encoded P2PKH bitcoin address using the DER uncompressed public key format.\n*** the bits with values 0x10 and 0x08 are reserved for a future specification that contemplates using multisig as a way to combine the factors such that parties in possession of the separate factors can independently sign a proposed transaction without requiring that any party possess both factors.  These bits must be 0 to comply with this version of the specification.\n*** the bit with value 0x04 indicates whether a lot and sequence number are encoded into the first factor, and activates special behavior for including them in the decryption process.  This applies to EC-multiplied keys only.  Must be 0 for non-EC-multiplied keys.\n*** remaining bits are reserved for future use and must all be 0 to comply with this version of the specification.\n** 4 bytes: SHA256(SHA256(expected_bitcoin_address))[0...3], used both for typo checking and as salt\n**16 bytes: Contents depend on whether EC multiplication is used.\n**16 bytes: lasthalf: An AES-encrypted key material record (contents depend on whether EC multiplication is used)\n* Range in base58check encoding for non-EC-multiplied keys without compression (prefix 6PR):\n** Minimum value: 6PRHv1jg1ytiE4kT2QtrUz8gEjMQghZDWg1FuxjdYDzjUkcJeGdFj9q9Vi (based on 01 42 C0 plus thirty-six 00's)\n** Maximum value: 6PRWdmoT1ZursVcr5NiD14p5bHrKVGPG7yeEoEeRb8FVaqYSHnZTLEbYsU (based on 01 42 C0 plus thirty-six FF's)\n* Range in base58check encoding for non-EC-multiplied keys with compression (prefix 6PY):\n** Minimum value: 6PYJxKpVnkXUsnZAfD2B5ZsZafJYNp4ezQQeCjs39494qUUXLnXijLx6LG (based on 01 42 E0 plus thirty-six 00's)\n** Maximum value: 6PYXg5tGnLYdXDRZiAqXbeYxwDoTBNthbi3d61mqBxPpwZQezJTvQHsCnk (based on 01 42 E0 plus thirty-six FF's)\n* Range in base58check encoding for EC-multiplied keys without compression (prefix 6Pf):\n** Minimum value: 6PfKzduKZXAFXWMtJ19Vg9cSvbFg4va6U8p2VWzSjtHQCCLk3JSBpUvfpf (based on 01 43 00 plus thirty-six 00's)\n** Maximum value: 6PfYiPy6Z7BQAwEHLxxrCEHrH9kasVQ95ST1NnuEnnYAJHGsgpNPQ9dTHc (based on 01 43 00 plus thirty-six FF's)\n* Range in base58check encoding for EC-multiplied keys with compression (prefix 6Pn):\n** Minimum value: 6PnM2wz9LHo2BEAbvoGpGjMLGXCom35XwsDQnJ7rLiRjYvCxjpLenmoBsR (based on 01 43 20 plus thirty-six 00's)\n** Maximum value: 6PnZki3vKspApf2zym6Anp2jd5hiZbuaZArPfa2ePcgVf196PLGrQNyVUh (based on 01 43 20 plus thirty-six FF's)\n\n====Encryption when EC multiply flag is not used====\nEncrypting a private key without the EC multiplication offers the advantage that any known private key can be encrypted.  The party performing the encryption must know the passphrase.\n\nEncryption steps:\n# Compute the Bitcoin address (ASCII), and take the first four bytes of SHA256(SHA256()) of it.  Let's call this \"addresshash\".\n# Derive a key from the passphrase using scrypt\n#*Parameters: ''passphrase'' is the passphrase itself encoded in UTF-8 and normalized using Unicode Normalization Form C (NFC).  salt is ''addresshash'' from the earlier step, n=16384, r=8, p=8, length=64 (n, r, p are provisional and subject to consensus)\n#*Let's split the resulting 64 bytes in half, and call them ''derivedhalf1'' and ''derivedhalf2''.\n# Do AES256Encrypt(block = bitcoinprivkey[0...15] xor derivedhalf1[0...15], key = derivedhalf2), call the 16-byte result ''encryptedhalf1''\n# Do AES256Encrypt(block = bitcoinprivkey[16...31] xor derivedhalf1[16...31], key = derivedhalf2), call the 16-byte result ''encryptedhalf2''\n\nThe encrypted private key is the Base58Check-encoded concatenation of the following, which totals 39 bytes without Base58 checksum:\n* 0x01 0x42 + ''flagbyte'' + ''salt'' + ''encryptedhalf1'' + ''encryptedhalf2''\n\nDecryption steps:\n# Collect encrypted private key and passphrase from user.\n# Derive ''derivedhalf1'' and ''derivedhalf2'' by passing the passphrase and ''addresshash'' into scrypt function.\n# Decrypt ''encryptedhalf1'' and ''encryptedhalf2'' using AES256Decrypt, merge them to form the encrypted private key.\n# Convert that private key into a Bitcoin address, honoring the compression preference specified in ''flagbyte'' of the encrypted key record.\n# Hash the Bitcoin address, and verify that ''addresshash'' from the encrypted private key record matches the hash.  If not, report that the passphrase entry was incorrect.\n\n====Encryption when EC multiply mode is used====\nEncrypting a private key with EC multiplication offers the ability for someone to generate encrypted keys knowing only an EC point derived from the original passphrase and some salt generated by the passphrase's owner, and without knowing the passphrase itself.  Only the person who knows the original passphrase can decrypt the private key.  A code known as an ''intermediate code'' conveys the information needed to generate such a key without knowledge of the passphrase.\n\nThis methodology does not offer the ability to encrypt a known private key - this means that the process of creating encrypted keys is also the process of generating new addresses.  On the other hand, this serves a security benefit for someone possessing an address generated this way: if the address can be recreated by decrypting its private key with a passphrase, and it's a strong passphrase one can be certain only he knows himself, then he can safely conclude that nobody could know the private key to that address.\n\nThe person who knows the passphrase and who is the intended beneficiary of the private keys is called the ''owner''.  He will generate one or more \"intermediate codes\", which are the first factor of a two-factor redemption system, and will give them to someone else we'll call ''printer'', who generates a key pair with an intermediate code can know the address and encrypted private key, but cannot decrypt the private key without the original passphrase.\n\nAn intermediate code should, but is not required to, embed a printable \"lot\" and \"sequence\" number for the benefit of the user.  The proposal forces these lot and sequence numbers to be included in any valid private keys generated from them.  An owner who has requested multiple private keys to be generated for him will be advised by applications to ensure that each private key has a unique lot and sequence number consistent with the intermediate codes he generated.  These mainly help protect ''owner'' from potential mistakes and/or attacks that could be made by ''printer''.\n\nThe \"lot\" and \"sequence\" number are combined into a single 32 bit number.  20 bits are used for the lot number and 12 bits are used for the sequence number, such that the lot number can be any decimal number between 0 and 1048575, and the sequence number can be any decimal number between 0 and 4095.  For programs that generate batches of intermediate codes for an ''owner'', it is recommended that lot numbers be chosen at random within the range 100000-999999 and that sequence numbers are assigned starting with 1.\n\nSteps performed by ''owner'' to generate a single intermediate code, if lot and sequence numbers are being included:\n# Generate 4 random bytes, call them ''ownersalt''.\n# Encode the lot and sequence numbers as a 4 byte quantity (big-endian): lotnumber * 4096 + sequencenumber.  Call these four bytes ''lotsequence''.\n# Concatenate ''ownersalt'' + ''lotsequence'' and call this ''ownerentropy''.\n# Derive a key from the passphrase using scrypt\n#* Parameters: ''passphrase'' is the passphrase itself encoded in UTF-8 and normalized using Unicode Normalization Form C (NFC).  salt is ''ownersalt''. n=16384, r=8, p=8, length=32.\n#* Call the resulting 32 bytes ''prefactor''.\n#* Take SHA256(SHA256(''prefactor'' + ''ownerentropy'')) and call this ''passfactor''. The \"+\" operator is concatenation.\n# Compute the elliptic curve point G * ''passfactor'', and convert the result to compressed notation (33 bytes).  Call this ''passpoint''.  Compressed notation is used for this purpose regardless of whether the intent is to create Bitcoin addresses with or without compressed public keys.\n# Convey ''ownersalt'' and ''passpoint'' to the party generating the keys, along with a checksum to ensure integrity.\n#* The following Base58Check-encoded format is recommended for this purpose: magic bytes \"2C E9 B3 E1 FF 39 E2 51\" followed by ''ownerentropy'', and then ''passpoint''.  The resulting string will start with the word \"passphrase\" due to the constant bytes, will be 72 characters in length, and encodes 49 bytes (8 bytes constant + 8 bytes ''ownerentropy'' + 33 bytes ''passpoint'').  The checksum is handled in the Base58Check encoding.  The resulting string is called ''intermediate_passphrase_string''.\n\nIf lot and sequence numbers are not being included, then follow the same procedure with the following changes:\n* ''ownersalt'' is 8 random bytes instead of 4, and ''lotsequence'' is omitted.  ''ownerentropy'' becomes an alias for ''ownersalt''.\n* The SHA256 conversion of ''prefactor'' to ''passfactor'' is omitted.  Instead, the output of scrypt is used directly as ''passfactor''.\n* The magic bytes are \"2C E9 B3 E1 FF 39 E2 53\" instead (the last byte is 0x53 instead of 0x51).\n\nSteps to create new encrypted private keys given ''intermediate_passphrase_string'' from ''owner'' (so we have ''ownerentropy'', and ''passpoint'', but we do not have ''passfactor'' or the passphrase):\n# Set ''flagbyte''.\n#* Turn on bit 0x20 if the Bitcoin address will be formed by hashing the compressed public key (optional, saves space, but many Bitcoin implementations aren't compatible with it)\n#* Turn on bit 0x04 if ''ownerentropy'' contains a value for ''lotsequence''.  (While it has no effect on the keypair generation process, the decryption process needs this flag to know how to process ''ownerentropy'')\n# Generate 24 random bytes, call this ''seedb''.  Take SHA256(SHA256(''seedb'')) to yield 32 bytes, call this ''factorb''.\n# ECMultiply ''passpoint'' by ''factorb''.  Use the resulting EC point as a public key and hash it into a Bitcoin address using either compressed or uncompressed public key methodology (specify which methodology is used inside ''flagbyte'').  This is the generated Bitcoin address, call it ''generatedaddress''.\n# Take the first four bytes of SHA256(SHA256(''generatedaddress'')) and call it ''addresshash''.\n# Now we will encrypt ''seedb''.  Derive a second key from ''passpoint'' using scrypt\n#*Parameters: ''passphrase'' is ''passpoint'' provided from the first party (expressed in binary as 33 bytes).  ''salt'' is ''addresshash'' + ''ownerentropy'', n=1024, r=1, p=1, length=64.  The \"+\" operator is concatenation.\n#*Split the result into two 32-byte halves and call them ''derivedhalf1'' and ''derivedhalf2''.\n# Do AES256Encrypt(block = (seedb[0...15] xor derivedhalf1[0...15]), key = derivedhalf2), call the 16-byte result ''encryptedpart1''\n# Do AES256Encrypt(block = ((encryptedpart1[8...15] + seedb[16...23]) xor derivedhalf1[16...31]), key = derivedhalf2), call the 16-byte result ''encryptedpart2''.  The \"+\" operator is concatenation.\n\nThe encrypted private key is the Base58Check-encoded concatenation of the following, which totals 39 bytes without Base58 checksum:\n* 0x01 0x43 + ''flagbyte'' + ''addresshash'' + ''ownerentropy'' + ''encryptedpart1''[0...7] + ''encryptedpart2''\n\n=====Confirmation code=====\nThe party generating the Bitcoin address has the option to return a ''confirmation code'' back to ''owner'' which allows ''owner'' to independently verify that he has been given a Bitcoin address that actually depends on his passphrase, and to confirm the lot and sequence numbers (if applicable).  This protects ''owner'' from being given a Bitcoin address by the second party that is unrelated to the key derivation and possibly spendable by the second party.  If a Bitcoin address given to ''owner'' can be successfully regenerated through the confirmation process, ''owner'' can be reasonably assured that any spending without the passphrase is infeasible.  This confirmation code is 75 characters starting with \"cfrm38\".\n\nTo generate it, we need ''flagbyte'', ''ownerentropy'', ''factorb'', ''derivedhalf1'' and ''derivedhalf2'' from the original encryption operation.\n# ECMultiply ''factorb'' by G, call the result ''pointb''.  The result is 33 bytes.\n# The first byte is 0x02 or 0x03.  XOR it by (derivedhalf2[31] & 0x01), call the resulting byte ''pointbprefix''.\n# Do AES256Encrypt(block = (pointb[1...16] xor derivedhalf1[0...15]), key = derivedhalf2) and call the result ''pointbx1''.\n# Do AES256Encrypt(block = (pointb[17...32] xor derivedhalf1[16...31]), key = derivedhalf2) and call the result ''pointbx2''.\n# Concatenate ''pointbprefix'' + ''pointbx1'' + ''pointbx2'' (total 33 bytes) and call the result ''encryptedpointb''.\n\nThe result is a Base58Check-encoded concatenation of the following:\n* 0x64 0x3B 0xF6 0xA8 0x9A + ''flagbyte'' + ''addresshash'' + ''ownerentropy'' + ''encryptedpointb''\n\nA confirmation tool, given a passphrase and a confirmation code, can recalculate the address, verify the address hash, and then assert the following: \"It is confirmed that Bitcoin address ''address'' depends on this passphrase\".  If applicable: \"The lot number is ''lotnumber'' and the sequence number is ''sequencenumber''.\"\n\nTo recalculate the address:\n# Derive ''passfactor'' using scrypt with ''ownerentropy'' and the user's passphrase and use it to recompute ''passpoint''\n# Derive decryption key for ''pointb'' using scrypt with ''passpoint'', ''addresshash'', and ''ownerentropy''\n# Decrypt ''encryptedpointb'' to yield ''pointb''\n# ECMultiply ''pointb'' by ''passfactor''. Use the resulting EC point as a public key and hash it into ''address'' using either compressed or uncompressed public key methodology as specified in ''flagbyte''.\n\n=====Decryption=====\n# Collect encrypted private key and passphrase from user.\n# Derive ''passfactor'' using scrypt with ''ownersalt'' and the user's passphrase and use it to recompute ''passpoint''\n# Derive decryption key for ''seedb'' using scrypt with ''passpoint'', ''addresshash'', and ''ownerentropy''\n# Decrypt ''encryptedpart2'' using AES256Decrypt to yield the last 8 bytes of ''seedb'' and the last 8 bytes of ''encryptedpart1''.\n# Decrypt ''encryptedpart1'' to yield the remainder of ''seedb''.\n# Use ''seedb'' to compute ''factorb''.\n# Multiply ''passfactor'' by ''factorb'' mod N to yield the private key associated with ''generatedaddress''.\n# Convert that private key into a Bitcoin address, honoring the compression preference specified in the encrypted key.\n# Hash the Bitcoin address, and verify that ''addresshash'' from the encrypted private key record matches the hash.  If not, report that the passphrase entry was incorrect.\n\n==Backwards compatibility==\nBackwards compatibility is minimally applicable since this is a new standard that at most extends Wallet Import Format. It is assumed that an entry point for private key data may also accept existing formats of private keys (such as hexadecimal and Wallet Import Format); this draft uses a key format that cannot be mistaken for any existing one and preserves auto-detection capabilities.\n\n==Suggestions for implementers of proposal with alt-chains==\nIf this proposal is accepted into alt-chains, it is requested that the unused flag bytes not be used for denoting that the key belongs to an alt-chain.\n\nAlt-chain implementers should exploit the address hash for this purpose.  Since each operation in this proposal involves hashing a text representation of a coin address which (for Bitcoin) includes the leading '1', an alt-chain can easily be denoted simply by using the alt-chain's preferred format for representing an address.  Alt-chain implementers may also change the prefix such that encrypted addresses do not start with \"6P\".\n\n==Discussion item: scrypt parameters==\nThis proposal leaves the scrypt parameters up in the air.  The following items are proposed for consideration:\n\nThe main goal of scrypt is to reduce the feasibility of brute force attacks.  It must be assumed that an attacker will be able to use an efficient implementation of scrypt.  The parameters should force a highly efficient implementation of scrypt to wait a decent amount of time to slow attacks.\n\nOn the other hand, an unavoidably likely place where scrypt will be implemented is using slow interpreted languages such as javascript.  What might take milliseconds on an efficient scrypt implementation may take seconds in javascript.\n\nIt is believed, however, that someone using a javascript implementation is probably dealing with codes by hand, one at a time, rather than generating or processing large batches of codes.  Thus, a wait time of several seconds is acceptable to a user.\n\nA private key redemption process that forces a server to consume several seconds of CPU time would discourage implementation by the server owner, because they would be opening up a denial of service avenue by inviting users to make numerous attempts to invoke the redemption process.  However, it's also feasible for the server owner to implement his redemption process in such a way that the decryption is done by the user's browser, offloading the task from his own server (and providing another reason why the chosen scrypt parameters should be tolerant of javascript-based decryptors).\n\nThe preliminary values of 16384, 8, and 8 are hoped to offer the following properties:\n* Encryption/decryption in javascript requiring several seconds per operation\n* Use of the parallelization parameter provides a modest opportunity for speedups in environments where concurrent threading is available - such environments would be selected for processes that must handle bulk quantities of encryption/decryption operations.  Estimated time for an operation is in the tens or hundreds of milliseconds.\n\n==Reference implementation==\nAdded to alpha version of Casascius Bitcoin Address Utility for Windows available at:\n\n* https://github.com/casascius/Bitcoin-Address-Utility\n\nClick \"Tools\" then \"PPEC Keygen\" (provisional name)\n\n==Test vectors==\n\n===No compression, no EC multiply===\n\nTest 1:\n*Passphrase: TestingOneTwoThree\n*Encrypted: 6PRVWUbkzzsbcVac2qwfssoUJAN1Xhrg6bNk8J7Nzm5H7kxEbn2Nh2ZoGg\n*Unencrypted (WIF): 5KN7MzqK5wt2TP1fQCYyHBtDrXdJuXbUzm4A9rKAteGu3Qi5CVR\n*Unencrypted (hex): CBF4B9F70470856BB4F40F80B87EDB90865997FFEE6DF315AB166D713AF433A5\n\nTest 2:\n*Passphrase: Satoshi\n*Encrypted: 6PRNFFkZc2NZ6dJqFfhRoFNMR9Lnyj7dYGrzdgXXVMXcxoKTePPX1dWByq\n*Unencrypted (WIF): 5HtasZ6ofTHP6HCwTqTkLDuLQisYPah7aUnSKfC7h4hMUVw2gi5\n*Unencrypted (hex): 09C2686880095B1A4C249EE3AC4EEA8A014F11E6F986D0B5025AC1F39AFBD9AE\n\nTest 3:\n*Passphrase \u03d2\u0301\u2400\ud801\udc00\ud83d\udca9 (<tt>\\u03D2\\u0301\\u0000\\U00010400\\U0001F4A9</tt>; [http://codepoints.net/U+03D2 GREEK UPSILON WITH HOOK], [http://codepoints.net/U+0301 COMBINING ACUTE ACCENT], [http://codepoints.net/U+0000 NULL], [http://codepoints.net/U+10400 DESERET CAPITAL LETTER LONG I], [http://codepoints.net/U+1F4A9 PILE OF POO])\n*Encrypted key: 6PRW5o9FLp4gJDDVqJQKJFTpMvdsSGJxMYHtHaQBF3ooa8mwD69bapcDQn\n*Bitcoin Address: 16ktGzmfrurhbhi6JGqsMWf7TyqK9HNAeF\n*Unencrypted private key (WIF): 5Jajm8eQ22H3pGWLEVCXyvND8dQZhiQhoLJNKjYXk9roUFTMSZ4\n* ''Note:'' The non-standard UTF-8 characters in this passphrase should be NFC normalized to result in a passphrase of <tt>0xcf9300f0909080f09f92a9</tt> before further processing\n\n===Compression, no EC multiply===\n\nTest 1:\n*Passphrase: TestingOneTwoThree\n*Encrypted: 6PYNKZ1EAgYgmQfmNVamxyXVWHzK5s6DGhwP4J5o44cvXdoY7sRzhtpUeo\n*Unencrypted (WIF): L44B5gGEpqEDRS9vVPz7QT35jcBG2r3CZwSwQ4fCewXAhAhqGVpP\n*Unencrypted (hex): CBF4B9F70470856BB4F40F80B87EDB90865997FFEE6DF315AB166D713AF433A5\n\nTest 2:\n*Passphrase: Satoshi\n*Encrypted: 6PYLtMnXvfG3oJde97zRyLYFZCYizPU5T3LwgdYJz1fRhh16bU7u6PPmY7\n*Unencrypted (WIF): KwYgW8gcxj1JWJXhPSu4Fqwzfhp5Yfi42mdYmMa4XqK7NJxXUSK7\n*Unencrypted (hex): 09C2686880095B1A4C249EE3AC4EEA8A014F11E6F986D0B5025AC1F39AFBD9AE\n\n===EC multiply, no compression, no lot/sequence numbers===\n\nTest 1:\n*Passphrase: TestingOneTwoThree\n*Passphrase code: passphrasepxFy57B9v8HtUsszJYKReoNDV6VHjUSGt8EVJmux9n1J3Ltf1gRxyDGXqnf9qm\n*Encrypted key: 6PfQu77ygVyJLZjfvMLyhLMQbYnu5uguoJJ4kMCLqWwPEdfpwANVS76gTX\n*Bitcoin address: 1PE6TQi6HTVNz5DLwB1LcpMBALubfuN2z2\n*Unencrypted private key (WIF): 5K4caxezwjGCGfnoPTZ8tMcJBLB7Jvyjv4xxeacadhq8nLisLR2\n*Unencrypted private key (hex): A43A940577F4E97F5C4D39EB14FF083A98187C64EA7C99EF7CE460833959A519\n\nTest 2:\n*Passphrase: Satoshi\n*Passphrase code: passphraseoRDGAXTWzbp72eVbtUDdn1rwpgPUGjNZEc6CGBo8i5EC1FPW8wcnLdq4ThKzAS\n*Encrypted key: 6PfLGnQs6VZnrNpmVKfjotbnQuaJK4KZoPFrAjx1JMJUa1Ft8gnf5WxfKd\n*Bitcoin address: 1CqzrtZC6mXSAhoxtFwVjz8LtwLJjDYU3V\n*Unencrypted private key (WIF): 5KJ51SgxWaAYR13zd9ReMhJpwrcX47xTJh2D3fGPG9CM8vkv5sH\n*Unencrypted private key (hex): C2C8036DF268F498099350718C4A3EF3984D2BE84618C2650F5171DCC5EB660A\n\n===EC multiply, no compression, lot/sequence numbers===\n\nTest 1:\n*Passphrase: MOLON LABE\n*Passphrase code: passphraseaB8feaLQDENqCgr4gKZpmf4VoaT6qdjJNJiv7fsKvjqavcJxvuR1hy25aTu5sX\n*Encrypted key: 6PgNBNNzDkKdhkT6uJntUXwwzQV8Rr2tZcbkDcuC9DZRsS6AtHts4Ypo1j\n*Bitcoin address: 1Jscj8ALrYu2y9TD8NrpvDBugPedmbj4Yh\n*Unencrypted private key (WIF): 5JLdxTtcTHcfYcmJsNVy1v2PMDx432JPoYcBTVVRHpPaxUrdtf8\n*Unencrypted private key (hex): 44EA95AFBF138356A05EA32110DFD627232D0F2991AD221187BE356F19FA8190\n*Confirmation code: cfrm38V8aXBn7JWA1ESmFMUn6erxeBGZGAxJPY4e36S9QWkzZKtaVqLNMgnifETYw7BPwWC9aPD\n*Lot/Sequence: 263183/1\n\nTest 2:\n*Passphrase (all letters are Greek - test UTF-8 compatibility with this): \u039c\u039f\u039b\u03a9\u039d \u039b\u0391\u0392\u0395\n*Passphrase code: passphrased3z9rQJHSyBkNBwTRPkUGNVEVrUAcfAXDyRU1V28ie6hNFbqDwbFBvsTK7yWVK\n*Encrypted private key: 6PgGWtx25kUg8QWvwuJAgorN6k9FbE25rv5dMRwu5SKMnfpfVe5mar2ngH\n*Bitcoin address: 1Lurmih3KruL4xDB5FmHof38yawNtP9oGf\n*Unencrypted private key (WIF): 5KMKKuUmAkiNbA3DazMQiLfDq47qs8MAEThm4yL8R2PhV1ov33D\n*Unencrypted private key (hex): CA2759AA4ADB0F96C414F36ABEB8DB59342985BE9FA50FAAC228C8E7D90E3006\n*Confirmation code: cfrm38V8G4qq2ywYEFfWLD5Cc6msj9UwsG2Mj4Z6QdGJAFQpdatZLavkgRd1i4iBMdRngDqDs51\n*Lot/Sequence: 806938/1\n", "content_length": 31663}
{"bip_number": 37, "filename": "bip-0037.mediawiki", "content": "<pre>\n  BIP: 37\n  Layer: Peer Services\n  Title: Connection Bloom filtering\n  Author: Mike Hearn <hearn@google.com>\n          Matt Corallo <bip37@bluematt.me>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0037\n  Status: Final\n  Type: Standards Track\n  Created: 2012-10-24\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP adds new support to the peer-to-peer protocol that allows peers to reduce the amount of transaction data they are sent. Peers have the option of setting ''filters'' on each connection they make after the version handshake has completed. A filter is defined as a [http://en.wikipedia.org/wiki/Bloom_filter Bloom filter] on data derived from transactions. A Bloom filter is a probabilistic data structure which allows for testing set membership - they can have false positives but not false negatives.\n\nThis document will not go into the details of how Bloom filters work and the reader is referred to Wikipedia for an introduction to the topic.\n\n==Motivation==\n\nAs Bitcoin grows in usage the amount of bandwidth needed to download blocks and transaction broadcasts increases. Clients implementing ''simplified payment verification'' do not attempt to fully verify the block chain, instead just checking that block headers connect together correctly and trusting that the transactions in a chain of high difficulty are in fact valid. See the Bitcoin paper for more detail on this mode.\n\nToday, [[https://bitcoin.org/en/developer-guide#simplified-payment-verification-spv|SPV]] clients have to download the entire contents of blocks and all broadcast transactions, only to throw away the vast majority of the transactions that are not relevant to their wallets. This slows down their synchronization process, wastes users bandwidth (which on phones is often metered) and increases memory usage. All three problems are triggering real user complaints for the Android \"Bitcoin Wallet\" app which implements SPV mode. In order to make chain synchronization fast, cheap and able to run on older phones with limited memory we want to have remote peers throw away irrelevant transactions before sending them across the network.\n\n==Design rationale==\n\nThe most obvious way to implement the stated goal would be for clients to upload lists of their keys to the remote node. We take a more complex approach for the following reasons:\n\n* Privacy: Because Bloom filters are probabilistic, with the false positive rate chosen by the client, nodes can trade off precision vs bandwidth usage. A node with access to lots of bandwidth may choose to have a high FP rate, meaning the remote peer cannot accurately know which transactions belong to the client and which don't. A node with very little bandwidth may choose to use a very accurate filter meaning that they only get sent transactions actually relevant to their wallet, but remote peers may be able to correlate transactions with IP addresses (and each other).\n* Bloom filters are compact and testing membership in them is fast. This results in satisfying performance characteristics with minimal risk of opening up potential for DoS attacks.\n\n==Specification==\n\n===New messages===\n\nWe start by adding three new messages to the protocol:\n\n* <code>filterload</code>, which sets the current Bloom filter on the connection\n* <code>filteradd</code>, which adds the given data element to the connections current filter without requiring a completely new one to be set\n* <code>filterclear</code>, which deletes the current filter and goes back to regular pre-BIP37 usage.\n\nNote that there is no filterremove command because by their nature, Bloom filters are append-only data structures. Once an element is added it cannot be removed again without rebuilding the entire structure from scratch.\n\nThe <code>filterload</code> command is defined as follows:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| ? || filter || uint8_t[] || The filter itself is simply a bit field of arbitrary byte-aligned size. The maximum size is 36,000 bytes.\n|-\n| 4 || nHashFuncs || uint32_t || The number of hash functions to use in this filter. The maximum value allowed in this field is 50.\n|-\n| 4 || nTweak || uint32_t || A random value to add to the seed value in the hash function used by the bloom filter.\n|-\n| 1 || nFlags || uint8_t || A set of flags that control how matched items are added to the filter.\n|}\n\nSee below for a description of the Bloom filter algorithm and how to select nHashFuncs and filter size for a desired false positive rate.\n\nUpon receiving a <code>filterload</code> command, the remote peer will immediately restrict the broadcast transactions it announces (in inv packets) to transactions matching the filter, where the matching algorithm is specified below. The flags control the update behaviour of the matching algorithm.\n\nThe <code>filteradd</code> command is defined as follows:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| ? || data || uint8_t[] || The data element to add to the current filter.\n|}\n\nThe data field must be smaller than or equal to 520 bytes in size (the maximum size of any potentially matched object).\n\nThe given data element will be added to the Bloom filter. A filter must have been previously provided using <code>filterload</code>. This command is useful if a new key or script is added to a clients wallet whilst it has connections to the network open, it avoids the need to re-calculate and send an entirely new filter to every peer (though doing so is usually advisable to maintain anonymity).\n\nThe <code>filterclear</code> command has no arguments at all.\n\nAfter a filter has been set, nodes don't merely stop announcing non-matching transactions, they can also serve filtered blocks. A filtered block is defined by the <code>merkleblock</code> message and is defined like this:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 4 || version || uint32_t || Block version information, based upon the software version creating this block\n|-\n| 32 || prev_block || char[32] || The hash value of the previous block this particular block references\n|-\n| 32 || merkle_root || char[32] || The reference to a Merkle tree collection which is a hash of all transactions related to this block\n|-\n| 4 || timestamp || uint32_t || A timestamp recording when this block was created (Limited to 2106!)\n|-\n| 4 || bits || uint32_t || The calculated difficulty target being used for this block\n|-\n| 4 || nonce || uint32_t || The nonce used to generate this block\u2026 to allow variations of the header and compute different hashes\n|-\n| 4 || total_transactions || uint32_t || Number of transactions in the block (including unmatched ones)\n|-\n| ? || hashes || uint256[] || hashes in depth-first order (including standard varint size prefix)\n|-\n| ? || flags || byte[] || flag bits, packed per 8 in a byte, least significant bit first (including standard varint size prefix)\n|}\n\nSee below for the format of the partial merkle tree hashes and flags.\n\nThus, a <code>merkleblock</code> message is a block header, plus a part of a merkle tree which can be used to extract identifying information for transactions that matched the filter and prove that the matching transaction data really did appear in the solved block. Clients can use this data to be sure that the remote node is not feeding them fake transactions that never appeared in a real block, although lying through omission is still possible.\n\n===Extensions to existing messages===\n\nThe <code>version</code> command is extended with a new field:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 1 byte || fRelay || bool || If false then broadcast transactions will not be announced until a filter{load,add,clear} command is received. If missing or true, no change in protocol behaviour occurs.\n|}\n\nSPV clients that wish to use Bloom filtering would normally set fRelay to false in the version message, then set a filter based on their wallet (or a subset of it, if they are overlapping different peers). Being able to opt-out of inv messages until the filter is set prevents a client being flooded with traffic in the brief window of time between finishing version handshaking and setting the filter.\n\nThe <code>getdata</code> command is extended to allow a new type in the <code>inv</code> submessage. The type field can now be <code>MSG_FILTERED_BLOCK (== 3)</code> rather than <code>MSG_BLOCK</code>. If no filter has been set on the connection, a request for filtered blocks is ignored. If a filter has been set, a <code>merkleblock</code> message is returned for the requested block hash. In addition, because a <code>merkleblock</code> message contains only a list of transaction hashes, transactions matching the filter should also be sent in separate tx messages after the merkleblock is sent. This avoids a slow roundtrip that would otherwise be required (receive hashes, didn't see some of these transactions yet, ask for them).  Note that because there is currently no way to request transactions which are already in a block from a node (aside from requesting the full block), the set of matching transactions that the requesting node hasn't either received or announced with an inv must be sent and any additional transactions which match the filter may also be sent.  This allows for clients (such as the reference client) to limit the number of invs it must remember a given node to have announced while still providing nodes with, at a minimum, all the transactions it needs.\n\n===Filter matching algorithm===\n\nThe filter can be tested against arbitrary pieces of data, to see if that data was inserted by the client. Therefore the question arises of what pieces of data should be inserted/tested.\n\nTo determine if a transaction matches the filter, the following algorithm is used. Once a match is found the algorithm aborts.\n\n# Test the hash of the transaction itself.\n# For each output, test each data element of the output script. This means each hash and key in the output script is tested independently. '''Important:''' if an output matches whilst testing a transaction, the node might need to update the filter by inserting the serialized COutPoint structure. See below for more details.\n# For each input, test the serialized COutPoint structure.\n# For each input, test each data element of the input script (note: input scripts only ever contain data elements).\n# Otherwise there is no match.\n\nIn this way addresses, keys and script hashes (for P2SH outputs) can all be added to the filter. You can also match against classes of transactions that are marked with well known data elements in either inputs or outputs, for example, to implement various forms of [[https://en.bitcoin.it/wiki/Smart_Property|Smart property]].\n\nThe test for outpoints is there to ensure you can find transactions spending outputs in your wallet, even though you don't know anything about their form. As you can see, once set on a connection the filter is '''not static''' and can change throughout the connections lifetime. This is done to avoid the following race condition:\n\n# A client sets a filter matching a key in their wallet. They then start downloading the block chain. The part of the chain that the client is missing is requested using getblocks.\n# The first block is read from disk by the serving peer. It contains TX 1 which sends money to the clients key. It matches the filter and is thus sent to the client.\n# The second block is read from disk by the serving peer. It contains TX 2 which spends TX 1. However TX 2 does not contain any of the clients keys and is thus not sent. The client does not know the money they received was already spent.\n\nBy updating the bloom filter atomically in step 2 with the discovered outpoint, the filter will match against TX 2 in step 3 and the client will learn about all relevant transactions, despite that there is no pause between the node processing the first and second blocks.\n\nThe nFlags field of the filter controls the nodes precise update behaviour and is a bit field.\n\n* <code>BLOOM_UPDATE_NONE (0)</code> means the filter is not adjusted when a match is found.\n* <code>BLOOM_UPDATE_ALL (1)</code> means if the filter matches any data element in a scriptPubKey the outpoint is serialized and inserted into the filter.\n* <code>BLOOM_UPDATE_P2PUBKEY_ONLY (2)</code> means the outpoint is inserted into the filter only if a data element in the scriptPubKey is matched, and that script is of the standard \"pay to pubkey\" or \"pay to multisig\" forms.\n\nThese distinctions are useful to avoid too-rapid degradation of the filter due to an increasing false positive rate. We can observe that a wallet which expects to receive only payments of the standard pay-to-address form doesn't need automatic filter updates because any transaction that spends one of its own outputs has a predictable data element in the input (the pubkey that hashes to the address). If a wallet might receive pay-to-address outputs and also pay-to-pubkey or pay-to-multisig outputs then BLOOM_UPDATE_P2PUBKEY_ONLY is appropriate, as it avoids unnecessary expansions of the filter for the most common types of output but still ensures correct behaviour with payments that explicitly specify keys.\n\nObviously, nFlags == 1 or nFlags == 2 mean that the filter will get dirtier as more of the chain is scanned. Clients should monitor the observed false positive rate and periodically refresh the filter with a clean one.\n\n===Partial Merkle branch format===\n\nA ''Merkle tree'' is a way of arranging a set of items as leaf nodes of tree in which the interior nodes are hashes of the concatenations of their child hashes. The root node is called the ''Merkle root''. Every Bitcoin block contains a Merkle root of the tree formed from the blocks transactions. By providing some elements of the trees interior nodes (called a ''Merkle branch'') a proof is formed that the given transaction was indeed in the block when it was being mined, but the size of the proof is much smaller than the size of the original block.\n\n====Constructing a partial merkle tree object====\n\n* Traverse the merkle tree from the root down, and for each encountered node:\n** Check whether this node corresponds to a leaf node (transaction) that is to be included OR any parent thereof:\n*** If so, append a '1' bit to the flag bits\n*** Otherwise, append a '0' bit.\n** Check whether this node is an internal node (non-leaf) AND is the parent of an included leaf node:\n*** If so:\n**** Descend into its left child node, and process the subtree beneath it entirely (depth-first).\n**** If this node has a right child node too, descend into it as well.\n*** Otherwise: append this node's hash to the hash list.\n\n====Parsing a partial merkle tree object====\n\nAs the partial block message contains the number of transactions in the entire block, the shape of the merkle tree is known before hand. Again, traverse this tree, computing traversed node's hashes along the way:\n* Read a bit from the flag bit list:\n** If it is '0':\n*** Read a hash from the hashes list, and return it as this node's hash.\n** If it is '1' and this is a leaf node:\n*** Read a hash from the hashes list, store it as a matched txid, and return it as this node's hash.\n** If it is '1' and this is an internal node:\n*** Descend into its left child tree, and store its computed hash as L.\n*** If this node has a right child as well:\n**** Descend into its right child, and store its computed hash as R.\n**** If L == R, the partial merkle tree object is invalid.\n**** Return Hash(L || R).\n*** If this node has no right child, return Hash(L || L).\n\nThe partial merkle tree object is only valid if:\n* All hashes in the hash list were consumed and no more.\n* All bits in the flag bits list were consumed (except padding to make it into a full byte), and no more.\n* The hash computed for the root node matches the block header's merkle root.\n* The block header is valid, and matches its claimed proof of work.\n* In two-child nodes, the hash of the left and right branches was never equal.\n\n===Bloom filter format===\n\nA Bloom filter is a bit-field in which bits are set based on feeding the data element to a set of different hash functions. The number of hash functions used is a parameter of the filter. In Bitcoin we use version 3 of the 32-bit Murmur hash function. To get N \"different\" hash functions we simply initialize the Murmur algorithm with the following formula:\n\n<code>nHashNum * 0xFBA4C795 + nTweak</code>\n\ni.e. if the filter is initialized with 4 hash functions and a tweak of 0x00000005, when the second function (index 1) is needed h1 would be equal to 4221880218.\n\nWhen loading a filter with the <code>filterload</code> command, there are two parameters that can be chosen. One is the size of the filter in bytes. The other is the number of hash functions to use. To select the parameters you can use the following formulas:\n\nLet N be the number of elements you wish to insert into the set and P be the probability of a false positive, where 1.0 is \"match everything\" and zero is unachievable.\n\nThe size S of the filter in bytes is given by <code>(-1 / pow(log(2), 2) * N * log(P)) / 8</code>. Of course you must ensure it does not go over the maximum size (36,000: selected as it represents a filter of 20,000 items with false positive rate of &lt; 0.1% or 10,000 items and a false positive rate of &lt; 0.0001%).\n\nThe number of hash functions required is given by <code>S * 8 / N * log(2)</code>.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 17633}
{"bip_number": 36, "filename": "bip-0036.mediawiki", "content": "<pre>\n  BIP: 36\n  Layer: Peer Services\n  Title: Custom Services\n  Author: Stefan Thomas <justmoon@members.fsf.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0036\n  Status: Rejected\n  Type: Standards Track\n  Created: 2012-08-03\n  License: PD\n</pre>\n\n==Abstract==\n\nThis BIP adds new fields to the <code>version</code> message which clients can use to announce custom services without polluting the limited 64-bit <code>services</code> field. It also makes some non-binding recommendations regarding the implementation of custom services.\n\n==Motivation==\n\nWe would like to encourage experimentation with custom services that extend the Bitcoin protocol with useful functionality. Examples include Distributed Hash Tables (DHT), distributed pools, lightweight client support protocols, directed message routing and support for custom transports. However, without a general framework for protocol extensions, these custom services are likely to collide in various ways. This BIP provides such a framework.\n\n==Specification==\n\nTwo new fields are added to the <code>version</code> command, after <code>extra_height</code>:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 1+ || service_count || [[Protocol_specification#Variable_length_integer|var_int]] || Number of extra services\n|-\n| ? || service_list || service[] || List of service definitions\n|}\n\nThe service definitions <code>service[]</code> are given in the following format:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| ? || service_name || [[#Variable length string|var_str]] || Unique service identifier\n|-\n| 4 || service_version || uint32_t || Identifies service version being used by the node\n|-\n| ? || service_data || [[#Variable length string|var_str]] || Additional service-specific data\n|}\n\nA node MUST NOT announce two services with the same <code>service_name</code>. If a remote node sends such a <code>version</code> message the client MAY disconnect.\n\nThe <code>service_version</code> is service-specific and can be any integer. Higher versions SHOULD be higher integers. When a service is standardized, it is assigned a <code>NODE_*</code> constant for use with the <code>services</code> field and future iterations of the protocol depend on the Bitcoin protocol version. Both the <code>NODE_*</code> flag and the custom service entry MAY be provided for the duration of a transitional period.\n\nServices SHOULD pass an empty string (0x00) as <code>service_data</code> and use a custom handshake to initialize their protocol, exchange information about capabilities etc. Note that to become a standardized service, a service MUST NOT rely on <code>service_data</code> since there is no corresponding mechanism for the standard services defined in the <code>services</code> field.\n\nHowever, services MAY use <code>service_data</code> if they do not intend to become standard services and need a simple way to transmit a small amount of initialization data. For example, a node offering a custom transport like UDP or WebSocket, may choose to announce this as a service and include the port number in <code>service_data</code>. The format for <code>service_data</code> is service-specific and may be any binary or ASCII data. For ease of debugging, a human-readable (ASCII) format is generally recommended.\n\n===Service identifier===\n\nEach service SHOULD choose a new identifier that is not used by any other service. To register a new identifier, add it to the [[Service identifiers]] wiki page along with the name of the maintainer and a way to contact them. Please do not register identifiers unless you are actually using them.\n\nService identifiers that are reserved or used by an accepted BIP MUST NOT be used except in the way specified by that BIP.\n\nService identifiers MUST be between five (5) and eleven (11) characters long. Service identifiers MUST use only ASCII characters, excluding: / * _ :\n\nValid examples:\n* <code>MySampleSvc</code>\n* <code>smartserv</code>\n* <code>P-Pool</code>\n\nValid, but discouraged examples:\n\n* <code>MySVC 1.0</code> (use <code>service_version</code> to differentiate versions)\n* <code>@@---.</code> (identifiers should be pronounceable)\n* <code>lightweight</code> (avoid too generic names)\n\nInvalid examples:\n\n* <code>Pppc</code> (too short)\n* <code>SuperService</code> (too long)\n* <code>Cool_Svc</code> (invalid character)\n\n===Optional: Custom commands===\n\nBitcoin command names are limited to 12 characters. That doesn't leave a lot of space for both the service identifier and the service command. Therefore we recommend that all service commands SHOULD be represented by a single \"command\" on the Bitcoin network. This command SHOULD consist of the exact service identifier to avoid collisions with other services, prefixed by an underscore to avoid collisions with current or future Bitcoin protocol messages. For example: <code>_MySampleSvc</code>\n\nThe service-specific command name SHOULD then be specified in an extra header in the payload:\n\n{|class=\"wikitable\"\n! Field Size !! Description !! Data type !! Comments\n|-\n| 12 || subcommand || char[12] || ASCII string identifying the service command, NULL padded (non-NULL padding results in packet rejected)\n|-\n| ? || subpayload || uchar[] || The actual data\n|}\n\nThe length of <code>subpayload</code> is derived from the length of the total payload minus twelve (12) bytes for the <code>subcommand</code>. Implementations MUST NOT rely on this format to be used by unknown services. Clients SHOULD ignore any services or subcommands they don't explicitly understand.\n\nThe recommended way to refer to messages following this format in documentation is by the service identifier, followed by a colon, followed by the subcommand. For example, the subcommand <code>search</code> for the <code>MySampleSvc</code> service would be referred to as: <code>MySampleSvc:search</code>\n\nFull hexdump of an example <code>MySampleSvc:search</code> message:\n\n<pre>\n0000   F9 BE B4 D9 5F 4D 79 53  61 6D 70 6C 65 53 76 63   ...._MySampleSvc\n0010   14 00 00 00 73 D5 56 77  73 65 61 72 63 68 00 00   ....s.Vwsearch..\n0020   00 00 00 00 12 34 56 78  9A BC DE F0               .....4Vx....\n\nMessage header:\n F9 BE B4 D9                                                                   - Main network magic bytes\n 5F 4D 79 53 61 6D 70 6C 65 53 76 63                                           - \"_MySampleSvc\" command\n 14 00 00 00                                                                   - Payload is 20 bytes long\n                                                                                 (includes 12 bytes for subcommand)\n 73 D5 56 77                                                                   - Checksum\n\nService header:\n 73 65 61 72 63 68 00 00 00 00 00 00                                           - \"search\" subcommand\n\nSearch message:\n 12 34 56 78 9A BC DE F0                                                       - Payload\n</pre>\n\n==Standardization==\n\nCustom services may become standard parts of the protocol. Services which wish to become part of the Bitcoin protocol MUST fulfill the following criteria:\n\n* MUST NOT use <code>service_data</code>; Standard services have no corresponding field\n* MUST use a peer discovery mechanism which specifies one bit per node, same as the <code>services</code> field in <code>addr</code> messages\n* MUST NOT use any subcommands that conflict with current or planned Bitcoin protocol commands\n\nThe standardization process will usually take place as follows:\n\n# The service is implemented and tested.\n# Once the API is known to be relatively stable it is formalized and submitted as a BIP.\n# Once the BIP is accepted, the service is assigned a <code>NODE_*</code> constant and the transitional period starts:\n#* Clients MUST understand both the announcement of the service via the <code>services</code> field and via <code>service_list</code> and include both methods in their own <code>version</code> message.\n#* Clients MUST accept both the wrapped form messages like <code>MySampleSvc:search</code> as well as the corresponding non-namespaced messages like <code>search</code>. Clients MUST only send wrapped messages.\n#* During the transitional period the API of the service MUST NOT change.\n# After the transitional period:\n#* Clients MUST only announce the service via the <code>services</code> field.\n#* Clients MUST only send unwrapped messages.\n# Future changes to the service API now require a BIP and an increase in the Bitcoin protocol version.\n\nThis process of adding a service to the Bitcoin protocol should only be undertaken for services where there is a strong rationale for doing so. Services MAY also be standardized as custom services via a BIP while maintaining the custom service format.\n\n==Rationale==\n\nThis BIP aims to fulfill the following goals:\n\n* Minimize the risk of namespace collisions, ambiguities or other issues arising from conflicting custom services\n* Provide an easy upgrade path for custom services to become standardized services with their own <code>NODE_*</code> flag\n* Place minimum restrictions on custom service authors\n* Allow custom services to be created with minimum effort\n* Allow clients to support multiple/many custom services at once\n\nTo achieve these goals this BIP adds two new fields to the <code>version</code> message. It would have been possible to avoid changes to <code>version</code> by adding a new message instead. However, it makes sense to keep both types of service announcements in the same message so that the life cycle of standardized services and custom services remains exactly the same. This also simplifies detecting a service which is in the transition from a custom to a standardized service (and being announced using both methods.)\n\nFinally, this BIP defines both explicitly and implicitly some useful common nomenclature that can be used when discussing custom services, e.g. \"subcommand\", \"subpayload\", \"service identifier\" and the colon format for referring to subcommands.\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 10154}
{"bip_number": 35, "filename": "bip-0035.mediawiki", "content": "<pre>\n  BIP: 35\n  Layer: Peer Services\n  Title: mempool message\n  Author: Jeff Garzik <jgarzik@exmulti.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0035\n  Status: Final\n  Type: Standards Track\n  Created: 2012-08-16\n</pre>\n\n==Abstract==\n\nMake a network node's transaction memory pool accessible via a new \"mempool\" message.  Extend the existing \"getdata\" message behavior to permit accessing the transaction memory pool.\n\n==Motivation==\n\nSeveral use cases make it desirable to expose a network node's transaction memory pool:\n# SPV clients, wishing to obtain zero-confirmation transactions sent or received.\n# Miners, to avoid missing lucrative fees, downloading existing network transactions after a restart.\n# Remote network diagnostics.\n\n==Specification==\n\n# The mempool message is defined as an empty message where pchCommand == \"mempool\"\n# Upon receipt of a \"mempool\" message, the node will respond with an \"inv\" message containing MSG_TX hashes of all the transactions in the node's transaction memory pool, if any.\n# The typical node behavior in response to an \"inv\" is \"getdata\". However, the reference Satoshi implementation ignores requests for transaction hashes outside that which is recently relayed. To support \"mempool\", an implementation must extend its \"getdata\" message support to querying the memory pool.\n# Feature discovery is enabled by checking two \"version\" message attributes:\n## Protocol version >= 60002\n## NODE_NETWORK bit set in nServices\n\nNote that existing implementations drop \"inv\" messages with a vector size > 50000.\n\n==Backward compatibility==\n\nOlder clients remain 100% compatible and interoperable after this change.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/1641\n", "content_length": 1783}
{"bip_number": 34, "filename": "bip-0034.mediawiki", "content": "<pre>\n  BIP: 34\n  Layer: Consensus (soft fork)\n  Title: Block v2, Height in Coinbase\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0034\n  Status: Final\n  Type: Standards Track\n  Created: 2012-07-06\n</pre>\n\n==Abstract==\n\nBitcoin blocks and transactions are versioned binary structures. Both currently use version 1. This BIP introduces an upgrade path for versioned transactions and blocks. A unique value is added to newly produced coinbase transactions, and blocks are updated to version 2.\n\n==Motivation==\n\n# Clarify and exercise the mechanism whereby the bitcoin network collectively consents to upgrade transaction or block binary structures, rules and behaviors.\n# Enforce block and transaction uniqueness, and assist unconnected block validation.\n\n==Specification==\n\n# Treat transactions with a version greater than 1 as non-standard (official Satoshi client will not mine or relay them).\n# Add height as the first item in the coinbase transaction's scriptSig, and increase block version to 2. The format of the height is \"minimally encoded serialized CScript\" -- first byte is number of bytes in the number (will be 0x03 on main net for the next 150 or so years with 2<sup>23</sup>-1 blocks), following bytes are little-endian representation of the number (including a sign bit).  Height is the height of the mined block in the block chain, where the genesis block is height zero (0).\n# 75% rule: If 750 of the last 1,000 blocks are version 2 or greater, reject invalid version 2 blocks. (testnet3: 51 of last 100)\n# 95% rule (\"Point of no return\"): If 950 of the last 1,000 blocks are version 2 or greater, reject all version 1 blocks. (testnet3: 75 of last 100)\n\n==Backward compatibility==\n\nAll older clients are compatible with this change. Users and merchants should not be impacted. Miners are strongly recommended to upgrade to version 2 blocks. Once 95% of the miners have upgraded to version 2, the remainder will be orphaned if they fail to upgrade.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/1526\n\n==Result==\n\nBlock number 227,835 (timestamp 2013-03-24 15:49:13 GMT) was the last version 1 block.\n", "content_length": 2240}
{"bip_number": 33, "filename": "bip-0033.mediawiki", "content": "<pre>\n  BIP: 33\n  Layer: Peer Services\n  Title: Stratized Nodes\n  Author: Amir Taaki <genjix@riseup.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0033\n  Status: Rejected\n  Type: Standards Track\n  Created: 2012-05-15\n</pre>\n\n== Abstract ==\n\nAs the Bitcoin network scales, roles are fast becoming specialised. In the beginning, a single Bitcoin user would perform the synonymous roles of miner, merchant and end-user. With the growth however of this system, these functions are being abstracted away to specialised services as a natural part of Bitcoin's growth.\n\nBitcoin's blockchain becomes more unwieldy for end users over time, negatively affecting the usability of Bitcoin clients. As it grows, it becomes ever more impractical to deal with on portable devices or low end machines. Several proposals have been put forward to deal with this such as lightweight (headers-only) clients and skipping validation for blocks before the last checkpoint. However these measures are at best stop-gap workarounds to stave off a growing problem.\n\nThis document will examine a proposal which will be termed ''stratized nodes'', a modification of an earlier concept termed ''blockchain service''.\n\n== History ==\n\nJan Moller created BCCAPI in 2011. BCCAPI allowed a user's client to delegate blockchain interaction to a remote server. This server would store and manage the blockchain while the user client would run queries against that server.\n\nThomasV later created Electrum server. BCCAPI's server backend was proprietary, and Electrum required a full Free Software stack. Electrum's server was an adhoc temporary replacement. As it grew and became used, issues started to appear in its design.\n\nMarek Palatinus (slush) drafted a new standard called Stratum to replace Electrum's server. Stratum has multiple transports and is usable as a blockchain server by merchants, miners and user-clients. Electrum moved to using a Stratum implementation first relying on ABE/bitcoind and more recently libbitcoin.\n\nStratum is unmaintained by Marek Palatinus, suffers from easy resource starvation and denial of service attacks, and is insecure. The proposal specified here is intended to replace the Stratum's role as a blockchain for user-clients. The proposal here is solely concerned with removing the onus of blockchain validation and lookups from user-clients to specialised services in a secure manner. Any secondary benefits or uses are purely incidental.\n\n== Overview ==\n\nDuring the initial handshake between Bitcoin nodes, a version packet is sent. version packets have a bitfield called services. Nodes can fill this field to tell the network how they behave and which services they support. NODE_NETWORK (1) means a node can be asked for full blocks for example.\n\nWe propose two more values of NODE_SERVICE (2) and NODE_STRATIZED (4).\n\n=== NODE_SERVICE ===\n\n* A blockchain service which supports the additional messages \"getoutputs\" and \"getspends\".\n* Does not respond to \"getdata\" messages by itself (unless NODE_NETWORK is specified)\n* If NODE_NETWORK is specified, then \"getdata\" for transactions will retrieve them not only from the memory pool but also check the blockchain if necessary.\n\n=== NODE_STRATIZED ===\n\n* A node which uses the stratized strategy specified in this document.\n* NODE_STRATIZED will relay inventories for accepted transactions.\n* Does not support \"getblocks\" as stratized nodes do not contain the entire blockchain.\n\nApart from the differences noted above, the nodes are otherwise unchanged in their behaviour from NODE_NETWORK.\n\n== Specification ==\n\n=== Initialisation ===\n\nFour new messages are defined which are represented below in C-like pseudocode.\n\n\"getoutputs\"\n<pre>\nstruct decoded_address\n{\n    uint8_t payment_type;\n    uint8_t address_hash[16];\n};\n\nstruct get_outputs\n{\n    decoded_address dest;\n};\n</pre>\n\n\"outputs\"\n<pre>\nstruct point_t\n{\n    uint8_t hash[32];\n    uint32_t index;\n};\n\nstruct outputs\n{\n    decoded_address dest;\n    uint64_t number_outputs;  // variable uint\n    point_t outpoints[];\n};\n</pre>\n\n\"getspend\"\n<pre>\nstruct get_spend\n{\n    point_t outpoint;\n};\n</pre>\n\n\"spend\"\n<pre>\nstruct spend\n{\n    point_t outpoint, inpoint;\n};\n</pre>\n\nThese four messages allow a node to discover the history of a Bitcoin address without needing direct access to the blockchain.\n\nA typical use case might look like:\n# Send \"getoutputs\" for a decoded Bitcoin address.\n# Receive \"outputs\", and loop through each contained output point:\n## Send \"getdata\" to download the transaction for that point.\n## Send \"getspend\" for each output point.\n# Receive \"spend\":\n## Send \"getdata\" to download the transaction for that input point.\n\nThis sequence allows the gradual but fast build up of history for an address.\n\n=== Updates ===\n\nNodes receive \"inv\" messages as normal from service nodes, issuing \"getdata\" to download the block or transaction data. From this they check for newly sent (in the input points) or received (in the output points) payments in the transaction data.\n\nNote that blocks must at minimum have their merkle root validated and transactions must be checked for uniqueness by stratized nodes.\n\n== Security ==\n\nThe concern here is that stratized nodes are at the mercy of blockchain services. This proposal deals with that issue by designing this protocol in such a way that the implementation can resolve the common history between multiple services.\n\nA stratized node will typically connect to 8 blockchain services. It will only accept an output, spend or inventory vector that has been sent by a common subset of all those services (6 in our example). This spreads the risk between all services, and does not make a node vulnerable to any one rogue blockchain service.\n\n== Privacy ==\n\nThe other strategy for thin clients termed ''headers-only'' or ''Simplified. Payment. Verification.'' have the same privacy issues as this proposal. SPV resolves this problem by sending out fake requests for transaction data which obfuscates the client data. By sending out a sufficient number of fake requests, privacy can be kept to a sufficient level.\n\n== Rationale ==\n\nNODE_SERVICE does not respond to \"getdata\" requests by itself (unless used in conjunction with NODE_NETWORK) to prevent starvation attacks. This allows a single trusted NODE_SERVICE architecture (possibly acting as a front-end to multiple backends) to service very many nodes while externalising the costs to the Bitcoin network.\n\nNODE_STRATIZED tries its best to maintain the facade and help upkeep the Bitcoin network (see relaying), but cannot support \"getblocks\" as it does not have the entire blockchain.\n\n== Backwards Compatibility ==\n\nThis proposal is an addon to the current Bitcoin network, and is completely backwards compatible.\n", "content_length": 6807}
{"bip_number": 32, "filename": "bip-0032.mediawiki", "content": "RECENT CHANGES:\n* (16 Apr 2013) Added private derivation for i \u2265 0x80000000 (less risk of parent private key leakage)\n* (30 Apr 2013) Switched from multiplication by I<sub>L</sub> to addition of I<sub>L</sub> (faster, easier implementation)\n* (25 May 2013) Added test vectors\n* (15 Jan 2014) Rename keys with index \u2265 0x80000000 to hardened keys, and add explicit conversion functions.\n* (24 Feb 2017) Added test vectors for hardened derivation with leading zeros\n* (4 Nov 2020) Added new test vectors for hardened derivation with leading zeros\n\n<pre>\n  BIP: 32\n  Layer: Applications\n  Title: Hierarchical Deterministic Wallets\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0032\n  Status: Final\n  Type: Informational\n  Created: 2012-02-11\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis document describes hierarchical deterministic wallets (or \"HD Wallets\"): wallets which can be shared partially or entirely with different systems, each with or without the ability to spend coins.\n\nThe specification is intended to set a standard for deterministic wallets that can be interchanged between different clients. Although the wallets described here have many features, not all are required by supporting clients.\n\nThe specification consists of two parts. In the first part, a system for deriving a tree of keypairs from a single seed is presented. The second part demonstrates how to build a wallet structure on top of such a tree.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\n\nThe Bitcoin reference client uses randomly generated keys. In order to avoid the necessity for a backup after every transaction, (by default) 100 keys are cached in a pool of reserve keys. Still, these wallets are not intended to be shared and used on several systems simultaneously. They support hiding their private keys by using the wallet encrypt feature and not sharing the password, but such \"neutered\" wallets lose the power to generate public keys as well.\n\nDeterministic wallets do not require such frequent backups, and elliptic curve mathematics permit schemes where one can calculate the public keys without revealing the private keys. This permits for example a webshop business to let its webserver generate fresh addresses (public key hashes) for each order or for each customer, without giving the webserver access to the corresponding private keys (which are required for spending the received funds).\n\nHowever, deterministic wallets typically consist of a single \"chain\" of keypairs. The fact that there is only one chain means that sharing a wallet happens on an all-or-nothing basis. However, in some cases one only wants some (public) keys to be shared and recoverable. In the example of a webshop, the webserver does not need access to all public keys of the merchant's wallet; only to those addresses which are used to receive customers' payments, and not for example the change addresses that are generated when the merchant spends money. Hierarchical deterministic wallets allow such selective sharing by supporting multiple keypair chains, derived from a single root.\n\n==Specification: Key derivation==\n\n===Conventions===\n\nIn the rest of this text we will assume the public key cryptography used in Bitcoin, namely elliptic curve cryptography using the field and curve parameters defined by secp256k1 (http://www.secg.org/sec2-v2.pdf). Variables below are either:\n* Integers modulo the order of the curve (referred to as n).\n* Coordinates of points on the curve.\n* Byte sequences.\n\nAddition (+) of two coordinate pair is defined as application of the EC group operation.\nConcatenation (||) is the operation of appending one byte sequence onto another.\n\nAs standard conversion functions, we assume:\n* point(p): returns the coordinate pair resulting from EC point multiplication (repeated application of the EC group operation) of the secp256k1 base point with the integer p.\n* ser<sub>32</sub>(i): serialize a 32-bit unsigned integer i as a 4-byte sequence, most significant byte first.\n* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n* parse<sub>256</sub>(p): interprets a 32-byte sequence as a 256-bit number, most significant byte first.\n\n\n===Extended keys===\n\nIn what follows, we will define a function that derives a number of child keys from a parent key. In order to prevent these from depending solely on the key itself, we extend both private and public keys first with an extra 256 bits of entropy. This extension, called the chain code, is identical for corresponding private and public keys, and consists of 32 bytes.\n\nWe represent an extended private key as (k, c), with k the normal private key, and c the chain code. An extended public key is represented as (K, c), with K = point(k) and c the chain code.\n\nEach extended key has 2<sup>31</sup> normal child keys, and 2<sup>31</sup> hardened child keys. Each of these child keys has an index. The normal child keys use indices 0 through 2<sup>31</sup>-1. The hardened child keys use indices 2<sup>31</sup> through 2<sup>32</sup>-1. To ease notation for hardened key indices, a number i<sub>H</sub> represents i+2<sup>31</sup>.\n\n===Child key derivation (CKD) functions===\n\nGiven a parent extended key and an index i, it is possible to compute the corresponding child extended key. The algorithm to do so depends on whether the child is a hardened key or not (or, equivalently, whether i \u2265 2<sup>31</sup>), and whether we're talking about private or public keys.\n\n====Private parent key &rarr; private child key====\n\nThe function CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i) &rarr; (k<sub>i</sub>, c<sub>i</sub>) computes a child extended private key from the parent extended private key:\n* Check whether i \u2265 2<sup>31</sup> (whether the child is a hardened key).\n** If so (hardened child): let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = 0x00 || ser<sub>256</sub>(k<sub>par</sub>) || ser<sub>32</sub>(i)). (Note: The 0x00 pads the private key to make it 33 bytes long.)\n** If not (normal child): let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>P</sub>(point(k<sub>par</sub>)) || ser<sub>32</sub>(i)).\n* Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.\n* The returned child key k<sub>i</sub> is parse<sub>256</sub>(I<sub>L</sub>) + k<sub>par</sub> (mod n).\n* The returned chain code c<sub>i</sub> is I<sub>R</sub>.\n* In case parse<sub>256</sub>(I<sub>L</sub>) \u2265 n or k<sub>i</sub> = 0, the resulting key is invalid, and one should proceed with the next value for i. (Note: this has probability lower than 1 in 2<sup>127</sup>.)\n\nThe HMAC-SHA512 function is specified in [http://tools.ietf.org/html/rfc4231 RFC 4231].\n\n====Public parent key &rarr; public child key====\n\nThe function CKDpub((K<sub>par</sub>, c<sub>par</sub>), i) &rarr; (K<sub>i</sub>, c<sub>i</sub>) computes a child extended public key from the parent extended public key. It is only defined for non-hardened child keys.\n* Check whether i \u2265 2<sup>31</sup> (whether the child is a hardened key).\n** If so (hardened child): return failure\n** If not (normal child): let I = HMAC-SHA512(Key = c<sub>par</sub>, Data = ser<sub>P</sub>(K<sub>par</sub>) || ser<sub>32</sub>(i)).\n* Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.\n* The returned child key K<sub>i</sub> is point(parse<sub>256</sub>(I<sub>L</sub>)) + K<sub>par</sub>.\n* The returned chain code c<sub>i</sub> is I<sub>R</sub>.\n* In case parse<sub>256</sub>(I<sub>L</sub>) \u2265 n or K<sub>i</sub> is the point at infinity, the resulting key is invalid, and one should proceed with the next value for i.\n\n====Private parent key &rarr; public child key====\n\nThe function N((k, c)) &rarr; (K, c) computes the extended public key corresponding to an extended private key (the \"neutered\" version, as it removes the ability to sign transactions).\n* The returned key K is point(k).\n* The returned chain code c is just the passed chain code.\n\nTo compute the public child key of a parent private key:\n* N(CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i)) (works always).\n* CKDpub(N(k<sub>par</sub>, c<sub>par</sub>), i) (works only for non-hardened child keys).\nThe fact that they are equivalent is what makes non-hardened keys useful (one can derive child public keys of a given parent key without knowing any private key), and also what distinguishes them from hardened keys. The reason for not always using non-hardened keys (which are more useful) is security; see further below for more information.\n\n====Public parent key &rarr; private child key====\n\nThis is not possible.\n\n===The key tree===\n\nThe next step is cascading several CKD constructions to build a tree. We start with one root, the master extended key m. By evaluating CKDpriv(m,i) for several values of i, we get a number of level-1 derived nodes. As each of these is again an extended key, CKDpriv can be applied to those as well.\n\nTo shorten notation, we will write CKDpriv(CKDpriv(CKDpriv(m,3<sub>H</sub>),2),5) as m/3<sub>H</sub>/2/5. Equivalently for public keys, we write CKDpub(CKDpub(CKDpub(M,3),2),5) as M/3/2/5. This results in the following identities:\n* N(m/a/b/c) = N(m/a/b)/c = N(m/a)/b/c = N(m)/a/b/c = M/a/b/c.\n* N(m/a<sub>H</sub>/b/c) = N(m/a<sub>H</sub>/b)/c = N(m/a<sub>H</sub>)/b/c.\nHowever, N(m/a<sub>H</sub>) cannot be rewritten as N(m)/a<sub>H</sub>, as the latter is not possible.\n\nEach leaf node in the tree corresponds to an actual key, while the internal nodes correspond to the collections of keys that descend from them. The chain codes of the leaf nodes are ignored, and only their embedded private or public key is relevant. Because of this construction, knowing an extended private key allows reconstruction of all descendant private keys and public keys, and knowing an extended public key allows reconstruction of all descendant non-hardened public keys.\n\n===Key identifiers===\n\nExtended keys can be identified by the Hash160 (RIPEMD160 after SHA256) of the serialized ECDSA public key K, ignoring the chain code. This corresponds exactly to the data used in traditional Bitcoin addresses. It is not advised to represent this data in base58 format though, as it may be interpreted as an address that way (and wallet software is not required to accept payment to the chain key itself).\n\nThe first 32 bits of the identifier are called the key fingerprint.\n\n===Serialization format===\n\nExtended public and private keys are serialized as follows:\n* 4 bytes: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)\n* 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 derived keys, ....\n* 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n* 4 bytes: child number. This is ser<sub>32</sub>(i) for i in x<sub>i</sub> = x<sub>par</sub>/i, with x<sub>i</sub> the key being serialized. (0x00000000 if master key)\n* 32 bytes: the chain code\n* 33 bytes: the public key or private key data (ser<sub>P</sub>(K) for public keys, 0x00 || ser<sub>256</sub>(k) for private keys)\n\nThis 78 byte structure can be encoded like other Bitcoin data in Base58, by first adding 32 checksum bits (derived from the double SHA-256 checksum), and then converting to the Base58 representation. This results in a Base58-encoded string of exactly 111 characters. Because of the choice of the version bytes, the Base58 representation will start with \"xprv\" or \"xpub\" on mainnet, \"tprv\" or \"tpub\" on testnet.\n\nNote that the fingerprint of the parent only serves as a fast way to detect parent and child nodes in software, and software must be willing to deal with collisions. Internally, the full 160-bit identifier could be used.\n\nWhen importing a serialized extended public key, implementations must verify whether the X coordinate in the public key data corresponds to a point on the curve. If not, the extended public key is invalid.\n\n===Master key generation===\n\nThe total number of possible extended keypairs is almost 2<sup>512</sup>, but the produced keys are only 256 bits long, and offer about half of that in terms of security. Therefore, master keys are not generated directly, but instead from a potentially short seed value.\n\n* Generate a seed byte sequence S of a chosen length (between 128 and 512 bits; 256 bits is advised) from a (P)RNG.\n* Calculate I = HMAC-SHA512(Key = \"Bitcoin seed\", Data = S)\n* Split I into two 32-byte sequences, I<sub>L</sub> and I<sub>R</sub>.\n* Use parse<sub>256</sub>(I<sub>L</sub>) as master secret key, and I<sub>R</sub> as master chain code.\nIn case parse<sub>256</sub>(I<sub>L</sub>) is 0 or parse<sub>256</sub>(I<sub>L</sub>) \u2265 n, the master key is invalid.\n\n<img src=bip-0032/derivation.png></img>\n\n==Specification: Wallet structure==\n\nThe previous sections specified key trees and their nodes. The next step is imposing a wallet structure on this tree. The layout defined in this section is a default only, though clients are encouraged to mimic it for compatibility, even if not all features are supported.\n\n===The default wallet layout===\n\nAn HDW is organized as several 'accounts'. Accounts are numbered, the default account (\"\") being number 0. Clients are not required to support more than one account - if not, they only use the default account.\n\nEach account is composed of two keypair chains: an internal and an external one. The external keychain is used to generate new public addresses, while the internal keychain is used for all other operations (change addresses, generation addresses, ..., anything that doesn't need to be communicated). Clients that do not support separate keychains for these should use the external one for everything.\n* m/i<sub>H</sub>/0/k corresponds to the k'th keypair of the external chain of account number i of the HDW derived from master m.\n* m/i<sub>H</sub>/1/k corresponds to the k'th keypair of the internal chain of account number i of the HDW derived from master m.\n\n===Use cases===\n\n====Full wallet sharing: m====\n\nIn cases where two systems need to access a single shared wallet, and both need to be able to perform spendings, one needs to share the master private extended key. Nodes can keep a pool of N look-ahead keys cached for external chains, to watch for incoming payments. The look-ahead for internal chains can be very small, as no gaps are to be expected here. An extra look-ahead could be active for the first unused account's chains - triggering the creation of a new account when used. Note that the name of the account will still need to be entered manually and cannot be synchronized via the block chain.\n\n====Audits: N(m/*)====\n\nIn case an auditor needs full access to the list of incoming and outgoing payments, one can share all account public extended keys. This will allow the auditor to see all transactions from and to the wallet, in all accounts, but not a single secret key.\n\n====Per-office balances: m/i<sub>H</sub>====\n\nWhen a business has several independent offices, they can all use wallets derived from a single master. This will allow the headquarters to maintain a super-wallet that sees all incoming and outgoing transactions of all offices, and even permit moving money between the offices.\n\n====Recurrent business-to-business transactions: N(m/i<sub>H</sub>/0)====\n\nIn case two business partners often transfer money, one can use the extended public key for the external chain of a specific account (M/i h/0) as a sort of \"super address\", allowing frequent transactions that cannot (easily) be associated, but without needing to request a new address for each payment.\nSuch a mechanism could also be used by mining pool operators as a variable payout address.\n\n====Unsecure money receiver: N(m/i<sub>H</sub>/0)====\n\nWhen an unsecure webserver is used to run an e-commerce site, it needs to know public addresses that are used to receive payments. The webserver only needs to know the public extended key of the external chain of a single account. This means someone illegally obtaining access to the webserver can at most see all incoming payments but will not be able to steal the money, will not (trivially) be able to distinguish outgoing transactions, nor be able to see payments received by other webservers if there are several.\n\n==Compatibility==\n\nTo comply with this standard, a client must at least be able to import an extended public or private key, to give access to its direct descendants as wallet keys. The wallet structure (master/account/chain/subchain) presented in the second part of the specification is advisory only, but is suggested as a minimal structure for easy compatibility - even when no separate accounts or distinction between internal and external chains is made. However, implementations may deviate from it for specific needs; more complex applications may call for a more complex tree structure.\n\n==Security==\n\nIn addition to the expectations from the EC public-key cryptography itself:\n* Given a public key K, an attacker cannot find the corresponding private key more efficiently than by solving the EC discrete logarithm problem (assumed to require 2<sup>128</sup> group operations).\nthe intended security properties of this standard are:\n* Given a child extended private key (k<sub>i</sub>,c<sub>i</sub>) and the integer i, an attacker cannot find the parent private key k<sub>par</sub> more efficiently than a 2<sup>256</sup> brute force of HMAC-SHA512.\n* Given any number (2 \u2264 N \u2264 2<sup>32</sup>-1) of (index, extended private key) tuples (i<sub>j</sub>,(k<sub>i<sub>j</sub></sub>,c<sub>i<sub>j</sub></sub>)), with distinct i<sub>j</sub>'s, determining whether they are derived from a common parent extended private key (i.e., whether there exists a (k<sub>par</sub>,c<sub>par</sub>) such that for each j in (0..N-1) CKDpriv((k<sub>par</sub>,c<sub>par</sub>),i<sub>j</sub>)=(k<sub>i<sub>j</sub></sub>,c<sub>i<sub>j</sub></sub>)), cannot be done more efficiently than a 2<sup>256</sup> brute force of HMAC-SHA512.\nNote however that the following properties do not exist:\n* Given a parent extended public key (K<sub>par</sub>,c<sub>par</sub>) and a child public key (K<sub>i</sub>), it is hard to find i.\n* Given a parent extended public key (K<sub>par</sub>,c<sub>par</sub>) and a non-hardened child private key (k<sub>i</sub>), it is hard to find k<sub>par</sub>.\n\n===Implications===\n\nPrivate and public keys must be kept safe as usual. Leaking a private key means access to coins - leaking a public key can mean loss of privacy.\n\nSomewhat more care must be taken regarding extended keys, as these correspond to an entire (sub)tree of keys.\n\nOne weakness that may not be immediately obvious, is that knowledge of a parent extended public key plus any non-hardened private key descending from it is equivalent to knowing the parent extended private key (and thus every private and public key descending from it). This means that extended public keys must be treated more carefully than regular public keys.\nIt is also the reason for the existence of hardened keys, and why they are used for the account level in the tree. This way, a leak of account-specific (or below) private keys never risks compromising the master or other accounts.\n\n\n==Test Vectors==\n\n===Test vector 1===\n\nSeed (hex): 000102030405060708090a0b0c0d0e0f\n* Chain m\n** ext pub: xpub661MyMwAqRbcFtXgS5sYJABqqG9YLmC4Q1Rdap9gSE8NqtwybGhePY2gZ29ESFjqJoCu1Rupje8YtGqsefD265TMg7usUDFdp6W1EGMcet8\n** ext prv: xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi\n* Chain m/0<sub>H</sub>\n** ext pub: xpub68Gmy5EdvgibQVfPdqkBBCHxA5htiqg55crXYuXoQRKfDBFA1WEjWgP6LHhwBZeNK1VTsfTFUHCdrfp1bgwQ9xv5ski8PX9rL2dZXvgGDnw\n** ext prv: xprv9uHRZZhk6KAJC1avXpDAp4MDc3sQKNxDiPvvkX8Br5ngLNv1TxvUxt4cV1rGL5hj6KCesnDYUhd7oWgT11eZG7XnxHrnYeSvkzY7d2bhkJ7\n* Chain m/0<sub>H</sub>/1\n** ext pub: xpub6ASuArnXKPbfEwhqN6e3mwBcDTgzisQN1wXN9BJcM47sSikHjJf3UFHKkNAWbWMiGj7Wf5uMash7SyYq527Hqck2AxYysAA7xmALppuCkwQ\n** ext prv: xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs\n* Chain m/0<sub>H</sub>/1/2<sub>H</sub>\n** ext pub: xpub6D4BDPcP2GT577Vvch3R8wDkScZWzQzMMUm3PWbmWvVJrZwQY4VUNgqFJPMM3No2dFDFGTsxxpG5uJh7n7epu4trkrX7x7DogT5Uv6fcLW5\n** ext prv: xprv9z4pot5VBttmtdRTWfWQmoH1taj2axGVzFqSb8C9xaxKymcFzXBDptWmT7FwuEzG3ryjH4ktypQSAewRiNMjANTtpgP4mLTj34bhnZX7UiM\n* Chain m/0<sub>H</sub>/1/2<sub>H</sub>/2\n** ext pub: xpub6FHa3pjLCk84BayeJxFW2SP4XRrFd1JYnxeLeU8EqN3vDfZmbqBqaGJAyiLjTAwm6ZLRQUMv1ZACTj37sR62cfN7fe5JnJ7dh8zL4fiyLHV\n** ext prv: xprvA2JDeKCSNNZky6uBCviVfJSKyQ1mDYahRjijr5idH2WwLsEd4Hsb2Tyh8RfQMuPh7f7RtyzTtdrbdqqsunu5Mm3wDvUAKRHSC34sJ7in334\n* Chain m/0<sub>H</sub>/1/2<sub>H</sub>/2/1000000000\n** ext pub: xpub6H1LXWLaKsWFhvm6RVpEL9P4KfRZSW7abD2ttkWP3SSQvnyA8FSVqNTEcYFgJS2UaFcxupHiYkro49S8yGasTvXEYBVPamhGW6cFJodrTHy\n** ext prv: xprvA41z7zogVVwxVSgdKUHDy1SKmdb533PjDz7J6N6mV6uS3ze1ai8FHa8kmHScGpWmj4WggLyQjgPie1rFSruoUihUZREPSL39UNdE3BBDu76\n\n===Test vector 2===\n\nSeed (hex): fffcf9f6f3f0edeae7e4e1dedbd8d5d2cfccc9c6c3c0bdbab7b4b1aeaba8a5a29f9c999693908d8a8784817e7b7875726f6c696663605d5a5754514e4b484542\n* Chain m\n** ext pub: xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB\n** ext prv: xprv9s21ZrQH143K31xYSDQpPDxsXRTUcvj2iNHm5NUtrGiGG5e2DtALGdso3pGz6ssrdK4PFmM8NSpSBHNqPqm55Qn3LqFtT2emdEXVYsCzC2U\n* Chain m/0\n** ext pub: xpub69H7F5d8KSRgmmdJg2KhpAK8SR3DjMwAdkxj3ZuxV27CprR9LgpeyGmXUbC6wb7ERfvrnKZjXoUmmDznezpbZb7ap6r1D3tgFxHmwMkQTPH\n** ext prv: xprv9vHkqa6EV4sPZHYqZznhT2NPtPCjKuDKGY38FBWLvgaDx45zo9WQRUT3dKYnjwih2yJD9mkrocEZXo1ex8G81dwSM1fwqWpWkeS3v86pgKt\n* Chain m/0/2147483647<sub>H</sub>\n** ext pub: xpub6ASAVgeehLbnwdqV6UKMHVzgqAG8Gr6riv3Fxxpj8ksbH9ebxaEyBLZ85ySDhKiLDBrQSARLq1uNRts8RuJiHjaDMBU4Zn9h8LZNnBC5y4a\n** ext prv: xprv9wSp6B7kry3Vj9m1zSnLvN3xH8RdsPP1Mh7fAaR7aRLcQMKTR2vidYEeEg2mUCTAwCd6vnxVrcjfy2kRgVsFawNzmjuHc2YmYRmagcEPdU9\n* Chain m/0/2147483647<sub>H</sub>/1\n** ext pub: xpub6DF8uhdarytz3FWdA8TvFSvvAh8dP3283MY7p2V4SeE2wyWmG5mg5EwVvmdMVCQcoNJxGoWaU9DCWh89LojfZ537wTfunKau47EL2dhHKon\n** ext prv: xprv9zFnWC6h2cLgpmSA46vutJzBcfJ8yaJGg8cX1e5StJh45BBciYTRXSd25UEPVuesF9yog62tGAQtHjXajPPdbRCHuWS6T8XA2ECKADdw4Ef\n* Chain m/0/2147483647<sub>H</sub>/1/2147483646<sub>H</sub>\n** ext pub: xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\n** ext prv: xprvA1RpRA33e1JQ7ifknakTFpgNXPmW2YvmhqLQYMmrj4xJXXWYpDPS3xz7iAxn8L39njGVyuoseXzU6rcxFLJ8HFsTjSyQbLYnMpCqE2VbFWc\n* Chain m/0/2147483647<sub>H</sub>/1/2147483646<sub>H</sub>/2\n** ext pub: xpub6FnCn6nSzZAw5Tw7cgR9bi15UV96gLZhjDstkXXxvCLsUXBGXPdSnLFbdpq8p9HmGsApME5hQTZ3emM2rnY5agb9rXpVGyy3bdW6EEgAtqt\n** ext prv: xprvA2nrNbFZABcdryreWet9Ea4LvTJcGsqrMzxHx98MMrotbir7yrKCEXw7nadnHM8Dq38EGfSh6dqA9QWTyefMLEcBYJUuekgW4BYPJcr9E7j\n\n===Test vector 3===\n\nThese vectors test for the retention of leading zeros. See [https://github.com/bitpay/bitcore-lib/issues/47 bitpay/bitcore-lib#47] and [https://github.com/iancoleman/bip39/issues/58 iancoleman/bip39#58] for more information.\n\nSeed (hex): 4b381541583be4423346c643850da4b320e46a87ae3d2a4e6da11eba819cd4acba45d239319ac14f863b8d5ab5a0d0c64d2e8a1e7d1457df2e5a3c51c73235be\n* Chain m\n** ext pub: xpub661MyMwAqRbcEZVB4dScxMAdx6d4nFc9nvyvH3v4gJL378CSRZiYmhRoP7mBy6gSPSCYk6SzXPTf3ND1cZAceL7SfJ1Z3GC8vBgp2epUt13\n** ext prv: xprv9s21ZrQH143K25QhxbucbDDuQ4naNntJRi4KUfWT7xo4EKsHt2QJDu7KXp1A3u7Bi1j8ph3EGsZ9Xvz9dGuVrtHHs7pXeTzjuxBrCmmhgC6\n* Chain m/0<sub>H</sub>\n** ext pub: xpub68NZiKmJWnxxS6aaHmn81bvJeTESw724CRDs6HbuccFQN9Ku14VQrADWgqbhhTHBaohPX4CjNLf9fq9MYo6oDaPPLPxSb7gwQN3ih19Zm4Y\n** ext prv: xprv9uPDJpEQgRQfDcW7BkF7eTya6RPxXeJCqCJGHuCJ4GiRVLzkTXBAJMu2qaMWPrS7AANYqdq6vcBcBUdJCVVFceUvJFjaPdGZ2y9WACViL4L\n\n===Test vector 4===\n\nThese vectors test for the retention of leading zeros. See [https://github.com/btcsuite/btcutil/issues/172 btcsuite/btcutil#172] for more information.\n\nSeed (hex): 3ddd5602285899a946114506157c7997e5444528f3003f6134712147db19b678\n* Chain m\n** ext pub: xpub661MyMwAqRbcGczjuMoRm6dXaLDEhW1u34gKenbeYqAix21mdUKJyuyu5F1rzYGVxyL6tmgBUAEPrEz92mBXjByMRiJdba9wpnN37RLLAXa\n** ext prv: xprv9s21ZrQH143K48vGoLGRPxgo2JNkJ3J3fqkirQC2zVdk5Dgd5w14S7fRDyHH4dWNHUgkvsvNDCkvAwcSHNAQwhwgNMgZhLtQC63zxwhQmRv\n* Chain m/0<sub>H</sub>\n** ext pub: xpub69AUMk3qDBi3uW1sXgjCmVjJ2G6WQoYSnNHyzkmdCHEhSZ4tBok37xfFEqHd2AddP56Tqp4o56AePAgCjYdvpW2PU2jbUPFKsav5ut6Ch1m\n** ext prv: xprv9vB7xEWwNp9kh1wQRfCCQMnZUEG21LpbR9NPCNN1dwhiZkjjeGRnaALmPXCX7SgjFTiCTT6bXes17boXtjq3xLpcDjzEuGLQBM5ohqkao9G\n* Chain m/0<sub>H</sub>/1<sub>H</sub>\n** ext pub: xpub6BJA1jSqiukeaesWfxe6sNK9CCGaujFFSJLomWHprUL9DePQ4JDkM5d88n49sMGJxrhpjazuXYWdMf17C9T5XnxkopaeS7jGk1GyyVziaMt\n** ext prv: xprv9xJocDuwtYCMNAo3Zw76WENQeAS6WGXQ55RCy7tDJ8oALr4FWkuVoHJeHVAcAqiZLE7Je3vZJHxspZdFHfnBEjHqU5hG1Jaj32dVoS6XLT1\n\n===Test vector 5===\n\nThese vectors test that invalid extended keys are recognized as invalid.\n\n* xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6LBpB85b3D2yc8sfvZU521AAwdZafEz7mnzBBsz4wKY5fTtTQBm (pubkey version / prvkey mismatch)\n* xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFGTQQD3dC4H2D5GBj7vWvSQaaBv5cxi9gafk7NF3pnBju6dwKvH (prvkey version / pubkey mismatch)\n* xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6Txnt3siSujt9RCVYsx4qHZGc62TG4McvMGcAUjeuwZdduYEvFn (invalid pubkey prefix 04)\n* xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFGpWnsj83BHtEy5Zt8CcDr1UiRXuWCmTQLxEK9vbz5gPstX92JQ (invalid prvkey prefix 04)\n* xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6N8ZMMXctdiCjxTNq964yKkwrkBJJwpzZS4HS2fxvyYUA4q2Xe4 (invalid pubkey prefix 01)\n* xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFAzHGBP2UuGCqWLTAPLcMtD9y5gkZ6Eq3Rjuahrv17fEQ3Qen6J (invalid prvkey prefix 01)\n* xprv9s2SPatNQ9Vc6GTbVMFPFo7jsaZySyzk7L8n2uqKXJen3KUmvQNTuLh3fhZMBoG3G4ZW1N2kZuHEPY53qmbZzCHshoQnNf4GvELZfqTUrcv (zero depth with non-zero parent fingerprint)\n* xpub661no6RGEX3uJkY4bNnPcw4URcQTrSibUZ4NqJEw5eBkv7ovTwgiT91XX27VbEXGENhYRCf7hyEbWrR3FewATdCEebj6znwMfQkhRYHRLpJ (zero depth with non-zero parent fingerprint)\n* xprv9s21ZrQH4r4TsiLvyLXqM9P7k1K3EYhA1kkD6xuquB5i39AU8KF42acDyL3qsDbU9NmZn6MsGSUYZEsuoePmjzsB3eFKSUEh3Gu1N3cqVUN (zero depth with non-zero index)\n* xpub661MyMwAuDcm6CRQ5N4qiHKrJ39Xe1R1NyfouMKTTWcguwVcfrZJaNvhpebzGerh7gucBvzEQWRugZDuDXjNDRmXzSZe4c7mnTK97pTvGS8 (zero depth with non-zero index)\n* DMwo58pR1QLEFihHiXPVykYB6fJmsTeHvyTp7hRThAtCX8CvYzgPcn8XnmdfHGMQzT7ayAmfo4z3gY5KfbrZWZ6St24UVf2Qgo6oujFktLHdHY4 (unknown extended key version)\n* DMwo58pR1QLEFihHiXPVykYB6fJmsTeHvyTp7hRThAtCX8CvYzgPcn8XnmdfHPmHJiEDXkTiJTVV9rHEBUem2mwVbbNfvT2MTcAqj3nesx8uBf9 (unknown extended key version)\n* xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzF93Y5wvzdUayhgkkFoicQZcP3y52uPPxFnfoLZB21Teqt1VvEHx (private key 0 not in 1..n-1)\n* xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFAzHGBP2UuGCqWLTAPLcMtD5SDKr24z3aiUvKr9bJpdrcLg1y3G (private key n not in 1..n-1)\n* xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6Q5JXayek4PRsn35jii4veMimro1xefsM58PgBMrvdYre8QyULY (invalid pubkey 020000000000000000000000000000000000000000000000000000000000000007)\n* xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHL (invalid checksum)\n\n==Acknowledgements==\n\n* Gregory Maxwell for the original idea of type-2 deterministic wallets, and many discussions about it.\n* Alan Reiner for the implementation of this scheme in Armory, and the suggestions that followed from that.\n* Eric Lombrozo for reviewing and revising this BIP.\n* Mike Caldwell for the version bytes to obtain human-recognizable Base58 strings.\n", "content_length": 27987}
{"bip_number": 31, "filename": "bip-0031.mediawiki", "content": "<pre>\n  BIP: 31\n  Layer: Peer Services\n  Title: Pong message\n  Author: Mike Hearn <hearn@google.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0031\n  Status: Final\n  Type: Standards Track\n  Created: 2012-04-11\n</pre>\n\n==Abstract==\n\nThis document describes a trivial protocol extension that makes it easier for clients to detect dead peer connections.\n\n==Motivation==\n\nToday there are a few network related problems that can degrade the Bitcoin user experience:\n\n1) Some Bitcoin clients run on platforms that can go to sleep and essentially stop running at any time without warning. Notably, this is very common on both mobiles and laptops (shut the lid). When the system comes back, TCP connections that existed before the sleep still exist but may no longer function correctly, eg, because the IP address has changed, or because the remote peer went away or the connection was timed out by some other system. Currently it can often take a while to notice this has happened.\n\n2) The reference Satoshi client is largely single threaded and when placed under heavy load (e.g., because it is downloading the block chain) becomes very slow to respond to network messages. There's no easy way to detect this has occurred, especially if you are just passively waiting for broadcasts from that peer. A way to detect overloaded remote peers and avoid them would both help balance load and provide a better, more responsive system.\n\n3) When downloading large data structures like the block chain it is efficient to choose a peer that is near to you network-wise, in order to reduce load on often congested trans-national links and ensure lower latency. Currently it is difficult to measure the latency to a remote peer so clients don't bother, and instead just select a random peer to download from.\n\nAll of these can be solved by a backwards compatible protocol modification.\n\n==Specification==\n\nWhen the protocol version as negotiated in the \"ver\" message is greater than 60000, the \"ping\" message must contain a uint64 field called \"nonce\". A peer sending \"ping\" should set the nonce to a random value, and it is then echoed back by the recipient in a new \"pong\" message that also contains a single uint64 field.\n\nIn this way, the client can send a ping and measure the time taken to receive the corresponding pong. If a client sends two pings before hearing back the first pong, the responses can be distinguished using the nonce. If the client chooses to never overlap pings in this way it should simply set the nonce value to zero.\n\n==Backward compatibility==\n\nClients must opt-in to the new feature by advertising a protocol version > 60000. Clients with older protocol versions are not expected to provide a nonce in the ping message and will not be sent a pong.\n\n==Implementation==\n\nhttps://github.com/bitcoin/bitcoin/pull/932/files\n", "content_length": 2894}
{"bip_number": 30, "filename": "bip-0030.mediawiki", "content": "<pre>\n  BIP: 30\n  Layer: Consensus (soft fork)\n  Title: Duplicate transactions\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0030\n  Status: Final\n  Type: Standards Track\n  Created: 2012-02-22\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\nThis document gives a specification for dealing with duplicate transactions in the block chain, in an attempt to solve certain problems the reference implementation has with them.\n\n==Copyright==\n\nThis BIP is licensed under the 2-clause BSD license.\n\n==Motivation==\nSo far, the Bitcoin reference implementation always assumed duplicate transactions (transactions with the same identifier) didn't exist. This is not true; in particular coinbases are easy to duplicate, and by building on duplicate coinbases, duplicate normal transactions are possible as well. Recently, an attack that exploits the reference implementation's dealing with duplicate transactions was described and demonstrated. It allows reverting fully-confirmed transactions to a single confirmation, making them vulnerable to become unspendable entirely. Another attack is possible that allows forking the block chain for a subset of the network.\n\n==Specification==\nTo counter this problem, the following network rule is introduced:\n*Blocks are not allowed to contain a transaction whose identifier matches that of an earlier, not-fully-spent transaction in the same chain.\n\nThis rule initially applied to all blocks whose timestamp is after March 15, 2012, 00:00 UTC (testnet: February 20, 2012 00:00 UTC). It was later extended by Commit [https://github.com/bitcoin/bitcoin/commit/ab91bf39b7c11e9c86bb2043c24f0f377f1cf514 Apply BIP30 checks to all blocks except the two historic violations.] to apply to all blocks except the two historic blocks at heights 91842 and 91880 on the main chain that had to be grandfathered in.\n\n==Rationale==\nWhatever solution is used, the following law must be obeyed to guarantee sane behaviour: the set of usable\ntransactions outputs must not be modified by adding blocks to the chain and removing them again. This happens during\na reorganisation, and the current Bitcoin reference implementation does not obey this law in case the temporarily\nadded blocks contain a duplicate transaction.\n\nThere are several potential solutions to this problem:\n#Guarantee that all coinbases are unique, making duplicate transactions very hard to create.\n#Remember previous remaining outputs of a given transaction identifier, in case a new transaction with the same identifier is added.\n#Only allow duplicate transactions in case the previous instance of the transaction had no spendable outputs left. Removing a block from the chain can then safely reset the removed transaction's outputs to nothing.\n\nThe first option is probably the most complete one, as it also guarantees transaction identifiers are unique. However, implementing it requires several changes that need to be accepted throughout the network. Furthermore, it does not prevent duplicate transactions based on earlier duplicate coinbases. The second option is impossible to implement in a forward-compatible way, as it potentially renders currently-invalid blocks valid. In this document we choose for the third option, because it only requires a trivial change.\n\nFully-spent transactions are allowed to be duplicated in order not to hinder pruning at some point in the future. Not allowing any transaction to be duplicated would require evidence to be kept for each transaction ever made.\n\n==Backward compatibility==\nThe addition of this rule only makes some previously-valid blocks invalid. This implies that if the rule is implemented by a supermajority of miners, it is not possible to fork the block chain in a permanent way between nodes with and without the new rule.\n\n==Implementation==\nA patch for the reference client can be found on https://github.com/sipa/bitcoin/tree/nooverwritetx\n\nThis BIP was implemented in Commit [https://github.com/bitcoin/bitcoin/commit/a206b0ea12eb4606b93323268fc81a4f1f952531 Do not allow overwriting unspent transactions (BIP 30)]\nThere have been additional commits to refine the implementation of this BIP.\n\n==Acknowledgements==\nThanks to Russell O'Connor for finding and demonstrating this problem, and helping test the patch.\n", "content_length": 4367}
{"bip_number": 23, "filename": "bip-0023.mediawiki", "content": "<pre>\n  BIP: 23\n  Layer: API/RPC\n  Title: getblocktemplate - Pooled Mining\n  Author: Luke Dashjr <luke+bip22@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0023\n  Status: Final\n  Type: Standards Track\n  Created: 2012-02-28\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes extensions to the getblocktemplate JSON-RPC call to enhance pooled mining.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Specification==\n\nNote that all sections of this specification are optional extensions on top of [[bip-0022.mediawiki|BIP 22]].\n\n===Summary Support Levels===\n\nSomething can be said to have BIP 23 Level 1 support if it implements at least:\n* [http://www.ietf.org/rfc/rfc1945.txt RFC 1945]\n* [http://json-rpc.org/wiki/specification JSON-RPC 1.0]\n* [[bip-0022.mediawiki|BIP 22 (non-optional sections)]]\n* [[bip-0022.mediawiki#Optional: Long Polling|BIP 22 Long Polling]]\n* [[#Basic Pool Extensions|BIP 23 Basic Pool Extensions]]\n* [[#Mutations|BIP 23 Mutation \"coinbase/append\"]]\n* [[#Submission Abbreviation|BIP 23 Submission Abbreviation \"submit/coinbase\"]]\n* [[#Mutations|BIP 23 Mutation \"time/increment\"]] (only required for servers)\n\nIt can be said to have BIP 23 Level 2 support if it also implements:\n* [[#Mutations|BIP 23 Mutation \"transactions/add\"]]\n* [[#Block Proposals|BIP 23 Block Proposals]]\n\n===Basic Pool Extensions===\n\n{| class=\"wikitable\"\n! colspan=\"3\" | template request\n|-\n! Key !! Type !! Description\n|-\n| target || String || desired target for block template (may be ignored)\n|}\n\n{| class=\"wikitable\"\n!colspan=\"3\"| template\n|-\n! Key !! Type !! Description\n|-\n| expires || Number || how many seconds (beginning from when the server sent the response) this work is valid for, at most\n|-\n| target || String || the number which valid results must be less than, in big-endian hexadecimal\n|}\n\n===Block Proposal===\n\nServers may indicate support for proposing blocks by including a capability string in their original template:\n{| class=\"wikitable\"\n!colspan=\"3\"| template\n|-\n! Key !! Type !! Description\n|-\n| capabilities || Array of Strings || MAY contain \"proposal\" to indicate support for block proposal\n|-\n| reject-reason || String || Reason the proposal was invalid as-is (only applicable in response to proposals)\n|}\n\nIf supported, a miner MAY propose a block to the server for general validation at any point before the job expires.\nThis is accomplished by calling getblocktemplate with two keys:\n{| class=\"wikitable\"\n!colspan=3| getblocktemplate parameters\n|-\n! Key !! Type !! Description\n|-\n| data || String || MUST be hex-encoded block data\n|-\n| mode || String || MUST be \"proposal\"\n|-\n| workid || String || if the server provided a workid, it MUST be included with proposals\n|}\n\nThe block data MUST be validated and checked against the server's usual acceptance rules (excluding the check for a valid proof-of-work).\nIf it is found to be in violation of any of these rules, the server MUST return one of the following:\n* Null if it is acceptable as-is, with the same workid (if any) as provided. Note that this SHOULD NOT invalidate the old template's claim to the same workid.\n* A String giving the reason for the rejection (see [[bip-0022.mediawiki#appendix-example-rejection-reasons|example rejection reasons]]).\n* A \"delta\" block template (with changes needed); in this case, any missing keys are assumed to default to those in the proposed block or, if not applicable, the original block template it was based on. This template MAY also include a \"reject-reason\" key with a String of the reason for rejection.\n\nIt is RECOMMENDED that servers which merely need to track the proposed block for later share/* submissions, return a simple Object of the form:\n {\"workid\":\"new workid\"}\n\nClients SHOULD assume their proposed block will remain valid if the only changes they make are to the portion of the coinbase scriptSig they themselves provided (if any) and the time header.\nServers SHOULD NOT break this assumption without good cause.\n\n===Mutations===\n\n{| class=\"wikitable\"\n! colspan=\"3\" | template request\n|-\n! Key !! Type !! Description\n|-\n| nonces || Number || size of nonce range the miner needs; if not provided, the server SHOULD assume the client requires 2<sup>32</sup>\n|}\n\n{| class=\"wikitable\"\n!colspan=3| template\n|-\n! Key !! Type !! Description\n|-\n| maxtime || Number || the maximum time allowed\n|-\n| maxtimeoff || Number || the maximum time allowed (as a moving offset from \"curtime\" - every second, the actual maxtime is incremented by 1; for example, \"maxtimeoff\":0 means \"time\" may be incremented by 1 every second)\n|-\n| mintime || Number || the minimum time allowed\n|-\n| mintimeoff || Number || the minimum time allowed (as a moving offset from \"curtime\")\n|-\n| mutable || Array of Strings || different manipulations that the server explicitly allows to be made\n|-\n| noncerange || String || two 32-bit integers, concatenated in big-endian hexadecimal, which represent the valid ranges of nonces the miner may scan\n|}\n\nIf the block template contains a \"mutable\" key, it is a list of these to signify modifications the miner is allowed to make:\n\n{| class=\"wikitable\"\n!colspan=2| mutations\n|-\n! Value !! Significance\n|-\n| coinbase/append\n| append the provided coinbase scriptSig\n|-\n| coinbase\n| provide their own coinbase; if one is provided, it may be replaced or modified (implied if \"coinbasetxn\" omitted)\n|-\n| generation\n| add or remove outputs from the coinbase/generation transaction (implied if \"coinbasetxn\" omitted)\n|-\n| time/increment\n| change the time header to a value after \"time\" (implied if \"maxtime\" or \"maxtimeoff\" are provided)\n|-\n| time/decrement\n| change the time header to a value before \"time\" (implied if \"mintime\" is provided)\n|-\n| time\n| modify the time header of the block\n|-\n| transactions/add (or \"transactions\")\n| add other valid transactions to the block (implied if \"transactions\" omitted from result)\n|-\n| prevblock\n| use the work with other previous-blocks; this implicitly allows removing transactions that are no longer valid (but clients SHOULD attempt to propose removal of any required transactions); it also implies adjusting \"height\" as necessary\n|-\n| version/force\n| encode the provide block version, even if the miner doesn't understand it\n|-\n| version/reduce\n| use an older block version than the one provided (for example, if the client does not support the version provided)\n|}\n\n===Submission Abbreviation===\n\n{| class=\"wikitable\"\n!colspan=3| template\n|-\n! Key !! Type !! Description\n|-\n| fulltarget || String || the number which full results should be less than, in big-endian hexadecimal (see \"share/*\" mutations)\n|-\n| mutable || Array of Strings || different manipulations that the server explicitly allows to be made, including abbreviations\n|}\n\nIf the block template contains a \"mutable\" key, it is a list of these to signify modifications the miner is allowed to make:\n\n{| class=\"wikitable\"\n!colspan=2| abbreviation mutations\n|-\n! Value !! Significance\n|-\n| submit/hash\n| each transaction being sent in a request, that the client is certain the server knows about, may be replaced by its hash in little-endian hexadecimal, prepended by a \":\" character\n|-\n| submit/coinbase\n| if the \"transactions\" provided by the server are used as-is with no changes, submissions may omit transactions after the coinbase (transaction count varint remains included with the full number of transactions)\n|-\n| submit/truncate\n| if the \"coinbasetxn\" and \"transactions\" provided by the server are used as-is with no changes, submissions may contain only the block header; if only the scriptSig of \"coinbasetxn\" is modified, the params Object MUST contain a \"coinbasesig\" key with the content, or a \"coinbaseadd\" with appended data (if only appending)\n|-\n| share/coinbase\n| same as \"submit/coinbase\", but only if the block hash is greater than \"fulltarget\"\n|-\n| share/merkle\n| if the block hash is greater than \"fulltarget\", the non-coinbase transactions may be replaced with a merkle chain connecting it to the root\n|-\n| share/truncate\n| same as \"submit/truncate\", but only if the block hash is greater than \"fulltarget\"\n|}\n\n==== Format of Data for Merkle-Only Shares ====\n\nThe format used for submitting shares with the \"share/merkle\" mutation shall be the 80-byte block header, the total number of transactions encoded in Bitcoin variable length number format, the coinbase transaction, and then finally the little-endian SHA256 hashes of each link in the merkle chain connecting it to the merkle root.\n\n===Logical Services===\n\n{| class=\"wikitable\"\n! colspan=\"3\" | template request\n|-\n! Key !! Type !! Description\n|-\n| capabilities || Array of Strings || miners which support this SHOULD provide a list including the String \"serverlist\"\n|}\n\n{| class=\"wikitable\"\n!colspan=3| template\n|-\n! Key !! Type !! Description\n|-\n| serverlist || Array of Objects || list of servers in this single logical service\n|}\n\nIf the \"serverlist\" parameter is provided, clients MAY choose to intelligently treat the server as part of a larger single logical service.\n\nEach host Object in the Array is comprised of the following fields:\n{| class=\"wikitable\"\n!colspan=3| serverlist element\n|-\n! Key !! Type !! Description\n|-\n| uri || String || URI of the individual server; if authentication information is omitted, the same authentication used for this request MUST be assumed\n|-\n| avoid ||  Number || number of seconds to avoid using this server\n|-\n| priority || Number || an integer priority of this host (default: 0)\n|-\n| sticky || Number || number of seconds to stick to this server when used\n|-\n| update || Boolean || whether this server may update the serverlist (default: true)\n|-\n| weight || Number || a relative weight for hosts with the same priority (default: 1)\n|}\n\nWhen choosing which actual server to get the next job from, URIs MUST be tried in order of their \"priority\" key, lowest Number first.\nWhere the priority of URIs is the same, they should be chosen from in random order, weighed by their \"weight\" key.\nWork proposals and submissions MUST be made to the same server that issued the job.\nClients MAY attempt to submit to other servers if, and only if, the original server cannot be reached.\nIf cross-server share submissions are desired, services SHOULD instead use the equivalent domain name system (DNS) features (RFCs [http://tools.ietf.org/html/rfc1794 1794] and [http://tools.ietf.org/html/rfc2782 2782]).\n\nUpdates to the Logical Service server list may only be made by the original server, or servers listed with the \"update\" key missing or true.\nClients MAY choose to advertise serverlist capability to servers with a false \"update\" key, but if so, MUST treat the server list provided as a subset of the current one, only considered in the context of this server.\nAt least one server with \"update\" privilege MUST be attempted at least once daily.\n\nIf the \"sticky\" key is provided, then when that server is used, it should be used consistently for at least that many seconds, if possible.\n\nA permanent change in server URI MAY be indicated with a simple \"serverlist\" parameter:\n \"serverlist\":[{\"uri\": \"http://newserver\"}]\n\nA temporary delegation to another server for 5 minutes MAY be indicated likewise:\n \"serverlist\":[{\"uri\": \"\", avoid: 300}, {\"uri\": \"http://newserver\", \"update\": false}]\n\n==Motivation==\n\nThere is reasonable concerns about mining currently being too centralized on pools, and the amount of control these pools hold.\nBy exposing the details of the block proposals to the miners, they are enabled to audit and possibly modify the block before hashing it.\n\nTo encourage widespread adoption, this BIP should be a complete superset of the existing centralized getwork protocol, so pools are not required to make substantial changes to adopt it.\n\n==Rationale==\nWhy allow servers to restrict the complete coinbase and nonce range?\n* This is necessary to provide a complete superset of JSON-RPC getwork functionality, so that pools may opt to enable auditing without significantly changing or increasing the complexity of their share validation or mining policies.\n* Since noncerange is optional (both for getwork and this BIP), neither clients nor servers are required to support it.\n\nWhy specify \"time/*\" mutations at all?\n* In most cases, these are implied by the mintime/mintimecur/maxtime/maxtimecur keys, but there may be cases that there are no applicable minimums/maximums.\n\nWhat is the purpose of the \"prevblock\" mutation?\n* There are often cases where a miner has processed a new block before the server. If the server allows \"prevblock\" mutation, the miner may begin mining on the new block immediately, without waiting for a new template.\n\nWhy must both \"mintime\"/\"maxtime\" and \"mintimeoff\"/\"maxtimeoff\" keys be defined?\n* In some cases, the limits may be unrelated to the current time (such as the Bitcoin network itself; the minimum is always a fixed median time)\n* In other cases, the limits may be bounded by other rules (many pools limit the time header to within 5 minutes of when the share is submitted to them).\n\nIs \"target\" really needed?\n* Some pools work with lower targets, and should not be expected to waste bandwidth ignoring shares that don't meet it.\n* Required to be a proper superset of getwork.\n* As mining hashrates grow, some miners may need the ability to request a lower target from their pools to be able to manage their bandwidth use.\n\nWhat is the purpose of the \"hash\" transaction list format?\n* Non-mining tools may wish to simply get a list of memory pool transactions.\n* Humans may wish to view their current memory pool.\n\n==Reference Implementation==\n\n* [http://gitorious.org/bitcoin/libblkmaker libblkmaker]\n* [https://gitorious.org/bitcoin/eloipool Eloipool]\n* [https://github.com/bitcoin/bitcoin/pull/936/files bitcoind]\n\n==See Also==\n* [[bip-0022.mediawiki|BIP 22: getblocktemplate - Fundamentals]]\n", "content_length": 13935}
{"bip_number": 22, "filename": "bip-0022.mediawiki", "content": "<pre>\n  BIP: 22\n  Layer: API/RPC\n  Title: getblocktemplate - Fundamentals\n  Author: Luke Dashjr <luke+bip22@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0022\n  Status: Final\n  Type: Standards Track\n  Created: 2012-02-28\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes a new JSON-RPC method for \"smart\" Bitcoin miners and proxies.\nInstead of sending a simple block header for hashing, the entire block structure is sent, and left to the miner to (optionally) customize and assemble.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Specification==\n\n===Block Template Request===\n\nA JSON-RPC method is defined, called \"getblocktemplate\".\nIt accepts exactly one argument, which MUST be an Object of request parameters.\nIf the request parameters include a \"mode\" key, that is used to explicitly select between the default \"template\" request or a [[bip-0023.mediawiki#Block Proposal|\"proposal\"]].\n\nBlock template creation can be influenced by various parameters:\n{| class=\"wikitable\"\n!colspan=4|template request\n|-\n! Key !! Required !! Type !! Description\n|-\n| capabilities || No || Array of Strings || SHOULD contain a list of the following, to indicate client-side support: [[#Optional: Long Polling|\"longpoll\"]], \"coinbasetxn\", \"coinbasevalue\", [[bip-0023.mediawiki#Block Proposal|\"proposal\"]], [[bip-0023.mediawiki#Logical Services|\"serverlist\"]], \"workid\", and any of the [[bip-0023.mediawiki#Mutations|mutations]]\n|-\n| mode || No || String || MUST be \"template\" or omitted\n|}\n\ngetblocktemplate MUST return a JSON Object containing the following keys:\n{| class=\"wikitable\"\n!colspan=4| template\n|-\n! Key !! Required !! Type !! Description\n|-\n| bits || Yes || String || the compressed difficulty in hexadecimal\n|-\n| curtime || Yes || Number || the current time as seen by the server (recommended for block time) - note this is not necessarily the system clock, and must fall within the mintime/maxtime rules\n|-\n| height || Yes || Number || the height of the block we are looking for\n|-\n| previousblockhash || Yes || String || the hash of the previous block, in big-endian hexadecimal\n|-\n| sigoplimit || No || Number || number of sigops allowed in blocks\n|-\n| sizelimit || No || Number || number of bytes allowed in blocks\n|-\n| transactions || Should || Array of Objects || Objects containing [[#Transactions Object Format|information for Bitcoin transactions]] (excluding coinbase)\n|-\n| version || Yes || Number || always 1 or 2 (at least for bitcoin) - clients MUST understand the implications of the version they use (eg, comply with [[bip-0034.mediawiki|BIP 0034]] for version 2)\n|-\n| coinbaseaux || No || Object || data that SHOULD be included in the coinbase's scriptSig content. Only the values (hexadecimal byte-for-byte) in this Object should be included, not the keys. This does not include the block height, which is required to be included in the scriptSig by [[bip-0034.mediawiki|BIP 0034]]. It is advisable to encode values inside \"PUSH\" opcodes, so as to not inadvertently expend SIGOPs (which are counted toward limits, despite not being executed).\n|-\n| coinbasetxn || this or \u2193 || Object || [[#Transactions Object Format|information for coinbase transaction]]\n|-\n| coinbasevalue || this or \u2191 || Number || total funds available for the coinbase (in Satoshis)\n|-\n| workid || No || String || if provided, this value must be returned with results (see [[#Block Submission|Block Submission]])\n|}\n\n==== Transactions Object Format ====\n\nThe Objects listed in the response's \"transactions\" key contains these keys:\n\n{| class=\"wikitable\"\n!colspan=3|template \"transactions\" element\n|-\n! Key !! Type !! Description\n|-\n| data || String || transaction data encoded in hexadecimal (byte-for-byte)\n|-\n| depends || Array of Numbers || other transactions before this one (by 1-based index in \"transactions\" list) that must be present in the final block if this one is; if key is not present, dependencies are unknown and clients MUST NOT assume there aren't any\n|-\n| fee || Number || difference in value between transaction inputs and outputs (in Satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\n|-\n| hash || String || hash/id encoded in little-endian hexadecimal\n|-\n| required || Boolean || if provided and true, this transaction must be in the final block\n|-\n| sigops || Number || total number of SigOps, as counted for purposes of block limits; if key is not present, sigop count is unknown and clients MUST NOT assume there aren't any\n|}\n\nOnly the \"data\" key is required, but servers should provide the others if they are known.\n\n===Block Submission===\n\nA JSON-RPC method is defined, called \"submitblock\", to submit potential blocks (or shares).\nIt accepts two arguments:\nthe first is always a String of the hex-encoded block data to submit;\nthe second is an Object of parameters, and is optional if parameters are not needed.\n\n{| class=\"wikitable\"\n!colspan=3|submitblock parameters (2nd argument)\n|-\n! Key !! Type !! Description\n|-\n| workid || String || if the server provided a workid, it MUST be included with submissions\n|}\n\nThis method MUST return either null (when a share is accepted), a String describing briefly the reason the share was rejected, or an Object of these with a key for each merged-mining chain the share was submitted to.\n\n===Optional: Long Polling===\n\n{| class=\"wikitable\"\n! colspan=\"3\" | template request\n|-\n! Key !! Type !! Description\n|-\n| capabilities || Array of Strings || miners which support long polling SHOULD provide a list including the String \"longpoll\"\n|-\n| longpollid || String || \"longpollid\" of job to monitor for expiration; required and valid only for long poll requests\n|}\n\n{| class=\"wikitable\"\n! colspan=\"3\" | template\n|-\n! Key !! Type !! Description\n|-\n| longpollid || String || identifier for long poll request; MUST be omitted if the server does not support long polling\n|-\n| longpolluri || String || if provided, an alternate URI to use for long poll requests\n|-\n| submitold || Boolean || only relevant for long poll responses: indicates if work received prior to this response remains potentially valid (default) and should have its shares submitted; if false, the miner may wish to discard its share queue\n|}\n\nIf the server supports long polling, it MUST include a \"longpollid\" key in block templates, and it MUST be unique for each event:\nany given \"longpollid\" should check for only one condition and not be reused.\nFor example, a server which has a long poll wakeup only for new blocks might use the previous block hash.\nHowever, clients should not assume the \"longpollid\" has any specific meaning.\nIt MAY supply the \"longpolluri\" key with a relative or absolute URI, which MAY specify a completely different resource than the original connection, including port number.\nIf \"longpolluri\" is provided by the server, clients MUST only attempt to use that URI for longpoll requests.\n\nClients MAY start a longpoll request with a standard JSON-RPC request (in the case of HTTP transport, POST with data) and same authorization, setting the \"longpollid\" parameter in the request to the value provided by the server.\n\nThis request SHOULD NOT be processed nor answered by the server until it wishes to replace the current block data as identified by the \"longpollid\".\nClients SHOULD make this request with a very long request timeout and MUST accept servers sending a partial response in advance (such as HTTP headers with \"chunked\" Transfer-Encoding), and only delaying the completion of the final JSON response until processing.\n\nUpon receiving a completed response:\n* Only if \"submitold\" is provided and false, the client MAY discard the results of past operations and MUST begin working on the new work immediately.\n* The client SHOULD begin working on the new work received as soon as possible, if not immediately.\n* The client SHOULD make a new request to the same long polling URI.\n\nIf a client receives an incomplete or invalid response, it SHOULD retry the request with an exponential backoff.\nClients MAY implement this backoff with limitations (such as maximum backoff time) or any algorithm as deemed suitable.\nIt is, however, forbidden to simply retry immediately with no delay after more than one failure.\nIn the case of a \"Forbidden\" response (for example, HTTP 403), a client SHOULD NOT attempt to retry without user intervention.\n\n===Optional: Template Tweaking===\n\n{| class=\"wikitable\"\n! colspan=\"3\" | template request\n|-\n! Key !! Type !! Description\n|-\n| sigoplimit || Number or Boolean || maximum number of sigops to include in template\n|-\n| sizelimit || Number or Boolean || maximum number of bytes to use for the entire block\n|-\n| maxversion || Number || highest block version number supported\n|}\n\nFor \"sigoplimit\" and \"sizelimit\", negative values and zero are offset from the server-determined block maximum.\nIf a Boolean is provided and true, the default limit is used; if false, the server is instructed not to use any limits on returned template.\nServers SHOULD respect these desired maximums, but are NOT required to:\nclients SHOULD check that the returned template satisfies their requirements appropriately.\n\n===Appendix: Example Rejection Reasons===\nPossible reasons a share may be rejected include, but are not limited to:\n{| class=\"wikitable\"\n!colspan=2| share rejection reasons\n|-\n! Reason !! Description\n|-\n| bad-cb-flag || the server detected a feature-signifying flag that it does not allow\n|-\n| bad-cb-length || the coinbase was too long (bitcoin limit is 100 bytes)\n|-\n| bad-cb-prefix || the server only allows appending to the coinbase, but it was modified beyond that\n|-\n| bad-diffbits || \"bits\" were changed\n|-\n| bad-prevblk || the previous-block is not the one the server intends to build on\n|-\n| bad-txnmrklroot || the block header's merkle root did not match the transaction merkle tree\n|-\n| bad-txns || the server didn't like something about the transactions in the block\n|-\n| bad-version || the version was wrong\n|-\n| duplicate || the server already processed this block data\n|-\n| high-hash || the block header did not hash to a value lower than the specified target\n|-\n| rejected || a generic rejection without details\n|-\n| stale-prevblk || the previous-block is no longer the one the server intends to build on\n|-\n| stale-work || the work this block was based on is no longer accepted\n|-\n| time-invalid || the time was not acceptable\n|-\n| time-too-new || the time was too far in the future\n|-\n| time-too-old || the time was too far in the past\n|-\n| unknown-user || the user submitting the block was not recognized\n|-\n| unknown-work || the template or workid could not be identified\n|}\n\n==Motivation==\n\nbitcoind's JSON-RPC server can no longer support the load of generating the work required to productively mine Bitcoin, and external software specializing in work generation has become necessary.\nAt the same time, new independent node implementations are maturing to the point where they will also be able to support miners.\n\nA common standard for communicating block construction details is necessary to ensure compatibility between the full nodes and work generation software.\n\n==Rationale==\nWhy not just deal with transactions as hashes (txids)?\n* Servers might not have access to the transaction database, or miners may wish to include transactions not broadcast to the network as a whole.\n* Miners may opt not to do full transaction verification, and may not have access to the transaction database on their end.\n\nWhat is the purpose of \"workid\"?\n* If servers allow all mutations, it may be hard to identify which job it is based on. While it may be possible to verify the submission by its content, it is much easier to compare it to the job issued. It is very easy for the miner to keep track of this. Therefore, using a \"workid\" is a very cheap solution to enable more mutations.\n\nWhy should \"sigops\" be provided for transactions?\n* Due to the [[bip-0016.mediawiki|BIP 0016]] changes regarding rules on block sigops, it is impossible to count sigops from the transactions themselves (the sigops in the scriptCheck must also be included in the count).\n\n==Reference Implementation==\n\n* [https://gitorious.org/bitcoin/eloipool Eloipool (server)]\n* [http://gitorious.org/bitcoin/libblkmaker libblkmaker (client)]\n* [https://github.com/bitcoin/bitcoin/pull/936/files bitcoind (minimal server)]\n\n==See Also==\n* [[bip-0023.mediawiki|BIP 23: getblocktemplate - Pooled Mining]]\n", "content_length": 12654}
{"bip_number": 21, "filename": "bip-0021.mediawiki", "content": "<pre>\n  BIP: 21\n  Layer: Applications\n  Title: URI Scheme\n  Author: Nils Schneider <nils.schneider@gmail.com>\n          Matt Corallo <bip21@bluematt.me>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0021\n  Status: Replaced\n  Type: Standards Track\n  Created: 2012-01-29\n  Superseded-By: 321\n</pre>\n\n=Superseded by BIP 321=\n\nThis BIP has been superseded and replaced with BIP 321. Please see [[bip-0321.mediawiki|BIP 321]] instead.\n\n=Original BIP=\n\nThis BIP is a modification of an earlier [[bip-0020.mediawiki|BIP 0020]] by Luke Dashjr. BIP 0020 was based off an earlier document by Nils Schneider. The alternative payment amounts in BIP 0020 have been removed.\n\n==Abstract==\nThis BIP proposes a URI scheme for making Bitcoin payments.\n\n==Motivation==\nThe purpose of this URI scheme is to enable users to easily make payments by simply clicking links on webpages or scanning QR Codes.\n\n==Specification==\n\n=== General rules for handling (important!) ===\n\nBitcoin clients MUST NOT act on URIs without getting the user's authorization.\nThey SHOULD require the user to manually approve each payment individually, though in some cases they MAY allow the user to automatically make this decision.\n\n=== Operating system integration ===\nGraphical bitcoin clients SHOULD register themselves as the handler for the \"bitcoin:\" URI scheme by default, if no other handler is already registered. If there is already a registered handler, they MAY prompt the user to change it once when they first run the client.\n\n=== General Format ===\n\nBitcoin URIs follow the general format for URIs as set forth in RFC 3986. The path component consists of a bitcoin address, and the query component provides additional payment options.\n\nElements of the query component may contain characters outside the valid range. These must first be encoded according to UTF-8, and then each octet of the corresponding UTF-8 sequence must be percent-encoded as described in RFC 3986.\n\n=== ABNF grammar ===\n\n(See also [[#simpler-syntax|a simpler representation of syntax]])\n\n bitcoinurn     = \"bitcoin:\" bitcoinaddress [ \"?\" bitcoinparams ]\n bitcoinaddress = *base58\n bitcoinparams  = bitcoinparam [ \"&\" bitcoinparams ]\n bitcoinparam   = [ amountparam / labelparam / messageparam / otherparam / reqparam ]\n amountparam    = \"amount=\" *digit [ \".\" *digit ]\n labelparam     = \"label=\" *qchar\n messageparam   = \"message=\" *qchar\n otherparam     = qchar *qchar [ \"=\" *qchar ]\n reqparam       = \"req-\" qchar *qchar [ \"=\" *qchar ]\n\nHere, \"qchar\" corresponds to valid characters of an RFC 3986 URI query component, excluding the \"=\" and \"&\" characters, which this BIP takes as separators.\n\nThe scheme component (\"bitcoin:\") is case-insensitive, and implementations must accept any combination of uppercase and lowercase letters. The rest of the URI is case-sensitive, including the query parameter keys.\n\n=== Query Keys ===\n\n*label: Label for that address (e.g. name of receiver)\n*address: bitcoin address\n*message: message that describes the transaction to the user ([[#Examples|see examples below]])\n*(others): optional, for future extensions\n\n==== Transfer amount ====\n\nIf an amount is provided, it MUST be specified in decimal BTC.\nAll amounts MUST contain no commas and use a period (.) as the separating character to separate whole numbers and decimal fractions.\nI.e. amount=50.00 or amount=50 is treated as 50 BTC, and amount=50,000.00 is invalid.\n\nBitcoin clients MAY display the amount in any format that is not intended to deceive the user.\nThey SHOULD choose a format that is foremost least confusing, and only after that most reasonable given the amount requested.\nFor example, so long as the majority of users work in BTC units, values should always be displayed in BTC by default, even if mBTC or TBC would otherwise be a more logical interpretation of the amount.\n== Rationale ==\n\n===Payment identifiers, not person identifiers===\nCurrent best practices are that a unique address should be used for every transaction.\nTherefore, a URI scheme should not represent an exchange of personal information, but a one-time payment.\n\n===Accessibility (URI scheme name)===\nShould someone from the outside happen to see such a URI, the URI scheme name already gives a description.\nA quick search should then do the rest to help them find the resources needed to make their payment.\nOther proposed names sound much more cryptic; the chance that someone googles that out of curiosity are much slimmer.\nAlso, very likely, what he will find are mostly technical specifications - not the best introduction to bitcoin.\n\n==Forward compatibility==\nVariables which are prefixed with a req- are considered required.  If a client does not implement any variables which are prefixed with req-, it MUST consider the entire URI invalid.  Any other variables which are not implemented, but which are not prefixed with a req-, can be safely ignored.\n\n==Backward compatibility==\nAs this BIP is written, several clients already implement a bitcoin: URI scheme similar to this one, however usually without the additional \"req-\" prefix requirement.  Thus, it is recommended that additional variables prefixed with req- not be used in a mission-critical way until a grace period of 6 months from the finalization of this BIP has passed in order to allow client developers to release new versions, and users of old clients to upgrade.\n\n== Appendix ==\n\n=== Simpler syntax ===\n\nThis section is non-normative and does not cover all possible syntax.\nPlease see the BNF grammar above for the normative syntax.\n\n[foo] means optional, &lt;bar&gt; are placeholders\n\n <nowiki>bitcoin:<address>[?amount=<amount>][?label=<label>][?message=<message>]</nowiki>\n\n=== Examples ===\n\nNote: The addresses used in these examples are intentionally invalid to prevent accidental transactions.\n\nJust the address:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\n\nAddress with name:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?label=Luke-Jr\n\nRequest 20.30 BTC to \"Luke-Jr\":\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=20.3&label=Luke-Jr\n\nRequest 50 BTC with message:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?amount=50&label=Luke-Jr&message=Donation%20for%20project%20xyz\n\nSome future version that has variables which are (currently) not understood and required and thus invalid:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?req-somethingyoudontunderstand=50&req-somethingelseyoudontget=999\n\nSome future version that has variables which are (currently) not understood but not required and thus valid:\n bitcoin:175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W?somethingyoudontunderstand=50&somethingelseyoudontget=999\n\nCharacters must be URI encoded properly.\n\n== Reference Implementation ==\n\nBitcoin-Qt supports the old version of Bitcoin URIs (ie without the req- prefix), with Windows and KDE integration as of commit 70f55355e29c8e45b607e782c5d76609d23cc858.\n", "content_length": 6918}
{"bip_number": 20, "filename": "bip-0020.mediawiki", "content": "<pre>\n  BIP: 20\n  Layer: Applications\n  Title: URI Scheme\n  Author: Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0020\n  Status: Replaced\n  Type: Standards Track\n  Created: 2011-01-10\n  License: BSD-2-Clause\n</pre>\n\nBIP 0020 is based off an earlier document by Nils Schneider. '''And has been replaced by BIP 0021'''\n\n==Abstract==\nThis BIP proposes a URI scheme for making Bitcoin payments.\n\n==Copyright==\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\nThe purpose of this URI scheme is to enable users to easily make payments by simply clicking links on webpages or scanning QR Codes.\n\n==Specification==\n\n=== General rules for handling (important!) ===\n\nBitcoin clients MUST NOT act on URIs without getting the user's authorization.\nThey SHOULD require the user to manually approve each payment individually, though in some cases they MAY allow the user to automatically make this decision.\n\n=== Operating system integration ===\nGraphical bitcoin clients SHOULD register themselves as the handler for the \"bitcoin:\" URI scheme by default, if no other handler is already registered. If there is already a registered handler, they MAY prompt the user to change it once when they first run the client.\n\n=== BNF grammar ===\n\n(See also [[#Simpler syntax|a simpler representation of syntax]])\n\n bitcoinurn      = \"bitcoin:\" bitcoinaddress [ \";version=\" bitcoinversion ] [ \"?\" bitcoinparams ]\n bitcoinaddress  = base58 *base58\n bitcoinversion  = \"1.0\"\n bitcoinparams   = *bitcoinparam\n bitcoinparam    = amountparam | labelparam | messageparam | sendparam | otherparam\n amountparam     = \"amount=\" amount\n amount          = amountdecimal | amounthex\n amountdecimal   = *digit [ \".\" *digit ] [ \"X\" *digit ]\n amounthex       = \"x\" *hexdigit [ \".\" *hexdigit ] [ \"X\" *hexdigit ]\n labelparam      = \"label=\" *pchar\n messageparam    = \"message=\" *pchar\n sendparam       = \"send=\" *pchar\n otherparam      = pchar *pchar \"=\" *pchar\n\n=== Query Keys ===\n\n*label: Label for that address (e.g. name of receiver)\n*address: bitcoin address\n*message: message that is shown to the user after scanning the QR code\n*size: amount of base bitcoin units ([[#Transfer amount/size|see below]])\n*send: used to send bitcoin, rather than to request them\n*(others): optional, for future extensions\n\n==== Transfer amount/size ====\n\nIf an amount is provided, it may be specified either in decimal or, when prefixed with a single \"x\" character, hexadecimal.\nThe number SHOULD be followed by \"X\" &lt;digits&gt; to signify an exponent to the base multiplier.\nThus, \"X8\" multiplies your number by 100,000,000.\nFor decimal values, this means the standard BTC unit.\nFor hexadecimal values, this means \u1d47TBC units (which are equivalent to 42.94967296 BTC).\nIf exponent is omitted, implementations SHOULD assume X8 for decimal numbers, and X4 for hexadecimal numbers.\nI.e. amount=50.00 is treated as 50 BTC, and amount=x40 is treated as 40 TBC.\nWhen specifying bitcoin base units, \"X0\" SHOULD be used.\n\nBitcoin clients MAY display the amount in any format that is not intended to deceive the user.\nThey SHOULD choose a format that is foremost least confusing, and only after that most reasonable given the amount requested.\nFor example, so long as the majority of users work in BTC units, values should always be displayed in BTC by default, even if mBTC or TBC would otherwise be a more logical interpretation of the amount.\n\n== Rationale ==\n\n===Payment identifiers, not person identifiers===\nCurrent best practices are that a unique address should be used for every transaction.\nTherefore, a URI scheme should not represent an exchange of personal information, but a one-time payment.\n\n===Accessibility (URI scheme name)===\nShould someone from the outside happen to see such a URI, the URI scheme name already gives a description.\nA quick search should then do the rest to help them find the resources needed to make their payment.\nOther proposed names sound much more cryptic; the chance that someone googles that out of curiosity are much slimmer.\nAlso, very likely, what he will find are mostly technical specifications - not the best introduction to bitcoin.\n\n==Forward compatibility==\nWe want URIs generated in 2011 to still work in 2036: think about extensibility.\nOf course we can make only educated guesses about the future, but don't act as if there is none.\nThis should be the best we can do, but it should not be seen as set in stone.\nMake it possible for later generations to improve our work, to mend our errors, without breaking the URIs created now.\n\n== Appendix ==\n\n=== Simpler syntax ===\n\nThis section is non-normative and does not cover all possible syntax.\nPlease see the [[#BNF grammar|BNF grammar]] above for the normative syntax.\n\n[foo] means optional, &lt;bar&gt; are placeholders\n\n<pre>\n bitcoin:<address>[;version=1.0][?amount=<amount>][?label=<label>][?message=<message>][?send=<private key>]\n</pre>\n\n=== Examples ===\n\nJust the address:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L\n\nAddress with name:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?label=Luke-Jr\n\nRequest 20.30 BTC to \"Luke-Jr\":\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?amount=20.3X8&label=Luke-Jr\n\nRequest 400 TBC:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?amount=x400X4\n\nRequest 4000 TBC:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?amount=x4X7\n\nRequest 5 uBTC:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?amount=5X2\n\nRequest 50 BTC with message:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?amount=50X8&label=Luke-Jr&message=Donation%20for%20project%20xyz\n\nSend 1 BTC:\n bitcoin:1NS17iag9jJgTHD1VXjvLCEnZuQ3rJED9L?amount=1X8&send=S4b3N3oGqDqR5jNuxEvDwf\n\nCharacters must be URI encoded properly.\n\n===Sending money via private key===\nTo send a payment to someone else first construct a new keypair. You may want to use a [[mini private key format]], or you may also use a full private key for more security depending on the amount being sent and how long you expect to pass before a claim. Now create and publish a transaction with an output of the amount you wish to send. Use this script in that output:\n\n<pre>\n <pubkey> OP_CHECKSIG\n</pre>\n\nConstruct an address from the public key. Encode the URI as below:\n\n<pre>\n bitcoin:<address>?send=<base 58 encoded private key>\n</pre>\n\nYou may optionally include amount or message fields as well. In a wallet to claim money sent this way search for an incoming transaction with the output script form above, where &lt;address&gt; matches the public key in the script. When you find the transaction create a claim transaction with an input script of this form:\n\n<pre>\n <sig>\n</pre>\n\nThis claims the money you were sent. Until your claim transaction has confirmed the sender may take their money back.\n\n== Reference Implementations ==\n=== Bitcoin clients ===\n* [[Spesmilo]] supports all valid Bitcoin URIs, with Windows and KDE integration\n\n=== Parsing amount ===\n==== ECMAScript ====\n<pre>\n reAmount = /^(([\\d.]+)(X(\\d+))?|x([\\da-f]*)(\\.([\\da-f]*))?(X([\\da-f]+))?)$/i;\n function parseAmount(txt) {\n    var m = txt.match(reAmount);\n    return m[5] ? (\n        (\n            parseInt(m[5], 16) +\n            (m[7] ? (parseInt(m[7], 16) * Math.pow(16, -(m[7].length))) : 0)\n        ) * (\n            m[9] ? Math.pow(16, parseInt(m[9], 16)) : 0x10000\n        )\n    ) : (\n            m[2]\n        *\n            (m[4] ? Math.pow(10, m[4]) : 1e8)\n    );\n }\n</pre>\n\n==== Python ====\n<pre>\n m = re.match(r'^(([\\d.]+)(X(\\d+))?|x([\\da-f]*)(\\.([\\da-f]*))?(X([\\da-f]+))?)$', amount, re.IGNORECASE)\n if m.group(5):\n     amount = float(int(m.group(5), 16))\n     if m.group(7):\n         amount += float(int(m.group(7), 16)) * pow(16, -(len(m.group(7))))\n     if m.group(9):\n         amount *= pow(16, int(m.group(9), 16))\n     else:\n         amount *= 0x10000\n else:\n     amount = Decimal(m.group(2))\n     if m.group(4):\n         amount *= 10 ** int(m.group(4))\n     else:\n         amount *= 100000000\n</pre>\n\n==== C# ====\n<pre>\n Regex amountExpression = new Regex(@\"^(([\\d.]+)(X(\\d+))?|x([\\da-f]*)(\\.([\\da-f]*))?(X([\\da-f]+))?)$\", RegexOptions.IgnoreCase);\n Match match = amountExpression.Match(value);\n if (match.Success)\n {\n     if (match.Groups[5].Success)\n     {\n         long hexDecimal = 0;\n         if (match.Groups[7].Success)\n             hexDecimal = Convert.ToInt64(match.Groups[7].Value, 16) * (long)Math.Pow(16, -match.Groups[7].Length);\n\n         long hexExponent = 0x10000;\n         if (match.Groups[9].Success)\n             hexExponent = (long)Math.Pow(16, Convert.ToInt32(match.Groups[9].Value, 16));\n\n         Amount = (Convert.ToInt64(match.Groups[5].Value, 16) + hexDecimal) * hexExponent;\n     }\n     else\n     {\n         long decimalExponent = 100000000;\n         if (match.Groups[4].Success)\n             decimalExponent = (long)Math.Pow(10, int.Parse(match.Groups[4].Value));\n         Amount = (long)(decimal.Parse(match.Groups[2].Value) * decimalExponent);\n     }\n }\n</pre>\n", "content_length": 8990}
{"bip_number": 19, "filename": "bip-0019.mediawiki", "content": "<pre>\n  BIP: 19\n  Layer: Applications\n  Title: M-of-N Standard Transactions (Low SigOp)\n  Author: Luke Dashjr <luke+bip17@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0019\n  Status: Rejected\n  Type: Standards Track\n  Created: 2012-01-30\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP proposes M-of-N-signatures required transactions as a new 'standard' transaction type using the existing scripting system without significant modifications.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nEnable secured wallets, escrow transactions, and other use cases where redeeming funds requires more than a single signature.\n\nA couple of motivating use cases:\n\n* A wallet secured by a \"wallet protection service\" (WPS).  2-of-2 signatures required transactions will be used, with one signature coming from the (possibly compromised) computer with the wallet and the second signature coming from the WPS. When sending protected bitcoins, the user's bitcoin client will contact the WPS with the proposed transaction and it can then contact the user for confirmation that they initiated the transaction and that the transaction details are correct. Details for how clients and WPS's communicate are outside the scope of this BIP. Side note: customers should insist that their wallet protection service provide them with copies of the private key(s) used to secure their wallets that they can safely store off-line, so that their coins can be spent even if the WPS goes out of business.\n\n* Three-party escrow (buyer, seller and trusted dispute agent). 2-of-3 signatures required transactions will be used. The buyer and seller and agent will each provide a public key, and the buyer will then send coins into a 2-of-3 CHECKMULTISIG transaction and send the seller and the agent the transaction id. The seller will fulfill their obligation and then ask the buyer to co-sign a transaction ( already signed by seller ) that sends the tied-up coins to him (seller).<br />If the buyer and seller cannot agree, then the agent can, with the cooperation of either buyer or seller, decide what happens to the tied-up coins.  Details of how buyer, seller, and agent communicate to gather signatures or public keys are outside the scope of this BIP.\n\n==Specification==\n\nTwo new standard transaction types (scriptPubKey) that are relayed by clients and included in mined blocks.\n\nN-of-N (all signatures required):\n\n    ( {pubkey} OP_CHECKSIGVERIFY )*n\n\nN-of-M (some signatures required):\n\n    {pubkey} OP_CHECKSIG  ( OP_SWAP {pubkey} OP_CHECKSIG OP_ADD )*(n-1) n OP_EQUAL\n\nBut only for n less than or equal to 3.\n\nThese transactions are redeemed using a standard scriptSig:\n    ...signatures...\n\nThe current Satoshi bitcoin client does not relay or mine transactions with scriptSigs larger than 200 bytes; to accommodate 3-signature transactions, this will be increased to 500 bytes.\n\n===Templates===\nscriptPubKey:\n\n  {pubkey} OP_CHECKSIGVERIFY {pubkey} OP_CHECKSIGVERIFY\n\n  {pubkey} OP_CHECKSIGVERIFY {pubkey} OP_CHECKSIGVERIFY {pubkey} OP_CHECKSIGVERIFY\n\n  {pubkey} OP_CHECKSIG OP_SWAP {pubkey} OP_CHECKSIG OP_ADD {n} OP_EQUAL\n\n  {pubkey} OP_CHECKSIG OP_SWAP {pubkey} OP_CHECKSIG OP_ADD OP_SWAP {pubkey} OP_CHECKSIG OP_ADD {n} OP_EQUAL\n\nscriptSig:\n\n  ...signatures... up to 500 bytes\n\n==Rationale==\n\nOP_CHECKMULTISIG is already an enabled opcode, and is the most straightforward way to support several important use cases.\nThis is already specified in [[bip-0011.mediawiki|BIP 0011]].\nHowever, each OP_CHECKMULTISIG counts toward the block limit as 20 sigops, which only allows 1000 total multisig transactions in a block.\nUsing OP_CHECKSIG only counts as 1 per signature, so can scale better.\n\n==Implementation==\n\nAll used operations are already supported by old clients and miners as a non-standard transaction type.\n", "content_length": 3911}
{"bip_number": 18, "filename": "bip-0018.mediawiki", "content": "<pre>\n  BIP: 18\n  Layer: Consensus (soft fork)\n  Title: hashScriptCheck\n  Author: Luke Dashjr <luke+bip17@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0018\n  Status: Proposed\n  Type: Standards Track\n  Created: 2012-01-27\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP modifies the basic format of transaction inputs and outputs, replacing the current scriptSig and scriptPubKey (scripts executed to validate a transaction) with new contents: dataSig, scriptCheck, and hashScriptCheck.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nThe purpose of pay-to-script-hash is to move the responsibility for supplying the conditions to redeem a transaction from the sender of the funds to the redeemer.\n\nThe benefit is allowing a sender to fund any arbitrary transaction, no matter how complicated, using a fixed-length 20-byte hash that is short enough to scan from a QR code or easily copied and pasted.\n\n==Specification==\n\nscriptSig and scriptPubKey are hereby deemed to be deprecated.\nBitcoin-compatible clients MUST still continue to support them for compatibility, but it should not be used for any new transaction types.\nServices and people which send Bitcoins SHOULD continue to support old pubkey-based addresses for the time being.\nServices and people which receive Bitcoins MAY continue to generate and use old pubkey-based addresses.\n\nTo replace these, there are 3 new elements:\n* dataSig is included in place of scriptSig in transaction inputs, and contains multiple serialized data elements\n* scriptCheck is the final element of dataSig, and is executed with the preceding dataSig elements preloaded onto the stack (the element immediately before scriptCheck is the top of the stack)\n* hashScriptCheck is included in place of scriptPubKey in transaction outputs, to specify the hash of the scriptCheck allowed to redeem it\n\ndataSig is to be encoded the same as a push-only script.\n\nhashScriptCheck must be encoded exactly so:\n\n    0xa9 0x14 (20-byte-hash-value) 0x87\n\nThis can be interpreted by legacy (pre-BIP 18) clients as the following script:\n\n    OP_HASH160 [20-byte-hash-value] OP_EQUAL\n\nIf this template is not matched exactly OR the transaction is in a block with a timestamp before the hashScriptCheck activation date, validation MUST proceed in backward-compatibility mode, using scriptSig+scriptPubKey rather than dataSig+scriptCheck+hashScriptCheck.\n\nA hashScriptCheck-compliant input is valid only if:\n* dataSig MUST NOT contain any operations other than \"push data\" (it is data, not a script; no mixing scriptSig with hashScriptCheck)\n* scriptCheck MUST hash (using Bitcoin's Hash160 algorithm) to the output's hashScriptCheck.\n* scriptCheck MUST be executed with the dataSig-based stack specified above (ie, not including scriptCheck itself) to perform validation (this does not imply clients are required to validate transactions).\n* scriptCheck must not abort, and must leave a true value on the top of the stack. This is the current behaviour for scriptSig+scriptPubKey.\n\nThe new scriptCheck SHOULD be checked against \"standard transaction\" templates by miners.\n\nFor example, the hashScriptCheck and corresponding dataSig for a one-signature-required transaction is:\n\n    scriptCheck: [pubkey] OP_CHECKSIG\n    dataSig: [signature] {[pubkey] OP_CHECKSIG}\n    hashScriptCheck: [20-byte-hash of {[pubkey] OP_CHECKSIG}]\n\n===Signature operation limits for scriptCheck===\n\nSignature operations in scriptCheck do not follow the same rules previously applied to scriptSig and scriptPubKey.\nInstead, they shall contribute to the maximum number allowed per block (20,000) as follows:\n\n# OP_CHECKSIG and OP_CHECKSIGVERIFY count as 1 signature operation, whether or not they are evaluated.\n# OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY immediately preceded by OP_1 through OP_16 are counted as 1 to 16 signature operation, whether or not they are evaluated.\n# All other OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY are counted as 20 signature operations.\n\nExamples:\n\n+3 signature operations:\n    2 [pubkey1] [pubkey2] [pubkey3] 3 OP_CHECKMULTISIG\n\n+22 signature operations\n    OP_CHECKSIG OP_IF OP_CHECKSIGVERIFY OP_ELSE OP_CHECKMULTISIGVERIFY OP_ENDIF\n\n==Rationale==\n\nThis BIP replaces BIPs 12 and 17, which propose extensions to the Script system to allow scriptPubKey to outsource its verification.\nIt also replaces BIP 16, which is identical in terms of protocol, but suggests a specific implementation and does not deprecate scriptPubKey to maintain protocol consistency.\n\nThe Motivation for this BIP (and BIP 13, the pay-to-script-hash address type) is somewhat controversial; several people feel that it is unnecessary, and complex/multisignature transaction types should be supported by simply giving the sender the complete {serialized script}. The author believes that this BIP will minimize the changes needed to all of the supporting infrastructure that has already been created to send funds to a base58-encoded-20-byte bitcoin addresses, allowing merchants and exchanges and other software to start supporting multisignature transactions sooner.\n\nThe signature operation counting rules are intended to be easy and quick to implement by statically scanning scriptCheck.\nBitcoin imposes a maximum-number-of-signature-operations per block to prevent denial-of-service attacks on miners.\nIf there was no limit, a rogue miner might broadcast a block that required hundreds of thousands of ECDSA signature operations to validate, and it might be able to get a head start computing the next block while the rest of the network worked to validate the current one.\n\nThere is a 1-confirmation attack on old implementations, but it is expensive and difficult in practice. The attack is:\n\n# Attacker creates a pay-to-script-hash transaction that is valid when interpreted as scriptPubKey, but contains an invalid scriptCheck, and sends themselves some coins using it.\n# Attacker also creates a standard transaction that spends the pay-to-script transaction, and pays the victim who is running old software.\n# Attacker mines a block that contains both transactions.\n\nIf the victim accepts the 1-confirmation payment, then the attacker wins because both transactions will be invalidated when the rest of the network overwrites the attacker's invalid block.\n\nThe attack is expensive because it requires the attacker create a block that they know will be invalidated by the rest of the network. It is difficult because creating blocks is difficult and users should not accept 1-confirmation transactions for higher-value transactions.\n\n==Backwards Compatibility==\n\nhashScriptCheck transactions are non-standard to old implementations, which will (typically) not relay them nor include them in blocks.\n\nOld implementations will validate that scriptCheck's hash value matches when they validate blocks created by software that fully support this BIP, but will do no other validation.\n\nAvoiding a block-chain split by malicious pay-to-script transactions requires careful handling of one case:\n\n* A pay-to-script-hash transaction that is invalid for new clients/miners but valid for old clients/miners.\n\nTo gracefully upgrade and ensure no long-lasting block-chain split occurs, more than 50% of miners must support full validation of the new transaction type and must switch from the old validation rules to the new rules at the same time.\n\nTo judge whether or not more than 50% of hashing power supports this BIP, miners are asked to upgrade their software and put the string \"/P2SH/\" in the input of the coinbase transaction for blocks that they create.\n\nAt 00:00:00 UTC on 15 Mar 2012, the block-chain will be examined to determine the number of blocks supporting pay-to-script-hash for the previous 7 days. If 550 or more contain \"/P2SH/\" in their coinbase, then all blocks with timestamps after 00:00:00 UTC on 1 Apr 2012 shall have their pay-to-script-hash transactions fully validated. Approximately 1,000 blocks are created in a week; 550 should, therefore, be approximately 55% of the network supporting the new feature.\n\nIf a majority of hashing power does not support the new validation rules, then rollout will be postponed (or rejected if it becomes clear that a majority will never be achieved).\n\n==Forwards Compatibility ==\nThe first two bytes of hashScriptCheck specify the hash algorithm and length used to verify scriptCheck.\nThis BIP only allows Bitcoin's Hash160 algorithm, but leaves open the possibility of a future BIP implementing others.\n\n==Reference Implementation==\n\nhttps://github.com/gavinandresen/bitcoin-git/tree/pay_to_script_hash\n\n==See Also==\n\n* The [[bip-0013.mediawiki|Address format for Pay to Script Hash BIP]]\n* [[bip-0016.mediawiki|BIP 16 - Pay to Script Hash (aka \"/P2SH/\")]]\n* M-of-N Multisignature Transactions [[bip-0011.mediawiki|BIP 11]]\n", "content_length": 8909}
{"bip_number": 17, "filename": "bip-0017.mediawiki", "content": "<pre>\n  BIP: 17\n  Layer: Consensus (soft fork)\n  Title: OP_CHECKHASHVERIFY (CHV)\n  Author: Luke Dashjr <luke+bip17@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0017\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2012-01-18\n  License: BSD-2-Clause\n</pre>\n\n==Abstract==\n\nThis BIP describes a new opcode (OP_CHECKHASHVERIFY) for the Bitcoin scripting system, and a new 'standard' transaction type that uses it to enables the receiver of bitcoins to specify the transaction type needed to re-spend them.\n\n==Copyright==\n\nThis BIP is licensed under the BSD 2-clause license.\n\n==Motivation==\n\nThe purpose of pay-to-script-hash is to move the responsibility for supplying the conditions to redeem a transaction from the sender of the funds to the redeemer.\n\nThe benefit is allowing a sender to fund any arbitrary transaction, no matter how complicated, using a fixed-length 20-byte hash that is short enough to scan from a QR code or easily copied and pasted.\n\n==Specification==\n\nOP_CHECKHASHVERIFY will re-define the existing OP_NOP2 opcode, and will function as follows when executed:\n\n* First, hash the end of the prior script (in the general case, scriptSig; if no prior script, a null string is hashed) beginning from the last evaluated OP_CODESEPARATOR onward (or from the beginning of the script, if no OP_CODESEPARATOR was present)\n* Then, compare this with the item on the top of the stack (if there is none, the script fails immediately)\n* If the hashes match, do nothing, proceed as if an OP_NOP; if they do not match, the script fails immediately.\n* Note that in the case of a matched hash, the top stack item (the hash being compared with) is <u>not</u> popped off the stack. This is for backward compatibility.\n\nThis opcode reassignment shall be applied when validating transactions in blocks only with timestamps after February 23, 2012 (see the Backwards Compatibility section for details).\n\nA new standard transaction type that is relayed and included in mined blocks is defined:\n\n    [20-byte-hash-value] OP_CHECKHASHVERIFY OP_DROP\n\n[20-byte-hash-value] shall be the push-20-bytes-onto-the-stack opcode (0x14) followed by exactly 20 bytes.\n\nThis new transaction type is redeemed by a standard scriptSig:\n\n    ...signatures... OP_CODESEPARATOR {script}\n\nTransactions that redeem these pay-to-script outpoints are only considered standard if they contain exactly one OP_CODESEPARATOR and the appended ''script'' is, itself, one of the other standard transaction types.\n\n==Example==\n\nFor example, the scriptPubKey and corresponding scriptSig for a one-signature-required transaction is:\n\n    scriptSig: [signature] OP_CODESEPARATOR [pubkey] OP_CHECKSIG\n    scriptPubKey: [20-byte-hash of {[pubkey] OP_CHECKSIG} ] OP_CHECKHASHVERIFY OP_DROP\n\n2-of-3:\n\n    scriptSig: [signatures...] OP_CODESEPARATOR 2 [pubkey1] [pubkey2] [pubkey3] 3 OP_CHECKMULTISIG\n    scriptPubKey: [20-byte-hash of {2 [pubkey1] [pubkey2] [pubkey3] 3 OP_CHECKMULTISIG} ] OP_CHECKHASHVERIFY OP_DROP\n\n==Rationale==\n\nThis BIP replaces BIP 12 and BIP 16, which propose evaluating a Script from the stack after verifying its hash.\n\nThe Motivation for this BIP (and BIP 13, the pay-to-script-hash address type) is somewhat controversial; several people feel that it is unnecessary, and complex/multisignature transaction types should be supported by simply giving the sender the complete {serialized script}. The author believes that this BIP will minimize the changes needed to all of the supporting infrastructure that has already been created to send funds to a base58-encoded-20-byte bitcoin addresses, allowing merchants and exchanges and other software to start supporting multisignature transactions sooner.\n\nThere is a 1-confirmation attack on old implementations, but it is expensive and difficult in practice. The attack is:\n\n# Attacker creates a pay-to-script-hash transaction that is valid as seen by old software, but invalid for new implementation, and sends themselves some coins using it.\n# Attacker also creates a standard transaction that spends the pay-to-script transaction, and pays the victim who is running old software.\n# Attacker mines a block that contains both transactions.\n\nIf the victim accepts the 1-confirmation payment, then the attacker wins because both transactions will be invalidated when the rest of the network overwrites the attacker's invalid block.\n\nThe attack is expensive because it requires the attacker create a block that they know will be invalidated by the rest of the network. It is difficult because creating blocks is difficult and users should not accept 1-confirmation transactions for higher-value transactions.\n\n==Backwards Compatibility==\n\nThese transactions are non-standard to old implementations, which will (typically) not relay them nor include them in blocks.\n\nOld implementations will not validate that the {script}'s hash value matches when they validate blocks created by software that fully support this BIP.\n\nAvoiding a block-chain split by malicious pay-to-script transactions requires careful handling of one case:\n\n* A pay-to-script-hash transaction that is invalid for new clients/miners but valid for old clients/miners.\n\nTo gracefully upgrade and ensure no long-lasting block-chain split occurs, more than 50% of miners must support full validation of the new transaction type and must switch from the old validation rules to the new rules at the same time.\n\nTo judge whether or not more than 50% of hashing power supports this BIP, miners are asked to upgrade their software and put the string \"p2sh/CHV\" in the input of the coinbase transaction for blocks that they create.\n\nOn February 8, 2012, the block-chain will be examined to determine the number of blocks supporting pay-to-script-hash for the previous 7 days. If at least 60% contain \"p2sh/CHV\" in their coinbase, then all blocks with timestamps after 23 Feb 2012, 00:00:00 GMT shall have their pay-to-script-hash transactions validated.\n\nIf a majority of hashing power does not support the new validation rules, then rollout will be postponed (or rejected if it becomes clear that a majority will never be achieved).\n\nOP_NOP2 is used, so existing OP_EVAL (BIP 12) transactions in the block chain can still be redeemed.\n\n==Reference Implementation==\n\n[https://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin/commits/checkhashverify Validation, sending, and receiving for bitcoind git master]\n\n[https://gitorious.org/~Luke-Jr/bitcoin/luke-jr-bitcoin/commits/checkhashverify_backport Validation only for 0.3.19+]\n\n==See Also==\n\n* The [[bip-0013.mediawiki|Address format for Pay to Script Hash BIP]]\n* [[bip-0011.mediawiki|M-of-N Multisignature Transactions (BIP 11)]]\n* Example BIP 17 transaction chain: [http://blockexplorer.com/tx/b8fd633e7713a43d5ac87266adc78444669b987a56b3a65fb92d58c2c4b0e84d a] [http://blockexplorer.com/tx/eb3b82c0884e3efa6d8b0be55b4915eb20be124c9766245bcc7f34fdac32bccb b] [http://blockexplorer.com/tx/055707ce7fea7b9776fdc70413f65ceec413d46344424ab01acd5138767db137 c] [http://blockexplorer.com/tx/6d36bc17e947ce00bb6f12f8e7a56a1585c5a36188ffa2b05e10b4743273a74b d]\n", "content_length": 7171}
{"bip_number": 16, "filename": "bip-0016.mediawiki", "content": "<pre>\n  BIP: 16\n  Layer: Consensus (soft fork)\n  Title: Pay to Script Hash\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0016\n  Status: Final\n  Type: Standards Track\n  Created: 2012-01-03\n</pre>\n\n==Abstract==\n\nThis BIP describes a new \"standard\" transaction type for the Bitcoin scripting system, and defines additional validation rules that apply only to the new transactions.\n\n==Motivation==\n\nThe purpose of pay-to-script-hash is to move the responsibility for supplying the conditions to redeem a transaction from the sender of the funds to the redeemer.\n\nThe benefit is allowing a sender to fund any arbitrary transaction, no matter how complicated, using a fixed-length 20-byte hash that is short enough to scan from a QR code or easily copied and pasted.\n\n==Specification==\n\nA new standard transaction type that is relayed and included in mined blocks is defined:\n\n    OP_HASH160 [20-byte-hash-value] OP_EQUAL\n\n[20-byte-hash-value] shall be the push-20-bytes-onto-the-stack opcode (0x14) followed by exactly 20 bytes.\n\nThis new transaction type is redeemed by a standard scriptSig:\n\n    ...signatures... {serialized script}\n\nTransactions that redeem these pay-to-script outpoints are only considered standard if the ''serialized script'' - also referred to as the ''redeemScript'' - is, itself, one of the other standard transaction types.\n\nThe rules for validating these outpoints when relaying transactions or considering them for inclusion in a new block are as follows:\n\n# Validation fails if there are any operations other than \"push data\" operations in the scriptSig.\n# Normal validation is done: an initial stack is created from the signatures and {serialized script}, and the hash of the script is computed and validation fails immediately if it does not match the hash in the outpoint.\n# {serialized script} is popped off the initial stack, and the transaction is validated again using the popped stack and the deserialized script as the scriptPubKey.\n\nThese new rules should only be applied when validating transactions in blocks with timestamps >= 1333238400 (Apr 1 2012) <ref>[https://github.com/bitcoin/bitcoin/commit/8f188ece3c82c4cf5d52a3363e7643c23169c0ff Remove -bip16 and -paytoscripthashtime command-line arguments]</ref>. There are transactions earlier than 1333238400 in the block chain that fail these new validation rules. <ref>[https://web.archive.org/web/20141122040355/http://blockexplorer.com/tx/6a26d2ecb67f27d1fa5524763b49029d7106e91e3cc05743073461a719776192 Transaction 6a26d2ecb67f27d1fa5524763b49029d7106e91e3cc05743073461a719776192]</ref>. Older transactions must be validated under the old rules. (see the Backwards Compatibility section for details).\n\nFor example, the scriptPubKey and corresponding scriptSig for a one-signature-required transaction is:\n\n    scriptSig: [signature] {[pubkey] OP_CHECKSIG}\n    scriptPubKey: OP_HASH160 [20-byte-hash of {[pubkey] OP_CHECKSIG} ] OP_EQUAL\n\nSignature operations in the {serialized script} shall contribute to the maximum number allowed per block (20,000) as follows:\n\n# OP_CHECKSIG and OP_CHECKSIGVERIFY count as 1 signature operation, whether or not they are evaluated.\n# OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY immediately preceded by OP_1 through OP_16 are counted as 1 to 16 signature operation, whether or not they are evaluated.\n# All other OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY are counted as 20 signature operations.\n\nExamples:\n\n+3 signature operations:\n    {2 [pubkey1] [pubkey2] [pubkey3] 3 OP_CHECKMULTISIG}\n\n+22 signature operations:\n    {OP_CHECKSIG OP_IF OP_CHECKSIGVERIFY OP_ELSE OP_CHECKMULTISIGVERIFY OP_ENDIF}\n\n==Rationale==\n\nThis BIP replaces BIP 12, which proposed a new Script opcode (\"OP_EVAL\") to accomplish everything in this BIP and more.\n\nThe Motivation for this BIP (and BIP 13, the pay-to-script-hash address type) is somewhat controversial; several people feel that it is unnecessary, and complex/multisignature transaction types should be supported by simply giving the sender the complete {serialized script}. The author believes that this BIP will minimize the changes needed to all of the supporting infrastructure that has already been created to send funds to a base58-encoded-20-byte bitcoin addresses, allowing merchants and exchanges and other software to start supporting multisignature transactions sooner.\n\nRecognizing one 'special' form of scriptPubKey and performing extra validation when it is detected is ugly. However, the consensus is that the alternatives are either uglier, are more complex to implement, and/or expand the power of the expression language in dangerous ways.\n\nThe signature operation counting rules are intended to be easy and quick to implement by statically scanning the {serialized script}. Bitcoin imposes a maximum-number-of-signature-operations per block to prevent denial-of-service attacks on miners. If there was no limit, a rogue miner might broadcast a block that required hundreds of thousands of ECDSA signature operations to validate, and it might be able to get a head start computing the next block while the rest of the network worked to validate the current one.\n\nThere is a 1-confirmation attack on old implementations, but it is expensive and difficult in practice. The attack is:\n\n# Attacker creates a pay-to-script-hash transaction that is valid as seen by old software, but invalid for new implementation, and sends themselves some coins using it.\n# Attacker also creates a standard transaction that spends the pay-to-script-hash transaction, and pays the victim who is running old software.\n# Attacker mines a block that contains both transactions.\n\nIf the victim accepts the 1-confirmation payment, then the attacker wins because both transactions will be invalidated when the rest of the network overwrites the attacker's invalid block.\n\nThe attack is expensive because it requires the attacker create a block that they know will be invalidated by the rest of the network. It is difficult because creating blocks is difficult and users should not accept 1-confirmation transactions for higher-value transactions.\n\n==Backwards Compatibility==\n\nThese transactions are non-standard to old implementations, which will (typically) not relay them or include them in blocks.\n\nOld implementations will validate that the {serialize script}'s hash value matches when they validate blocks created by software that fully support this BIP, but will do no other validation.\n\nAvoiding a block-chain split by malicious pay-to-script transactions requires careful handling of one case:\n\n* A pay-to-script-hash transaction that is invalid for new clients/miners but valid for old clients/miners.\n\nTo gracefully upgrade and ensure no long-lasting block-chain split occurs, more than 50% of miners must support full validation of the new transaction type and must switch from the old validation rules to the new rules at the same time.\n\nTo judge whether or not more than 50% of hashing power supports this BIP, miners are asked to upgrade their software and put the string \"/P2SH/\" in the input of the coinbase transaction for blocks that they create.\n\nOn February 1, 2012, the block-chain will be examined to determine the number of blocks supporting pay-to-script-hash for the previous 7 days. If 550 or more contain \"/P2SH/\" in their coinbase, then all blocks with timestamps after 15 Feb 2012, 00:00:00 GMT shall have their pay-to-script-hash transactions fully validated. Approximately 1,000 blocks are created in a week; 550 should, therefore, be approximately 55% of the network supporting the new feature.\n\nIf a majority of hashing power does not support the new validation rules, then rollout will be postponed (or rejected if it becomes clear that a majority will never be achieved).\n\n===520-byte limitation on serialized script size===\n\nAs a consequence of the requirement for backwards compatibility the serialized script is itself subject to the same rules as any other PUSHDATA operation, including the rule that no data greater than 520 bytes may be pushed to the stack. Thus it is not possible to spend a P2SH output if the redemption script it refers to is >520 bytes in length. For instance while the OP_CHECKMULTISIG opcode can itself accept up to 20 pubkeys, with 33-byte compressed pubkeys it is only possible to spend a P2SH output requiring a maximum of 15 pubkeys to redeem: 3 bytes + 15 pubkeys * 34 bytes/pubkey = 513 bytes.\n\n\n==Reference Implementation==\n\nhttps://gist.github.com/gavinandresen/3966071\n\n==See Also==\n\n* https://bitcointalk.org/index.php?topic=46538\n* The [[bip-0013.mediawiki|Address format for Pay to Script Hash BIP]]\n* M-of-N Multisignature Transactions [[bip-0011.mediawiki|BIP 11]]\n* [[bip-0016/qa.mediawiki|Quality Assurance test checklist]]\n\n== References ==\n\n<references/>\n", "content_length": 8900}
{"bip_number": 15, "filename": "bip-0015.mediawiki", "content": "<pre>\n  BIP: 15\n  Layer: Applications\n  Title: Aliases\n  Author: Amir Taaki <genjix@riseup.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0015\n  Status: Deferred\n  Type: Standards Track\n  Created: 2011-12-10\n</pre>\n\n[[bip-0070.mediawiki|BIP 0070]] (payment protocol) may be seen as the alternative to Aliases.\n\nUsing vanilla bitcoin, to send funds to a destination, an address in the form 1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ is needed. The problem with using addresses is that they are not easy to remember. An analogy can be thought if one were required to enter the IP address of their favourite websites if domain names did not exist.\n\nThis document aims to layout through careful argument, a bitcoin alias system. This is a big modification to the protocol that is not easily changed in the future and has big ramifications. There is impetus in getting it correct the first time. Aliases have to be robust and secure.\n\n== Schemes ==\n\nHere are a few different proposals and the properties of each system.\n\n=== FirstBits ===\n\nFirstBits is a proposal for using the blockchain as an address book.\n\nWhen bitcoins are sent to an address, that address becomes recorded in the blockchain. It is therefore known that this address exists or did exist by simply seeing that there was a payment to that address. FirstBits is a method to have a memorable alias. One first converts the address to lower-case, then takes the first few unique characters. This is your FirstBits alias.\n\nAs an example, brmlab hackerspace in Prague has an address for purchasing food or drink, or making donations:\n\n  1BRMLAB7nryYgFGrG8x9SYaokb8r2ZwAsX\n\nTheir FirstBits alias becomes:\n\n  1brmlab\n\nIt is enough information to be given the FirstBits alias ''1brmlab''. When someone wishes to make a purchase, without FirstBits, they either have to type out their address laboriously by hand, scan their QR code (which requires a mobile handset that this author does not own) or find their address on the internet to copy and paste into the client to send bitcoins. FirstBits alleviates this impracticality by providing an easy method to make payments.\n\nTogether with Vanitygen (vanity generator), it becomes possible to create memorable unique named addresses. Addresses that are meaningful, rather than an odd assemblage of letters and numbers but add context to the destination.\n\nHowever FirstBits has its own problems. One is that the possible aliases one is able to generate is limited by the available computing power available. It may not be feasible to generate a complete or precise alias that is wanted- only approximates may be possible. It is also computationally resource intensive which means a large expenditure of power for generating unique aliases in the future, and may not scale up to the level of individuals at home or participants with hand-held devices in an environment of ubiquitous computing.\n\nFirstBits scales extremely poorly as the network grows. Each indexer or lookup node needs to keep track of every bitcoin address ever in existence and provide a fast lookup from the aliases to those addresses. As the network grows linearly, the number of addresses should grow exponentially (assuming a networked effect of (n-1)*(n-2)/2) rapidly making this scheme unfeasible.\n\nLight clients of the partial merkle root types become dependent on a trusted third party for their alias lookups. The cost of storing every bitcoin address is too high considering their typical use-case on low-resource devices. This factor more than the others, means this scheme is sub-optimal and must be rejected.\n\n=== DNS TXT Records ===\n\nDNS allows TXT records to be created containing arbitrary data. In a bitcoin alias system, a custom format mutually agreed upon by a BIP standard would be used to store mappings to bitcoin addresses from domain names. How such a format would look is out of the scope of this document.\n\nAn issue is that it requires people who wish to create such mappings to be familiar with configuring DNS records, and be able to run the necessary toolsets to insert the correct data. Although not a huge concern, it is a usability issue.\n\nSecurity wise, DNS is unsafe and insecure by design. It is possible to spoof records by being on the same network as another host. A number of revisions to mitigate the issue under the guise of DNSSEC have been in the works since the 1990s and are still being rolled out.\n\nAs of Dec 2011, DNSSEC is still not yet a defacto standard on the internet. Should a participant in the bitcoin network wish to use DNS TXT records, they would in addition to having to configure DNS, be able to setup DNSSEC. This may not be feasible, especially where some registrars provide access to DNS through a web interface only.\n\nThe disadvantage of DNS TXT records is that updating a record takes time. This encourages people to not use new addresses per transaction which has certain security issues.\n\n=== Server Service ===\n\nAside from using DNS TXT records, another possibility is using the domain name system to lookup hosts and then contact a service running on a predefined port to get the bitcoin address.\n\n# User wishes to send to foo@bar.net\n# Client uses DNS to find the IP address of bar.net: 123.123.123.123\n# Client connects to port 123.123.123.123:4567 and requests the bitcoin address for the user ''foo''\n# Server responds with the address or error code and terminates the connection.\n# Client sends the funds to the address\n\nThe service would be responsible for providing the mechanisms for changing and storing the mappings on their service. A front-end web interface could be provided to users wishing to use the service and customise their accounts on the server.\n\nThis approach has the positive aspect of providing the best flexibility for the implementer to store the records however they wish in a database or plaintext file, and then serve them up quickly using a small server side daemon typically written in C. This approach is highly scalable.\n\nHowever this approach also suffers the problem of being reliant on DNS and hence also being vulnerable to spoofing. Hence DNSSEC is also required. This approach is slightly better than the DNS TXT records though since it makes inserting new users and modifying aliases very easy which allows people to run these server services more cheaply.\n\n=== HTTPS Web Service ===\n\nHTTPS provides an additional layer of security by encrypting the connection, providing much needed privacy for users. Together with using Certificate Authorities, it fixes the issue with using DNSSEC since an error would be thrown up were someone to try to spoof a domain name on the local network.\n\nWhen trying to send to:\n\n  genjix@foo.org\n\nThe request is broken into the handle (genjix) and domain (foo.org) at the last occurrence of the @. The client then constructs a request that will query for the address.\n\n  https://foo.org/bitcoin-alias/?handle=genjix\n\nbitcoin-alias has been chosen as the query suffix because it allows this system to co-exist easily within another web root without the fear of name clashes.\n\nThe query will then return an address which is used to make the payment.\n\n  1Hd44nkJfNAcPJeZyrGC5sKJS1TzgmCTjjZ\n\nThe details of whether a unique address is returned per query, whether an address is fetched from a pre-existing pool of addresses, and so on is an implementation detail unique to every server. How alias to address mappings are setup is dependent on the site which could have a web-interface and be providing a free service to users or be a private customised service serving pre-existing addresses. This is left up to sysop policy, and deliberately not defined here.\n\nA web service is trivial to setup and the cost is low. There are many free out of the box providers on the net that allows anyone with the most basic knowledge of web technologies to create their own website. By providing users with a package, anybody can quickly set themselves up with a bitcoin alias. It could be something as simple as a PHP script that the user edits with their custom settings and uploads themselves to their website.\n\nIt also scales reasonably- anybody wishing to run a naming service can attach a backend with a variety of database technologies then provide a web frontend for users to customise and create their own aliases.\n\nA naive implementation is provided below as an example.\n\n<pre>\n// resolv.h\n#ifndef NOMRESOLV_H__\n#define NOMRESOLV_H__\n\n#include <string>\n#include \"curl/curl.h\"\n\nusing std::string;\n\n/*\n\nThis class resolves against a server to lookup addresses.\nTo not conflict with the bitcoin addresses, we refer here to people's handles.\nA handle is of the form:\n\n   genjix@foo.org\n\nMost characters are valid for the username + password (and handled accordingly), but the domain follows usual web standards. It is possible to affix a path if needed,\n\n   genjix@bar.com/path/to/\n\n*/\n\nclass NameResolutionService\n{\npublic:\n    NameResolutionService();\n    ~NameResolutionService();\n\n    // Three main methods map to RPC actions.\n    string FetchAddress(const string& strHandle, string& strAddy);\n\nprivate:\n    // A POST block\n    class PostVariables\n    {\n    public:\n        PostVariables();\n        ~PostVariables();\n        // Add a new key, value pair\n        bool Add(const string& strKey, const string& strVal);\n        curl_httppost* operator()() const;\n    private:\n        // CURL stores POST blocks as linked lists.\n        curl_httppost *pBegin, *pEnd;\n    };\n\n    // Explodes user@domain => user, domain\n    static void ExplodeHandle(const string& strHandle, string& strNickname, string& strDomain);\n    // Perform the HTTP request. Returns true on success.\n    bool Perform();\n\n    // CURL error message\n    char pErrorBuffer[CURL_ERROR_SIZE];\n    // CURL response\n    string strBuffer;\n    // CURL handle\n    CURL *curl;\n};\n\n#endif\n</pre>\n\n<pre>\n// resolv.cpp\n#include \"resolv.h\"\n\n#include <boost/lexical_cast.hpp>\n\n#include \"access.h\"\n\n// callback used to write response from the server\nstatic int writer(char *pData, size_t nSize, size_t nNmemb, std::string *pBuffer)\n{\n  int nResult = 0;\n  if (pBuffer != NULL)\n  {\n    pBuffer->append(pData, nSize * nNmemb);\n    // How much did we write?\n    nResult = nSize * nNmemb;\n  }\n  return nResult;\n}\n\nNameResolutionService::NameResolutionService()\n{\n    // Initialise CURL with our various options.\n    curl = curl_easy_init();\n    // This goes first in case of any problems below. We get an error message.\n    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, pErrorBuffer);\n    // fail when server sends >= 404\n    curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n    curl_easy_setopt(curl, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n    curl_easy_setopt(curl, CURLOPT_POSTREDIR, CURL_REDIR_POST_302);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writer);\n    curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1);\n    // server response goes in strBuffer\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &strBuffer);\n    pErrorBuffer[0] = '\\0';\n}\nNameResolutionService::~NameResolutionService()\n{\n    curl_easy_cleanup(curl);\n}\n\nvoid NameResolutionService::ExplodeHandle(const string& strHandle, string& strNickname, string& strDomain)\n{\n    // split address at @ furthest to the right\n    size_t nPosAtsym = strHandle.rfind('@');\n    strNickname = strHandle.substr(0, nPosAtsym);\n    strDomain = strHandle.substr(nPosAtsym + 1, strHandle.size());\n}\nbool NameResolutionService::Perform()\n{\n    // Called after everything has been setup. This actually does the request.\n    CURLcode result = curl_easy_perform(curl);\n    return (result == CURLE_OK);\n}\n\nstring NameResolutionService::FetchAddress(const string& strHandle, string& strAddy)\n{\n    // GET is defined for 'getting' data, so we use GET for the low risk fetching of people's addresses\n    if (!curl)\n        // For some reason CURL didn't start...\n        return pErrorBuffer;\n    // Expand the handle\n    string strNickname, strDomain;\n    ExplodeHandle(strHandle, strNickname, strDomain);\n    // url encode the nickname for get request\n    const char* pszEncodedNick = curl_easy_escape(curl, strNickname.c_str(), strNickname.size());\n    if (!pszEncodedNick)\n        return \"Unable to encode nickname.\";\n    // construct url for GET request\n    string strRequestUrl = strDomain + \"/bitcoin-alias/?handle=\" + pszEncodedNick;\n    // Pass URL to CURL\n    curl_easy_setopt(curl, CURLOPT_URL, strRequestUrl.c_str());\n    if (!Perform())\n        return pErrorBuffer;\n    // Server should respond with a JSON that has the address in.\n    strAddy = strBuffer;\n    return \"\";  // no error\n}\n\nNameResolutionService::PostVariables::PostVariables()\n{\n    // pBegin/pEnd *must* be null before calling curl_formadd\n    pBegin = NULL;\n    pEnd = NULL;\n}\nNameResolutionService::PostVariables::~PostVariables()\n{\n    curl_formfree(pBegin);\n}\nbool NameResolutionService::PostVariables::Add(const string& strKey, const string& strVal)\n{\n    // Copy strings to this block. Return true on success.\n    return curl_formadd(&pBegin, &pEnd, CURLFORM_COPYNAME, strKey.c_str(), CURLFORM_COPYCONTENTS, strVal.c_str(), CURLFORM_END) == CURL_FORMADD_OK;\n}\n\ncurl_httppost* NameResolutionService::PostVariables::operator()() const\n{\n    return pBegin;\n}\n</source>\n\n<source lang=\"cpp\">\n// rpc.cpp\n...\n\nconst Object CheckMaybeThrow(const string& strJsonIn)\n{\n    // Parse input JSON\n    Value valRequest;\n    if (!read_string(strJsonIn, valRequest) || valRequest.type() != obj_type)\n        throw JSONRPCError(-32700, \"Parse error\");\n    const Object& request = valRequest.get_obj();\n    // Now check for a key called \"error\"\n    const Value& error  = find_value(request, \"error\");\n    // It's an error JSON! so propagate the error.\n    if (error.type() != null_type)\n        throw JSONRPCError(-4, error.get_str());\n    // Return JSON object\n    return request;\n}\n\nconst string CollectAddress(const string& strIn)\n{\n    // If the handle does not have an @ in it, then it's a normal base58 bitcoin address\n    if (strIn.find('@') == (size_t)-1)\n        return strIn;\n\n    // Open the lookup service\n    NameResolutionService ns;\n    // We established that the input string is not a BTC address, so we use it as a handle now.\n    string strHandle = strIn, strAddy;\n    string strError = ns.FetchAddress(strHandle, strAddy);\n    if (!strError.empty())\n        throw JSONRPCError(-4, strError);\n\n    const Object& request(CheckMaybeThrow(strAddy));\n    // Get the BTC address from the JSON\n    const Value& address = find_value(request, \"address\");\n    if (address.type() != str_type)\n        throw JSONRPCError(-32600, \"Server responded with malformed reply.\");\n    return address.get_str();\n}\n\n// Named this way to prevent possible conflicts.\nValue rpc_send(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 2)\n        throw runtime_error(\n            \"send <name@domain or address> <amount>\\n\"\n            \"<amount> is a real and is rounded to the nearest 0.01\");\n\n    // Intelligent function which looks up address given handle, or returns address\n    string strAddy = CollectAddress(params[0].get_str());\n    int64 nAmount = AmountFromValue(params[1]);\n    // Do the send\n    CWalletTx wtx;\n    string strError = SendMoneyToBitcoinAddress(strAddy, nAmount, wtx);\n    if (!strError.empty())\n        throw JSONRPCError(-4, strError);\n    return wtx.GetHash().GetHex();\n}\n\n...\n</pre>\n\n=== IP Transactions ===\n\nAn IP transaction is an old transaction format in bitcoin that is disabled and possibly could be deprecated. It involves being given an IP address to make payment to. Upon connecting to the node and requesting their public key using \"checkorder\", they will respond with a script in the form:\n\n  <public key> OP_CHECKSIG\n\nSimilar to coinbase output transactions. IP transactions have the advantage of being able to contain additional metadata which can be useful in many transactions. Currently no authentication is done making the scheme insecure against man in the middle (MITM) attacks.\n\nThis proposal seeks to enable DNS lookups for IP transactions.\n\nThe \"checkorder\" message would contain a destination account, which could map to different isolated sets of keypairs/wallets running under the same host. The exact mapping from the checkorder reference info to the local system is implementation defined.\n\nBy using DNS lookups, the MITM problem with IP transactions could be mitigated by storing a public key in a DNS TXT record. This public key would be used for all future \"reply\" messages originating from that host. First time use would require a confirmation for acceptance of that public key; like with SSH. Should the \"reply\" message not match the accepted public key, then the host will be given an error.\n\n[[Category:BIP|E]]\n\n=== Namecoin ID ===\n\nThis proposal uses the Namecoin blockchain to associate an alias with a bitcoin address. Bitcoin queries a namecoin node. This retrieves the structured data containing the bitcoin address(es) associated with this alias.\n\nUsing a decentralised domain name system like Namecoin, means no external server or entity needs to be trusted unlike the other proposals listed here. This indicates a system with the advantage of having a high availability and ease of entry (no restrictions for users to create aliases).\n\nTwo examples are presented below. The first shows a simpler format, while the second shows several Bitcoin addresses in a structured format.\n\n $ namecoind name_show id/khal\n {\n   \"bitcoin\" : \"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\"\n }\n\n $ namecoind name_show id/khal\n {\n   \"bitcoin\" :\n   {\n     \"default\" : \"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\",\n     \"donation\": \"1J3EKMfboca3SESWGrQKESsG1MA9yK6vN4\"\n   }\n }\n\n'''More possibilities :'''\n\n* Allow to securely use '''unsecured channels'''\nYou can put an url and a bitcoin address that will be used to sign the result. It means that a query to this url will return a bitcoin address and a signature. Bitcoin can then check (with the verify_message function) that the returned address has not been replaced by another one.\n $ namecoind name_show id/khal\n {\n   \"bitcoin\" :\n   {\n     \"url\" : \"http://merchant.com/bitcoin/getnewaddres/\",\n     \"signedWith\" : \"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\"\n   }\n }\n\n* Allow to get a different address each time, or per user, per order, etc\n $ namecoind name_show id/khal\n {\n   \"bitcoin\" :\n   {\n     \"url\" : \"http://merchant.com/bitcoin/getaddres/{Your customer id}\",\n     \"signedWith\" : \"1KHAL8bUjnkMRMg9yd2dNrYnJgZGH8Nj6T\",\n     \"useOnce\": false\n   }\n }\nIn the above example, bitcoin will ask the user for \"Your customer id\" and replace that value in the url before making the http request. The merchant will receive the request and give the user a payment address associated with that customer.\n\nAny text can be put into the brackets, allowing merchants to adapt it to all their needs.\n\n\n* Specification is extensible\n\nNew features can be added later to support uncovered cases.\n\n\nSee the specification of [http://dot-bit.org/Namespace:Identity Namecoin ID] for more information.\n", "content_length": 19183}
{"bip_number": 14, "filename": "bip-0014.mediawiki", "content": "<pre>\n  BIP: 14\n  Layer: Peer Services\n  Title: Protocol Version and User Agent\n  Author: Amir Taaki <genjix@riseup.net>\n          Patrick Strateman <bitcoin-bips@covertinferno.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0014\n  Status: Final\n  Type: Standards Track\n  Created: 2011-11-10\n  Post-History: 2011-11-02\n</pre>\n\nIn this document, bitcoin will be used to refer to the protocol while Satoshi will refer to the current client in order to prevent confusion.\n\n== Past Situation ==\n\nBitcoin as a protocol began life with the Satoshi client. Now that the community is diversifying, a number of alternative clients with their own codebases written in a variety of languages (Java, Python, Javascript, C++) are rapidly developing their own feature-sets.\n\nEmbedded in the protocol is a version number. Primarily this version number is in the \"version\" and \"getblocks\" messages, but is also in the \"block\" message to indicate the software version that created that block. Currently this version number is the same version number as that of the client. This document is a proposal to separate the protocol version from the client version, together with a proposed method to do so.\n\n== Rationale ==\n\nWith non-separated version numbers, every release of the Satoshi client will increase its internal version number. Primarily this holds every other client hostage to a game of catch-up with Satoshi version number schemes. This plays against the decentralised nature of bitcoin, by forcing every software release to remain in step with the release schedule of one group of bitcoin developers.\n\nVersion bumping can also introduce incompatibilities and fracture the network. In order that the health of the network is maintained, the development of the protocol as a shared common collaborative process requires being split off from the implementation of that protocol. Neutral third entities to guide the protocol with representatives from all groups, present the chance for bitcoin to grow in a positive manner with minimal risks.\n\nBy using a protocol version, we set all implementations on the network to a common standard. Everybody is able to agree within their confines what is protocol and what is implementation-dependent. A user agent string is offered as a 'vanity-plate' for clients to distinguish themselves in the network.\n\nSeparation of the network protocol from the implementation, and forming development of said protocol by means of a mutual consensus among participants, has the democratic disadvantage when agreement is hard to reach on contentious issues. To mitigate this issue, strong communication channels and fast release schedules are needed, and are outside the scope of this document (concerning a process-BIP type).\n\nUser agents provide extra tracking information that is useful for keeping tabs on network data such as client implementations used or common architectures/operating-systems. In the rare case they may even provide an emergency method of shunning faulty clients that threaten network health- although this is strongly unrecommended and extremely bad form. The user agent does not provide a method for clients to work around and behave differently to different implementations, as this will lead to protocol fracturing.\n\nIn short:\n\n* Protocol version: way to distinguish between nodes and behave different accordingly.\n* User agent: simple informational tool. Protocol should not be modified depending on user agent.\n\n== Browser User-Agents ==\n\n[http://tools.ietf.org/html/rfc1945 RFC 1945] vaguely specifies a user agent to be a string of the product with optional comments.\n\n  Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.6) Gecko/20100127 Gentoo Shiretoko/3.5.6\n\nUser agents are most often parsed by computers more than humans. The space delimited format, does not provide an easy, fast or efficient way for parsing. The data contains no structure indicating hierarchy in this placement.\n\nThe most immediate pieces of information there are the browser product, rendering engine and the build (Gentoo Shiretoko) together with version number. Various other pieces of information as included as comments such as desktop environment, platform, language and revision number of the build.\n\n== Proposal ==\n\nThe version field in \"version\" and \"getblocks\" packets will become the protocol version number. The version number in the \"blocks\" reflects the protocol version from when that block was created.\n\nThe currently unused sub_version_num field in \"version\" packets will become the new user-agent string.\n\nBitcoin user agents are a modified browser user agent with more structure to aid parsers and provide some coherence. In bitcoin, the software usually works like a stack starting from the core code-base up to the end graphical interface. Therefore the user agent strings codify this relationship.\n\nBasic format:\n\n  /Name:Version/Name:Version/.../\n\nExample:\n\n  /Satoshi:5.64/bitcoin-qt:0.4/\n  /Satoshi:5.12/Spesmilo:0.8/\n\nHere bitcoin-qt and Spesmilo may use protocol version 5.0, however the internal codebase they use are different versions of the same software. The version numbers are not defined to any strict format, although this guide recommends:\n\n* Version numbers in the form of Major.Minor.Revision (2.6.41)\n* Repository builds using a date in the format of YYYYMMDD (20110128)\n\nFor git repository builds, implementations are free to use the git commitish. However the issue lies in that it is not immediately obvious without the repository which version precedes another. For this reason, we lightly recommend dates in the format specified above, although this is by no means a requirement.\n\nOptional -r1, -r2, ... can be appended to user agent version numbers. This is another light recommendation, but not a requirement. Implementations are free to specify version numbers in whatever format needed insofar as it does not include (, ), : or / to interfere with the user agent syntax.\n\nAn optional comments field after the version number is also allowed. Comments should be delimited by brackets (...). The contents of comments is entirely implementation defined although this BIP recommends the use of semi-colons ; as a delimiter between pieces of information.\n\nExample:\n\n  /BitcoinJ:0.2(iPad; U; CPU OS 3_2_1)/AndroidBuild:0.8/\n\nReserved symbols are therefore: / : ( )\n\nThey should not be misused beyond what is specified in this section.\n\n* / separates the code-stack\n* : specifies the implementation version of the particular stack\n* ( and ) delimits a comment which optionally separates data using ;\n\n== Timeline ==\n\nWhen this document was published, the bitcoin protocol and Satoshi client versions were currently at 0.5 and undergoing changes. In order to minimise disruption and allow the undergoing changes to be completed, the next protocol version at 0.6 became peeled from the client version (also at 0.6). As of that time (January 2012), protocol and implementation version numbers are distinct from each other.\n", "content_length": 7046}
{"bip_number": 13, "filename": "bip-0013.mediawiki", "content": "<pre>\n  BIP: 13\n  Layer: Applications\n  Title: Address Format for pay-to-script-hash\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0013\n  Status: Final\n  Type: Standards Track\n  Created: 2011-10-18\n</pre>\n\n==Abstract==\n\nThis BIP describes a new type of Bitcoin address to support arbitrarily complex transactions.  Complexity in this context is defined as what information is needed by the recipient to respend the received coins, in contrast to needing a single ECDSA private key as in current implementations of Bitcoin.\n\nIn essence, an address encoded under this proposal represents the encoded hash of a [https://en.bitcoin.it/wiki/Script script], rather than the encoded hash of an ECDSA public key.\n\n==Motivation==\n\nEnable \"end-to-end\" secure wallets and payments to fund escrow transactions or other complex transactions.  Enable third-party wallet security services.\n\n==Specification==\n\nThe new bitcoin address type is constructed in the same manner as existing bitcoin addresses (see [https://en.bitcoin.it/Base58Check_encoding Base58Check encoding]):\n\n    base58-encode: [one-byte version][20-byte hash][4-byte checksum]\n\nVersion byte is 5 for a main-network address, 196 for a testnet address.\nThe 20-byte hash is the hash of the script that will be used to redeem the coins.\nAnd the 4-byte checksum is the first four bytes of the double SHA256 hash of the version and hash.\n\n==Rationale==\n\nOne criticism is that bitcoin addresses should be deprecated in favor of a more user-friendly mechanism for payments, and that this will just encourage continued use of a poorly designed mechanism.\n\nAnother criticism is that bitcoin addresses are inherently insecure because there is no identity information tied to them; if you only have a bitcoin address, how can you be certain that you're paying who or what you think you're paying?\n\nFurthermore, truncating SHA256 is not an optimal checksum; there are much better error-detecting algorithms. If we are introducing a new form of Bitcoin address, then perhaps a better algorithm should be used.\n\nThis is one piece of the simplest path to a more secure bitcoin infrastructure. It is not intended to solve all of bitcoin's usability or security issues, but to be an incremental improvement over what exists today. A future BIP or BIPs should propose more user-friendly mechanisms for making payments, or for verifying that you're sending a payment to the Free Software Foundation and not Joe Random Hacker.\n\nAssuming that typing in bitcoin addresses manually will become increasingly rare in the future, and given that the existing checksum method for bitcoin addresses seems to work \"well enough\" in practice and has already been implemented multiple times, the Author believes no change to the checksum algorithm is necessary.\n\nThe leading version bytes are chosen so that, after base58 encoding, the leading character is consistent: for the main network, byte 5 becomes the character '3'. For the testnet, byte 196 is encoded into '2'.\n\n==Backwards Compatibility==\n\nThis proposal is not backwards compatible, but it fails gracefully-- if an older implementation is given one of these new bitcoin addresses, it will report the address as invalid and will refuse to create a transaction.\n\n==Reference Implementation==\n\nSee base58.cpp/base58.h at https://github.com/bitcoin/bitcoin/tree/master/src\n\n==See Also==\n\n* [[bip-0012.mediawiki|BIP 12: OP_EVAL, the original P2SH design]]\n* [[bip-0016.mediawiki|BIP 16: Pay to Script Hash (aka \"/P2SH/\")]]\n* [[bip-0017.mediawiki|BIP 17: OP_CHECKHASHVERIFY, another P2SH design]]\n", "content_length": 3681}
{"bip_number": 12, "filename": "bip-0012.mediawiki", "content": "<pre>\n  BIP: 12\n  Layer: Consensus (soft fork)\n  Title: OP_EVAL\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0012\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2011-10-18\n</pre>\n\n==Abstract==\n\nThis BIP describes a new opcode (OP_EVAL) for the [https://en.bitcoin.it/wiki/Script Bitcoin scripting system], and a new 'standard' transaction type that uses it to enables the receiver of bitcoins to specify the transaction type needed to re-spend them.\n\n==Motivation==\n\nEnable \"end-to-end\" secure wallets and payments to fund escrow transactions or other complex transactions in a way that is backwards-compatible for old clients and miners.\n\n==Specification==\n\nOP_EVAL will re-define the existing OP_NOP1 opcode, and will function as follows:\n\n* When executed during transaction verification, pops the item from the top of the stack, deserializes it, and executes the resulting script.\n* If there is no item on the top of the stack or the item is not a valid script then transaction validation fails.\n* If there are any OP_CODESEPARATORs in the deserialized script then transaction validation fails.\n* If there are any OP_EVALs in the deserialized script they are also executed, but recursion is limited to a depth of 2.\n* Transaction verification must fail if interpreting OP_EVAL as a no-op would cause the verification to fail.\n\nA new standard transaction type (scriptPubKey) that is relayed by clients and included in mined blocks is also defined:\n\n    DUP HASH160 {20-byte-hash-value} EQUALVERIFY OP_EVAL\n\nWhich is redeemed by a standard scriptSig:\n    ...signatures... {serialized script}\n\nTransactions that redeem standard OP_EVAL scriptPubKeys are only considered standard if the ''serialized script'' is, itself, one of the standard transaction types.\n\n==Rationale==\n\nOP_EVAL allows the receiver of bitcoins to specify how they can be spent when they are spent, instead of requiring the sender of the bitcoins to know the details of how the bitcoins may be redeemed. The sender only needs to know the hash of the ''serialized script'', and one new type of bitcoin address can be used to fund arbitrarily complex transactions.\n\nIf ''serialized script'' is a large or complicated multi-signature script, then the burden of paying for it (in increased transaction fees due to more signature operations or transaction size) is shifted from the sender to the receiver.\n\nThe main objection to OP_EVAL is that it adds complexity, and complexity is the enemy of security. Also, evaluating data as code has a long record of being a source of security vulnerabilities.\n\nThat same argument can be applied to the existing Bitcoin 'scripting' system; scriptPubKeys are transmit as data across the network and are then interpreted by every bitcoin implementation. OP_EVAL just moves the data that will be interpreted. It is debatable whether or not the entire idea of putting a little interpreted expression evaluation language at the core of Bitcoin was brilliant or stupid, but the existence of OP_EVAL does not make the expression language less secure.\n\nThere is a 1-confirmation attack on old clients that interpret OP_EVAL as a no-op, but it is expensive and difficult in practice. The attack is:\n\n# Attacker creates an OP_EVAL transaction that is valid as seen by old clients, but invalid for new clients.\n# Attacker also creates a standard transaction that spends the OP_EVAL transaction, and pays the victim.\n# Attacker manages to mine a block that contains both transactions. If the victim accepts the 1-confirmation payment, then the attacker wins because both transactions will be invalidated when the rest of the network overwrites the attacker's invalid block.\n\nThe attack is expensive because it requires the attacker create a block that they know will be invalidated. It is difficult because bitcoin businesses should not accept 1-confirmation transactions for higher-value transactions.\n\n==Backwards Compatibility==\n\nSurprisingly, because OP_EVAL redefines the OP_NOP1 opcode, standard OP_EVAL transactions will validate with old clients and miners. They will check only that the ''serialized script'' hashes to the correct value; the OP_EVAL will be interpreted as a no-op, and as long as the hash is correct the transaction will be considered valid (no signature checking will be done by old clients and miners).\n\nOld clients will ignore OP_EVAL transactions and transactions that depend on them until they are put into a block by either an old miner that includes non-standard transactions in its blocks or by a new miner.\n\nAvoiding a block-chain split by malicious OP_EVAL transactions requires careful handling of two cases:\n\n# An OP_EVAL transaction that is invalid for new clients/miners but valid for old clients/miners.\n# An OP_EVAL transaction that is valid for new clients/miners but invalid for old clients/miners.\n\nFor case (1), new clients and miners will be coded to interpret OP_EVAL as a no-op until February 1, 2012. Before then, miners will be asked to put the string \"OP_EVAL\" in blocks that they produce so that hashing power that supports the new opcode can be gauged.  If less than 50% of miners accept the change as of January 15, 2012 the rollout will be postponed until more than 50% of hashing power supports OP_EVAL (the rollout will be rejected if it becomes clear that a majority of hashing power will not be achieved).\n\nFor case (2), new clients and miners will be written to make sure that transactions involving OP_EVAL are valid if OP_EVAL is interpreted as a no-op.\nExample of a transaction that must fail for both old and new miners/clients:\n  scriptSig:  {serialized OP_11}\n  scriptPubKey:  OP_EVAL OP_11 OP_EQUAL\n\n==Reference Implementation==\n\nhttps://github.com/gavinandresen/bitcoin-git/tree/77f21f1583deb89bf3fffe80fe9b181fedb1dd60\n\n==See Also==\n\nhttps://bitcointalk.org/index.php?topic=46538\n\n\"Bitcoin Address 01\" BIP\n\nM-of-N Multisignature Transactions BIP 11\n", "content_length": 6029}
{"bip_number": 11, "filename": "bip-0011.mediawiki", "content": "<pre>\n  BIP: 11\n  Layer: Applications\n  Title: M-of-N Standard Transactions\n  Author: Gavin Andresen <gavinandresen@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0011\n  Status: Final\n  Type: Standards Track\n  Created: 2011-10-18\n  Post-History: 2011-10-02\n</pre>\n\n==Abstract==\n\nThis BIP proposes M-of-N-signatures required transactions as a new 'standard' transaction type.\n\n==Motivation==\n\nEnable secured wallets, escrow transactions, and other use cases where redeeming funds requires more than a single signature.\n\nA couple of motivating use cases:\n\n* A wallet secured by a \"wallet protection service\" (WPS).  2-of-2 signatures required transactions will be used, with one signature coming from the (possibly compromised) computer with the wallet and the second signature coming from the WPS. When sending protected bitcoins, the user's bitcoin client will contact the WPS with the proposed transaction and it can then contact the user for confirmation that they initiated the transaction and that the transaction details are correct. Details for how clients and WPS's communicate are outside the scope of this BIP. Side note: customers should insist that their wallet protection service provide them with copies of the private key(s) used to secure their wallets that they can safely store off-line, so that their coins can be spent even if the WPS goes out of business.\n\n* Three-party escrow (buyer, seller, and trusted dispute agent). 2-of-3 signatures required transactions will be used. The buyer and seller and agent will each provide a public key, and the buyer will then send coins into a 2-of-3 CHECKMULTISIG transaction and send the seller and the agent the transaction id. The seller will fulfill their obligation and then ask the buyer to co-sign a transaction ( already signed by seller ) that sends the tied-up coins to him (seller).<br />If the buyer and seller cannot agree, then the agent can, with the cooperation of either buyer or seller, decide what happens to the tied-up coins.  Details of how buyer, seller, and agent communicate to gather signatures or public keys are outside the scope of this BIP.\n\n==Specification==\n\nA new standard transaction type (scriptPubKey) that is relayed by clients and included in mined blocks:\n\n    m {pubkey}...{pubkey} n OP_CHECKMULTISIG\n\nBut only for n less than or equal to 3.\n\nOP_CHECKMULTISIG transactions are redeemed using a standard scriptSig:\n    OP_0 ...signatures...\n\n(OP_0 is required because of a bug in OP_CHECKMULTISIG; it pops one too many items off the execution stack, so a dummy value must be placed on the stack).\n\nThe current Satoshi bitcoin client does not relay or mine transactions with scriptSigs larger than 200 bytes; to accommodate 3-signature transactions, this will be increased to 500 bytes.\n\n==Rationale==\n\nOP_CHECKMULTISIG is already an enabled opcode, and is the most straightforward way to support several important use cases.\n\nOne argument against using OP_CHECKMULTISIG is that old clients and miners count it as \"20 sigops\" for purposes of computing how many signature operations are in a block, and there is a hard limit of 20,000 sigops per block-- meaning a maximum of 1,000 multisig transactions per block. Creating multisig transactions using multiple OP_CHECKSIG operations allows more of them per block.\n\nThe counter-argument is that these new multi-signature transactions will be used in combination with OP_EVAL (see the OP_EVAL BIP), and '''will''' be counted accurately. And in any case, as transaction volume rises the hard-coded maximum block size will have to be addressed, and the rules for counting number-of-signature-operations-in-a-block can be addressed at that time.\n\nA weaker argument is OP_CHECKMULTISIG should not be used because it pops one too many items off the stack during validation. Adding an extra OP_0 placeholder to the scriptSig adds only 1 byte to the transaction, and any alternative that avoids OP_CHECKMULTISIG adds at least several bytes of opcodes.\n\n==Implementation==\n\nOP_CHECKMULTISIG is already supported by old clients and miners as a non-standard transaction type.\n\nhttps://github.com/gavinandresen/bitcoin-git/tree/77f21f1583deb89bf3fffe80fe9b181fedb1dd60\n\n== Post History ==\n\n* [https://bitcointalk.org/index.php?topic=46538 OP_EVAL proposal]\n", "content_length": 4356}
{"bip_number": 10, "filename": "bip-0010.mediawiki", "content": "<pre>\n  BIP: 10\n  Layer: Applications\n  Title: Multi-Sig Transaction Distribution\n  Author: Alan Reiner <etotheipi@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0010\n  Status: Withdrawn\n  Type: Informational\n  Created: 2011-10-28\n</pre>\n\nA multi-signature transaction is one where a certain number of Bitcoins are \"encumbered\" with more than one recipient address.  The subsequent transaction that spends these coins will require each party involved (or some subset, depending on the script), to see the proposed transaction and sign it with their private key.  This necessarily requires collaboration between all parties -- to propose a distribution of encumbered funds, collect signatures from all necessary participants, and then broadcast the completed transaction.\n\nThis BIP describes a way standardize the encoding of proposal transactions, to assist with signature collection and broadcast (which includes regular, 1-of-1 transactions requiring signatures from an offline computer).  The goal is to encourage a standard that guarantees interoperability of all programs that implement it.\n\n\n==Motivation==\n\nThe enabling of multi-signature transactions in Bitcoin will introduce a great deal of extra functionality to the users of the network, but also a great deal of extra complexity.  Executing a multi-signature tx will be a multi-step process, and will potentially get worse with multiple clients, each implementing this process differently.  By providing an efficient, standardized technique, we can improve the chance that developers will adopt compatible protocols and not bifurcate the user-base based on client selection.\n\nIn addition to providing a general encoding scheme for transaction signing/collection, it does not require the signing device to hold any blockchain information (all information needed for verification and signing is part of the encoding).  This enables the existence of very lightweight devices that can be used for signing since they do not need the blockchain -- only a minimal set of Bitcoin tools and an ECDSA module.  Therefore, BIP 0010 has benefit beyond just multi-signature transactions.\n\n==Specification==\n\nThis BIP proposes the following process, with terms in quotes referring to recommended terminology that should be encouraged across all implementations.\n\n#  One party will initiate this process by creating a \"Distribution Proposal\", which could be abbreviated DP, or TxDP\n#  The user creating the TxDP (the preparer) will create the transaction as they would like to see it spent, but with blank TxIn scripts (where the signatures scripts will eventually go).\n#  The proposed transaction will be spending a set of unspent TxOuts available in the blockchain.  The full transactions containing these TxOuts will be serialized and included, as well.  This so that the values of the TxIns can be verified before signing (the prev-tx-hash is part of the data being signed, but the value is not).  By including the full tx, the signing party can verify that the tx matches the OutPoint hash, and then verify input values, all without any access to the blockchain.\n#  The TxDP will have an \"DP ID\" or \"Unsigned ID\" which is the hash of the proposed transaction with blanked scripts, in Base58.  This is a specific naming convention to make sure it is not confused with the actual transaction ID that it will have after it is broadcast (the transaction ID cannot be determined until after all signatures are collected).  The final Tx ID can be referred to as its \"Broadcast ID\", in order to distinguish it from the pre-signed ID.\n#  The TxDP will have a potentially-unordered list of sig-pubkey pairs which represent collected signatures.  If you receive a TxDP missing only your signature, you can broadcast it as soon as you sign it.\n#  Identical TxDP objects with different signatures can be easily combined.  This allows one party to send out all the requests for signatures at once, and combine them all when they are received (instead of having to \"pass it around\".\n#  For cases where the TxDP might be put into a file or sent via email, it should use .txdp or .btcdp suffix\n\nAnyone adopting BIP 0010 for multi-sig transactions will use the following format (without indentation):\n\n<pre>\n '-----BEGIN-TRANSACTION-TXDPID-------'\n (\"_TXDIST_\") (magicBytes) (base58Txid) (varIntTxSize)\n    (serializedTxListInHex_Line1)\n    (serializedTxListInHex_Line2)\n    (serializedTxListInHex_Line3)\n    ...\n (\"_TXINPUT_\") (00) (InputValue)\n    (\"_SIG_\") (AddrBase58) (SigBytes) (SigHexPart0)\n    (SigHexRemainingLines)\n    (\"_SIG_\") (AddrBase58) (SigBytes) (SigHexPart0)\n    (SigHexRemainingLines)\n (\"_TXINPUT_\") (01) (InputValue)\n    (\"_SIG_\") (AddrBase58) (SigBytes) (SigHexPart0)\n    (SigHexRemainingLines)\n (\"_TXINPUT_\") (02) (InputValue)\n '-------END-TRANSACTION-TXDPID-------'\n</pre>\n\nThe following is an example TxDP from Armory, produced while running on the test network.  Its DPID is 3fX59xPj:\n\n</pre>\n -----BEGIN-TRANSACTION-3fX59xPj-------------------------------------------------\n _TXDIST_fabfb5da_3fX59xPj_00a0\n 010000000292807c8e70a28c687daea2998d6273d074e56fa8a55a0b10556974cf2b526e61000000\n 0000ffffffffe3c1ee0711611b01af3dee55b1484f0d6b65d17dce4eff0e6e06242e6cf457e10000\n 000000ffffffff02b0feea0b000000001976a91457996661391fa4e95bed27d7e8fe47f47cb8e428\n 88ac00a0acb9030000001976a914dc504e07b1107110f601fb679dd3f56cee9ff71e88ac00000000\n 0100000001eb626e4f73d88f415a8e8cb32b8d73eed47aa1039d0ed2f013abdc741ce6828c010000\n 008c493046022100b0da540e4924518f8989a9da798ca2d9e761b69a173b8cc41a3e3e3c6d77cd50\n 022100ecfa61730e58005338420516744ef680428dcfc05022dec70a851365c8575b190141042dc5\n be3afa5887aee4a377032ed014361b0b9b61eb3ea6b8a8821bfe13ee4b65cd25d9630e4f227a53e8\n bf637f85452c9981bcbd64ef77e22ce97b0f547c783effffffff0200d6117e030000001976a914cf\n f580fd243f64f0ad7bf69faf41c0bf42d86d8988ac00205fa0120000001976a9148d573ef6984fd9\n f8847d420001f7ac49b222a24988ac000000000100000001f2782db40ae147398a31cff9c7cc3423\n 014a073a92e463741244330cc304168f000000008c493046022100c9311b9eef0cc69219cb96838f\n dd621530a80c46269a00dccc66498bc03ccf7a0221003742ee652a0a76fd28ad81aa73bb7f7a0a6a\n 81850af58f62d9a184d10e5eec30014104f815e8ef4cad584e04974889d7636e8933803d2e72991d\n b5288c9e953c2465533905f98b7b688898c7c1f0708f2e49f0dd0abc06859ffed5144e8a1018a4e8\n 63ffffffff02008c8647000000001976a914d4e211215967f8e3744693bf85f47eb4ee9567fc88ac\n 603d4e95010000001976a914e9a6b50901c1969d2b0fd43a3ccfa3fef3291efe88ac00000000\n _TXINPUT_00_150.00000000\n _SIG_mzUYGfqGpyXmppYpmWJ31Y4zTxR4ZCod22_00_008c\n 4930460221007699967c3ec09d072599558d2e7082fae0820206b63aa66afea124634ed11a080221\n 0003346f7e963e645ecae2855026dc7332eb7237012539b34cd441c3cef97fbd4d01410497d5e1a0\n 0e1db90e893d1f2e547e2ee83b5d6bf4ddaa3d514e6dc2d94b6bcb5a72be1fcec766b8c382502caa\n 9ec09fe478bad07d3f38ff47b2eb42e681c384cc\n _TXINPUT_01_12.00000000\n _SIG_mzvaN8JUhHLz3Gdec1zBRxs5rNaYLQnbD1_01_008c\n 49304602210081554f8b08a1ad8caa69e34f4794d54952dac7c5efcf2afe080985d6bd5b00770221\n 00dea20ca3dbae1d15ec61bec57b4b8062e7d7c47614aba032c5a32f651f471cfd014104c30936d2\n 456298a566aa76fefeab8a7cb7a91e8a936a11757c911b4c669f0434d12ab0936fc13986b156156f\n 9b389ed244bbb580112be07dbe23949a4764dffb\n -------END-TRANSACTION-3fX59xPj-------------------------------------------------\n</pre>\n\nIn this transaction, there are two inputs, one of 150 BTC and the other of 12 BTC.  This transaction combines 162 BTC to create two outputs, one of 160 BTC, one 1.9995 BTC, and a tx fee of 0.0005.  In this TxDP, both inputs have been signed, and thus could broadcast immediately.\n\nThe style of communication is taken directly from PGP/GPG, which uses blocks of ASCII like this to communicate encrypted messages and signatures.  This serialization is compact, and will be interpreted the same in all character encodings.  It can be copied inline into an email, or saved in a text file.  The advantage over the analogous PGP encoding is that there are some human readable elements to it, for users that wish to examine the TxDP packet manually, instead of requiring a program to parse the core elements of the TxDP.\n\nA party receiving this TxDP can simply add their signature to the appropriate _TXINPUT_ line.  If that is the last signature required, they can broadcast it themselves.  Any software that implements this standard should be able to combine multiple TxDPs into a single TxDP.  However, even without the programmatic support, a user could manually combine them by copying the appropriate _SIG_ lines between serializations, though it is not the recommended method for combining TxDPs.\n\n== Reference Implementation ==\n\nThis proposal was implemented and tested in the older versions of ''Armory'' Bitcoin software for use in offline-wallet transaction signing (as a 1-of-1 transaction). Implementation can be found in https://github.com/etotheipi/BitcoinArmory/blob/v0.91-beta/armoryengine/Transaction.py under the class PyTxDistProposal. However, as of version 0.92 released in July 2014, Armory no longer uses this proposal for offline wallet transaction signing and has moved on to a new format.\n", "content_length": 9148}
{"bip_number": 9, "filename": "bip-0009.mediawiki", "content": "<pre>\n  BIP: 9\n  Title: Version bits with timeout and delay\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Peter Todd <pete@petertodd.org>\n          Greg Maxwell <greg@xiph.org>\n          Rusty Russell <rusty@rustcorp.com.au>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0009\n  Status: Final\n  Type: Informational\n  Created: 2015-10-04\n  License: PD\n</pre>\n\n==Abstract==\n\nThis document specifies a proposed change to the semantics of the 'version' field in Bitcoin blocks, allowing multiple backward-compatible changes (further called \"soft forks\") to be deployed in parallel. It relies on interpreting the version field as a bit vector, where each bit can be used to track an independent change. These are tallied each retarget period. Once the consensus change succeeds or times out, there is a \"fallow\" pause after which the bit can be reused for later changes.\n\n==Motivation==\n\n[[bip-0034.mediawiki|BIP 34]] introduced a mechanism for doing soft-forking changes without a predefined flag timestamp (or flag block height), instead relying on measuring miner support indicated by a higher version number in block headers. As it relies on comparing version numbers as integers however, it only supports one single change being rolled out at once, requiring coordination between proposals, and does not allow for permanent rejection: as long as one soft fork is not fully rolled out, no future one can be scheduled.\n\nIn addition, BIP 34 made the integer comparison (nVersion >= 2) a consensus rule after its 95% threshold was reached, removing 2<sup>31</sup>+2 values from the set of valid version numbers (all negative numbers, as nVersion is interpreted as a signed integer, as well as 0 and 1). This indicates another downside this approach: every upgrade permanently restricts the set of allowed nVersion field values. This approach was later reused in [[bip-0066.mediawiki|BIP 66]] and [[bip-0065.mediawiki|BIP 65]], which further removed nVersions 2 and 3 as valid options. As will be shown further, this is unnecessary.\n\n==Specification==\n\nEach soft fork deployment is specified by the following per-chain parameters (further elaborated below):\n\n# The '''name''' specifies a very brief description of the soft fork, reasonable for use as an identifier. For deployments described in a single BIP, it is recommended to use the name \"bipN\" where N is the appropriate BIP number.\n# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,28}.\n# The '''starttime''' specifies a minimum median time past of a block at which the bit gains its meaning.\n# The '''timeout''' specifies a time at which the deployment is considered failed. If the median time past of a block >= timeout and the soft fork has not yet locked in (including this block's bit state), the deployment is considered failed on all descendants of the block.\n\n===Selection guidelines===\n\nThe following guidelines are suggested for selecting these parameters for a soft fork:\n\n# '''name''' should be selected such that no two softforks, concurrent or otherwise, ever use the same name.\n# '''bit''' should be selected such that no two concurrent softforks use the same bit.\n# '''starttime''' should be set to some date in the future, approximately one month after a software release date including the soft fork.  This allows for some release delays, while preventing triggers as a result of parties running pre-release software.\n# '''timeout''' should be 1 year (31536000 seconds) after starttime.\n\nA later deployment using the same bit is possible as long as the starttime is after the previous one's\ntimeout or activation, but it is discouraged until necessary, and even then recommended to have a pause in between to detect buggy software.\n\n===States===\n\nWith each block and soft fork, we associate a deployment state. The possible states are:\n\n# '''DEFINED''' is the first state that each soft fork starts out as. The genesis block is by definition in this state for each deployment.\n# '''STARTED''' for blocks past the starttime.\n# '''LOCKED_IN''' for one retarget period after the first retarget period with STARTED blocks of which at least threshold have the associated bit set in nVersion.\n# '''ACTIVE''' for all blocks after the LOCKED_IN retarget period.\n# '''FAILED''' for one retarget period past the timeout time, if LOCKED_IN was not reached.\n\n===Bit flags===\n\nThe nVersion block header field is to be interpreted as a 32-bit little-endian integer (as present), and bits are selected within this integer as values (1 << N) where N is the bit number.\n\nBlocks in the STARTED state get an nVersion whose bit position bit is set to 1. The top 3 bits of such blocks must be\n001, so the range of actually possible nVersion values is [0x20000000...0x3FFFFFFF], inclusive.\n\nDue to the constraints set by BIP 34, BIP 66 and BIP 65, we only have 0x7FFFFFFB possible nVersion values available.\nThis restricts us to at most 30 independent deployments. By restricting the top 3 bits to 001 we get 29 out of those\nfor the purposes of this proposal, and support two future upgrades for different mechanisms (top bits 010 and 011).\nWhen a block nVersion does not have top bits 001, it is treated as if all\nbits are 0 for the purposes of deployments.\n\nMiners should continue setting the bit in LOCKED_IN phase so uptake is visible, though this has no effect on\nconsensus rules.\n\n===New consensus rules===\n\nThe new consensus rules for each soft fork are enforced for each block that has ACTIVE state.\n\n===State transitions===\n\n<img src=\"bip-0009/states.png\" align=\"middle\"></img>\n\nThe genesis block has state DEFINED for each deployment, by definition.\n\n    State GetStateForBlock(block) {\n        if (block.height == 0) {\n            return DEFINED;\n        }\n\nAll blocks within a retarget period have the same state. This means that if\nfloor(block1.height / 2016) = floor(block2.height / 2016), they are guaranteed to have the same state for every\ndeployment.\n\n        if ((block.height % 2016) != 0) {\n            return GetStateForBlock(block.parent);\n        }\n\nOtherwise, the next state depends on the previous state:\n\n        switch (GetStateForBlock(GetAncestorAtHeight(block, block.height - 2016))) {\n\nWe remain in the initial state until either we pass the start time or the timeout. GetMedianTimePast in the code below\nrefers to the median nTime of a block and its 10 predecessors. The expression GetMedianTimePast(block.parent) is\nreferred to as MTP in the diagram above, and is treated as a monotonic clock defined by the chain.\n\n        case DEFINED:\n            if (GetMedianTimePast(block.parent) >= timeout) {\n                return FAILED;\n            }\n            if (GetMedianTimePast(block.parent) >= starttime) {\n                return STARTED;\n            }\n            return DEFINED;\n\nAfter a period in the STARTED state, if we're past the timeout, we switch to FAILED. If not, we tally the bits set,\nand transition to LOCKED_IN if a sufficient number of blocks in the past period set the deployment bit in their\nversion numbers. The threshold is \u22651916 blocks (95% of 2016), or \u22651512 for testnet (75% of 2016).\nThe transition to FAILED takes precedence, as otherwise an ambiguity can arise.\nThere could be two non-overlapping deployments on the same bit, where the first one transitions to LOCKED_IN while the\nother one simultaneously transitions to STARTED, which would mean both would demand setting the bit.\n\nNote that a block's state never depends on its own nVersion; only on that of its ancestors.\n\n        case STARTED:\n            if (GetMedianTimePast(block.parent) >= timeout) {\n                return FAILED;\n            }\n            int count = 0;\n            walk = block;\n            for (i = 0; i < 2016; i++) {\n                walk = walk.parent;\n                if (walk.nVersion & 0xE0000000 == 0x20000000 && (walk.nVersion >> bit) & 1 == 1) {\n                    count++;\n                }\n            }\n            if (count >= threshold) {\n                return LOCKED_IN;\n            }\n            return STARTED;\n\nAfter a retarget period of LOCKED_IN, we automatically transition to ACTIVE.\n\n        case LOCKED_IN:\n            return ACTIVE;\n\nAnd ACTIVE and FAILED are terminal states, which a deployment stays in once they're reached.\n\n        case ACTIVE:\n            return ACTIVE;\n\n        case FAILED:\n            return FAILED;\n        }\n    }\n\n'''Implementation'''\nIt should be noted that the states are maintained along block chain\nbranches, but may need recomputation when a reorganization happens.\n\nGiven that the state for a specific block/deployment combination is completely determined by its ancestry before the\ncurrent retarget period (i.e. up to and including its ancestor with height block.height - 1 - (block.height % 2016)),\nit is possible to implement the mechanism above efficiently and safely by caching the resulting state of every multiple-of-2016\nblock, indexed by its parent.\n\n===Warning mechanism===\n\nTo support upgrade warnings, an extra \"unknown upgrade\" is tracked, using the \"implicit bit\" mask = (block.nVersion & ~expectedVersion) != 0. Mask will be non-zero whenever an unexpected bit is set in nVersion.  Whenever LOCKED_IN for the unknown upgrade is detected, the software should warn loudly about the upcoming soft fork. It should warn even more loudly after the next retarget period (when the unknown upgrade is in the ACTIVE state).\n\n===getblocktemplate changes===\n\nThe template request Object is extended to include a new item:\n\n{| class=\"wikitable\"\n!colspan=4| template request\n|-\n! Key !! Required !! Type !! Description\n|-\n| rules || No || Array of Strings || list of supported softfork deployments, by name\n|}\n\nThe template Object is also extended:\n\n{| class=\"wikitable\"\n!colspan=4| template\n|-\n! Key !! Required !! Type !! Description\n|-\n| rules || Yes || Array of Strings || list of softfork deployments, by name, that are active state\n|-\n| vbavailable || Yes || Object || set of pending, supported softfork deployments; each uses the softfork name as the key, and the softfork bit as its value\n|-\n| vbrequired || No || Number || bit mask of softfork deployment version bits the server requires enabled in submissions\n|}\n\nThe \"version\" key of the template is retained, and used to indicate the server's preference of deployments.\nIf versionbits is being used, \"version\" MUST be within the versionbits range of [0x20000000...0x3FFFFFFF].\nMiners MAY clear or set bits in the block version WITHOUT any special \"mutable\" key, provided they are listed among the template's \"vbavailable\" and (when clearing is desired) NOT included as a bit in \"vbrequired\".\n\nSoftfork deployment names listed in \"rules\" or as keys in \"vbavailable\" may be prefixed by a '!' character.\nWithout this prefix, GBT clients may assume the rule will not impact usage of the template as-is; typical examples of this would be when previously valid transactions cease to be valid, such as BIPs [[bip-0016.mediawiki|16]], [[bip-0065.mediawiki|65]], [[bip-0066.mediawiki|66]], [[bip-0068.mediawiki|68]], [[bip-0112.mediawiki|112]], and [[bip-0113.mediawiki|113]].\nIf a client does not understand a rule without the prefix, it may use it unmodified for mining.\nOn the other hand, when this prefix is used, it indicates a more subtle change to the block structure or generation transaction; examples of this would be [[bip-0034.mediawiki|BIP 34]] (because it modifies coinbase construction) and [[bip-0141.mediawiki|141]] (since it modifies the txid hashing and adds a commitment to the generation transaction).\nA client that does not understand a rule prefixed by '!' must not attempt to process the template, and must not attempt to use it for mining even unmodified.\n\n==Support for future changes==\n\nThe mechanism described above is very generic, and variations are possible for future soft forks. Here are some ideas that can be taken into account.\n\n'''Modified thresholds'''\nThe 1916 threshold (based on BIP 34's 95%) does not have to be maintained for eternity, but changes should take the effect on the warning system into account. In particular, having a lock-in threshold that is incompatible with the one used for the warning system may have long-term effects, as the warning system cannot rely on a permanently detectable condition anymore.\n\n'''Conflicting soft forks'''\nAt some point, two mutually exclusive soft forks may be proposed. The naive way to deal with this is to never create software that implements both, but that is making a bet that at least one side is guaranteed to lose. Better would be to encode \"soft fork X cannot be locked-in\" as consensus rule for the conflicting soft fork - allowing software that supports both, but can never trigger conflicting changes.\n\n'''Multi-stage soft forks'''\nSoft forks right now are typically treated as booleans: they go from an inactive to an active state in blocks. Perhaps at some point there is demand for a change that has a larger number of stages, with additional validation rules that get enabled one by one. The above mechanism can be adapted to support this, by interpreting a combination of bits as an integer, rather than as isolated bits. The warning system is compatible with this, as (nVersion & ~nExpectedVersion) will always be non-zero for increasing integers.\n\n== Rationale ==\n\nThe failure timeout allows eventual reuse of bits even if a soft fork was\nnever activated, so it's clear that the new use of the bit refers to a\nnew BIP.  It's deliberately very coarse-grained, to take into account\nreasonable development and deployment delays.  There are unlikely to be\nenough failed proposals to cause a bit shortage.\n\nThe fallow period at the conclusion of a soft fork attempt allows some\ndetection of buggy clients, and allows time for warnings and software\nupgrades for successful soft forks.\n\n==Deployments==\n\nA living list of deployment proposals can be found [[bip-0009/assignments.mediawiki|here]].\n\n==Copyright==\n\nThis document is placed in the public domain.\n", "content_length": 14154}
{"bip_number": 8, "filename": "bip-0008.mediawiki", "content": "<pre>\n  BIP: 8\n  Title: Version bits with lock-in by height\n  Author: Shaolin Fry <shaolinfry@protonmail.ch>\n          Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0008\n  Status: Draft\n  Type: Informational\n  Created: 2017-02-01\n  License: BSD-3-Clause\n           CC0-1.0\n</pre>\n\n==Abstract==\n\nThis document specifies an alternative to [[bip-0009.mediawiki|BIP9]] that corrects for a number of perceived mistakes.\nBlock heights are used for start and timeout rather than POSIX timestamps.\nIt additionally introduces an activation parameter that can guarantee activation of backward-compatible changes (further called \"soft forks\").\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n\n==Motivation==\n\nBIP9 introduced a mechanism for doing parallel soft forking deployments based on repurposing the block nVersion field. Activation is dependent on near unanimous hashrate signalling which may be impractical and result in veto by a small minority of non-signalling hashrate. Super majority hashrate based activation triggers allow for accelerated activation where the majority hash power enforces the new rules in lieu of full nodes upgrading. Since all consensus rules are ultimately enforced by full nodes, eventually any new soft fork will be enforced by the economy. This proposal combines these two aspects to provide optional flag day activation after a reasonable time, as well as for accelerated activation by majority of hash rate before the flag date.\n\nDue to using timestamps rather than block heights, it was found to be a risk that a sudden loss of significant hashrate could interfere with a late activation.\n\nBlock time is somewhat unreliable and may be intentionally or unintentionally inaccurate, so thresholds based on block time are not ideal. Secondly, BIP9 specified triggers based on the first retarget after a given time, which is non-intuitive. Since each new block must increase the height by one, thresholds based on block height are much more reliable and intuitive and can be calculated exactly for difficulty retarget.\n\n==Specification==\n\n===Parameters===\n\nEach soft fork deployment is specified by the following per-chain parameters (further elaborated below):\n\n# The '''name''' specifies a very brief description of the soft fork, reasonable for use as an identifier.\n# The '''bit''' determines which bit in the nVersion field of the block is to be used to signal the soft fork lock-in and activation. It is chosen from the set {0,1,2,...,28}.\n# The '''startheight''' specifies the height of the first block at which the bit gains its meaning.\n# The '''timeoutheight''' specifies a block height at which the miner signalling ends. Once this height has been reached, if the soft fork has not yet locked in (excluding this block's bit state), the deployment is considered failed on all descendants of the block.\n# The '''threshold''' specifies the minimum number of block per retarget period which indicate lock-in of the soft fork during the subsequent period.\n# The '''minimum_activation_height''' specifies the height of the first block at which the soft fork is allowed to become active.\n# The '''lockinontimeout''' boolean if set to true, blocks are required to signal in the final period, ensuring the soft fork has locked in by timeoutheight.\n\n===Selection guidelines===\n\nThe following guidelines are suggested for selecting these parameters for a soft fork:\n\n# '''name''' should be selected such that no two softforks, concurrent or otherwise, ever use the same name. For deployments described in a single BIP, it is recommended to use the name \"bipN\" where N is the appropriate BIP number.\n# '''bit''' should be selected such that no two concurrent softforks use the same bit. The bit chosen should not overlap with active usage (legitimately or otherwise) for other purposes.\n# '''startheight''' should be set to some block height in the future. If '''minimum_activation_height''' is not going to be set, then '''startheight''' should be set to a height when a majority of economic activity is expected to have upgraded to software including the activation parameters. Some allowance should be made for potential release delays. If '''minimum_activation_height''' is going to be set, then '''startheight''' can be set to be soon after software with parameters is expected to be released. This shifts the time for upgrading from before signaling begins to during the LOCKED_IN state.\n# '''timeoutheight''' should be set to a block height when it is considered reasonable to expect the entire economy to have upgraded by, probably at least 1 year, or 52416 blocks (26 retarget intervals) after '''startheight'''.\n# '''threshold''' should be 1815 blocks (90% of 2016), or 1512 (75%) for testnet.\n# '''minimum_activation_height''' should be set to several retarget periods in the future if the '''startheight''' is to be very soon after software with parameters is expected to be released. '''minimum_activation_height''' should be set to a height when a majority of economic activity is expected to have upgraded to software including the activation parameters. This allows more time to be spent in the LOCKED_IN state so that nodes can upgrade. This may be set to 0 to have the LOCKED_IN state be a single retarget period.\n# '''lockinontimeout''' should be set to true for any softfork that is expected or found to have political opposition from a non-negligible percent of miners. (It can be set after the initial deployment, but cannot be cleared once set.)\n\nA later deployment using the same bit is possible as long as the startheight is after the previous one's\ntimeoutheight or activation, but it is discouraged until necessary, and even then recommended to have a pause in between to detect buggy software.\n\n'''startheight''', '''timeoutheight''', and '''minimum_activation_height''' must be an exact multiple of 2016 (ie, at a retarget boundary), and '''timeoutheight''' must be at least 4032 blocks (2 retarget intervals) after '''startheight'''.\n\n===States===\n\nWith each block and soft fork, we associate a deployment state. The possible states are:\n\n# '''DEFINED''' is the first state that each soft fork starts out as. The genesis block is by definition in this state for each deployment.\n# '''STARTED''' for blocks at or beyond the startheight.\n# '''MUST_SIGNAL''' for one retarget period prior to the timeout, if LOCKED_IN was not reached and '''lockinontimeout''' is true.\n# '''LOCKED_IN''' for at least one retarget period after the first retarget period with STARTED (or MUST_SIGNAL) blocks of which at least threshold have the associated bit set in nVersion. A soft fork remains in LOCKED_IN until at least '''minimum_activation_height''' is reached.\n# '''ACTIVE''' for all blocks after the LOCKED_IN state.\n# '''FAILED''' for all blocks after the timeoutheight if LOCKED_IN is not reached.\n\n===Bit flags===\n\nThe nVersion block header field is to be interpreted as a 32-bit little-endian integer (as present), and bits are selected within this integer as values (1 << N) where N is the bit number.\n\nBlocks in the STARTED state get an nVersion whose bit position bit is set to 1. The top 3 bits of such blocks must be\n001, so the range of actually possible nVersion values is [0x20000000...0x3FFFFFFF], inclusive.\n\nDue to the constraints set by BIP 34, BIP 66 and BIP 65, we only have 0x7FFFFFFB possible nVersion values available.\nThis restricts us to at most 30 independent deployments. By restricting the top 3 bits to 001 we get 29 out of those\nfor the purposes of this proposal, and support two future upgrades for different mechanisms (top bits 010 and 011).\nWhen a block nVersion does not have top bits 001, it is treated as if all\nbits are 0 for the purposes of deployments.\n\nMiners should continue setting the bit in LOCKED_IN phase so uptake is visible, though this has no effect on consensus rules.\n\n===New consensus rules===\n\nThe new consensus rules for each soft fork are enforced for each block that has ACTIVE state.\n\nDuring the MUST_SIGNAL phase, if '''(2016 - threshold)''' blocks in the retarget period have already failed to signal, any further blocks that fail to signal are invalid.\n\n===State transitions===\n\n<img src=\"bip-0008/states.png\" align=\"middle\"></img>\n\nNote that when '''lockinontimeout''' is true, the LOCKED_IN state will be reached no later than at a height of '''timeoutheight'''.\nRegardless of the value of '''lockinontimeout''', if LOCKED_IN is reached, ACTIVE will be reached either one retarget period later, or at '''minimum_activation_height''', whichever comes later.\n\nThe genesis block has state DEFINED for each deployment, by definition.\n\n    State GetStateForBlock(block) {\n        if (block.height == 0) {\n            return DEFINED;\n        }\n\nAll blocks within a retarget period have the same state. This means that if\nfloor(block1.height / 2016) = floor(block2.height / 2016), they are guaranteed to have the same state for every\ndeployment.\n\n        if ((block.height % 2016) != 0) {\n            return GetStateForBlock(block.parent);\n        }\n\nOtherwise, the next state depends on the previous state:\n\n        switch (GetStateForBlock(GetAncestorAtHeight(block, block.height - 2016))) {\n\nWe remain in the initial state until we reach the start block height.\n\n        case DEFINED:\n            if (block.height >= startheight) {\n                return STARTED;\n            }\n            return DEFINED;\n\nAfter a period in the STARTED state, we tally the bits set,\nand transition to LOCKED_IN if a sufficient number of blocks in the past period set the deployment bit in their\nversion numbers.\nIf the threshold hasn't been met, lockinontimeout is true, and we are at the last period before the timeout, then we transition to MUST_SIGNAL.\nIf the threshold hasn't been met and we reach the timeout, we transition directly to FAILED.\n\nNote that a block's state never depends on its own nVersion; only on that of its ancestors.\n\n        case STARTED:\n            int count = 0;\n            walk = block;\n            for (i = 0; i < 2016; i++) {\n                walk = walk.parent;\n                if (walk.nVersion & 0xE0000000 == 0x20000000 && (walk.nVersion >> bit) & 1 == 1) {\n                    ++count;\n                }\n            }\n            if (count >= threshold) {\n                return LOCKED_IN;\n            } else if (lockinontimeout && block.height + 2016 >= timeoutheight) {\n                return MUST_SIGNAL;\n            } else if (block.height >= timeoutheight) {\n                return FAILED;\n            }\n            return STARTED;\n\nIf we have finished a period of MUST_SIGNAL, we transition directly to LOCKED_IN.\n\n        case MUST_SIGNAL:\n            return LOCKED_IN;\n\nAfter at least one retarget period of LOCKED_IN, we automatically transition to ACTIVE if the minimum activation height is reached. Otherwise LOCKED_IN continues.\n\n        case LOCKED_IN:\n            if (block.height >= minimum_activation_height) {\n                return ACTIVE;\n            } else {\n                return LOCKED_IN;\n            }\n\nAnd ACTIVE and FAILED are terminal states, which a deployment stays in once they're reached.\n\n        case ACTIVE:\n            return ACTIVE;\n\n        case FAILED:\n            return FAILED;\n        }\n    }\n\n'''Implementation'''\nIt should be noted that the states are maintained along block chain\nbranches, but may need recomputation when a reorganization happens.\n\nGiven that the state for a specific block/deployment combination is completely determined by its ancestry before the\ncurrent retarget period (i.e. up to and including its ancestor with height block.height - 1 - (block.height % 2016)),\nit is possible to implement the mechanism above efficiently and safely by caching the resulting state of every multiple-of-2016\nblock, indexed by its parent.\n\n===Mandatory signalling===\n\nBlocks received while in the MUST_SIGNAL phase must be checked to ensure that they signal as required. For example:\n\n    if (GetStateForBlock(block) == MUST_SIGNAL) {\n        int nonsignal = 0;\n        walk = block;\n        while (true) {\n            if ((walk.nVersion & 0xE0000000) != 0x20000000 || ((walk.nVersion >> bit) & 1) != 1) {\n                ++nonsignal;\n                if (nonsignal > 2016 - threshold) {\n                    return state.Invalid(BlockValidationResult::RECENT_CONSENSUS_CHANGE, \"bad-version-bip8-must-signal\");\n                }\n            }\n            if (walk.nHeight % 2016 == 0) {\n                // checked every block in this retarget period\n                break;\n            }\n            walk = walk.parent;\n        }\n    }\n\nImplementations should be careful not to ban peers that send blocks that are invalid due to not signalling (or blocks that build on those blocks), as that would allow an incompatible chain that is only briefly longer than the compliant chain to cause a split of the p2p network. If that occurred, nodes that have not set ''lockinontimeout'' may not see new blocks in the compliant chain, and thus not reorg to it at the point when it has more work, and would thus not be following the valid chain with the most work.\n\nImplementations with ''lockinontimeout'' set to true may potentially follow a lower work chain than nodes with ''lockinontimeout'' set to false for an extended period. In order for this not to result in a net split nodes with ''lockinontimeout'' set to true, those nodes may need to preferentially connect to each other. Deployments proposing that implementations set ''lockinontimeout'' to true should either use parameters that do not risk there being a higher work alternative chain, or specify a mechanism for implementations that support the deployment to preferentially peer with each other.\n\n===Warning mechanism===\n\nTo support upgrade warnings, an extra \"unknown upgrade\" is tracked, using the \"implicit bit\" mask = (block.nVersion & ~expectedVersion) != 0. Mask will be non-zero whenever an unexpected bit is set in nVersion.  Whenever LOCKED_IN for the unknown upgrade is detected, the software should warn loudly about the upcoming soft fork. It should warn even more loudly after the next retarget period (when the unknown upgrade is in the ACTIVE state).\n\n===getblocktemplate changes===\n\nThe template request Object is extended to include a new item:\n\n{| class=\"wikitable\"\n!colspan=4| template request\n|-\n! Key !! Required !! Type !! Description\n|-\n| rules || No || Array of Strings || list of supported softfork deployments, by name\n|}\n\nThe template Object is also extended:\n\n{| class=\"wikitable\"\n!colspan=4| template\n|-\n! Key !! Required !! Type !! Description\n|-\n| rules || Yes || Array of Strings || list of softfork deployments, by name, that are active state\n|-\n| vbavailable || Yes || Object || set of pending, supported softfork deployments; each uses the softfork name as the key, and the softfork bit as its value\n|-\n| vbrequired || No || Number || bit mask of softfork deployment version bits the server requires enabled in submissions\n|}\n\nThe \"version\" key of the template is retained, and used to indicate the server's preference of deployments.\nIf versionbits is being used, \"version\" MUST be within the versionbits range of [0x20000000...0x3FFFFFFF].\nMiners MAY clear or set bits in the block version WITHOUT any special \"mutable\" key, provided they are listed among the template's \"vbavailable\" and (when clearing is desired) NOT included as a bit in \"vbrequired\".\nServers MUST set bits in \"vbrequired\" for deployments in MUST_SIGNAL state, to ensure blocks produced are valid.\n\nSoftfork deployment names listed in \"rules\" or as keys in \"vbavailable\" may be prefixed by a '!' character.\nWithout this prefix, GBT clients may assume the rule will not impact usage of the template as-is; typical examples of this would be when previously valid transactions cease to be valid, such as BIPs 16, 65, 66, 68, 112, and 113.\nIf a client does not understand a rule without the prefix, it may use it unmodified for mining.\nOn the other hand, when this prefix is used, it indicates a more subtle change to the block structure or generation transaction; examples of this would be BIP 34 (because it modifies coinbase construction) and 141 (since it modifies the txid hashing and adds a commitment to the generation transaction).\nA client that does not understand a rule prefixed by '!' must not attempt to process the template, and must not attempt to use it for mining even unmodified.\n\n=== Reference implementation ===\n\nhttps://github.com/bitcoin/bitcoin/compare/master...luke-jr:bip8\n\n==Contrasted with BIP 9==\n\n* The '''lockinontimeout''' flag is added, providing a way to guarantee transition to LOCKED_IN.\n* Block heights are used for the deployment monotonic clock, rather than median-time-past.\n\n==Backwards compatibility==\n\nBIP8 and BIP9 deployments should not share concurrent active deployment bits. Nodes that only implement BIP9 will not activate a BIP8 soft fork if hashpower threshold is not reached by '''timeoutheight''', however, those nodes will still accept the blocks generated by activated nodes.\n\n==Deployments==\n\nA living list of deployment proposals can be found [[bip-0008/assignments.mediawiki|here]].\n\n==References==\n\n[[bip-0009.mediawiki|BIP9]]\n\n[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013643.html Mailing list discussion]\n\n==Copyright==\n\nThis document is dual licensed as BSD 3-clause, and Creative Commons CC0 1.0 Universal.\n\n", "content_length": 17661}
{"bip_number": 2, "filename": "bip-0002.mediawiki", "content": "<pre>\n  BIP: 2\n  Title: BIP process, revised\n  Author: Luke Dashjr <luke+bip@dashjr.org>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0002\n  Status: Active\n  Type: Process\n  Created: 2016-02-03\n  License: BSD-2-Clause\n           OPL\n  Replaces: 1\n</pre>\n\n==Abstract==\n\nA Bitcoin Improvement Proposal (BIP) is a design document providing information to the Bitcoin community, or describing a new feature for Bitcoin or its processes or environment. The BIP should provide a concise technical specification of the feature and a rationale for the feature.\n\nWe intend BIPs to be the primary mechanisms for proposing new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Bitcoin. The BIP author is responsible for building consensus within the community and documenting dissenting opinions.\n\nBecause the BIPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.\n\nThis particular BIP replaces BIP 1 with a more well-defined and clear process.\n\n==Copyright==\n\nThis BIP is dual-licensed under the Open Publication License and BSD 2-clause license.\n\n==BIP workflow==\n\nThe BIP process begins with a new idea for Bitcoin. Each potential BIP must have a champion -- someone who writes the BIP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. The BIP champion (a.k.a. Author) should first attempt to ascertain whether the idea is BIP-able.\nSmall enhancements or patches to a particular piece of software often don't require standardisation between multiple projects; these don't need a BIP and should be injected into the relevant project-specific development workflow with a patch submission to the applicable issue tracker.\nAdditionally, many ideas have been brought forward for changing Bitcoin that have been rejected for various reasons.\nThe first step should be to search past discussions to see if an idea has been considered before, and if so, what issues arose in its progression.\nAfter investigating past work, the best way to proceed is by posting about the new idea to the [https://groups.google.com/g/bitcoindev Bitcoin development mailing list].\n\nVetting an idea publicly before going as far as writing a BIP is meant to save both the potential author and the wider community time.\nAsking the Bitcoin community first if an idea is original helps prevent too much time being spent on something that is guaranteed to be rejected based on prior discussions (searching the internet does not always do the trick).\nIt also helps to make sure the idea is applicable to the entire community and not just the author. Just because an idea sounds good to the author does not mean it will work for most people in most areas where Bitcoin is used.\n\nOnce the champion has asked the Bitcoin community as to whether an idea has any chance of acceptance, a draft BIP should be presented to the [https://groups.google.com/g/bitcoindev Bitcoin development mailing list].\nThis gives the author a chance to flesh out the draft BIP to make it properly formatted, of high quality, and to address additional concerns about the proposal.\nFollowing a discussion, the proposal should be submitted to the [https://github.com/bitcoin/bips BIPs git repository] as a pull request.\nThis draft must be written in BIP style as described below, and named with an alias such as \"bip-johndoe-infinitebitcoins\" until an editor has assigned it a BIP number (authors MUST NOT self-assign BIP numbers).\n\nBIP authors are responsible for collecting community feedback on both the initial idea and the BIP before submitting it for review. However, wherever possible, long open-ended discussions on public mailing lists should be avoided. Strategies to keep the discussions efficient include: setting up a separate SIG mailing list for the topic, having the BIP author accept private comments in the early design phases, setting up a wiki page or git repository, etc. BIP authors should use their discretion here.\n\nIt is highly recommended that a single BIP contain a single key proposal or new idea. The more focused the BIP, the more successful it tends to be. If in doubt, split your BIP into several well-focused ones.\n\nWhen the BIP draft is complete, a BIP editor will assign the BIP a number, label it as Standards Track, Informational, or Process, and merge the pull request to the BIPs git repository.\nThe BIP editors will not unreasonably reject a BIP.\nReasons for rejecting BIPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the Bitcoin philosophy.\nFor a BIP to be accepted it must meet certain minimum criteria.\nIt must be a clear and complete description of the proposed enhancement.\nThe enhancement must represent a net improvement.\nThe proposed implementation, if applicable, must be solid and must not complicate the protocol unduly.\n\nThe BIP author may update the draft as necessary in the git repository. Updates to drafts should also be submitted by the author as pull requests.\n\n===Transferring BIP Ownership===\n\nIt occasionally becomes necessary to transfer ownership of BIPs to a new champion. In general, we'd like to retain the original author as a co-author of the transferred BIP, but that's really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the BIP process, or has fallen off the face of the 'net (i.e. is unreachable or not responding to email). A bad reason to transfer ownership is because you don't agree with the direction of the BIP. We try to build consensus around a BIP, but if that's not possible, you can always submit a competing BIP.\n\nIf you are interested in assuming ownership of a BIP, send a message asking to take over, addressed to both the original author and the BIP editors. If the original author doesn't respond to email in a timely manner, the BIP editors will make a unilateral decision (it's not like such decisions can't be reversed :).\n\n===BIP Editors===\n\nThe current BIP editors are:\n\n* Bryan Bishop ([[mailto:kanzure@gmail.com|kanzure@gmail.com]])\n* Jon Atack ([[mailto:jon@atack.com|jon@atack.com]])\n* Luke Dashjr ([[mailto:luke_bipeditor@dashjr.org|luke_bipeditor@dashjr.org]])\n* Mark \"Murch\" Erhardt ([[mailto:murch@murch.one|murch@murch.one]])\n* Olaoluwa Osuntokun ([[mailto:laolu32@gmail.com|laolu32@gmail.com]])\n* Ruben Somsen ([[mailto:rsomsen@gmail.com|rsomsen@gmail.com]])\n\n===BIP Editor Responsibilities & Workflow===\n\nThe BIP editors subscribe to the Bitcoin development mailing list.\nOff-list BIP-related correspondence should be sent (or CC'd) to the BIP editors.\n\nFor each new BIP that comes in an editor does the following:\n\n* Read the BIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to be accepted.\n* The title should accurately describe the content.\n* The BIP draft must have been sent to the Bitcoin development mailing list for discussion.\n* Motivation and backward compatibility (when applicable) must be addressed.\n* The defined Layer header must be correctly assigned for the given specification.\n* Licensing terms must be acceptable for BIPs.\n\nIf the BIP isn't ready, the editor will send it back to the author for revision, with specific instructions.\n\nOnce the BIP is ready for the repository it should be submitted as a \"pull request\" to the [https://github.com/bitcoin/bips BIPs git repository] where it may get further feedback.\n\nThe BIP editor will:\n\n* Assign a BIP number in the pull request.\n\n* Merge the pull request when it is ready.\n\n* List the BIP in [[README.mediawiki]]\n\nThe BIP editors are intended to fulfill administrative and editorial responsibilities. The BIP editors monitor BIP changes, and update BIP headers as appropriate.\n\nBIP editors may also, at their option, unilaterally make and merge strictly-editorial changes to BIPs, such as correcting misspellings, fixing broken links, etc.\n\n==BIP format and structure==\n\n===Specification===\n\nBIPs should be written in mediawiki or markdown format.\n\nEach BIP should have the following parts:\n\n* Preamble -- Headers containing metadata about the BIP ([[#BIP header preamble|see below]]).\n\n* Abstract -- A short (~200 word) description of the technical issue being addressed.\n\n* Copyright -- The BIP must be explicitly licensed under acceptable copyright terms ([[#BIP licensing|see below]]).\n\n* Specification -- The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Bitcoin platforms.\n\n* Motivation -- The motivation is critical for BIPs that want to change the Bitcoin protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the BIP solves.\n\n* Rationale -- The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.\n\n* Backwards compatibility -- All BIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The BIP must explain how the author proposes to deal with these incompatibilities.\n\n* Reference implementation -- The reference implementation must be completed before any BIP is given status \"Final\", but it need not be completed before the BIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Bitcoin protocol.\n\n====BIP header preamble====\n\nEach BIP must begin with an RFC 822 style header preamble. The headers must appear in the following order. Headers marked with \"*\" are optional and are described below. All other headers are required.\n\n<pre>\n  BIP: <BIP number, or \"?\" before being assigned>\n* Layer: <Consensus (soft fork) | Consensus (hard fork) | Peer Services | API/RPC | Applications>\n  Title: <BIP title; maximum 44 characters>\n  Author: <list of authors' real names and email addrs>\n* Discussions-To: <email address>\n* Comments-Summary: <summary tone>\n  Comments-URI: <links to wiki page for comments>\n  Status: <Draft | Active | Proposed | Deferred | Rejected |\n           Withdrawn | Final | Replaced | Obsolete>\n  Type: <Standards Track | Informational | Process>\n  Created: <date created on, in ISO 8601 (yyyy-mm-dd) format>\n  License: <abbreviation for approved license(s)>\n* License-Code: <abbreviation for code under different approved license(s)>\n* Post-History: <dates of postings to bitcoin mailing list, or link to thread in mailing list archive>\n* Requires: <BIP number(s)>\n* Replaces: <BIP number>\n* Superseded-By: <BIP number>\n</pre>\n\nThe Layer header (only for Standards Track BIPs) documents which layer of Bitcoin the BIP applies to.\nSee [[bip-0123.mediawiki|BIP 123]] for definitions of the various BIP layers. Activation of this BIP implies activation of BIP 123.\n\nThe Author header lists the names and email addresses of all the authors/owners of the BIP.\nThe format of the Author header value must be\n\n  Random J. User <address@dom.ain>\n\nIf there are multiple authors, each should be on a separate line following RFC 2822 continuation line conventions.\n\nWhile a BIP is in private discussions (usually during the initial Draft phase), a Discussions-To header will indicate the mailing list or URL where the BIP is being discussed. No Discussions-To header is necessary if the BIP is being discussed privately with the author, or on the bitcoin email mailing lists.\n\nThe Type header specifies the type of BIP: Standards Track, Informational, or Process.\n\nThe Created header records the date that the BIP was assigned a number, while Post-History is used to record when new versions of the BIP are posted to bitcoin mailing lists.\nDates should be in yyyy-mm-dd format, e.g. 2001-08-14.\nPost-History is permitted to be a link to a specific thread in a mailing list archive.\n\nBIPs may have a Requires header, indicating the BIP numbers that this BIP depends on.\n\nBIPs may also have a Superseded-By header indicating that a BIP has been rendered obsolete by a later document; the value is the number of the BIP that replaces the current document. The newer BIP must have a Replaces header containing the number of the BIP that it rendered obsolete.\n\n====Auxiliary Files====\n\nBIPs may include auxiliary files such as diagrams. Auxiliary files should be included in a subdirectory for that BIP, or must be named BIP-XXXX-Y.ext, where \"XXXX\" is the BIP number, \"Y\" is a serial number (starting at 1), and \"ext\" is replaced by the actual file extension (e.g. \"png\").\n\n==BIP types==\n\nThere are three kinds of BIP:\n\n* A Standards Track BIP describes any change that affects most or all Bitcoin implementations, such as a change to the network protocol, a change in block or transaction validity rules, or any change or addition that affects the interoperability of applications using Bitcoin. Standards Track BIPs consist of two parts, a design document and a reference implementation.\n* An Informational BIP describes a Bitcoin design issue, or provides general guidelines or information to the Bitcoin community, but does not propose a new feature. Informational BIPs do not necessarily represent a Bitcoin community consensus or recommendation, so users and implementers are free to ignore Informational BIPs or follow their advice.\n* A Process BIP describes a process surrounding Bitcoin, or proposes a change to (or an event in) a process. Process BIPs are like Standards Track BIPs but apply to areas other than the Bitcoin protocol itself. They may propose an implementation, but not to Bitcoin's codebase; they often require community consensus; unlike Informational BIPs, they are more than recommendations, and users are typically not free to ignore them. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in Bitcoin development. Any meta-BIP is also considered a Process BIP.\n\n==BIP status field==\n\n===Specification===\n\nThe typical paths of the status of BIPs are as follows:\n\n<img src=\"bip-0002/process.png\"></img>\n\nChampions of a BIP may decide on their own to change the status between Draft, Deferred, or Withdrawn.\nA BIP editor may also change the status to Deferred when no progress is being made on the BIP.\n\nA BIP may only change status from Draft (or Rejected) to Proposed, when the author deems it is complete, has a working implementation (where applicable), and has community plans to progress it to the Final status.\n\nBIPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years. Such a BIP may be changed to Draft status if the champion provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph.\n\nA Proposed BIP may progress to Final only when specific criteria reflecting real-world adoption has occurred. This is different for each BIP depending on the nature of its proposed changes, which will be expanded on below. Evaluation of this status change should be objectively verifiable, and/or be discussed on the development mailing list.\n\nWhen a Final BIP is no longer relevant, its status may be changed to Replaced or Obsolete (which is equivalent to Replaced). This change must also be objectively verifiable and/or discussed.\n\nA process BIP may change status from Draft to Active when it achieves rough consensus on the mailing list. Such a proposal is said to have rough consensus if it has been open to discussion on the development mailing list for at least one month, and no person maintains any unaddressed substantiated objections to it. Addressed or obstructive objections may be ignored/overruled by general agreement that they have been sufficiently addressed, but clear reasoning must be given in such circumstances.\n\n====Progression to Final status====\n\nA soft-fork BIP strictly requires a clear miner majority expressed by blockchain voting (eg, using BIP 9). In addition, if the economy seems willing to make a \"no confidence\" hard-fork (such as a change in proof-of-work algorithm), the soft-fork does not become Final for as long as such a hard-fork might have majority support, or at most three months. Soft-fork BIPs may also set additional requirements for their adoption. Because of the possibility of changes to miner dynamics, especially in light of delegated voting (mining pools), it is highly recommended that a supermajority vote around 95% be required by the BIP itself, unless rationale is given for a lower threshold.\n\nA hard-fork BIP requires adoption from the entire Bitcoin economy, particularly including those selling desirable goods and services in exchange for bitcoin payments, as well as Bitcoin holders who wish to spend or would spend their bitcoins (including selling for other currencies) differently in the event of such a hard-fork. Adoption must be expressed by de facto usage of the hard-fork in practice (ie, not merely expressing public support, although that is a good step to establish agreement before adoption of the BIP). This economic adoption cannot be established merely by a super-majority, except by literally forcing the minority to accept the hard-fork (whether this is viable or not is outside the scope of this document).\n\nPeer services BIPs should be observed to be adopted by at least 1% of public listening nodes for one month.\n\nAPI/RPC and application layer BIPs must be implemented by at least two independent and compatible software applications.\n\nSoftware authors are encouraged to publish summaries of what BIPs their software supports to aid in verification of status changes. Good examples of this at the time of writing this BIP, can be observed in [https://github.com/bitcoin/bitcoin/blob/master/doc/bips.md Bitcoin Core's doc/bips.md file] as well as [https://github.com/bitcoin-wallet/bitcoin-wallet/blob/master/wallet/README.specs.md Bitcoin Wallet for Android's wallet/README.specs.md file].\n\nThese criteria are considered objective ways to observe the de facto adoption of the BIP, and are not to be used as reasons to oppose or reject a BIP. Should a BIP become actually and unambiguously adopted despite not meeting the criteria outlined here, it should still be updated to Final status.\n\n===Rationale===\n\nWhy is this necessary at all?\n\n* BIP 1 defines an ambiguous criteria for the Status field of BIPs, which is often a source of confusion. As a result, many BIPs with significant real-world use have been left as Draft or Proposed status longer than appropriate. By giving objective criteria to judge the progression of BIPs, this proposal aims to help keep the Status accurate and up-to-date.\n\nHow is the entire Bitcoin economy defined by people selling goods/services and holders?\n\n* For Bitcoin to function as a currency, it must be accepted as payment. Bitcoins have no value if you cannot acquire anything in exchange for them. If everyone accepting such payments requires a particular set of consensus rules, \"bitcoins\" are de facto defined by that set of rules - this is already the case today. If those consensus rules are expected to broaden (as with a hard-fork), those merchants need to accept payments made under the new set of rules, or they will reject \"bitcoins\" as invalid. Holders are relevant to the degree in that they choose the merchants they wish to spend their bitcoins with, and could also as a whole decide to sell under one set of consensus rules or the other, thus flooding the market with bitcoins and crashing the price.\n\nWhy aren't <x> included in the economy?\n\n* Some entities may, to some degree, also be involved in offering goods and/or services in exchange for bitcoins, thus in that capacity (but not their capacity as <x>) be involved in the economy.\n* Miners are not included in the economy, because they merely *rely on* others to sell/spend their otherwise-worthless mined produce. Therefore, they must accept everyone else's direction in deciding the consensus rules.\n* Exchanges are not included in the economy, because they merely provide services of connecting the merchants and users who wish to trade. Even if all exchanges were to defect from Bitcoin, those merchants and users can always trade directly and/or establish their own exchanges.\n* Developers are not included in the economy, since they merely write code, and it is up to others to decide to use that code or not.\n\nBut they're doing something important and have invested a lot in Bitcoin! Shouldn't they be included in such an important decision?\n\n* This BIP does not aim to address what \"should\" be the basis of decisions. Such a statement, no matter how perfect in its justification, would be futile without some way to force others to use it. The BIP process does not aim to be a kind of forceful \"governance\" of Bitcoin, merely to provide a collaborative repository for proposing and providing information on standards, which people may voluntarily adopt or not. It can only hope to achieve accuracy in regard to the \"Status\" field by striving to reflect the reality of *how things actually are*, rather than *how they should be*.\n\nWhat if a single merchant wishes to block a hard-fork?\n\n* This BIP addresses only the progression of the BIP Status field, not the deployment of the hard-fork (or any other change) itself.\n* Regardless, one shop cannot operate in a vacuum: if they are indeed alone, they will soon find themselves no longer selling in exchange for bitcoin payments, as nobody else would exist willing to use the previous blockchain to pay them. If they are no longer selling, they cease to meet the criteria herein which enables their veto.\n\nHow about a small number of merchants (maybe only two) who sell products to each other?\n\n* In this scenario, it would seem the previous Bitcoin is alive and working, and that the hard-fork has failed. How to resolve such a split is outside the scope of this BIP.\n\nHow can economic agreement veto a soft-fork?\n\n* The group of miners is determined by the consensus rules for the dynamic-membership multi-party signature (for Bitcoin, the proof-of-work algorithm), which can be modified with a hard-fork. Thus, if the same conditions required to modify this group are met in opposition to a soft-fork, the miner majority supporting the soft-fork is effectively void because the economy can decide to replace them with another group of would-be miners who do not support the soft-fork.\n\nWhat happens if the economy decides to hard-fork away from a controversial soft-fork, more than three months later?\n\n* The controversial soft-fork, in this circumstance, changes from Final to Replaced status to reflect the nature of the hard-fork replacing the previous (final) soft-fork.\n\nWhat is the ideal percentage of listening nodes needed to adopt peer services proposals?\n\n* This is unknown, and set rather arbitrarily at this time. For a random selection of peers to have at least one other peer implementing the extension, 13% or more would be necessary, but nodes could continue to scan the network for such peers with perhaps some reasonable success. Furthermore, service bits exist to help identification upfront.\n\nWhy is it necessary for at least two software projects to release an implementation of API/RPC and application layer BIPs, before they become Final?\n\n* If there is only one implementation of a specification, there is no other program for which a standard interface is used with or needed.\n* Even if there are only two projects rather than more, some standard coordination between them exists.\n\nWhat if a BIP is proposed that only makes sense for a single specific project?\n\n* The BIP process exists for standardisation between independent projects. If something only affects one project, it should be done through that project's own internal processes, and never be proposed as a BIP in the first place.\n\n==BIP comments==\n\n===Specification===\n\nEach BIP should, in its preamble, link to a public wiki page with a summary tone of the comments on that page.\nReviewers of the BIP who consider themselves qualified, should post their own comments on this wiki page.\nThe comments page should generally only be used to post final comments for a completed BIP.\nIf a BIP is not yet completed, reviewers should instead post on the applicable development mailing list thread to allow the BIP author(s) to address any concerns or problems pointed out by the review.\n\nSome BIPs receive exposure outside the development community prior to completion, and other BIPs might not be completed at all. To avoid a situation where critical BIP reviews may go unnoticed during this period, reviewers may, at their option, still post their review on the comments page, provided they first post it to the mailing list and plan to later remove or revise it as applicable based on the completed version. Such revisions should be made by editing the previous review and updating the timestamp. Reviews made prior to the complete version may be removed if they are no longer applicable and have not been updated in a timely manner (eg, within one month).\n\nPages must be named after the full BIP number (eg, \"BIP 0001\") and placed in the \"Comments\" namespace.\nFor example, the link for BIP 1 will be https://github.com/bitcoin/bips/wiki/Comments:BIP-0001 .\n\nComments posted to this wiki should use the following format:\n\n    <Your opinion> --<Your name>, <Date of posting, as YYYY-MM-DD>\n\nBIPs may also choose to list a second forum for BIP comments, in addition to the BIPs wiki.\nIn this case, the second forum's URI should be listed below the primary wiki's URI.\n\nAfter some time, the BIP itself may be updated with a summary tone of the comments.\nSummary tones may be chosen from the following, but this BIP does not intend to cover all possible nuances and other summaries may be used as needed:\n\n* No comments yet.\n* Unanimously Recommended for implementation\n* Unanimously Discourage for implementation\n* Mostly Recommended for implementation, with some Discouragement\n* Mostly Discouraged for implementation, with some Recommendation\n\nFor example, the preamble to BIP 1 might be updated to include the line:\n\n    Comments-Summary: No comments yet.\n    Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0001\n                  https://some-other-wiki.org/BIP_1_Comments\n\nThese fields must follow the \"Discussions-To\" header defined in BIP 1 (if that header is not present, it should follow the position where it would be present; generally this is immediately above the Status header).\n\nTo avoid doubt: comments and status are unrelated metrics to judge a BIP, and neither should be directly influencing the other.\n\n===Rationale===\n\nWhat is the purpose of BIP comments?\n\n* Various BIPs have been adopted (the criteria required for \"Final\" Status) despite being considered generally inadvisable. Some presently regard BIPs as a \"good idea\" simply by virtue of them being assigned a BIP number. Due to the low barrier of entry for submission of new BIPs, it seems advisable for a way for reviewers to express their opinions on them in a way that is consumable to the public without needing to review the entire development discussion.\n\nWill BIP comments be censored or limited to particular participants/\"experts\"?\n\n* Participants should freely refrain from commenting outside of their area of knowledge or expertise. However, comments should not be censored, and participation should be open to the public.\n\n==BIP licensing==\n\n===Specification===\n\nNew BIPs may be accepted with the following licenses. Each new BIP must identify at least one acceptable license in its preamble. The License header in the preamble must be placed after the Created header. Each license must be referenced by their respective abbreviation given below.\n\nFor example, a preamble might include the following License header:\n\n    License: BSD-2-Clause\n             GNU-All-Permissive\n\nIn this case, the BIP text is fully licensed under both the OSI-approved BSD 2-clause license as well as the GNU All-Permissive License, and anyone may modify and redistribute the text provided they comply with the terms of *either* license. In other words, the license list is an \"OR choice\", not an \"AND also\" requirement.\n\nIt is also possible to license source code differently from the BIP text. An optional License-Code header is placed after the License header. Again, each license must be referenced by their respective abbreviation given below.\n\nFor example, a preamble specifying the optional License-Code header might look like:\n\n    License: BSD-2-Clause\n             GNU-All-Permissive\n    License-Code: GPL-2.0+\n\nIn this case, the code in the BIP is not available under the BSD or All-Permissive licenses, but only under the terms of the GNU General Public License (GPL), version 2 or newer.\nIf the code were to be available under *only* version 2 exactly, the \"+\" symbol should be removed from the license abbreviation.\nFor a later version (eg, GPL 3.0), you would increase the version number (and retain or remove the \"+\" depending on intent).\n\n    License-Code: GPL-2.0   # This refers to GPL v2.0 *only*, no later license versions are acceptable.\n    License-Code: GPL-2.0+  # This refers to GPL v2.0 *or later*.\n    License-Code: GPL-3.0   # This refers to GPL v3.0 *only*, no later license versions are acceptable.\n    License-Code: GPL-3.0+  # This refers to GPL v3.0 *or later*.\n\nIn the event that the licensing for the text or code is too complicated to express with a simple list of alternatives, the list should instead be replaced with the single term \"Complex\". In all cases, details of the licensing terms must be provided in the Copyright section of the BIP.\n\nBIPs are not required to be *exclusively* licensed under approved terms, and may also be licensed under unacceptable licenses *in addition to* at least one acceptable license.\nIn this case, only the acceptable license(s) should be listed in the License and License-Code headers.\n\n====Recommended licenses====\n\n* BSD-2-Clause: [https://opensource.org/license/BSD-2-Clause OSI-approved BSD 2-clause license]\n* BSD-3-Clause: [https://opensource.org/license/BSD-3-Clause OSI-approved BSD 3-clause license]\n* CC0-1.0: [https://creativecommons.org/publicdomain/zero/1.0/ Creative Commons CC0 1.0 Universal]\n* GNU-All-Permissive: [https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html GNU All-Permissive License]\n\nIn addition, it is recommended that literal code included in the BIP be dual-licensed under the same license terms as the project it modifies. For example, literal code intended for Bitcoin Core would ideally be dual-licensed under the MIT license terms as well as one of the above with the rest of the BIP text.\n\n====Not recommended, but acceptable licenses====\n\n* Apache-2.0: [https://www.apache.org/licenses/LICENSE-2.0 Apache License, version 2.0]\n* BSL-1.0: [https://www.boost.org/LICENSE_1_0.txt Boost Software License, version 1.0]\n* CC-BY-4.0: [https://creativecommons.org/licenses/by/4.0/ Creative Commons Attribution 4.0 International]\n* CC-BY-SA-4.0: [https://creativecommons.org/licenses/by-sa/4.0/ Creative Commons Attribution-ShareAlike 4.0 International]\n* MIT: [https://opensource.org/license/MIT The MIT License]\n* AGPL-3.0+: [https://www.gnu.org/licenses/agpl-3.0.en.html GNU Affero General Public License (AGPL), version 3 or newer]\n* FDL-1.3: [https://www.gnu.org/licenses/fdl-1.3.en.html GNU Free Documentation License, version 1.3]\n* GPL-2.0+: [https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html GNU General Public License (GPL), version 2 or newer]\n* LGPL-2.1+: [https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html GNU Lesser General Public License (LGPL), version 2.1 or newer]\n\n====Not acceptable licenses====\n\nAll licenses not explicitly included in the above lists are not acceptable terms for a Bitcoin Improvement Proposal unless a later BIP extends this one to add them.\nHowever, BIPs predating the acceptance of this BIP were allowed under other terms, and should use these abbreviation when no other license is granted:\n\n* OPL: [https://opencontent.org/openpub/ Open Publication License, version 1.0]\n* PD: Released into the public domain\n\n===Rationale===\n\nBIP 1 allowed the Open Publication License or releasing into the public domain; was this insufficient?\n\n* The OPL is generally regarded as obsolete, and not a license suitable for new publications.\n* Many are unfamiliar with the OPL terms, and may just prefer to use the public domain rather than license under uncertain terms.\n* The OPL license terms allowed for the author to prevent publication and derived works, which was widely considered inappropriate for Bitcoin standards.\n* Public domain is not universally recognised as a legitimate action, thus it is inadvisable.\n\nWhy are there software licenses included?\n\n* Some BIPs, especially consensus layer, may include literal code in the BIP itself which may not be available under the exact license terms of the BIP.\n* Despite this, not all software licenses would be acceptable for content included in BIPs.\n\nWhy is Public Domain no longer acceptable for new BIPs?\n\n* In some jurisdictions, public domain is not recognised as a legitimate legal action, leaving the BIP simply copyrighted with no redistribution or modification allowed at all.\n\n==Changes from BIP 1==\n\n* Acceptable licenses are entirely rechosen, allowing a wide variety of open licenses, while prohibiting the problematic older choices.\n* Accepted Status has been renamed to Proposed.\n* An implementation is now required (when applicable) before BIPs can proceed to Proposed Status.\n* BIP Comments are newly introduced.\n* The License preamble headers have been added.\n* The Layer header is included from BIP 123.\n* Non-image auxiliary files are permitted in the bip-XXXX subdirectory.\n* Email addresses are now required for authors.\n* The Post-History header may be provided as a link instead of a simple date.\n* The Resolution header has been dropped, as it is not applicable to a decentralised system where no authority exists to make final decisions.\n\n==See Also==\n\n* [[bip-0001.mediawiki|BIP 1: BIP Purpose and Guidelines]]\n* [[bip-0123.mediawiki|BIP 123: BIP Classification]]\n* [https://tools.ietf.org/html/rfc7282 RFC 7282: On Consensus and Humming in the IETF]\n", "content_length": 35169}
{"bip_number": 1, "filename": "bip-0001.mediawiki", "content": "<pre>\n  BIP: 1\n  Title: BIP Purpose and Guidelines\n  Author: Amir Taaki <genjix@riseup.net>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0001\n  Status: Replaced\n  Type: Process\n  Created: 2011-09-19\n  Superseded-By: 2\n</pre>\n\n==What is a BIP?==\n\nBIP stands for Bitcoin Improvement Proposal. A BIP is a design document providing information to the Bitcoin community, or describing a new feature for Bitcoin or its processes or environment. The BIP should provide a concise technical specification of the feature and a rationale for the feature.\n\nWe intend BIPs to be the primary mechanisms for proposing new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Bitcoin. The BIP author is responsible for building consensus within the community and documenting dissenting opinions.\n\nBecause the BIPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.\n\n==BIP Types==\n\nThere are three kinds of BIP:\n\n* A Standards Track BIP describes any change that affects most or all Bitcoin implementations, such as a change to the network protocol, a change in block or transaction validity rules, or any change or addition that affects the interoperability of applications using Bitcoin.\n* An Informational BIP describes a Bitcoin design issue, or provides general guidelines or information to the Bitcoin community, but does not propose a new feature. Informational BIPs do not necessarily represent a Bitcoin community consensus or recommendation, so users and implementers are free to ignore Informational BIPs or follow their advice.\n* A Process BIP describes a process surrounding Bitcoin, or proposes a change to (or an event in) a process. Process BIPs are like Standards Track BIPs but apply to areas other than the Bitcoin protocol itself. They may propose an implementation, but not to Bitcoin's codebase; they often require community consensus; unlike Informational BIPs, they are more than recommendations, and users are typically not free to ignore them. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in Bitcoin development. Any meta-BIP is also considered a Process BIP.\n\n==BIP Work Flow==\n\nThe BIP process begins with a new idea for Bitcoin. Each potential BIP must have a champion -- someone who writes the BIP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. The BIP champion (a.k.a. Author) should first attempt to ascertain whether the idea is BIP-able. Posting to the [https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev bitcoin-dev@lists.linuxfoundation.org] mailing list (and maybe the [https://bitcointalk.org/index.php?board=6.0 Development & Technical Discussion] forum) is the best way to go about this.\n\nVetting an idea publicly before going as far as writing a BIP is meant to save both the potential author and the wider community time. Many ideas have been brought forward for changing Bitcoin that have been rejected for various reasons. Asking the Bitcoin community first if an idea is original helps prevent too much time being spent on something that is guaranteed to be rejected based on prior discussions (searching the internet does not always do the trick). It also helps to make sure the idea is applicable to the entire community and not just the author. Just because an idea sounds good to the author does not mean it will work for most people in most areas where Bitcoin is used. Small enhancements or patches often don't need standardisation between multiple projects; these don't need a BIP and should be injected into the relevant Bitcoin development work flow with a patch submission to the applicable Bitcoin issue tracker.\n\nOnce the champion has asked the Bitcoin community as to whether an idea has any chance of acceptance, a draft BIP should be presented to the [https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev bitcoin-dev] mailing list. This gives the author a chance to flesh out the draft BIP to make it properly formatted, of high quality, and to address additional concerns about the proposal. Following a discussion, the proposal should be sent to the bitcoin-dev list and the BIP editor with the draft BIP. This draft must be written in BIP style as described below, else it will be sent back without further regard until proper formatting rules are followed.\n\nBIP authors are responsible for collecting community feedback on both the initial idea and the BIP before submitting it for review. However, wherever possible, long open-ended discussions on public mailing lists should be avoided. Strategies to keep the discussions efficient include: setting up a separate SIG mailing list for the topic, having the BIP author accept private comments in the early design phases, setting up a wiki page or git repository, etc. BIP authors should use their discretion here.\n\nIt is highly recommended that a single BIP contain a single key proposal or new idea. The more focused the BIP, the more successful it tends to be. If in doubt, split your BIP into several well-focused ones.\n\nThe BIP editors assign BIP numbers and change their status. Please send all BIP-related email to the BIP editor, which is listed under [[#BIP_Editors|BIP Editors]] below. Also see [[#BIP_Editor_Responsibilities__Workflow|BIP Editor Responsibilities & Workflow]]. The BIP editor reserves the right to reject BIP proposals if they appear too unfocused or too broad.\n\nAuthors MUST NOT self assign BIP numbers, but should use an alias such as \"bip-johndoe-infinitebitcoins\" which includes the author's name/nick and the BIP subject.\n\nIf the BIP editor approves, he will assign the BIP a number, label it as Standards Track, Informational, or Process, give it status \"Draft\", and add it to the BIPs git repository. The BIP editor will not unreasonably deny a BIP. Reasons for denying BIP status include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the Bitcoin philosophy. For a BIP to be accepted it must meet certain minimum criteria. It must be a clear and complete description of the proposed enhancement. The enhancement must represent a net improvement. The proposed implementation, if applicable, must be solid and must not complicate the protocol unduly.\n\nThe BIP author may update the Draft as necessary in the git repository. Updates to drafts may also be submitted by the author as pull requests.\n\nStandards Track BIPs consist of two parts, a design document and a reference implementation. The BIP should be reviewed and accepted before a reference implementation is begun, unless a reference implementation will aid people in studying the BIP. Standards Track BIPs must include an implementation -- in the form of code, a patch, or a URL to same -- before it can be considered Final.\n\nOnce a BIP has been accepted, the reference implementation must be completed. When the reference implementation is complete and accepted by the community, the status will be changed to \"Final\".\n\nA BIP can also be assigned status \"Deferred\". The BIP author or editor can assign the BIP this status when no progress is being made on the BIP. Once a BIP is deferred, the BIP editor can re-assign it to draft status.\n\nA BIP can also be \"Rejected\". Perhaps after all is said and done it was not a good idea. It is still important to have a record of this fact.\n\nBIPs can also be superseded by a different BIP, rendering the original obsolete. This is intended for Informational BIPs, where version 2 of an API can replace version 1.\n\nThe possible paths of the status of BIPs are as follows:\n\n<img src=bip-0001/process.png></img>\n\nSome Informational and Process BIPs may also have a status of \"Active\" if they are never meant to be completed. E.g. BIP 1 (this BIP).\n\n==What belongs in a successful BIP?==\n\nEach BIP should have the following parts:\n\n* Preamble -- RFC 822 style headers containing meta-data about the BIP, including the BIP number, a short descriptive title (limited to a maximum of 44 characters), the names, and optionally the contact info for each author, etc.\n\n* Abstract -- a short (~200 word) description of the technical issue being addressed.\n\n* Copyright/public domain -- Each BIP must either be explicitly labelled as placed in the public domain (see this BIP as an example) or licensed under the Open Publication License.\n\n* Specification -- The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Bitcoin platforms (Satoshi, BitcoinJ, bitcoin-js, libbitcoin).\n\n* Motivation -- The motivation is critical for BIPs that want to change the Bitcoin protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the BIP solves. BIP submissions without sufficient motivation may be rejected outright.\n\n* Rationale -- The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages.\n\n* The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.\n\n* Backwards Compatibility -- All BIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The BIP must explain how the author proposes to deal with these incompatibilities. BIP submissions without a sufficient backwards compatibility treatise may be rejected outright.\n\n* Reference Implementation -- The reference implementation must be completed before any BIP is given status \"Final\", but it need not be completed before the BIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code.\n\n* The final implementation must include test code and documentation appropriate for the Bitcoin protocol.\n\n==BIP Formats and Templates==\n\nBIPs should be written in mediawiki or markdown format.\n\n===BIP Header Preamble===\n\nEach BIP must begin with an RFC 822 style header preamble. The headers must appear in the following order. Headers marked with \"*\" are optional and are described below. All other headers are required.\n\n<pre>\n  BIP: <BIP number>\n  Title: <BIP title>\n  Author: <list of authors' real names and optionally, email addrs>\n* Discussions-To: <email address>\n  Status: <Draft | Active | Accepted | Deferred | Rejected |\n           Withdrawn | Final | Superseded>\n  Type: <Standards Track | Informational | Process>\n  Created: <date created on, in ISO 8601 (yyyy-mm-dd) format>\n* Post-History: <dates of postings to bitcoin mailing list>\n* Replaces: <BIP number>\n* Superseded-By: <BIP number>\n* Resolution: <url>\n</pre>\n\nThe Author header lists the names, and optionally the email addresses of all the authors/owners of the BIP. The format of the Author header value must be\n\n  Random J. User <address@dom.ain>\n\nif the email address is included, and just\n\n  Random J. User\n\nif the address is not given.\n\nIf there are multiple authors, each should be on a separate line following RFC 2822 continuation line conventions.\n\nNote: The Resolution header is required for Standards Track BIPs only. It contains a URL that should point to an email message or other web resource where the pronouncement about the BIP is made.\n\nWhile a BIP is in private discussions (usually during the initial Draft phase), a Discussions-To header will indicate the mailing list or URL where the BIP is being discussed. No Discussions-To header is necessary if the BIP is being discussed privately with the author, or on the bitcoin email mailing lists.\n\nThe Type header specifies the type of BIP: Standards Track, Informational, or Process.\n\nThe Created header records the date that the BIP was assigned a number, while Post-History is used to record the dates of when new versions of the BIP are posted to bitcoin mailing lists. Both headers should be in yyyy-mm-dd format, e.g. 2001-08-14.\n\nBIPs may have a Requires header, indicating the BIP numbers that this BIP depends on.\n\nBIPs may also have a Superseded-By header indicating that a BIP has been rendered obsolete by a later document; the value is the number of the BIP that replaces the current document. The newer BIP must have a Replaces header containing the number of the BIP that it rendered obsolete.\n\n===Auxiliary Files===\n\nBIPs may include auxiliary files such as diagrams. Image files should be included in a subdirectory for that BIP. Auxiliary files must be named BIP-XXXX-Y.ext, where \"XXXX\" is the BIP number, \"Y\" is a serial number (starting at 1), and \"ext\" is replaced by the actual file extension (e.g. \"png\").\n\n==Transferring BIP Ownership==\n\nIt occasionally becomes necessary to transfer ownership of BIPs to a new champion. In general, we'd like to retain the original author as a co-author of the transferred BIP, but that's really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the BIP process, or has fallen off the face of the 'net (i.e. is unreachable or not responding to email). A bad reason to transfer ownership is because you don't agree with the direction of the BIP. We try to build consensus around a BIP, but if that's not possible, you can always submit a competing BIP.\n\nIf you are interested in assuming ownership of a BIP, send a message asking to take over, addressed to both the original author and the BIP editor. If the original author doesn't respond to email in a timely manner, the BIP editor will make a unilateral decision (it's not like such decisions can't be reversed :).\n\n==BIP Editors==\n\nThe current BIP editor is Luke Dashjr who can be contacted at [[mailto:luke_bipeditor@dashjr.org|luke_bipeditor@dashjr.org]].\n\n==BIP Editor Responsibilities & Workflow==\n\nThe BIP editor subscribes to the Bitcoin development mailing list. All BIP-related correspondence should be sent (or CC'd) to luke_bipeditor@dashjr.org.\n\nFor each new BIP that comes in an editor does the following:\n\n* Read the BIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to be accepted.\n* The title should accurately describe the content.\n* Edit the BIP for language (spelling, grammar, sentence structure, etc.), markup (for reST BIPs), code style (examples should match BIP 8 & 7).\n\nIf the BIP isn't ready, the editor will send it back to the author for revision, with specific instructions.\n\nOnce the BIP is ready for the repository it should be submitted as a \"pull request\" to the [https://github.com/bitcoin/bips bitcoin/bips] repository on GitHub where it may get further feedback.\n\nThe BIP editor will:\n\n* Assign a BIP number (almost always just the next available number, but sometimes it's a special/joke number, like 666 or 3141) in the pull request comments.\n\n* Merge the pull request when the author is ready (allowing some time for further peer review).\n\n* List the BIP in [[README.mediawiki]]\n\n* Send email back to the BIP author with next steps (post to bitcoin-dev mailing list).\n\nThe BIP editors are intended to fulfill administrative and editorial responsibilities. The BIP editors monitor BIP changes, and correct any structure, grammar, spelling, or markup mistakes we see.\n\n==History==\n\nThis document was derived heavily from Python's PEP-0001. In many places text was simply copied and modified. Although the PEP-0001 text was written by Barry Warsaw, Jeremy Hylton, and David Goodger, they are not responsible for its use in the Bitcoin Improvement Process, and should not be bothered with technical questions specific to Bitcoin or the BIP process. Please direct all comments to the BIP editors or the Bitcoin development mailing list.\n\n==Changelog==\n\n10 Oct 2015 - Added clarifications about submission process and BIP number assignment.\n\n01 Jan 2016 - Clarified early stages of BIP idea championing, collecting community feedback, etc.\n", "content_length": 16571}
{"bip_number": 379, "filename": "bip-0379.md", "content": "```\n  BIP: 379\n  Layer: Applications\n  Title: Miniscript\n  Author: Pieter Wuille <pieter@wuille.net>\n          Andrew Poelstra <andrew.poelstra@gmail.com>\n          Sanket Kanjalkar <sanket1729@gmail.com>\n          Antoine Poinsot <darosior@protonmail.com>\n          Ava Chow <me@achow101.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0379\n  Status: Draft\n  Type: Informational\n  Created: 2023-10-10\n  License: CC0-1.0\n  Requires: 380\n```\n\n## Abstract\n\nThis document specifies Miniscript, a language for writing (a subset of) Bitcoin Scripts in a\nstructured way, enabling analysis, composition, generic signing and more.\n\n## Copyright\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n## Motivation\n\nBitcoin Script is an unusual stack-based language with many edge cases, designed for implementing\nspending conditions consisting of various combinations of signatures, hash locks, and time locks.\nYet, despite being limited in functionality, it is still highly nontrivial to:\n\n* Given a combination of spending conditions, finding the most economical script to implement it.\n* Given two scripts, construct a script that implements a composition of their spending conditions (e.g. a multisig where one of the \"keys\" is another multisig).\n* Given a script, find out what spending conditions it permits.\n* Given a script and access to a sufficient set of private keys, construct a general satisfying witness for it.\n* Given a script, be able to predict the cost of spending an output.\n* Given a script, know whether particular resource limitations like the ops limit might be hit when spending.\n\nMiniscript functions as a representation for scripts that makes this sort of operations possible.\nIt has a structure that allows composition. It is very easy to statically analyze for various\nproperties (spending conditions, correctness, security properties, malleability, ...). It can be\ntargeted by spending policy compilers. Finally, compatible scripts can easily be converted to\nMiniscript form - avoiding the need for additional metadata for e.g. signing devices that support\nit.\n\n## Specification\n\nThese specifications apply to P2WSH ([BIP 141](bip-0141.mediawiki)) and Tapscript ([BIP 342](bip-0342.mediawiki)) scripts, with only minor\nvariations between the two. Differences are noted inline. Unless explicitly stated otherwise,\nspecifications apply to both. P2SH and bare scripts are excluded from this specification.\n\n### Translation Table\n\nMiniscript consists of a set of script *fragments* which are designed to be safely and correctly composable.\n\nThis table shows all Miniscript *fragments* and their associated semantics and Bitcoin Script.\nFragments that do not change the semantics of their subexpressions are called *wrappers*. Normal\nfragments use a `fragment(arg1,arg2,...)` notation, while wrappers are written using\nprefixes separated from other fragments by a colon. The colon is dropped between subsequent\nwrappers; e.g.  `dv:older(144)` is the `d:` wrapper applied to the\n`v:` wrapper applied to the `older` fragment for 144 blocks.\n\nThe `pk`, `pkh`, and `and_n` fragments and `t:`,\n`l:`, and `u:` wrappers are syntactic sugar for other Miniscripts, as listed\nin the table below. Note that `<20>` are in hex representation in this document.\n\nMiniscript fragments are expected to be used in [BIP 382](bip-0382.mediawiki) `wsh()` descriptors\nand [BIP 386](bip-0386.mediawiki) `tr()` descriptors. Key expressions are specified in\n[BIP 380](bip-0380.mediawiki#user-content-Key_Expressions). Additionally, BIPs 382 and 386 specify\nrestrictions on key expressions and what they resolve to - these apply to key expressions in\nMiniscript. BIP 382's key expression restrictions apply to Miniscript in P2WSH contexts, and BIP\n386's key expression restrictions apply to Miniscript in P2TR contexts. From a user's perspective,\nMiniscript is not a separate language, but rather a significant expansion of the descriptor language.\n\n| Semantics                                                | Miniscript Fragment           | Bitcoin Script\n|----------------------------------------------------------|-------------------------------|---------------\n| false                                                    | `0`                           | `0`\n| true                                                     | `1`                           | `1`\n| check(key)                                               | `pk_k(key)`                   | `<key>`\n|                                                          | `pk_h(key)`                   | `DUP HASH160 <HASH160(key)> EQUALVERIFY `\n|                                                          | `pk(key)` = `c:pk_k(key)`     | `<key> CHECKSIG`\n|                                                          | `pkh(key)` = `c:pk_h(key)`    | `DUP HASH160 <HASH160(key)> EQUALVERIFY CHECKSIG`\n| nSequence \u2265 n (and compatible)                           | `older(n)`                    | `<n> CHECKSEQUENCEVERIFY`\n| nLockTime \u2265 n (and compatible)                           | `after(n)`                    | `<n> CHECKLOCKTIMEVERIFY`\n| len(x) = 32 and SHA256(x) = h                            | `sha256(h)`                   | `SIZE <0x20> EQUALVERIFY SHA256 <h> EQUAL`\n| len(x) = 32 and HASH256(x) = h                           | `hash256(h)`                  | `SIZE <0x20> EQUALVERIFY HASH256 <h> EQUAL`\n| len(x) = 32 and RIPEMD160(x) = h                         | `ripemd160(h)`                | `SIZE <0x20> EQUALVERIFY RIPEMD160 <h> EQUAL`\n| len(x) = 32 and HASH160(x) = h                           | `hash160(h)`                  | `SIZE <0x20> EQUALVERIFY HASH160 <h> EQUAL`\n| (X and Y) or Z                                           | `andor(X,Y,Z)`                | `[X] NOTIF [Z] ELSE [Y] ENDIF`\n| X and Y                                                  | `and_v(X,Y)`                  | `[X] [Y]`\n|                                                          | `and_b(X,Y)`                  | `[X] [Y] BOOLAND`\n|                                                          | `and_n(X,Y)` = `andor(X,Y,0)` | `[X] NOTIF 0 ELSE [Y] ENDIF`\n| X or Z                                                   | `or_b(X,Z)`                   | `[X] [Z] BOOLOR`\n|                                                          | `or_c(X,Z)`                   | `[X] NOTIF [Z] ENDIF`\n|                                                          | `or_d(X,Z)`                   | `[X] IFDUP NOTIF [Z] ENDIF`\n|                                                          | `or_i(X,Z)`                   | `IF [X] ELSE [Z] ENDIF`\n| X_1 + ... + X_n = k                                      | `thresh(k,X_1,...,X_n)`       | `[X_1] [X_2] ADD ... [X_n] ADD ... <k> EQUAL`\n| check(key_1) + ... + check(key_n) = k *(P2WSH only)*     | `multi(k,key_1,...,key_n)`    | `<k> <key_1> ... <key_n> <n> CHECKMULTISIG`\n| check(key_1) + ... + check(key_n) = k *(Tapscript only)* | `multi_a(k,key_1,...,key_n)`  | `<key_1> CHECKSIG <key_2> CHECKSIGADD ... <key_n> CHECKSIGADD <k> NUMEQUAL`\n| X (identities)                                           | `a:X`                         | `TOALTSTACK [X] FROMALTSTACK`\n|                                                          | `s:X`                         | `SWAP [X]`\n|                                                          | `c:X`                         | `[X] CHECKSIG`\n|                                                          | `t:X` = `and_v(X,1)`          | `[X] 1`\n|                                                          | `d:X`                         | `DUP IF [X] ENDIF`\n|                                                          | `v:X`                         | `[X] VERIFY (or VERIFY version of last opcode in [X])`\n|                                                          | `j:X`                         | `SIZE 0NOTEQUAL IF [X] ENDIF`\n|                                                          | `n:X`                         | `[X] 0NOTEQUAL`\n|                                                          | `l:X` = `or_i(0,X)`           | `IF 0 ELSE [X] ENDIF`\n|                                                          | `u:X` = `or_i(X,0)`           | `IF [X] ELSE 0 ENDIF`\n\n### Type System\n\nNot every Miniscript expression can be composed with every other. Some return their result by\nputting true or false on the stack; others can only abort or continue. Some require subexpressions\nthat consume an exactly known number of arguments, while others need a subexpression that has a\nnonzero top stack element to satisfy. To model all these properties, we define a correctness type\nsystem for Miniscript.\n\n#### Correctness\n\nEvery miniscript expression has one of four basic types: \"**B**\" (base), \"**V**\" (verify),\n\"**K**\" (key) and \"**W**\" (wrapped). Then there are 5 type modifiers that guarantee additional\nproperties: \"**z**\" (zero-arg), \"**o**\" (one-arg), \"**n**\" (nonzero), \"**d**\"\n(dissatisfiable), and \"**u**\" (unit).\n\nThe following table lists the correctness requirements for each of the Miniscript expressions, and\nits type properties in function of those of their subexpressions.\n\n| Miniscript                   | Requires                                              | Type        | Properties\n|------------------------------|-------------------------------------------------------|-------------|-----------\n| `0`                          |                                                       | B           | z; u; d\n| `1`                          |                                                       | B           | z; u\n| `pk_k(key)`                  |                                                       | K           | o; n; d; u\n| `pk_h(key)`                  |                                                       | K           | n; d; u\n| `older(n)`, `after(n)`       | 1 &le; n &lt; 2<sup>31</sup>                          | B           | z\n| `sha256(h)`                  |                                                       | B           | o; n; d; u\n| `ripemd160(h)`               |                                                       | B           | o; n; d; u\n| `hash256(h)`                 |                                                       | B           | o; n; d; u\n| `hash160(h)`                 |                                                       | B           | o; n; d; u\n| `andor(X,Y,Z)`               | X is Bdu; Y and Z are both B, K, or V                 | same as Y/Z | z=z<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Y</sub>o<sub>Z</sub> or o<sub>X</sub>z<sub>Y</sub>z<sub>Z</sub>; u=u<sub>Y</sub>u<sub>Z</sub>; d=d<sub>Z</sub>\n| `and_v(X,Y)`                 | X is V; Y is B, K, or V                               | same as Y   | z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; u=u<sub>Y</sub>\n| `and_b(X,Y)`                 | X is B; Y is W                                        | B           | z=z<sub>X</sub>z<sub>Y</sub>; o=z<sub>X</sub>o<sub>Y</sub> or z<sub>Y</sub>o<sub>X</sub>; n=n<sub>X</sub> or z<sub>X</sub>n<sub>Y</sub>; d=d<sub>X</sub>d<sub>Y</sub>; u\n| `or_b(X,Z)`                  | X is Bd; Z is Wd                                      | B           | z=z<sub>X</sub>z<sub>Z</sub>; o=z<sub>X</sub>o<sub>Z</sub> or z<sub>Z</sub>o<sub>X</sub>; d; u\n| `or_c(X,Z)`                  | X is Bdu; Z is V                                      | V           | z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub>\n| `or_d(X,Z)`                  | X is Bdu; Z is B                                      | B           | z=z<sub>X</sub>z<sub>Z</sub>; o=o<sub>X</sub>z<sub>Z</sub>; d=d<sub>Z</sub>; u=u<sub>Z</sub>\n| `or_i(X,Z)`                  | both are B, K, or V                                   | same as X/Z | o=z<sub>X</sub>z<sub>Z</sub>; u=u<sub>X</sub>u<sub>Z</sub>; d=d<sub>X</sub> or d<sub>Z</sub>\n| `thresh(k,X_1,...,X_n)`      | 1 &le; k &le; n; X<sub>1</sub> is Bdu; others are Wdu | B           | z=all are z; o=all are z except one is o; d; u\n| `multi(k,key_1,...,key_n)`   | 1 &le; k &le; n &le; 20                               | B           | n; d; u\n| `multi_a(k,key_1,...,key_n)` | 1 &le; k &le; n                                       | B           | d; u\n| `a:X`                        | X is B                                                | W           | d=d<sub>X</sub>; u=u<sub>X</sub>\n| `s:X`                        | X is Bo                                               | W           | d=d<sub>X</sub>; u=u<sub>X</sub>\n| `c:X`                        | X is K                                                | B           | o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u\n| `d:X`                        | X is Vz                                               | B           | o; n; d; *(Tapscript only)* u\n| `v:X`                        | X is B                                                | V           | z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub>\n| `j:X`                        | X is Bn                                               | B           | o=o<sub>X</sub>; n; d; u=u<sub>X</sub>\n| `n:X`                        | X is B                                                | B           | z=z<sub>X</sub>; o=o<sub>X</sub>; n=n<sub>X</sub>; d=d<sub>X</sub>; u\n\n#### Timelock Type Mixing\n\nThere is one additional correctness property that Miniscript expressions must satisfy:\nthe four timelock types (absolute time based, absolute height based, relative time based, and\nrelative height based) must not be mixed in an incompatible way.\n\nWithin `and` combinators and the `thresh` combinator where k >= 2, it is illegal for both absolute\nheight based and time based timelocks to appear, or for both relative height based and time based\ntimelocks to appear.\n\nFor all other combinators, it is legal to mix timelock types. It is also always legal to\nmix absolute and relative timelocks (even if one is height based and the other is time based).\n\n#### Malleability\n\nMalleability is the ability for a third party (someone who does *not* hold a participating private\nkey) to modify an existing satisfaction into another valid satisfaction. To analyze the\nmalleability guarantees of a script we define three additional type properties: \"**s**\" (signed),\n\"**f**\" (forced) and \"**e**\" (expressive).\n\nThe following table lists the malleability properties and requirement of each fragment.\n\n| Miniscript                   | Requires                                                            | Properties\n|------------------------------|---------------------------------------------------------------------|-----------\n| `0`                          |                                                                     | s, e\n| `1`                          |                                                                     | f\n| `pk_k(key)`                  |                                                                     | s, e\n| `pk_h(key)`                  |                                                                     | s, e\n| `older(n)`                   |                                                                     | f\n| `after(n)`                   |                                                                     | f\n| `sha256(h)`                  |                                                                     |\n| `ripemd160(h)`               |                                                                     |\n| `hash256(h)`                 |                                                                     |\n| `hash160(h)`                 |                                                                     |\n| `andor(X,Y,Z)`               | e<sub>X</sub> and (s<sub>X</sub> or s<sub>Y</sub> or s<sub>Z</sub>) | s=s<sub>Z</sub> and (s<sub>X</sub> or s<sub>Y</sub>); f=f<sub>Z</sub> and (s<sub>X</sub> or f<sub>Y</sub>); e=e<sub>Z</sub> and (s<sub>X</sub> or f<sub>Y</sub>)\n| `and_v(X,Y)`                 |                                                                     | s=s<sub>X</sub> or s<sub>Y</sub>; f=s<sub>X</sub> or f<sub>Y</sub>\n| `and_b(X,Y)`                 |                                                                     | s=s<sub>X </sub>or s<sub>Y;</sub> f=f<sub>Xf</sub><sub>Y</sub> or s<sub>X</sub>f<sub>X</sub> or s<sub>Y</sub>f<sub>Y</sub>; e=e<sub>X</sub>e<sub>Y</sub>s<sub>X</sub>s<sub>Y</sub>\n| `or_b(X,Z)`                  | e<sub>Xe</sub><sub>Z </sub>and (s<sub>X</sub> or s<sub>Z</sub>)     | s=s<sub>X</sub>s<sub>Z</sub>; e\n| `or_c(X,Z)`                  | e<sub>X</sub> and (s<sub>X</sub> or s<sub>Z</sub>)                  | s=s<sub>X</sub>s<sub>Z</sub>; f\n| `or_d(X,Z)`                  | e<sub>X</sub> and (s<sub>X</sub> or s<sub>Z</sub>)                  | s=s<sub>X</sub>s<sub>Z</sub>; f=f<sub>Z</sub>; e=e<sub>Z</sub>\n| `or_i(X,Z)`                  | s<sub>X</sub> or s<sub>Z</sub>                                      | s=s<sub>X</sub>s<sub>Z</sub>; f=f<sub>X</sub>f<sub>Z</sub>; e=e<sub>X</sub>f<sub>Z</sub> or e<sub>Z</sub>f<sub>X</sub>\n| `thresh(k,X_1,...,X_n)`      | all are e; at most k are non-s                                      | s=at most k-1 are non-s; e=all are s\n| `multi(k,key_1,...,key_n)`   |                                                                     | s; e\n| `multi_a(k,key_1,...,key_n)` |                                                                     | s; e\n| `a:X`                        |                                                                     | s=s<sub>X</sub>; f=f<sub>X</sub>; e=e<sub>X</sub>\n| `s:X`                        |                                                                     | s=s<sub>X</sub>; f=f<sub>X</sub>; e=e<sub>X</sub>\n| `c:X`                        |                                                                     | s; f=f<sub>X</sub>; e=e<sub>X</sub>\n| `d:X`                        |                                                                     | s=s<sub>X</sub>; e\n| `v:X`                        |                                                                     | s=s<sub>X</sub>; f\n| `j:X`                        |                                                                     | s=s<sub>X</sub>; e=f<sub>X\n| `n:X`                        |                                                                     | s=s<sub>X</sub>; f=f<sub>X</sub>; e=e<sub>X</sub>\n\n### Satisfaction\n\nThe following table shows all valid satisfactions and dissatisfactions for every Miniscript, using\nsatisfactions and dissatisfactions of its subexpressions. Multiple possibilities are separated by\nsemicolons. Some options are inefficient and provably unnecessary to the satisfaction algorithm\ndescribed below, but are valid according to script rules and could be used by a malleator or other\nnon-standard actor. These are called *non-canonical* options, and are listed for completeness, but\n~~[struckthrough]~~. The fragments where a satisfaction or dissatisfaction does not exist will\ncontain *(none)*. The fragments where the satisfaction or dissatisfaction is to provide no data\nwill contain *(empty)*.\n\n| Miniscript                   | Dissatisfactions (dsat)                                 | Satisfactions (sat)\n|------------------------------|---------------------------------------------------------|--------------------\n| `0`                          | *(empty)*                                               | *(none)*\n| `1`                          | *(none)*                                                | *(empty)*\n| `pk_k(key)`                  | 0                                                       | sig\n| `pk_h(key)`                  | 0 key                                                   | sig key\n| `older(n)`                   | *(none)*                                                | *(empty)*\n| `after(n)`                   | *(none)*                                                | *(empty)*\n| `sha256(h)`                  | any 32-byte vector except the preimage                  | preimage\n| `ripemd160(h)`               | any 32-byte vector except the preimage                  | preimage\n| `hash256(h)`                 | any 32-byte vector except the preimage                  | preimage\n| `hash160(h)`                 | any 32-byte vector except the preimage                  | preimage\n| `andor(X,Y,Z)`               | dsat(Z) dsat(X); ~~[dsat(Y) sat(X)]~~                   | sat(Y) sat(X); sat(Z) dsat(X)\n| `and_v(X,Y)`                 | *(none)*; ~~[dsat(Y) sat(X)]~~                          | sat(Y) sat(X)\n| `and_b(X,Y)`                 | dsat(Y) dsat(X); ~~[sat(Y) dsat(X)]; [dsat(Y) sat(X)]~~ | sat(Y) sat(X)\n| `or_b(X,Z)`                  | dsat(Z) dsat(X)                                         | dsat(Z) sat(X); sat(Z) dsat(X); ~~[sat(Z) sat(X)]~~\n| `or_c(X,Z)`                  | *(none)*                                                | sat(X); sat(Z) dsat(X)\n| `or_d(X,Z)`                  | dsat(Z) dsat(X)                                         | sat(X); sat(Z) dsat(X)\n| `or_i(X,Z)`                  | dsat(X) 1; dsat(Z) 0                                    | sat(X) 1; sat(Z) 0\n| `thresh(k,X_1,...,X_n)`      | All dsats; ~~[Sats/dsats with 1 &le; #(sats) &ne; k]~~  | Sats/dsats with #(sats) = k\n| `multi(k,key_1,...,key_n)`   | 0 0 ... 0 (k+1 times)                                   | 0 sig ... sig\n| `multi_a(k,key_1,...,key_n)` | 0 ... 0 (n times); ~~[sig/0 with #(sig) &ne; k]~~        | sig/0 with #(sig) = k and #(sigs/0) = n\n| `a:X`                        | dsat(X)                                                 | sat(X)\n| `s:X`                        | dsat(X)                                                 | sat(X)\n| `c:X`                        | dsat(X)                                                 | sat(X)\n| `d:X`                        | 0                                                       | sat(X) 1\n| `v:X`                        | *(none)*                                                | sat(X)\n| `j:X`                        | 0; ~~[dsat(X) (if nonzero top stack)]~~                 | sat(X)\n| `n:X`                        | dsat(X)                                                 | sat(X)\n\n#### Non-malleable Satisfaction Algorithm\n\nIn order to produce non-malleable satisfactions we make use of a function that returns the optimal\nsatisfaction and dissatisfaction for a given expression (if any exist), or a special DONTUSE (\"don't use\") value,\ntogether with an optional HASSIG (\"has signature\") marker that tracks whether the solution contains at least one\nsignature. To implement the function:\n* Invoke the function recursively for all subexpressions, obtaining all their satisfactions/dissatisfactions.\n* Iterate over all the valid satisfactions/dissatisfactions in the table above (including the non-canonical ones), taking into account:\n  * The dissatisfactions for `sha256`, `ripemd160`, `hash256`, and `hash160` are always malleable, so instead use DONTUSE there.\n  * The non-canonical options for `and_b`, `or_b`, and `thresh` are always overcomplete, so instead use DONTUSE there as well (with HASSIG flag if the original non-canonical solution had one).\n  * The satisfactions for `pk_k`, `pk_h`, and `multi` can be marked HASSIG.\n  * When constructing solutions by combining results for subexpressions, the result is DONTUSE if any of the constituent results is DONTUSE. Furthermore, the result gets the HASSIG tag if any of the constituents does.\n* If among all valid solutions (including DONTUSE ones) more than one does not have the HASSIG marker, return DONTUSE.\n* If instead exactly one does not have the HASSIG marker, return that solution.\n* If all valid solutions have the HASSIG marker, but all of them are DONTUSE, return DONTUSE-HASSIG. The HASSIG marker is important because while this represents a choice between multiple options that would cause malleability if used, they are not available to the attacker, and we may be able to avoid them entirely still.\n* Otherwise, all not-DONTUSE options are valid, so return the smallest one (in terms of witness size).\n\nTo produce an overall satisfaction, invoke the function on the toplevel expression. If no valid\nsatisfaction is returned, or it is DONTUSE, fail. Otherwise, if any timelocking is used in the\nscript but the result does not have the HASSIG flag, also fail. If the satisfaction is both not\nDONTUSE and HASSIG, return it.\n\n\n## Discussion\n\n## Security\n\nMiniscript primarily aims to provide guarantees on the correctness of a Bitcoin Script. That is, to\nguarantee **consensus soundness** and **standardness completeness**. Consensus soundness means\nit is not possible to construct a consensus-valid witness for a Bitcoin Script unless the Miniscript\nspending conditions are met. Standardness completeness means a standardness-valid witness can be\ncreated for all spending paths of a Miniscript, assuming the resource limits are respected and there\nis no timelock mixing.\n\nAdditionally, Miniscript can guarantee the non-malleability and maximum size of a witness. These can\nassist in assessing the soundness of protocols where transaction fees (and therefore transaction\nsize) are security-critical parameters.\n\nHash preimages are constrained to 32 bytes to disallow various forms of griefing, including making\nnon-standard (un-relayable) transactions, consensus-invalid swaps across blockchains, as well as\nensure that satisfaction cost can be accurately calculated.\n\nIn order for these properties to not just apply to script, but to an entire transaction, it's\nimportant that the witness commits to all data relevant for verification. In practice this means\nthat scripts whose conditions can be met without any digital signature are insecure. Besides being\ntrivially insecure, note how a transaction lacking a signature check allows an attacker to change\nits nLockTime and nSequence fields to meet additional timelock conditions.\n\n### Type System\n\nTo statically verify the correctness and malleability guarantees discussed in the previous section,\nwe define a type system. See the specifications above for a reference of each fragment's\nrequirements and properties. Here we give more information about each type.\n\nEvery expression has one of four basic types:\n* \"**B**\" Base expressions. These take their inputs from the top of the stack. When satisfied, they push a nonzero value of up to 4 bytes onto the stack. When dissatisfied, they push an exact 0 onto the stack (if dissatisfaction without aborting is possible at all). This type is used for most expressions, and required for the top level expression. An example is `older(n)` = `<n> CHECKSEQUENCEVERIFY`.\n* \"**V**\" Verify expressions. Like \"B\", these take their inputs from the top of the stack. Upon satisfaction however, they continue without pushing anything. They cannot be dissatisfied (will abort instead). A \"V\" can be obtained using the `v:` wrapper on a \"B\" expression, or by combining other \"V\" expressions using `and_v`, `or_i`, `or_c`, or `andor`. An example is `v:pk(key)` = `<key> CHECKSIGVERIFY`.\n* \"**K**\" Key expressions. They again take their inputs from the top of the stack, but instead of verifying a condition directly they always push a public key onto the stack, for which a signature is still required to satisfy the expression. A \"K\" can be converted into a \"B\" using the `c:` wrapper. An example is `pk_h(key)` = `DUP HASH160 <Hash160(key)> EQUALVERIFY`.\n* \"**W**\" Wrapped expressions. They take their inputs from one below the top of the stack, and push a nonzero (in case of satisfaction) or zero (in case of dissatisfaction) either on top of the stack, or one below. So for example a 3-input \"W\" would take the stack \"A B C D E F\" and turn it into \"A B F 0\" or \"A B 0 F\" in case of dissatisfaction, and \"A B F n\" or \"A B n F\" in case of satisfaction (with n a nonzero value). Every \"W\" is either `s:B` (SWAP B) or `a:B` (TOALTSTACK B FROMALTSTACK). An example is `s:pk(key)` = `SWAP <key> CHECKSIG`.\n\nThen there are 6 type modifiers, which guarantee additional properties:\n* \"**z**\" Zero-arg: this expression always consumes exactly 0 stack elements.\n* \"**o**\" One-arg: this expression always consumes exactly 1 stack element.\n* \"**n**\" Nonzero: this expression always consumes at least 1 stack element, no satisfaction for this expression requires the top input stack element to be zero.\n* \"**d**\" Dissatisfiable: a dissatisfaction for this expression can unconditionally be constructed. This implies the dissatisfaction cannot include any signature or hash preimage, and cannot rely on timelocks being satisfied.\n* \"**u**\" Unit: when satisfied, this expression will put an exact 1 on the stack (as opposed to any nonzero value).\n* \"**k**\" No timelock mixing. This expression does not contain a mix of heightlock and timelock of the same type. If the miniscript does not have the \"k\" property, the miniscript template will not match the user expectation of the corresponding spending policy.\n\nFinally to analyze malleability guarantees we introduce 3 new type modifiers:\n* \"**s**\" Signed: satisfying this expression always requires a signature (predicting whether all satisfactions will be HASSIG).\n* \"**f**\" Forced: dissatisfying this expression always requires a signature (predicting whether all dissatisfactions will be HASSIG).\n* \"**e**\" Expressive: this requires a unique unconditional dissatisfaction to exist, and forces all conditional dissatisfactions (if any) to require a signature.\n\n\n### Malleability\n\nSince Segwit, malleating a transaction no longer breaks the validity of unconfirmed descendant\ntransactions. However, unintentional malleability may still have a number of much weaker undesirable\neffects. If a witness can be stuffed with additional data, the transaction's feerate will go down,\npotentially to the point where its ability to propagate and get confirmed is impacted. Additionally,\nmalleability can be exploited to add roundtrips to BIP152 block propagation, by trying to get\ndifferent miners to mine different versions of the same transaction. Finally, malleability may\ninterfere with the usage of hash locks as a mechanism for publishing preimages.\n\nUsing the malleability type properties it is possible to determine statically whether a script can\nbe non-malleably satisfied under all circumstances. In many cases it is reasonable to only accept\nsuch guaranteed-non-malleable scripts, as unexpected behavior can occur when using other scripts.\n\nFor example, when running the non-malleable satisfaction algorithm above, adding available\npreimages, or increasing the nLockTime/nSequence values actually may make it fail where it succeeded\nbefore. This is because a larger set of met conditions may mean an existing satisfaction goes from\nnon-malleable to malleable. Restricting things to scripts that are guaranteed to be satisfiable in a\nnon-malleable way avoids this problem.\n\nWhen analysing Miniscripts for resource limits, restricting yourself to just non-malleable solutions\n(or even non-malleable scripts) also leads to tighter bounds, as all non-canonical satisfactions and\ndissatisfactions can be left out of consideration.\n\nThe malleability analysis makes the following assumptions:\n* The attacker does not have access to any of the private keys of public keys that participate in the Script. Participants with private keys inherently have the ability to produce different satisfactions by creating multiple signatures. While it is also interesting to study the impact rogue participants can have, we treat it as a distinct problem.\n* The attacker only has access to hash preimages that honest users have access to as well. This is a reasonable assumption because hash preimages are revealed once globally, and then available to everyone. On the other hand, making the assumption that attackers may have access to more preimages than honest users makes a large portion of scripts impossible to satisfy in a non-malleable way.\n* The attacker gets to see exactly one satisfying witness of any transaction. If he sees multiple, it becomes possible for the attacker to mix and match different satisfactions. This is very hard to reason about.\n* We restrict this analysis to scripts where no public key is repeated. If signatures constructed for one part of the script can be bound to other checks in the same script, a variant of the mixing from the previous point becomes available that is equally hard to reason about. Furthermore this situation can be avoided by using separate keys.\n* The attacker is constrained by common standardness rules. A miner may be able to malleate a witness considered non-malleable by Miniscript.\n\n#### Non-Malleable Satisfaction\n\nMalleable satisfactions or dissatisfactions appear whenever options are available to attackers distinct from the one taken by honest users. This can happen for multiple reasons:\n1. Two or more options for a satisfaction or dissatisfaction are listed in the table above which are both available to attackers directly. Regardless of which option is used in the honest solution, the attacker can change the solution to the other one.\n2. Two or more options for a satisfaction or dissatisfaction are listed in the table above, only one of which is available to attackers, but the honest solution uses another one. In that case, the attacker can modify the solution to pick the one available to him.\n3. The honest users pick a solution that contains a satisfaction which can be turned into a dissatisfaction without invalidating the overall witness. Those are called overcomplete solutions.\n\nBecause we assume attackers never have access to private keys, we can treat any solution that\nincludes a signature as one that is unavailable to attackers. For others, the worst case is that the\nattacker has access to every solution the honest users have, but no others: for preimages this is an\nexplicit assumption, while timelock availability is determined by the nLockTime and nSequence fields\nin the transaction. As long as the overall satisfaction includes at least one signature, those\nvalues are fixed, and timelock availability is identical for attackers and honest users.\n\nThe description of the non-malleable satisfaction algorithm can be used to show that no\nnon-canonical solutions listed in the satisfaction table can occur inside non-malleable\nsatisfaction:\n* Some of the non-canonical options (the `or_b`, `and_b`, and `thresh` ones) are overcomplete, and thus can clearly not appear in non-malleable satisfactions.\n* The fact that non-\"d\" expressions cannot be dissatisfied in valid witnesses rules out the usage of the non-canonical `and_v` dissatisfaction.\n* \"d\" expressions are defined to be unconditionally dissatisfiable, which implies that for those a non-HASSIG dissatisfaction must exist. Non-HASSIG solutions must be preferred over HASSIG ones (reason 2), and when multiple non-HASSIG ones exist, none can be used (reason 1). This lets us rule out the other non-canonical options in the table:\n  * `j:X` is always \"d\", its non-HASSIG dissatisfaction \"0\" always exists, and thus rules out any usage of \"dsat(X)\".\n  * If `andor(X,Y,Z)` is \"d\", a non-HASSIG dissatisfaction \"dsat(Z) dsat(X)\" must exist, and thus rules out any usage of \"dsat(Y) sat(X)\".\n  * If `and_b(X,Y)` is \"d\", a non-HASSIG dissatisfaction \"dsat(Y) dsat(X)\" must exist, and thus rules out any usage of \"dsat(Y) sat(X)\" and \"sat(Y) dsat(X)\". Those are also overcomplete.\n  * `thresh(k,...)` is always \"d\", a non-HASSIG dissatisfaction with just dissatisfactions must exist due to typing rules, and thus rules out usage of the other dissatisfactions. They are also overcomplete.\n\n\n### Resource Limits\n\nVarious types of Bitcoin Scripts have different resource limitations, either through consensus or standardness. Some of them affect otherwise valid Miniscripts:\n* In P2WSH, scripts larger than 3600 bytes are invalid by standardness. In Tapscript, scripts are implicitly bounded by the maximum size of a block (1 million virtual bytes).\n* In P2WSH, script satisfactions where the total number of non-push opcodes plus the number of keys participating in all executed `CHECKMULTISIG` is above 201 are invalid by consensus.\n* In both Tapscript and P2WSH, script satisfactions which make the stack exceed 1000 elements before or during execution are invalid.\n* In P2WSH, satisfactions with a witness consisting of over 100 stack elements (excluding the script itself) are invalid by standardness.\n\nA static analysis can be performed on a Miniscript to verify if none, all or any of the spending\npaths hit any of the limits.\n\n\n## Test Vectors\n\nTBD\n\n## Backwards Compatibility\n\nMiniscript's syntax is compatible with BIP 380 Output Script Descriptors, and should be considered\nan extension to it that provides a new type of Script expression that is only valid in\n`wsh()` and `tr()` contexts. As these are wholly new expressions, they are not\ncompatible with any existing implementation of descriptors. Additionally, the scripts produced are\nunlikely to be standard scripts.\n\nThe `pk()`, `pkh()`, `multi()`, and `multi_a()`\nfragments overlap with existing descriptors. These parse to the same semantic meanings as those\ndescriptors and produce the same scripts.\n\n## Reference Implementation\n\nA first reference implementation and documentation for Miniscript in P2WSH was originally published at\nhttps://github.com/sipa/miniscript .\n\nThe reference implementation for Miniscript in P2WSH was introduced in Bitcoin Core through PRs\n[24147](https://github.com/bitcoin/bitcoin/pull/24147), [24148](https://github.com/bitcoin/bitcoin/pull/24148), and\n[24149](https://github.com/bitcoin/bitcoin/pull/24149). The last one to be merged was released in Bitcoin\nCore version 25.0.\n\nThe reference implementation for Miniscript in Tapscript was introduced in Bitcoin Core in PR\n[27255](https://github.com/bitcoin/bitcoin/pull/27255). This PR was merged and released in Bitcoin Core\nversion 26.0.\n", "content_length": 37981}
{"bip_number": 349, "filename": "bip-0349.md", "content": "```\n  BIP: 349\n  Layer: Consensus (soft fork)\n  Title: OP_INTERNALKEY\n  Author: Brandon Black <freedom@reardencode.com>\n          Jeremy Rubin <j@rubin.io>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0349\n  Status: Draft\n  Type: Standards Track\n  Created: 2024-11-14\n  License: BSD-3-Clause\n```\n\n## Abstract\n\nThis BIP describes a new tapscript opcode (`OP_INTERNALKEY`) which\npushes the _taproot internal key_ to the stack.\n\n## Specification\n\nWhen verifying taproot script path spends having leaf version `0xc0` (as\ndefined in [BIP 342]), `OP_INTERNALKEY` replaces `OP_SUCCESS203` (0xcb).\n`OP_INTERNALKEY` pushes the 32-byte x-only representation of the _taproot\ninternal key_ (referred to as _p_), as defined in [BIP 341], to the stack.\n\n## Motivation\n\n### Key spend with additional conditions\n\nWhen building taproot outputs, especially those secured by an aggregate key\nrepresenting more than one signer, the parties may wish to collaborate on\nsigning with the _taproot internal key_, but only with additional script\nrestrictions. In this case, `OP_INTERNALKEY` saves 8 vBytes.\n\n### Mitigated control block overhead for scripts using hash locks\n\nIn cases where key path spending is not desired, the internal key may be set to\na NUMS point whose bytes would otherwise be required in a tapscript. This could\nbe used with any hash locked transaction, for example, to save 8 vBytes.\n\nNote: The internal key must be the X coordinate of a point on the SECP256K1\ncurve, so any such hash must be checked and modified until it is such an X\ncoordinate. This will typically take approximately 2 attempts.\n\n### Re-Keying with Merkle Root Preservation\n\nConsider a program such `CTV <X> CSFS <S+1> CLTV`. Such fragments are useful for LN-Symmetry applications.\n\nSuch a program would be embedded within a Taproot script path, such as `TR(X, {CTV <X> CSFS <S+1> CLTV})`.\n\nWere the internal key to be updated from `X` to `Y`, the resulting program would be: `TR(Y, {CTV <X> CSFS <S+1> CLTV})`.\n\nThe key in the leaf and the key-path would be mismatched. Were `OP_INTERNALKEY` to be used,\nthe leaf would automatically re-key.\nE.g., `TR(X, {CTV OP_INTERNALKEY CSFS <S+1> CLTV})` is equivalent to `TR(X, {CTV <X> CSFS <S+1> CLTV})`\nand `TR(Y, {CTV OP_INTERNALKEY CSFS <S+1> CLTV})` is equivalent to `TR(Y, {CTV <Y> CSFS <S+1> CLTV})`.\n\nWhile this particular example is contrived, the general technique of using `OP_INTERNALKEY`\nas updatable across an entire script tree is a helpful covenant primitive when it is desirable to\ninvalidate signatures from prior states. For example, the theoretical `OP_TAPLEAFUPDATEVERIFY` opcode\nmodifies the internal key directly to remove or add a participant, and `OP_INTERNALKEY` would ensure\nthat the tweaked key is used from all script paths where desired.\n\n## Reference Implementation\n\nA reference implementation is provided here:\n\nhttps://github.com/bitcoin/bitcoin/pull/29269\n\n## Backward Compatibility\n\nBy constraining the behavior of an OP_SUCCESS opcode, deployment of the BIP\ncan be done in a backwards compatible, soft-fork manner. If anyone were to\nrely on the OP_SUCCESS behavior of `OP_SUCCESS203`, `OP_INTERNALKEY` would\ninvalidate their spend.\n\n## Deployment\n\nTBD\n\n## Credits\n\nThe concept for INTERNALKEY first arose in a [discussion](https://gnusha.org/bitcoin-wizards/2022-01-05.log) between Russell O'Connor\nand Jeremy Rubin in Bitcoin Wizards IRC, inspired by BIP-0118's key punning technique\nfor the internal key. It was later\ndrafted into this BIP by Brandon Black.\n\n\n## Copyright\n\nThis document is licensed under the 3-clause BSD license.\n\n[BIP 341]: https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki\n\n[BIP 342]: https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki\n", "content_length": 3750}
{"bip_number": 348, "filename": "bip-0348.md", "content": "```\n  BIP: 348\n  Layer: Consensus (soft fork)\n  Title: CHECKSIGFROMSTACK\n  Author: Brandon Black <freedom@reardencode.com>\n          Jeremy Rubin <j@rubin.io>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0348\n  Status: Draft\n  Type: Standards Track\n  Created: 2024-11-26\n  License: BSD-3-Clause\n```\n\n## Abstract\n\nThis BIP describes a new opcode for the purpose of checking cryptographic\nsignatures in bitcoin scripts against data from the stack.\n\n## Summary\n\nWhen verifying taproot script spends having leaf version 0xc0 (as defined in\n[BIP 342]), we propose `OP_CHECKSIGFROMSTACK` to replace `OP_SUCCESS204`\n(0xcc).\n\n`OP_CHECKSIGFROMSTACK` has semantics similar to `OP_CHECKSIG`, as specified\nbelow. Briefly, it pops 3 elements from the stack: a 32-byte public key, a\nmessage, and a signature. If the signature is valid for that public key and\nmessage, 1 is pushed to the stack. If the signature is the empty vector, 0 is\npushed to the stack, and otherwise script execution fails.\n\nOnly 32-byte keys are constrained. Similar to [BIP 342] unknown key types, for\nother key lengths no signature verification is performed and it is considered\nsuccessful.\n\n## Specification\n\n* If fewer than 3 elements are on the stack, the script MUST fail and terminate immediately.\n* The public key (top element), message (second to top element), and signature (third from top element) are read from the stack.\n* The top three elements are popped from the stack.\n* If the public key size is zero, the script MUST fail and terminate immediately.\n* If the public key size is 32 bytes, it is considered to be a public key as described in [BIP 340]:\n    * If the signature is not the empty vector, the signature is validated against the public key and message according to [BIP 340]. Validation failure in this case immediately terminates script execution with failure.\n* If the public key size is not zero and not 32 bytes; the public key is of an unknown public key type. Signature verification for unknown public key types succeeds as if signature verification for a known public key type had succeeded.\n* If the script did not fail and terminate before this step, regardless of the public key type:\n    * If the signature is the empty vector: An empty vector is pushed onto the stack, and execution continues with the next opcode.\n    * If the signature is not the empty vector:\n        * The opcode is counted towards the sigops budget as described in [BIP 342].\n        * A 1-byte value 0x01 is pushed onto the stack.\n\n## Design Considerations\n\n1. Message hashing: [BIP 340] is compatible with any size of message and does not require it to be a securely hashed input, so the message is not hashed prior to [BIP 340] verification.\n2. Lack of verify semantics: Adding a single opcode for this purpose keeps the implementation and design simple. An earlier draft had a verify variant as a NOP upgrade, and if this functionality is later brought to legacy scripts, that would be a good time to add a verify variant.\n3. Add/multisig: No concession is made to `OP_CHECKMULTISIG` or `OP_CHECKSIGADD` semantics with `OP_CHECKSIGFROMSTACK`. In Tapscript, add semantics can be implemented with 1 additional vByte per key (`OP_TOALTSTACK OP_CHECKSIGFROMSTACK OP_FROMALTSTACK OP_ADD`).\n4. Splitting R/S on the stack: Implementing split/separate signatures is left as an exercise for other bitcoin upgrades, such as [BIP 347] (`OP_CAT`).\n5. APO-style ([BIP 118]) Taproot internal key: Rather than introducing an additional key type in this change, we suggest implementing `OP_INTERNALKEY` ([BIP 349]) or separately introducing that key type for all Tapscript signature checking operations in a separate change.\n\n## Resource Limits\n\nThese opcodes are treated identically to other signature checking opcodes and\ncount against the sigops and budget.\n\n## Motivation\n\n### LN Symmetry\n\nWhen combined with [BIP 119] (`OP_CHECKTEMPLATEVERIFY`/CTV),\n`OP_CHECKSIGFROMSTACK` (CSFS) can be used to implement Lightning Symmetry\nchannels. The construction `OP_CHECKTEMPLATEVERIFY <pubkey>\nOP_CHECKSIGFROMSTACK` with a spend stack containing the CTV hash and a\nsignature for it is logically equivalent to `<bip118_pubkey> OP_CHECKSIG` and\na signature over `SIGHASH_ALL|SIGHASH_ANYPREVOUTANYSCRIPT`. The\n`OP_CHECKSIGFROMSTACK` construction is 8 vBytes larger.\n\nSummary of alternatives:\n* CTV+CSFS is the minimal functionality needed for Lightning Symmetry but requires the use of an `OP_RETURN` for data availability\n* APO is the original design for Lightning Symmetry and uses the taproot annex for data availability.\n* LNHANCE (CTV+CSFS+IKEY+PC) is the most efficient and direct way currently designed to implement Lightning Symmetry.\n\n### Delegation\n\nUsing a script like:\n`<pubkey> SWAP IF 2 PICK SWAP CSFS VERIFY ENDIF CHECKSIG`\neither direct verification or delegation can be achieved by the following\nunlock stacks: `<sig> 0` or `<dsig> <dpubkey> <sig> 1`\n\n### Advanced delegation when combined with [OP_PAIRCOMMIT] or OP_CAT\n\nUsing a script like:\n`CLTV OVER PAIRCOMMIT TOALT CHECKSIGVERIFY FROMALT <pubkey> CSFS`\nor:\n`CLTV SHA256 OVER CAT TOALT CHECKSIGVERIFY FROMALT <pubkey> CSFS`\nwith the unlock stack:\n`<sig> <delegate_sig> <delegate_pubkey> <locktime>`\n\nDelegates to a public key after a lock time, enabling delegation to various\nkeys after various associated times.\n\n## Reference Implementation\n\nA reference implementation is provided here:\n\nhttps://github.com/bitcoin/bitcoin/pull/29270\n\n## Backward Compatibility\n\nBy constraining the behavior of an OP_SUCCESS opcode,\ndeployment of the BIP can be done in a backwards compatible, soft-fork manner.\nIf anyone were to rely on the OP_SUCCESS behavior of\n`OP_SUCCESS204`, `OP_CHECKSIGFROMSTACK` would invalidate\ntheir spend.\n\n## Deployment\n\nTBD\n\n## Credits\n\nReference implementation was made with reference to the implementation in\nElements and started by moonsettler.\n\n## Copyright\n\nThis document is licensed under the 3-clause BSD license.\n\n[BIP 119]: https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki\n\n[BIP 118]: https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki\n\n[BIP 340]: https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n\n[BIP 342]: https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki\n\n[BIP 349]: https://github.com/bitcoin/bips/blob/master/bip-0349.md\n\n[BIP 347]: https://github.com/bitcoin/bips/blob/master/bip-0347.mediawiki\n\n[OP_PAIRCOMMIT]: https://github.com/bitcoin/bips/pull/1699\n\n[mailing list]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019192.html\n", "content_length": 6577}
{"bip_number": 77, "filename": "bip-0077.md", "content": "```\n  BIP: 77\n  Layer: Applications\n  Title: Async Payjoin\n  Author: Dan Gould <d@ngould.dev>\n          Yuval Kogman <nothingmuch@woobling.org>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0077\n  Status: Draft\n  Type: Standards Track\n  Created: 2023-08-08\n  License: BSD-2-Clause\n  Post-History: https://github.com/bitcoin/bips/pull/1483\n                https://gnusha.org/pi/bitcoindev/7B11AE34-27A7-46ED-95BF-66CA13BA26F3@ngould.dev/#t\n                https://gnusha.org/pi/bitcoindev/3C0A6E4C-444E-4E75-829C-1A21D8EE40E0@ngould.dev/#t\n  Requires: 21, 78, 173, 174\n```\n\n## Copyright\n\nThis BIP is licensed under the 2-clause BSD license.\n\n## Abstract\n\nPayjoin lets Bitcoin senders and receivers interact to make batched\ntransactions.\n\nThis document proposes a second, backwards-compatible, asynchronous version of\nthe Payjoin protocol (\"Version 2\") relative to and described in [BIP 78](bip-0078.mediawiki) (\"Version 1\"). An untrusted\nthird-party \"directory server\" replaces the requirement\nfor a receiver to host a secure public endpoint for interactions. HTTP clients\naccess the directory server using an asynchronous protocol and authenticated,\nencrypted payloads. The design preserves complete Payjoin receiver\nfunctionality, including payment\noutput substitution. Authenticated encryption depends only on cryptographic\nprimitives available in Bitcoin Core. Requests use [Oblivious\nHTTP](https://www.ietf.org/rfc/rfc9458.html) (OHTTP) to\nprevent the directory and other Payjoin clients from linking requests to client\nIP addresses.\n\n## Motivation\n\nSatoshi Nakamoto pointed out one specific privacy risk in the\n[whitepaper](https://bitcoin.org/en/bitcoin-paper),\nthat transactions with multiple inputs \"necessarily reveal that\ntheir inputs were owned by the same owner.\"\nPayjoin addresses that risk, the _common-input-ownership heuristic_,\nby making it practical to spend inputs owned by multiple parties\nin one transaction.\n\nWhile addressing Bitcoin's primal privacy risk, Payjoin *input* batching\nalso improves on the widespread non-interactive *output* batching practice\ndeployed by exchanges. When combined, the same movement of funds can use\nless block weight and save fees.\n\nA natural application of Payjoin would be to combine\ngetting paid with consolidating UTXOs into one transaction. But Payjoin\ncan also secure [transaction\ncut-through](https://bitcointalk.org/index.php?topic=281848.0),\nallowing a sender to transfer funds to a receiver who also transfers\nfunds to a third party in the same transaction. For example, deposits to an\nexchange may \"cut through\" in a single transaction that also satisfies\nwithdrawals instead of with a second transaction that spends the deposited\nfunds. Payjoin enables more blockspace-efficient transactions that\nreduce fees while addressing privacy risks.\n\nHowever, BIP 78's requirements for Payjoin Version 1 have proven to be an\nobstacle to adoption. Version 1 receivers must host a secured\npublic-facing HTTP server. Mobile and web environments limit the ability\nto fulfil such a requirement. Version 1 also requires synchronous\ncommunication. Both sender and receiver must be online simultaneously.\nWallet developers [\nregard](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-January/018358.html)\nthese requirements as barriers to Payjoin adoption.\n\nTo address these limitations, our goal is to specify a practical\ncoordination mechanism suitable for widespread implementation. This proposal\nleverages mature solutions to common problems, building on established web\nstandards and proven Bitcoin primitives.\n\n## Overview\n\nA Payjoin *sender* and *receiver* interact so that they may both contribute to a\ntransaction. In this proposal, they exchange asynchronous end-to-end\nencrypted messages by relaying them to a store-and-forward *directory* server\nusing OHTTP.\n\nBefore initiating the protocol, the receiver must secure communications with\nthe directory by [bootstrapping](#ohttp-bootstrapping).\n\n- The receiver [initiates a Payjoin Session](#session-initiation)\n  by sharing a [Payjoin URI](#payjoin-uri) that includes the URL of an\n  ephemeral mailbox hosted on the directory, where it can receive a message\n  from the sender.\n- The sender [posts a message](#sender-original-psbt-messaging)\n  containing a fully signed fallback transaction, known as the *Original PSBT*,\n  to the mailbox.\n- The receiver gets this message and\n  [posts a message containing a *Proposal\n  PSBT*](#receiver-proposal-psbt-messaging)\n  to the sender's ephemeral mailbox, by updating the Original PSBT with\n  appropriate inputs and/or outputs.\n- The sender gets the Proposal PSBT, [checks it, signs, and\n  broadcasts](#sender-signing-and-broadcast) the final transaction.\n\nAt any point, either party may choose to broadcast the\nfallback transaction described by the Original PSBT instead of proceeding.\nBecause the Original PSBT and Proposal PSBT spend the same input(s) they are\nmutually exclusive and only one can be confirmed.\n\nMessages are buffered in the directory, allowing both parties to tolerate\ntemporary disconnections and resume communication by polling.\n\n### Sequence Diagram\n\n```mermaid\nsequenceDiagram\n    title Async Payjoin Sequence Diagram\n    participant R as Receiver\n    participant D as Directory\n    participant S as Sender\n    participant N as Network\n\n    R-)S:  Payjoin URI (BIP 21) out of band\n    \n    R-->>D: Poll GET Requests<br/>for Original PSBT\n    activate D\u00a0\n    S->>D: POST Request<br/>Original PSBT\n    D->>R: GET Response<br/>Original PSBT\n    deactivate D\n\n    S-->>D: Poll GET Requests<br/>for Proposal PSBT\n    activate D\n    R->>D: POST Request<br/>Proposal PSBT\n    D->>S: GET Response<br/>Proposal PSBT\n    deactivate D\n\n    S->>N: Broadcast Payjoin\n```\n\n## Specification\n\n### OHTTP Bootstrapping\n\nBefore initiating a Payjoin Session a receiver must first discover the\ndirectory's\n[OHTTP Key Configuration](https://www.ietf.org/rfc/rfc9458.html#section-3.1),\nvia an authenticated\nbootstrap mechanism. The key configuration contains information to establish\n[Hybrid Public Key Encryption](#secp256k1-hybrid-public-key-encryption) (HPKE) in order to secure communications between the client and the directory in\nlieu of TLS.\n\nThe bootstrap mechanism may vary by implementation but must\nfollow [OHTTP Consistency\nRequirements](https://datatracker.ietf.org/doc/html/draft-ietf-privacypass-key-consistency-01)\nand should not reveal a receiver IP address to the directory. Some\nexamples of suitable mechanisms include getting a key configuration\nfrom a Payjoin URI, a trusted application binary, or fetching using https-in-http\nCONNECT method, https-in-WebSocket, Tor, or a VPN.\n\nDirectory OHTTP Gateways MUST support [RFC 9540 Key Configuration\nFetching](https://www.rfc-editor.org/rfc/rfc9540.html#name-key-configuration-fetching)\nvia GET request. RFC 9540 defines the\ngateway location as `/.well-known/ohttp-gateway`.\n\n### Session Initiation\n\nA receiver initiates a session by sharing a Payjoin URI. Because a URI\ncontains sensitive information, such as a receiver address, it should be shared\nover a confidential channel.\n\n#### Payjoin URI\n\nBitcoin URIs ([BIP\n21](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)\nor [BIP\n321](https://github.com/bitcoin/bips/blob/master/bip-0321.mediawiki))\nare a standard way to request bitcoin.\n\nA Payjoin URI is a Bitcoin URI that contains a `pj` parameter. The `pj`\nparameter value is a URL in both BIP 78 and BIP 77.\n\nSenders that understand Bitcoin URI but don't support Payjoin will just\nignore the `pj` parameter and proceed to typical address-based\ntransaction flows.\n\nA `req-pj` parameter may be used as a [BIP 21 forwards compatibility `reqparam`](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki#forward-compatibility) instead of\n`pj` to signal that Payjoin is required.\n\nThe parameter value must be [uppercased and the parameter should be placed last in the URI](#uppercase-url).\n\nSince BIP 78 payloads are neither encrypted nor authenticated,\na directory used for backwards-compatible payloads is known\nas an [\"unsecured payjoin server\" in BIP 78\nparlance](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#unsecured-payjoin-server).\nBackwards-compatible receivers MUST disable output substitution\nby setting `pjos=0` to prevent modification by a malicious directory.\n\n##### Mailbox endpoint\n\nIn this proposal the URL in the `pj` parameter value is the mailbox\nendpoint URL. Mailboxes are shared HTTP resources hosted by the\ndirectory and serve as OHTTP Target Resources. Clients use these endpoints\nto relay encrypted messages. They `POST` messages to and `GET` messages from\nmailbox endpoints via OHTTP.\n\nSenders that support BIP 78 but not this proposal may POST messages directly to\nmailbox endpoints for [backwards compatibility](#backwards-compatibility).\n\n###### Short ID\n\nA Short ID identifies a mailbox based on its associated public key. The Short\nID is the path component of the mailbox endpoint. One is derived by hashing the\n33-byte compressed public key encoding with SHA-256, truncating it to\n[8 bytes (64 bits)](#64-bit-short-id-length), and encoding it in\n[uppercase](#uppercase-url) using the bech32 character set (like a bech32 string without the HRP, separator and checksum).\n\n##### Receiver fragment parameters\n\nThis proposal introduces session-specific parameters which the\nreceiver shares encoded in the URI.\n\nInstead of defining new Bitcoin URI parameters, the session-specific\nparameters are encoded in the [\nfragment](https://datatracker.ietf.org/doc/html/rfc3986#section-3.5)\nof the mailbox endpoint URL.\n\nThe `#` fragment separator character must be [RFC 3986\npercent-encoded](https://datatracker.ietf.org/doc/html/rfc3986#section-2.1)\nas `%23`,\u00a0because\u00a0it\u00a0separates the\nfragment\u00a0of\u00a0the\u00a0mailbox\u00a0endpoint\u00a0URL\u00a0included\u00a0in\u00a0the `pj` parameter, not the\nfragment of the Bitcoin URI.\n\nThese session-specific parameters use a bech32-inspired encoding.\nThe HRP is used as the parameter key, followed by the '1' separator,\nfollowed by the parameter value encoded using the bech32 character set in\n[uppercase](#uppercase-url). No checksum is used. Parameters are separated\nby a `-` character.\n\nThe following parameters are defined, and must be provided in lexicographical\norder:\n\n- `EX`: specifies a [session\n  expiration](#session-expiration) in [unix\n  time](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16).\n- `OH`: encodes an alternate format of the OHTTP Key Configuration of\n  the directory. It consists of a 33-byte compressed public key of the\n  directory's OHTTP Gateway, prefixed by the 2-byte Key Identifier. A [\n  RFC 9458 Key\n  Configuration](https://www.ietf.org/rfc/rfc9458.html#section-3.1)\n  is reconstructed by assuming the HPKE KEM ID and Symmetric Algorithms\n  are [fixed](#secp256k1-hybrid-public-key-encryption).\n- `RK`: encodes the *receiver key* as a 33-byte compressed public key.\n  Senders will initiate HPKE with the receiver using this key.\n\nFor example, a properly encoded endpoint Bitcoin URI looks like this\n`bitcoin:tb1q6q6de88mj8qkg0q5lupmpfexwnqjsr4d2gvx2p?amount=0.00666666&pjos=0&pj=HTTPS://PAYJO.IN/TXJCGKTKXLUUZ%23EX1WKV8CEC-OH1QYPM59NK2LXXS4890SUAXXYT25Z2VAPHP0X7YEYCJXGWAG6UG9ZU6NQ-RK1Q0DJS3VVDXWQQTLQ8022QGXSX7ML9PHZ6EDSF6AKEWQG758JPS2EV`\n\nUntil 2026 implementations SHOULD also accept `+` as a fragment parameter\nseparator and not enforce parameter ordering requirements, for compatibility\nwith the [previous version of this document](#changelog).\n\n### Sender Original PSBT Messaging\n\nThe sender constructs the fallback transaction, a typical transaction\nspending funds to the receiver's address specified in the Payjoin URI.\nThis transaction is serialized as a BIP 174 PSBTv0, satisfying\n[the receiver checklist](#receivers-original-psbt-checklist).\n\nThe Original PSBT MUST:\n\n- Include complete UTXO data.\n- Be fully signed.\n- Exclude unnecessary fields such as global xpubs or keypath\n  information.\n- Be broadcastable.\n\nThe Original PSBT MAY:\n\n- Include outputs unrelated to the sender-receiver transfer for batching\n  purposes.\n\nThis *Original PSBT* is encoded as base64, followed by the query\nparameter string on a new line containing [optional sender\nparameters](#optional-sender-parameters).\n\nThe sender generates an ephemeral mailbox key. The corresponding public key is\nknown as the *reply key*, and it is prepended to the base64 plaintext string,\nserialized in compressed form as 33 bytes.\n\nThis plaintext string is encrypted to the receiver key according to [HPKE Base\nmode](https://www.rfc-editor.org/rfc/rfc9180.html#name-encryption-to-a-public-key).\nThe HPKE `info` string, used for domain separation, is `PjV2MsgA`. The\nciphertext ensures message secrecy and integrity when passed to the receiver\nusing the mailbox endpoint. The 16-byte authentication tag is appended to the\nciphertext.\n\nRFC 9180 [does not\nspecify](https://www.rfc-editor.org/rfc/rfc9180.html#section-10) the wire format\nencoding of HPKE messages. To construct an HPKE payload, the secp256k1 public\nkey from the DHKEM is encoded using ElligatorSwift in 64 bytes. Note that\nElligatorSwift is only the wire format; when deriving shared secrets, the curve\npoint is re-serialized in uncompressed form.\n\n```\nPjV2MsgA Byte Representation (7168 bytes total)\n+---------------------------------------------------------------------------------------+\n| ElligatorSwift |                             Ciphertext                               |\n|   (64 bytes)   |                            (7104 bytes)                              |\n|                +-----------------------+---------------------------------+------------+\n|                |       Reply Key       |         Padded Plaintext        |  AEAD Tag  |\n|                |       (33 bytes)      |   (7055 bytes = 7168-64-33-16)  | (16 bytes) |\n+---------------------------------------------------------------------------------------+\n```\n\nThe resulting HPKE payload is the body of a POST request to the\nreceiver's mailbox. This request is then [\nencapsulated](#clientdirectory-interactions) according to\nOblivious HTTP to the directory's OHTTP Gateway. OHTTP serializes the\ninner request as BHTTP, and provides another layer of HPKE encryption,\nbetween the client and directory.\n\nUpon receipt, the directory's OHTTP Gateway decapsulates the OHTTP\nrequest and handles the inner POST request at the receiver's mailbox\nendpoint, which stores the HPKE encrypted payload to be forwarded to the\nreceiver.\n\nThe sender then polls OHTTP encapsulated GET requests to the sender's\nmailbox endpoint until it receives a response from the directory\ncontaining the receiver's *Proposal PSBT*, and proceeds to\n[sign and broadcast](#sender-signing-and-broadcast).\nIt stops polling after expiration.\n\n#### Optional sender parameters\n\n[BIP 78's optional sender parameters](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#optional-parameters)\nmay be used in this proposal, but must be included in\nthe body as part of the ciphertext rather than as a query string.\n\nHPKE binds ciphertexts to application-specific `info` strings. Because\nof this domain separation, BIP 78's `v` parameter is redundant and\nshould be omitted for this proposal.\n\n### Receiver Proposal PSBT Messaging\n\nAfter sharing the Payjoin URI with the sender, the receiver polls via\nOHTTP encapsulated GET requests to the receiver's mailbox endpoint. So\nlong as the mailbox contains no message, the directory responds with\nstatus 202 ACCEPTED. Once a mailbox contains a message, the directory\nreturns it in the response body with status 200 OK.\n\nUpon receiving an encapsulated 200 OK response, the receiver decrypts\nthe payload and checks the *Original PSBT* therein according to the\n[receiver checklist](#receivers-original-psbt-checklist).\n\nThe receiver then updates the *Original PSBT* to include new signed\ninputs and outputs, invalidating the sender's signature(s). The receiver\nmay also adjust the transaction fee. The result, called the *Proposal\nPSBT*, must satisfy the [sender checklist](#senders-proposal-psbt-checklist)\n\nThe Proposal PSBT MUST:\n\n- Include complete UTXO data.\n- Include all inputs from the Original PSBT.\n- Include all outputs which do not belong to the receiver from the\n  Original PSBT.\n- Use a random index if additional inputs or outputs are added.\n\nThe Proposal PSBT sender MAY:\n\n- Add inputs at random indices.\n- Add outputs at random indices.\n- Remove or modify Original PSBT outputs under the control of the\n  receiver (i.e. not sender change).\n\nThe Proposal PSBT MUST NOT:\n\n- Shuffle the order of inputs or outputs contained in the Original PSBT.\n- Decrease the absolute fee of the Original PSBT.\n\nThe receiver encrypts the *Proposal PSBT* to the sender's reply key according to\n[HPKE Auth\nmode](https://www.rfc-editor.org/rfc/rfc9180.html#name-authentication-using-an-asy),\nusing the receiver's key for authentication. The HPKE `info` string is\n`PjV2MsgB`. The HPKE wire format is the same as in the [sender's\nmessage](#sender-original-psbt-messaging).\n\n```\nPjV2MsgB Byte Representation (7168 bytes total)\n+---------------------------------------------------------------------------------------+\n| ElligatorSwift |                             Ciphertext                               |\n|   (64 bytes)   |                            (7104 bytes)                              |\n|                +---------------------------------------------------------+------------+\n|                |           Padded Plaintext                              |  AEAD Tag  |\n|                |       (7088 bytes = 7168-64-16)                         | (16 bytes) |\n+---------------------------------------------------------------------------------------+\n```\n\nThe receiver makes the resulting HPKE payload the body of a POST request to the\nsender's mailbox whose Short ID is derived from the sender's reply key. This request is then [\nencapsulated](#clientdirectory-interactions) according to\nOblivious HTTP to the directory's OHTTP Gateway. OHTTP serializes the\ninner request as BHTTP, and provides another layer of HPKE encryption,\nbetween the client and directory.\n\nOnce the receiver makes this request, they wait for either transaction from the\nOriginal PSBT or Proposal PSBT to be broadcast to the Bitcoin network.\n\n#### Receiver's Original PSBT checklist\n\nThe receiver checklist is the same as [the BIP 78 receiver\nchecklist](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#receivers-original-psbt-checklist).\n\n### Sender signing and broadcast\n\nThe sender validates the *Proposal PSBT* it receives against a\nchecklist. If the checks pass, it may sign and broadcast the resulting\nPayjoin transaction.\n\n#### Sender's Proposal PSBT checklist\n\nThis proposal's sender checklist is the same as [the BIP 78 sender\nchecklist](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#senders-payjoin-proposal-checklist).\n\n### Client/Directory interactions\n\nThe Payjoin Directory provides a rendezvous point for senders and\nreceivers to exchange messages. The directory stores Payjoin payloads to\nsupport asynchronous communication. Async Payjoin requests must be\nsubmitted as encapsulated messages to the directory's OHTTP Gateway.\n\nThe wire format OHTTP request is specified in [RFC\n9458](https://www.ietf.org/rfc/rfc9458.html#name-hpke-encapsulation). HPKE\nrequires the directory's OHTTP key configuration. The plaintext is a binary\nencoded HTTP request ([RFC 9292](https://www.rfc-editor.org/rfc/rfc9292.html))\nintended for the OHTTP target resource, usually a mailbox endpoint, padded to\n8104 bytes with [random data](#random-padding).\n\n```\nOHTTP Encapsulated Request Byte Representation (8192 bytes total)\n+--------------+-------------------------+------------------------------------------+\n| OHTTP Header |         HPKE KEM        |               Ciphertext                 |\n|  (7 bytes)   | Uncompressed Public Key |        (8120 bytes = 8192-65-7)          +\n|              |        (65 bytes)       +-----------------------------+------------+\n|              |                         |     Padded BHTTP Request    |  AEAD Tag  |\n|              |                         | (8104 bytes = 8192-65-16-7) | (16 bytes) |\n+--------------+-------------------------+------------------------------------------+\n```\n\nResponse encryption uses the Export functionality of the request HPKE context to\nestablish a shared secret, and therefore consists of a 32 byte nonce followed by\nthe AEAD ciphertext and tag.\n\n```\nOHTTP Encapsulated Response Byte Representation (8192 bytes total)\n+---------------------+------------------------------------------+\n|        Nonce        |               Ciphertext                 |\n|      (32 bytes)     |          (8160 bytes = 8192-32)          +\n|                     +-----------------------------+------------+\n|                     |     Padded BHTTP Response   |  AEAD Tag  |\n|                     |   (8144 bytes = 8192-32-16) | (16 bytes) |\n+---------------------+------------------------------------------+\n```\n\nGET requests on an empty mailbox should block until a message is posted\nor a timeout occurs. The timeout should be 30 seconds because that will\nnot exceed the default timeout for most HTTP clients.\n\nThe directory may optionally accept HTTP/1.1 POST requests without OHTTP\nto mailbox endpoint URLs for backwards compatibility with BIP 78 senders.\n\n#### OHTTP Sequence Diagram\n\n```mermaid\nsequenceDiagram\n  title OHTTP Sequence Diagram\n  participant C as Client\n  participant R as OHTTP Relay\n\n  box PaleVioletRed Payjoin Directory\n    participant G as OHTTP Gateway\n    participant D as HTTP Resource\n  end\n\n  C->>R: Relay Request<br/>FROM: Client IP<br/>[+ Encapsulated Request]\n  R->>G: Gateway Request<br/>FROM: Relay IP<br/>[+ Encapsulated Request]\n  G->>D: Request\n  D->>G: Response\n  G->>R: Gateway Response<br/>TO: Relay IP<br/>[+ Encapsulated Response]\n  R->>C: Relay Response<br/>TO: Client IP<br/>[+ Encapsulated Response]\n```\n\n### Relay/Directory interactions\n\nRFC 9458 requires each OHTTP Relay to be configured to forward requests\nto exactly one OHTTP Gateway. This requirement prevents receivers from\nbeing able to choose any directory, and senders from choosing relays\nindependently. Without addressing this limitation, senders would have to\nknow which relays are appropriate to use for each directory, creating a\ntendency for one directory and its affiliated relays to monopolize the\nprotocol.\n\nIn order to allow OHTTP Relays to be used with any directory, a\ndirectory's OHTTP Gateway may advertise this allowed purpose. This\nadvertisement prevents OHTTP Relays from acting as open internet proxies,\nwhich would otherwise allow anonymized access to arbitrary resources and\nexpose them to denial-of-service attacks, as well as other forms of abuse.\nWhen the directory receives a GET request to the `/.well-known/ohttp-gateway`\npath with an `allowed_purposes` query parameter, its response body\nshould contain a magic string in the same format as a TLS ALPN protocol\nlist (a U16BE length encoded list of U8 length encoded strings). The\nmagic string is `BIP77 454403bb-9f7b-4385-b31f-acd2dae20b7e`, offering\nan unambiguous signal to relays that this OHTTP Gateway will accept\nrequests associated with this purpose from any relay.\n\nBy supporting this `allowed_purposes` parameter, the directory signals\nto OHTTP Relays that it is willing to handle requests related to BIP 77,\nremoving the RFC 9458's requirement that relays and\nGateways be configured in a one-to-one relationship.\n\n## Rationale\n\n### Uppercase URL\n\nIn order to simplify parsing and allow QR encoders to use [Alphanumeric\nQR\nmode](https://www.rfc-editor.org/rfc/rfc9285.html#name-the-alphabet-used-in-base45),\nwhich is more compact than Byte mode, the mailbox endpoint URL,\nincluding the fragment parameters, is encoded in uppercase.\n\nUnlike Bitcoin URI parameters, which require switching back to Byte\nmode, the use of the URL fragment for session-specific parameters makes\nit possible to stay in Alphanumeric mode.\n\n### Parameter Ordering\n\nThe order of fragment parameters, Bitcoin URI parameters, as well as in the\nsender's optional parameters have no defined meaning.\n\nIn the BIP 21 URI, the `pj` parameter mailbox endpoint URL SHOULD be the last\nparameter to avoid QR mode switching.\n\nSince variations might create a fingerprint for particular wallet software,\nthis document requires that fragment parameters MUST appear in reverse\nlexicographical order.\n\n### Session Expiration\n\nThe directory may hold a message for an offline Payjoin client until that\nclient comes online. However, the BIP 78 spec [\nrecommends](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#receiver-does-not-need-to-be-a-full-node)\nbroadcasting Original PSBTs in the case of an offline counterparty.\nDoing so exposes a na\u00efve, surveillance-vulnerable transaction, which\nPayjoin intends to avoid.\n\nBecause BIP 78 is a synchronous protocol without a standard expiration\nmechanism, and automated receivers are vulnerable to probing attacks,\nBIP 78 encourages receivers to broadcast the Original PSBT after some\nundefined expiration time.\n\nBecause BIP 77 is an asynchronous protocol, it requires an explicit [\nsession-specific fragment\nparameter](#receiver-fragment-parameters), `EX`, to\ncommunicate this expiration time to the sender.\n\nThere is no way for a sender to prevent a receiver from broadcasting the\nfallback transaction extracted from the Original PSBT before the\nreceiver-specified expiration time.\n\n### 64-bit Short ID Length\n\n64 bits are sufficient to make the probability of experiencing a random\ncollision negligible. As of writing, the UTXO set has ~2^28 elements.\nThis is a very loose upper bound for the number of concurrent (non-spam)\nsessions, for which the probability of a random collision will be less\nthan 1%. The actual number of sessions will of course be (orders of\nmagnitudes) lower given that sessions are short-lived. With ~2^21\nsessions (a loose bound on number of transactions that can be confirmed\nin 24 hours) the probability is less than 1e-6. These figures bound the\nprobability of a collision existing anywhere in the entire set, whereas\nthe probability for an individual session to experience a collision is\n\\<\\< 1e-10 in either case.\n\n### Complete UTXO Data\n\nComplete UTXO data is required because this information is required for\nsigning and calculating fees for some input types.\n\n### HTTP\n\nHTTP is ubiquitous. Using simple HTTP polling allows even Bitcoin Core\nto consider an implementation. Unlike a WebSockets protocol, plain HTTP\ncan benefit from metadata protection by using Oblivious HTTP.\n\n### Oblivious HTTP\n\nOHTTP protects sender and receiver IP addresses both from one another\nand from the directory. This makes it more difficult for a directory to\ncorrelate many Payjoin transactions with specific IP addresses.\n\nOHTTP relays can be run as basic HTTP proxies from wallet providers or\nthird parties.\n\n### Uniform Payloads\n\nEncapsulated OHTTP payloads seen by the relay and directory, and\nencrypted messages seen by the directory, are constructed to be uniform\nso that these third-party services are unable to distinguish between\nthem.\n\nEncapsulated OHTTP messages are 8192 bytes long, and begin with a\ncleartext OHTTP header and an uncompressed key which is distinguishable\nfrom random bytes but uniform across different encapsulated requests.\n\nEnd-to-end encrypted messages are 7168 bytes long, and should be\nindistinguishable from uniformly random bytes.\n[ElligatorSwift as defined in BIP 324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#elligatorswift-encoding-of-curve-x-coordinates)\nis used to encode encapsulated HPKE public keys prepended to the HPKE ciphertext\nso that the directory can't distinguish between key material, the\nciphertext, and randomness. This ensures the two different protocol\nmessages are indistinguishable from each other as well as any protocol\nextensions.\n\nThese padded sizes are sufficient for most PSBTs without exceeding the [\n8KB\nlimit](https://www.geekersdigest.com/max-http-request-header-size-server-comparison/)\nof many HTTP/1.1 web servers. 8KB is also too small for image sharing,\nmaking misuse of the directory impractical.\n\n#### Random Padding\n\nThe typical [zero padding recommended by the BHTTP\nspecification](https://www.rfc-editor.org/rfc/rfc9292.html#name-padding-and-truncation)\nwould make future use of [multi-hop OHTTP inspired by the Sphinx mix\nformat](https://github.com/orgs/payjoin/discussions/582) detectable from the\npoint of view of the directory. Random padding is allowed so long as the BHTTP\nencoded request is not truncated.\n\nBy randomly padding OHTTP messages, any future use of such techniques would be\nindistinguishable from clients that only implement standardized OHTTP. Since\nthis would limit a malicious directory's ability to censor any such requests in\nthe future, and such requests significantly bolster the privacy threat model\nagainst malicious OHTTP relays or traffic analysis by a global passive\nadversary, it is desirable to do so for standard OHTTP requests as well.\n\n### Secp256k1 Hybrid Public Key Encryption\n\n[RFC 9180 Hybrid Public Key\nEncryption](https://www.rfc-editor.org/rfc/rfc9180.html)\n(HPKE) is a modern IETF standard for secure\nmessage exchange without TLS, since TLS is not available in Bitcoin Core.\n\nThis proposal uses `DHKEM(Secp256k1, HKDF-SHA256)` and\n`ChaCha20Poly1305` AEAD for both OHTTP encapsulation and for end-to-end\nencryption between the sender and receiver.\n\nThe receiver transmits its receiver key in [receiver fragment\nparameters](#receiver-fragment-parameters). The sender shares\nits reply key along with the Original PSBT. These keys are ephemeral and\nmust only be used for a single Payjoin Session.\n\n#### Secp256k1-based DHKEM\n\n[Secp256k1-based DHKEM for\nHPKE](https://www.ietf.org/archive/id/draft-wahby-cfrg-hpke-kem-secp256k1-01.html)\nis most appropriate because of secp256k1's availability in bitcoin\ncontexts.\n\n#### ChaCha20Poly1305 AEAD\n\nThis authenticated encryption with additional data [\nalgorithm](https://en.wikipedia.org/wiki/ChaCha20-Poly1305)\nis standardized in [RFC\n8439](https://www.rfc-editor.org/rfc/rfc8439) and has high\nperformance. ChaCha20Poly1305 AEAD has been implemented [in Bitcoin\nCore](https://github.com/bitcoin/bitcoin/pull/15649) for [\nBIP 324 Encrypted\nTransport](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki)\nas well. This has widespread support in browsers and common\ncryptographic libraries. AES-GCM is more widespread but slower without\nhardware support and not typically already a dependency in bitcoin software.\n\n#### HKDF-SHA256\n\nSHA-256 is necessarily available in bitcoin contexts.\n\n## Attack vectors\n\nIn addition to the attack vectors and mitigations in\n[BIP 78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#attack-vectors),\nthis proposal has the following attack vectors.\n\n### Directory Denial of Service\n\nSince each mailbox stores arbitrary encrypted payloads, directories are\nvulnerable to flooding. To mitigate such denial of service attacks,\ndirectory operators may respond with `401` unauthorized unless an\nauthorization token is provided. Authorization tokens must be unlinkable\nto preserve client privacy. A specific unlinkable authorization token\nmechanism is out of the scope of this proposal.\n\n### Network privacy\n\nOblivious HTTP must be used to protect the IP addresses of both sender\nand receiver from the directory. This requires an OHTTP Key\nConfiguration to be shared in the Payjoin URI and for the directory to\nsupport Oblivious HTTP.\n\nUnlike BIP 78 implementations, sender and receiver clients will only see\nthe IP address of the directory and not that of the client they are\ninteracting with.\n\nSenders that submit requests directly to the directory, without using\nan OHTTP Relay, may reveal their IP address to the receiver since that\nreceiver also specifies the directory.\n\n## Backwards compatibility\n\nSenders not supporting Payjoin will just ignore the `pj` parameter and\nproceed to typical address-based transaction flows.\n\nAll Payjoin versions use [Bitcoin URIs](#payjoin-uri).\nReceivers may choose to accept BIP 78 payloads at their discretion.\n\nA BIP 78 sender posts their request to the directory, which stores\nand forwards it to the BIP 77 receiver. A backwards-compatible\nreceiver proceeds with the BIP 78 checks if the encapsulated response\nbody is UTF-8 plaintext, signifying BIP 78. In order to service the\nrequest, a BIP 78 response must be returned to the sender within 30\nseconds or else the directory should respond with an `unavailable` JSON\nerror code as [defined in BIP\n78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki#receivers-well-known-errors).\n\n## Reference implementation\n\nA production reference implementation client can be found at\n<https://crates.io/crates/payjoin-cli>. Source code for the clients, the\ndirectory, and development kit may be found here:\n<https://github.com/payjoin/rust-payjoin>. Source code for an Oblivious\nHTTP relay implementation may be found here:\n<https://github.com/payjoin/ohttp-relay>.\n\n## Changelog\n\n- 0.2.0 2025-07-08\n    - Change fragment parameter delimiter from `+` to `-` to improve\n      compatibility with generic URI parsing libraries, and order them\n      lexicographically. `+` can cause issues due to a common convention (not\n      specified in RFC 3986, but in RFC 1866, in relation to HTML form\n      submission and query parameters) of interpreting `+` as ` ` when decoding\n      URIs.\n- 0.1.0 2025-05-28\n    - First merged Draft version of BIP 77\n", "content_length": 33648}
{"bip_number": 54, "filename": "bip-0054.md", "content": "```\n  BIP: 54\n  Layer: Consensus (soft fork)\n  Title: Consensus Cleanup\n  Author: Antoine Poinsot <mail@antoinep.com>\n          Matt Corallo <bips@bluematt.me>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0054\n  Status: Draft\n  Type: Standards Track\n  Created: 2025-04-11\n  License: CC0-1.0\n```\n\n## Abstract\n\nThis document proposes new consensus rules in order to fix the timewarp attack, reduce the worst\ncase block validation time, prevent Merkle tree weaknesses, and avoid duplicate transactions without\n[bip-0030][BIP30] validation.\n\n## Motivation\n\nThis proposal addresses a number of long-standing vulnerabilities and weaknesses in the Bitcoin\nprotocol. Bundling these fixes together allows to overcome the fixed cost of deploying a Bitcoin\nsoft fork.\n\nThe timewarp bug permits a majority hashrate attacker to arbitrarily increase the block rate,\nallowing them to steal block subsidy from future miners and increase validation costs to nodes that\nhave to deal with the increased average transaction rate. By strategically setting the block\ntimestamp, the [timewarp bug][SE timewarp] lets miners bring down the difficulty to its minimum\nwithin 38 days of starting the attack. The existence of this bug not only significantly empowers a\n51% attacker, but also makes it notably harder to reason about miners' incentives. It could indeed\nbe in the interest of short-sighted miners as well as short-sighted users to exploit this\nvulnerability in a small enough proportion to increase the block rate without fatally hurting the\nnetwork, as the effectively increased block space would \u2014 all other things being equal \u2014 bring fee\nrates down for users.\n\nSpecially crafted blocks may be expensive to process, with validation times ranging from a few\nminutes up to more than an hour on lower-end devices. Long block validation times are a nuisance to\nusers, increasing the cost to independently fully validate the consensus rules. In addition they can\nbe used by miners to attack their competition, creating perverse incentives, centralization\npressures and leading to reduced network security.\n\nIn computing a block's Merkle root, a 64-byte transaction can be interpreted as an intermediate\nnode in the tree in addition to a leaf. This makes it possible to fake inclusion proofs by\npretending a 64-byte block transaction is an inner node, as well as to pretend the inner nodes on\none level of the tree are the actual block transactions.\n\nSince [bip-0034][BIP34] activation, explicit [bip-0030][BIP30] validation is not necessary until\nblock height 1,983,702[^0].  Mandating new coinbase transactions be different from the early\n[bip-0034][BIP34] violations makes it possible to get rid of [bip-0030][BIP30] validation forever.\nBesides its unnecessary cost, another downside of [bip-0030][BIP30] validation is that it cannot be\nperformed by Utreexo clients. Finally, leveraging the coinbase transaction's `nLockTime` field\nallows applications to recover the block height corresponding to a coinbase transaction without\nhaving to parse Script.\n\n## Specification\n\nFor all blocks after activation the following new rules apply.\n\nGiven a block at height `N`:\n- if `N % 2016` is equal to 0, the timestamp of the block must be set to a value higher than or\n  equal to the value of the timestamp of block at height `N-1` minus 7200 (T<sub>N</sub> &ge;\n  T<sub>N\u22121</sub> \u2212 7200);\n- if `N % 2016` is equal to 2015, the timestamp of the block must be set to a value higher than\n  or equal to the value of the timestamp of the block at height `N-2015` (T<sub>N</sub> &ge;\n  T<sub>N\u22122015</sub>).\n\nA limit is set on the number of potentially executed signature operations in validating a\ntransaction. It applies to all transactions in the block except the coinbase transaction[^1]. For\neach input in the transaction, count the number of `CHECKSIG` and `CHECKMULTISIG` in the input\nscriptSig and previous output's scriptPubKey, including the P2SH redeemScript. If the total summed\nover all transaction inputs is strictly higher than 2500, the transaction is invalid. The accounting is the\nsame as for [bip-0016][BIP16 specs], evaluating the scriptSig, scriptPubKey, and P2SH redeemScript\nseparately:\n\n1. `CHECKSIG` and `CHECKSIGVERIFY` count as 1 signature operation, whether or not they are evaluated.\n2. `CHECKMULTISIG` and `CHECKMULTISIGVERIFY` immediately preceded by `OP_1` through `OP_16` are counted as 1 to 16 signature operations, whether or not they are evaluated.\n3. All other `CHECKMULTISIG` and `CHECKMULTISIGVERIFY` are counted as 20 signature operations, whether or not they are evaluated.\n\nTransactions whose witness-stripped serialized size is exactly 64 bytes are invalid.\n\nThe coinbase transaction's `nLockTime` field must be set to the height of the block minus 1[^2]\nand its `nSequence` field must not be equal to 0xffffffff.\n\n## Rationale\n\nThe restrictions on the timestamp of the first and last blocks of a difficulty adjustment period fix\nthe timewarp and Murch\u2013Zawy vulnerabilities[^3]. The latter poses mostly theoretical concerns but is\nextremely low risk to fix: the duration of an adjustment period has never been, and should never be,\nnegative. The former is fixed by preventing the timestamp of the first block of a difficulty period\nfrom being lower than the previous block's, with a two-hour grace period. A [previous\nproposal][BIP-XXXX] to fix timewarp used a ten-minute grace period instead, also adopted for\n[testnet4][BIP94 timewarp]. Out of an abundance of caution and because it only trivially worsens the\nblock rate increase under attack, a two-hour grace period is used here[^4].\n\nDisabling some Script operations and functionalities was [previously proposed][BIP-XXXX] to reduce\nthe worst case block validation time but was met with resistance due to confiscation concerns[^5]. A\ndelicate balance needs to be struck between minimizing the confiscation risks of a mitigation, even\nif merely theoretical, and bounding the costs one could impose on all other users of the system. To\nthis effect a limit on the number of potentially executed signature operations pinpoints exactly the\nharmful behaviour, leaving maximum flexibility in how Script functionalities may have been used.\nSuch a limit reduces the worst case block validation time by a factor of 40 and drastically\nincreases the preparation cost of an attack to make it uneconomical for a miner[^6]. The maximum of\n2500 was chosen as the tightest value that did not make any non-pathological standard transaction\ninvalid[^7].\n\nIn the presence of 64-byte transactions a block header's Merkle root may be valid for different sets\nof transactions. This is because in the Merkle tree construction a 64-byte transaction may be\ninterpreted as the catenation of two 32-byte hashes, or the catenation of two 32-byte hashes may be\ninterpreted as a transaction. The former allows to fake a block inclusion proof and the latter makes\nit such that for a valid block the Merkle root in the block header is not a unique identifier for\nthe corresponding list of valid transactions[^8]. 64-byte transactions can only contain a\nscriptPubKey that lets anyone spend the funds, or one that burns them. 64-byte transactions have\nalso been non-standard since 2019. It was suggested that the known vulnerabilities could instead be\nmitigated by committing to the Merkle tree depth in the header's version field[^9]. The authors\nbelieve it is preferable to address the root cause by invalidating 64-byte transactions. This\napproach also fixes the vulnerability without developers of SPV verifiers having to implement the\nmitigation or to know it is necessary in the first place.\n\nSeveral blocks prior to [bip-0034][BIP34] activation contain a coinbase transaction whose scriptSig\ncontains a valid [bip-0034][BIP34] commitment to a future block height. This offers an opportunity\nto duplicate these coinbase transactions in the future[^10] and for this reason [bip-0030][BIP30]\nvalidation will need to be re-activated from block 1,983,702. A simple way to prevent this is to\nmandate that future coinbase transactions vary from coinbase transactions before [bip-0034][BIP34]\nactivation. There are multiple ways of achieving this, but setting and enforcing the timelock for\nthe coinbase transaction makes it so all coinbase transactions past Consensus Cleanup activation\ncould not have been valid before this height and therefore cannot be a duplicate[^11].\n\n## Backward compatibility\n\nThis proposal only tightens the block validation rules: there is no block that is valid under the\nrules proposed in this BIP but not under the existing Bitcoin consensus rules. As a consequence\nthese changes are backward-compatible with non-upgraded node software. That said, the authors\nstrongly encourage node operators to upgrade in order to fully validate all consensus rules.\n\n## Miner forward compatibility\n\nBitcoin Core version [29.0][Core 29.0] and later will not generate a block template that violates\nthe timestamp restrictions introduced in this BIP. Although it would be extremely unlikely due to\nthe grace period used in this proposal, miners should use the `curtime` or `mintime` field from the\n`getblocktemplate` result for their block's timestamp to make sure they always create blocks valid\naccording to this proposal. Note this is not a new requirement: using a timestamp lower than the\n`mintime` field from the `getblocktemplate` result already leads to creating an invalid block.\n\nBitcoin Core version [30.0][Core 30.0] and later will not generate a block template including a\ntransaction that violates the signature operations limit introduced in this BIP.\n\nBitcoin Core version [0.16.1][Core 0.16.1] and later will neither relay nor create block templates\nthat include 64-byte transactions.\n\nThe coinbase transaction is usually crafted by mining pool software. To the best of the authors'\nknowledge, there does not exist an open source reference broadly in use today for such software.\nWe encourage mining pools to update their software to craft coinbase transactions that are\nforward-compatible with the changes proposed in this BIP.\n\n## Reference implementation\n\nAn implementation of BIP54 for Bitcoin Core is available [here][inquisition-implem].\n\n## Test vectors\n\nDocumented test vectors are available [here](./bip-0054/test_vectors/) for all mitigations\nintroduced in this BIP.\n\n## Acknowledgements\n\nThis document builds upon an [earlier proposal][BIP-XXXX] by Matt Corallo.\n\nThe authors would like to thank everyone involved in researching the most appropriate mitigation for\neach of these bugs. We would like to thank in particular Anthony Towns and Sjors Provoost for their\ndirect contributions to this proposal, as well as @0xb10c and Brian Groll for providing the authors\nwith data to analyze the proposed mitigations. Thanks to Chris Stewart for digging up historical\nviolations to the new transaction size rule, which are partially reused in this BIP's test vectors.\n\n## Copyright\n\nThis document is licensed under the Creative Commons CC0 1.0 Universal license.\n\n\n[^0]: Block 1,983,702 is the earliest future block which could contain a duplicate coinbase\ntransaction while still respecting [bip-0034][BIP34]. See [this post][Delving duplicable] for a list\nof all such future blocks.\n[^1]: Technically this limit *cannot* apply to a coinbase transaction as the size of its sole\ninput's scriptSig is limited.\n[^2]: The locktime validation, which is also performed for coinbase transactions, enforces that the\nnLockTime value is the last block at which a transaction is invalid, not the first one at which it\nis valid.\n[^3]: The timewarp attack is described [here][SE timewarp] and the Murch\u2013Zawy attack [here][Delving\nMurch-Zawy].\n[^4]: The testnet4 difficulty exception pushed blocks' timestamps in the future when abused,\nrevealing how some broken pool software may produce blocks that don't respect a 10 minutes grace\nperiod. Some [raised concerns][Sjors grace period] similarly broken software might be used on\nmainnet. Using a grace period of 2 hours instead of 10 minutes only reduces the expected block\ninterval time under attack by ~2.2 seconds. See [this post][grace period debate summary] for more.\n[^5]: The argument is about someone having a timelocked presigned transaction using some of those\nfeatures in its output script. The transaction cannot be mined before activation. Such outputs would\nnot be covered by an amnesty for old UTxOs. See for instance [here][O'Connor OP_CODESEPARATOR] and\n[here][O'Connor sighash type] for discussions on this topic.\n[^6]: It is important to reduce the worst case block validation time as well as the ratio of\nvalidation time imposed over preparation cost. The former is to limit the damages an externally\nmotivated attacker can do. The latter is to disincentivize miners slowing down their competition by\nmining expensive blocks. See [this thread][ML thread validation time] for more.\n[^7]: A non-pathological transaction would have a public key per signature operation and at least\none signature per input. Per standardness a single P2SH input may not have more than 15 signature\noperations. Even by using 1-of-15 `CHECKMULTISIG`s a transaction would bump against the maximum\nstandard transaction size before running into the newly introduced limit. To run against the newly\nintroduced limit but not the transaction size a transaction would need to spend P2SH inputs with a\nredeem script similar to `CHECKSIG DROP CHECKSIG DROP ...`. This type of redeem script serves no\npurpose beyond increasing its validation cost, which is exactly what this proposal aims to mitigate.\n[^8]: See [this writeup][Suhas Merkle] by Suhas Daftuar for an explanation as well as a discussion\nof the consequences.\n[^9]: By Sergio Demian Lerner in a [blog post][Sergio post] surfaced [by Eric Voskuil][Eric\nversion]. Eric also pushed back against the importance of fixing this issue. See [this post][64\nbytes debate] for an attempt at summarizing the arguments for both sides of this debate.\n[^10]: See [here][BIP34 list] for a full list of the heights of historical blocks including a valid\nbip-0034 height commitment and the corresponding future block height.\n[^11]: Technically it could be argued a duplicate could in principle always be possible before block\n31,001 when `nLockTime` enforcement [was originally soft-forked][Harding nLockTime]. But treating\ncoinbase transactions as not having duplicate past Consensus Cleanup activation would be consistent\nfor any implementation which enforces `nLockTime` from the genesis block, which is the behaviour\nnotably of Bitcoin Core but also of all other implementations the authors are aware of.\n\n[BIP30]: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki\n[BIP-XXXX]: https://github.com/TheBlueMatt/bips/blob/7f9670b643b7c943a0cc6d2197d3eabe661050c2/bip-XXXX.mediawiki\n[BIP34]: https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki\n[BIP16 specs]: https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki#specification\n[SE timewarp]: https://bitcoin.stackexchange.com/questions/75831/what-is-time-warp-attack-and-how-does-it-work-in-general/75834#75834\n[Delving Murch-Zawy]: https://delvingbitcoin.org/t/zawy-s-alternating-timestamp-attack/1062#variant-on-zawys-attack-2\n[BIP94 timewarp]: https://github.com/bitcoin/bips/blob/master/bip-0094.mediawiki#user-content-Time_Warp_Fix\n[Sjors grace period]: https://delvingbitcoin.org/t/timewarp-attack-600-second-grace-period/1326\n[grace period debate summary]: https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/66\n[O'Connor OP_CODESEPARATOR]: https://gnusha.org/pi/bitcoindev/CAMZUoKneArC+YZ36YFwxNTKsDtJhEz5P2cosXKxJS8Rf_3Nyuw@mail.gmail.com\n[O'Connor sighash type]: https://gnusha.org/pi/bitcoindev/CAMZUoK=1kgZLR1YZ+cJgzwmEOwrABYFs=2Ri=xGX=BCr+w=VQw@mail.gmail.com\n[ML thread validation time]: https://gnusha.org/pi/bitcoindev/VsltJ2PHqWfzG4BU9YETTXjL7fYBbJhjVXKZQyItemySIA1okvNee9kf0zAOyLMeJ4Nqv1VOrYbWns5nP4TANCWvPJYu1ew_yxQSaudizzk=@protonmail.com\n[Suhas Merkle]: https://gnusha.org/pi/bitcoindev/CAFp6fsGtEm9p-ZQF_XqfqyQGzZK7BS2SNp2z680QBsJiFDraEA@mail.gmail.com\n[Sergio post]: https://bitslog.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design\n[Eric version]: https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/37\n[64 bytes debate]: https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/41\n[BIP34 list]: https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/4\n[Harding nLockTime]: https://bitcoin.stackexchange.com/questions/90229/nlocktime-in-bitcoin-core\n[Delving duplicable]: https://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/4\n[Core 0.16.1]: https://bitcoincore.org/en/releases/0.16.1\n[Core 29.0]: https://bitcoincore.org/en/releases/29.0\n[inquisition-implem]: https://github.com/darosior/bitcoin/tree/2509_inquisition_consensus_cleanup\n[Core 30.0]: https://bitcoincore.org/en/releases/30.0\n", "content_length": 16960}
{"bip_number": 3, "filename": "bip-0003.md", "content": "```\n  BIP: 3\n  Title: Updated BIP Process\n  Author: Murch <murch@murch.one>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0003\n  Status: Proposed\n  Type: Process\n  Created: 2025-01-09\n  License: BSD-2-Clause\n  Post-History: https://github.com/murchandamus/bips/pull/2\n                https://gnusha.org/pi/bitcoindev/59fa94cea6f70e02b1ce0da07ae230670730171c.camel@timruffing.de/#t\n  Requires: 123\n  Replaces: 2\n```\n\n## Abstract\n\nThis _Bitcoin Improvement Proposal (BIP)_ provides information about the preparation of BIPs and policies relating to\nthe publication of BIPs. It replaces [BIP\u202f2](bip-0002.mediawiki) with a streamlined process, and may be amended to\naddress the evolving needs of the BIP process.\n\n## Motivation\n\nBIP\u202f2 was written in 2016.\nThis BIP revisits aspects of the BIP\u202f2 process\nthat did not achieve broad adoption, reduces the judgment calls assigned to the BIP Editor role, delineates the\nBIP\u202ftypes more clearly, and generalizes the BIP process to fit the community\u2019s use of the repository.\n\n## Fundamentals\n\n### What is a BIP?\n\nBIPs are improvement proposals for Bitcoin[^capitalization]. The main topic is information and technologies that support and expand the utility of the bitcoin\ncurrency. Most BIPs provide a concise, self-contained, technical description of one new concept, feature, or standard.\nSome BIPs describe processes, implementation guidelines, best practices, incident reports (e.g.,\n[BIP\u202f50](bip-0050.mediawiki)), or other information relevant to the Bitcoin community. However, any topics related to\nthe Bitcoin protocol, peer-to-peer network, and client software may be acceptable.\n\nBIPs are intended to be a means for proposing new protocol features, coordinating client standards, and\ndocumenting design decisions that have gone into implementations. A BIP may be submitted by anyone,\nprovided it is the original work of its authors and the content is of high quality, e.g. does not waste\nthe community's time. No content may be generated by AI/LLMs and authors must proactively disclose\nup-front any use of AI/LLMs.\n\nThe scope of the BIPs\nrepository is limited to BIPs that do not oppose the fundamental principle that Bitcoin constitutes a peer-to-peer\nelectronic cash system for the bitcoin currency.\n\n### BIP Ownership\n\nEach BIP is primarily owned by its authors and represents the authors\u2019 opinion or recommendation. The authors are\nexpected to foster discussion, address feedback and dissenting opinions, and, if applicable, advance the adoption of\ntheir proposal within the Bitcoin community. As a BIP progresses through the workflow, it becomes increasingly\nco-owned by the Bitcoin community.\n\n#### Authors and Deputies\n\nAuthors may want additional help with the BIP process after writing an initial draft. In that case, they may assign\none or more Deputies to their BIP. Deputies are stand-in owners of a BIP who were not involved in writing the\ndocument. They support the authors in advancing the proposal, or act as a point of contact for the BIP in the absence of the\nauthors. Deputies may perform the role of Authors for any aspect of the BIP process unless overruled by an Author.\nDeputies share ownership of the BIP at the discretion of the Authors.\n\n### What is the Significance of BIPs?\n\nBIPs do not define what Bitcoin is: individual BIPs do not represent Bitcoin community consensus or a general\nrecommendation for implementation. A BIP represents a personal recommendation by the BIP authors to the Bitcoin\ncommunity. Some BIPs may never be adopted. Some BIPs may be adopted by one or more Bitcoin clients or other related\nsoftware. Some may even end up changing the consensus rules that the Bitcoin ecosystem jointly enforces.\n\n### What is the Purpose of the BIPs Repository?\n\nThe [BIPs repository](https://github.com/bitcoin/bips/) serves as a publication medium and archive for mature proposals.\nThrough its high visibility, it facilitates the community-wide consideration of BIPs and provides a well-established\nsource to retrieve the latest version of any BIP. The repository transparently records all changes to each BIP and\nallows any community member to retain a complete copy of the archive easily.\n\nThe BIPs repository neither tracks community sentiment[^acceptance] nor ecosystem adoption[^adoption] of BIPs beyond\nthe brief overview provided via the BIP status (see [Workflow](#workflow) below).\nProposals are published in this repository if they are on-topic and fulfill the editorial criteria.\nNo formal or informal decision body governs Bitcoin development or decides adoption of BIPs.\n\n## BIP Format and Structure\n\n### Specification\n\nAuthors may choose to submit BIPs in MediaWiki or Markdown[^markdown] format.\n\nEach BIP must have a _Preamble_, an _Abstract_, a _Copyright_, and a _Motivation_ section. Authors should consider all issues in the\nfollowing list and address each as appropriate.\n\n* Preamble \u2014 Headers containing metadata about the BIP (see the section [BIP Header Preamble](#bip-header-preamble)\n  below).\n* Abstract \u2014 A short description of the issue being addressed.\n* Motivation \u2014 Why is this BIP being written? Clearly explain how the existing situation presents a problem and why the proposed idea resolves the\n  issue or improves upon the current situation.\n* Specification \u2014 The technical specification should describe the syntax and semantics of any new feature. The\n  specification should be detailed enough to enable any Bitcoin project to create an interoperable implementation.\n* Rationale \u2014 The rationale fleshes out the specification by describing what inspired the design and why particular\n  design decisions were made. It should describe related work and alternate designs that were considered. The rationale\n  should record relevant objections or important concerns that were raised and addressed as this proposal was developed.\n* Backward Compatibility \u2014 Any BIP that introduces incompatibilities must include a section describing these incompatibilities and their severity as well as provide instructions on how\n  implementers and users should deal with these incompatibilities.\n* Reference Implementation \u2014 Where applicable, a reference implementation, test vectors, and documentation must be\n  finished before the BIP can be given the status \"Complete\". Test vectors must be provided in the BIP or\n  as auxiliary files (see [Auxiliary Files](#auxiliary-files)) under an acceptable license. The reference implementation can be provided in the BIP, as an auxiliary file, or per reference to a pull request that is expected to remain available permanently.\n* Changelog \u2014 A section to track modifications to a BIP after reaching Complete status.\n* Copyright \u2014 The BIP must be placed under an acceptable license (see [BIP Licensing](#bip-licensing) below).\n\n#### BIP Header Preamble\n\nEach BIP must begin with an [RFC 822-style header preamble](https://www.w3.org/Protocols/rfc822/). The headers must\nappear in the following order. Headers marked with \"\\*\" are optional. All other headers are required.\n\n##### Overview\n\n```\n  BIP: <BIP number, or \"?\" before assignment>\n* Layer: <Consensus (soft fork) | Consensus (hard fork) | Peer Services | API/RPC | Applications>\n  Title: <BIP title (\u2264\u202f50 characters)>\n  Authors: <Authors\u2019 names and email addresses>\n* Deputies: <Deputies\u2019 names and email addresses>\n  Status: <Draft | Complete | Deployed | Closed>\n  Type: <Specification | Informational | Process>\n  Assigned: <Date of number assignment (yyyy-mm-dd), or \"?\" before assignment>\n  License: <SPDX License Expression>\n* Discussion: <Noteworthy discussion threads in \"yyyy-mm-dd: URL\" format>\n* Version: <MAJOR.MINOR.PATCH>\n* Requires: <BIP number(s)>\n* Replaces: <BIP number(s)>\n* Proposed-Replacement: <BIP number(s)>\n```\n\n##### Header Descriptions\n\n* BIP \u2014 The assigned number of the BIP (without leading zeros). Please use \"?\" before a number has been assigned by the BIP Editors.\n* Layer \u2014 The layer of Bitcoin the BIP applies to using the BIP classification defined in [BIP\u202f123](bip-0123.mediawiki).\n* Authors \u2014 The names (or pseudonyms) and email addresses of all authors of the BIP. The format of each authors header\n  value must be\n\n      Random J. User <address@dom.ain>\n\n  Multiple authors are recorded on separate lines:\n\n      Authors: Random J. User <address@dom.ain>\n               Anata Sample <anata@domain.example>\n\n* Deputies \u2014 Additional owners of the BIP that are not authors. The Deputies header uses the same format as the\n  Authors header. See the [BIP Ownership](#bip-ownership) section above.\n* Status \u2014 The stage of the workflow of the proposal. See the [Workflow](#workflow) section below.\n* Type \u2014 See the [BIP Types](#bip-types) section below for a description of the three BIP types.\n* Assigned \u2013 The date a BIP was assigned its number. Please use \"?\" before a number has been assigned by the BIP Editors.\n* License \u2014 The License header specifies SPDX License Expressions describing the terms under which the\n  BIP and its auxiliary files are available. See the [BIP Licensing](#bip-licensing) section below.\n* Discussion \u2014 The Discussion header points the audience to relevant discussions of the BIP, e.g., the mailing list\n  thread in which the idea for the BIP was discussed, a thread where a new version of the BIP was presented, or relevant\n  discussion threads on other platforms. Entries take the format \"yyyy-mm-dd: URL\", e.g., `2009-01-09:\n  https://www.mail-archive.com/cryptography@metzdowd.com/msg10142.html`, using the date and URL of the start of the\n  conversation. Multiple discussions should be listed on separate lines.\n* Version \u2014 The current version number of this BIP. See the [Changelog](#changelog) section below.\n* Requires \u2014 A list of existing BIPs the new proposal depends on. If multiple BIPs\n  are required, they should be listed in one line separated by a comma and space (e.g., \"1, 2\").\n* Replaces[^proposes-to-replace] \u2014 BIP authors may put the numbers of one or more prior BIPs in the Replaces header to recommend that their\n  BIP succeeds, supersedes, or renders obsolete those prior BIPs.\n* Proposed-Replacement[^superseded-by-proposed-replacement] \u2014 When a later BIP indicates that it intends to supersede an\n  existing BIP, the later BIP\u2019s number is added to the Proposed-Replacement header of the existing BIP to indicate the\n  potential successor BIP.\n\n#### Auxiliary Files\n\nBIPs may include auxiliary files such as diagrams and source code. Auxiliary files must be included in a subdirectory\nfor that BIP named `bip-XXXX`, where \"XXXX\" is the BIP number zero-padded to four digits. File names in the subdirectory\ndo not need to adhere to a specific convention.\n\n### BIP Types\n\n* A **Specification BIP** defines a set of technical rules describing a new feature or affecting the interoperability of implementations. The\n  distinguishing characteristic of a Specification BIP is that it can be implemented, and implementations can be compliant with\n  it. Specification BIPs must have a Specification section, must have a Backward Compatibility section (if incompatibilities are introduced), and can only be advanced to Complete after they contain or refer to a reference implementation and test vectors.\n* An **Informational BIP** describes a Bitcoin design issue, or provides general guidelines or other information to the\n  Bitcoin community.\n* A **Process BIP** describes a process surrounding Bitcoin, or proposes a change to (or an event in) a process. Process\n  BIPs are like Specification BIPs, but apply to topics other than the Bitcoin protocol and Bitcoin implementations.\n  They often require community consensus and are typically binding for the corresponding process. Examples include\n  procedures, guidelines, and changes to decision-making processes such as the BIP process.\n\n## Workflow\n\nThe BIP process starts with a new idea for Bitcoin. Each potential BIP must have authors\u2014people who write the BIP,\ngather feedback, shepherd the discussion in the appropriate forums, and finally recommend a mature proposal to the\ncommunity.\n\n![Status Diagram](bip-0003/status-diagram.png \"Status Diagram for the BIP Workflow\")\n\n### Ideation\n\nAfter having an idea, the authors should evaluate whether it meets the criteria to become a BIP, as described in this\nBIP. The idea must be of interest to the broader community or relevant to multiple software projects. Minor improvements\nand matters concerning only a single project usually do not require standardization and should instead be brought up directly to\nthe relevant project.\n\nThe authors should first research whether their idea has been considered before. Ideas in Bitcoin are often rediscovered,\nand prior related discussions may inform the authors of the issues that may arise in its progression. After some investigation,\nthe novelty and viability of the idea should be tested by posting a new, dedicated thread about the idea to the [Bitcoin Development Mailing\nList](https://groups.google.com/g/bitcoindev). Prior correspondence can be found in the [mailing list\narchive](https://gnusha.org/pi/bitcoindev/).\n\nIt is recommended that authors establish before or at the start of working on a draft whether their idea may be of\ninterest to the Bitcoin community.\nAuthors should avoid opening a pull request with a BIP draft out of the blue.\nVetting an idea publicly before investing time and effort to formally describe the idea is meant to save time for both the authors and\nthe community. Not only may someone point out relevant discussion topics that were missed in the authors\u2019\nresearch, or that an idea is guaranteed to be rejected based on prior discussions, but describing an idea publicly also\ntests whether it is of interest to more people beside the authors.\n\nAs a first sketch of the proposal is taking shape, the authors should present it to the [Bitcoin Development Mailing\nList](https://groups.google.com/g/bitcoindev). This gives the authors a chance to collect initial feedback and address\nfundamental concerns. If the authors wish to work in public on the proposal at this stage, it is recommended that they\nopen a pull request against one of their forks of the BIPs repository instead of the main BIPs repository.\n\nIt is recommended that complicated proposals be split into separate BIPs that each focus on a specific component of the\noverall proposal.\n\n### Progression through BIP Statuses\n\nThe following sections refer to BIP Status field values. The BIP Status field is defined in the Header Preamble\nspecification above.\n\n#### Draft\n\nAfter fleshing out the proposal further and ensuring that it is of high quality and properly formatted, the authors\nshould open a pull request to the [BIPs repository](https://github.com/bitcoin/bips). The document must adhere to the\nformatting requirements specified above and should be provided as a file named with a working title of the form\n\"bip-title.[md|mediawiki]\". The authors must not self-assign a number to their proposal.\n\nBIPs that (1) adhere to the formatting requirements, (2) are on-topic, and (3) have materially progressed beyond the\nideation phase, e.g., by generating substantial public discussion and commentary from diverse contributors, by\nindependent Bitcoin projects working on adopting the proposal, or by the authors working for an extended period toward\nimproving the proposal based on community feedback, will be assigned a number by a BIP Editor. A number may be\nconsidered assigned only after it has been publicly announced in the pull request by a BIP Editor. The BIP Editors should\nnot assign a number when they perceive a proposal being met with lack of interest: number assignment facilitates the\ndistributed discussion of ideas, but before a proposal garners some interest in the Bitcoin community, there is no need\nto refer to it by a number.\n\nProposals are also not ready for number assignment if they duplicate efforts, disregard formatting rules, are too\nunfocused or too broad, fail to provide proper motivation, fail to address backward compatibility where necessary, or\nfail to specify the feature clearly and comprehensively. Reviewers and BIP Editors should provide guidance on how the\nproposal may be improved to progress toward readiness. Pull requests that are proposing off-topic ideas or\nhave stopped making progress may be closed.\n\nWhen the proposal is ready and has been assigned a number, a BIP Editor will merge it into the BIPs repository. After the\nBIP has been merged to the repository, its main focus should no longer shift significantly, even while the authors may\ncontinue to update the proposal as necessary. Updates to merged documents by the authors should also be submitted as\npull requests.\n\n#### Complete[^complete]\n\nWhen the authors have concluded all planned work on their proposal, are confident that their BIP represents a net\nimprovement, is clear, comprehensive, and is\nready for adoption by the Bitcoin community, they may update the BIP\u2019s status to Complete to indicate that they\nrecommend adoption, implementation, or deployment of the BIP. Where applicable, the authors must ensure that any\nproposed specification is solid, not unduly complicated, and definitive. Specification BIPs must come with or refer to a working reference implementation and comprehensive test vectors before they can be moved to Complete. Subsequently, the BIP\u2019s content should only be\nadjusted in minor details, e.g., to improve language, clarify ambiguities, backfill omissions in the specification, add\ntest vectors for edge cases, or address other issues discovered as the BIP is being adopted.\n\nA Complete BIP can only move to Deployed or Closed. Any necessary changes to the specification should be minimal and\ninterfere as little as possible with ongoing adoption. If a Complete BIP is found to need substantial functional\nchanges, it may be preferable to move it to Closed[^new-BIP], and to start a new BIP with the changes instead.\nOtherwise, it could cause confusion as to what being compliant with the BIP means.\n\nA BIP may remain in the Complete status indefinitely unless its authors or deputies decide to move it to Closed or it is advanced to\nDeployed.\nComplete is the final status for most successful Informational BIPs.\n\n#### Deployed\n\nA Complete BIP should only be moved to Deployed once it is settled: after its approach has solidified, its\nSpecification has been put through its paces, feedback from early adopters has been processed, and amendments to the BIP have stopped.\nThen, a BIP may be advanced to Deployed upon request by any community member with evidence[^evidence] that\nthe BIP is in active use. Convincing evidence includes for example: an established project having deployed support\nfor the BIP in mainnet software releases, a soft fork proposal\u2019s activation criteria having been met on the network, or\nrough consensus for the BIP having been demonstrated.\n\nOnce Deployed, the BIP is considered final.\nAny modifications to the BIP beyond bug fixes, other minor amendments, additions to the test vectors, or editorial\nchanges should be avoided.\nAny breaking changes to the BIP\u2019s Specification should be proposed as a new separate BIP.[^new-BIP]\n\n##### Process BIPs\n\nA Process BIP may change status from Complete to Deployed when it achieves rough consensus on the Bitcoin Development Mailing List. A\nproposal is said to have rough consensus if its advancement has been open to discussion on the mailing list for at least\none month, the discussion achieved meaningful engagement, and no person maintains any unaddressed substantiated objections to it. Addressed or obstructive objections\nmay be ignored/overruled by general agreement that they have been sufficiently addressed, but clear reasoning must be\ngiven in such circumstances. Deployed Process BIPs may be modified indefinitely as long as a proposed modification has\nrough consensus per the same criteria.[^living-documents]\n\n#### Closed[^closed]\n\nA BIP that is of historical interest only, and is not being actively worked on, promoted or in active use, should be\nmarked as Closed. The reason for moving the\nproposal to (or from) Closed should be recorded in the Changelog section in the same commit that updates the status.\nBIPs do not get deleted, they are retained even after being updated to Closed.\nTransitions involving the Closed state are:\n\n##### Draft \u21a6 Closed\n\nBIP authors may decide on their own to change their BIP\u2019s status from Draft to Closed. If a Draft BIP stops making\nprogress, sees accumulated feedback unaddressed, or otherwise appears stalled for a year, anyone may propose the BIP\nstatus be updated to Closed. The BIP is then updated to Closed unless the authors assert that they intend to continue work within four weeks of being contacted.\n\n##### Complete \u21a6 Closed\n\nBIPs that had attained the Complete status, i.e., that had been recommended for adoption, may be moved to Closed per the\nauthors\u2019 announcement to the Bitcoin Development Mailing List[^bip-announcements-to-list]. However, if someone volunteers to adopt the proposal\nwithin four weeks, they become the BIP's author or deputy (see [Transferring BIP Ownership](#transferring-bip-ownership) below), and the BIP will\nremain Complete instead.\n\n##### Deployed \u21a6 Closed\n\nA BIP may evolve from Deployed to Closed when it is no longer in active use. Any community member may initiate this\nStatus update by announcing it to the mailing list[^bip-announcements-to-list], and proceed if no objections have been raised for four weeks.\n\n##### Closed \u21a6 Draft\n\nThe Closed status is generally intended to be a final status for BIPs,\nand if BIP authors decide to make another attempt at a previously Closed BIP, it is generally recommended to create a new\nproposal. (Obviously, the authors may borrow any amount of inspiration or actual text from any prior BIPs as licensing\npermits.) The authors should take special care to address the issues that caused the prior attempt\u2019s abandonment. Even\nif the prior attempt had been assigned a number, the new BIP will generally be assigned a distinct number. However, if it is\nobvious that the new attempt directly continues work on the same idea, it may be reasonable to return the\nClosed BIP to Draft status.\n\n### Changelog\n\nTo help implementers understand updates to a BIP, any changes after it has reached Complete must be tracked with version,\ndate, and description in a Changelog section sorted by most recent version first. The version number is inspired by semantic versioning (MAJOR.MINOR.PATCH).\nThe MAJOR version is incremented if changes to the BIP\u2019s Specification are introduced that are incompatible with prior\nversions (which should be rare after a BIP is Complete, and only happen in well-grounded exceptional cases to a BIP that\nis Deployed). The MINOR version is incremented whenever the specification of the BIP is changed or extended in a\nbackward-compatible way. The PATCH version is incremented for other changes to the BIP that are noteworthy (bug fixes,\ntest vectors, important clarifications, etc.). Version 1.0.0 is used to label the promotion to\nComplete. A Changelog section may be introduced during the Draft phase to record significant changes (using versions 0.x.y).\n\nExample:\n\n> __Changelog__\n>\n> * __2.0.0__ (2025-01-22):\n>     * Introduce a breaking change in the specification to fix a bug.\n> * __1.1.0__ (2025-01-17):\n>     * Add a backward compatible extension to the BIP.\n> * __1.0.1__ (2025-01-15):\n>     * Clarify an edge case and add corresponding test vectors.\n> * __1.0.0__ (2025-01-14):\n>     * Complete planned work on the BIP.\n\nAfter a BIP receives a Changelog, the\nPreamble must indicate the latest version in the Version header. The Changelog highlights revisions to BIPs to human readers. A single\nBIP shall not recommend more than one variant of an idea at the same time. A different or\ncompeting variant of an existing BIP must be published as a separate BIP.\n\n### Adoption of Proposals\n\nThe BIPs repository does not track the sentiment on proposals and does not track the adoption of BIPs beyond whether they\nare in active use or not. It is not intended for BIPs to list additional implementations beyond the reference\nimplementation: the BIPs repository is not a signpost where to find implementations.[^OtherImplementations] After a BIP\nis advanced to Complete, it is up to the Bitcoin community to evaluate, adopt, ignore, or reject a BIP. Individual\nBitcoin projects are encouraged to publish a list of BIPs they implement. A good example of this at the time of writing\nthis BIP can be observed in Bitcoin Core\u2019s [doc/bips.md](https://github.com/bitcoin/bitcoin/blob/master/doc/bips.md)\nfile.\n\n### Transferring BIP Ownership\n\nIt occasionally becomes necessary to transfer ownership of BIPs to new owners. In general, it would be preferable to\nretain the original authors of the transferred BIP, but that is up to the original authors. A good reason to transfer\nownership is because the original authors no longer have the time or interest in updating it or following through with\nthe BIP process, or are unreachable or unresponsive. A bad reason\nto transfer ownership is because someone doesn't agree with the direction of the BIP. The community tries to build\nconsensus around a BIP, but if that's not possible, rather than fighting over control, the dissenters should supply a\ncompeting BIP.\n\nIf someone is interested in assuming ownership of a BIP, they should send an email asking to take over, addressed to the\noriginal authors, the BIP\u202fEditors, and the Bitcoin Development Mailing List[^bip-announcements-to-list]. If the authors are unreachable or do not respond in a timely\nmanner (e.g., four weeks), the BIP Editors will make a unilateral decision whether to appoint the applicants as\n[Authors or Deputies](#authors-and-deputies) (which may be amended should the original authors make a delayed reappearance).\n\n## BIP Licensing\n\nThe Bitcoin project develops a global peer-to-peer digital cash system. Open standards are indispensable for continued\ninteroperability. Open standards reduce friction, and encourage anybody and everyone to contribute, compete, and\ninnovate on a level playing field. Only freely licensed contributions are accepted to the BIPs repository.\n\n### Specification\n\nEach new BIP must specify in two ways under which license terms it is made available. First, it must specify an [SPDX\nLicense Expression](https://spdx.dev/ids/) in the License field in the preamble. Second, it must include a matching\nCopyright section, possibly providing further details on licensing.\n\nFor example, a preamble might include the following License header:\n\n    License: CC0-1.0 OR MIT\n\nIn this case, the BIP (including all auxiliary files) is made available under the terms of both CC0 1.0 Universal as well as the\nMIT License, and anyone may modify and redistribute it provided they comply with the terms of\n*either* license, at their option. In other words, the license list is an \"OR choice\", not an \"AND also\" requirement. See the [SPDX\ndocumentation](https://spdx.dev/ids/) and the [SPDX License List](https://spdx.org/licenses/) for further details.\n\nWherever different from those specified in the License header, an auxiliary file or directory should specify the license terms under which it is made available as is common in\nsoftware (e.g., with a [`SPDX-License-Identifier: <SPDX License Expression>` comment](https://spdx.dev/ids/),\na license header, or a LICENSE/COPYING file). Such exceptions should also be mentioned in the Copyright section. It is recommended to make any test vectors available\nunder CC0-1.0 or FSFAP in addition to any other licenses to allow anyone to copy test vectors into their\nimplementations without introducing license hindrances.\n\nA few BIP2-era BIPs (98, 116, 117, 330, 340) have a no longer used \"License-Code\" header indicating the license terms applicable to auxiliary source code files. For such cases, please refer to BIP2.\n\nIt is recommended that source code included in a BIP (whether within the text or in auxiliary files) be licensed under the same license terms as the project it\nis proposed to modify, if any. For example, changes intended for Bitcoin Core would ideally be licensed (also) under the MIT\nLicense.\n\nIn all cases, details of the licensing terms must be provided in the Copyright section of the BIP.\n\n#### Acceptable Licenses[^licenses]\n\nEach new BIP must be made available under at least one acceptable license as listed below. BIPs are not required to be\n*exclusively* licensed under approved terms, and may also be licensed under other licenses *in addition to* at least one\nacceptable license.\n\nIn other words, a new BIP must specify an SPDX License Expression that is either \"L\" or equivalent to \"L OR E\" for some\nacceptable license L from the following list and another SPDX License Expression E.\n\n* BSD-2-Clause: [BSD 2-Clause License](https://opensource.org/license/BSD-2-Clause)\n* BSD-3-Clause: [BSD 3-Clause License](https://opensource.org/license/BSD-3-Clause)\n* CC0-1.0: [CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/)\n* FSFAP: [FSF All Permissive License](https://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html)\n* CC-BY-4.0: [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)\n* MIT: [The MIT License](https://opensource.org/license/MIT)\n* MIT-0: [MIT No Attribution License](https://opensource.org/license/MIT-0)\n* Apache-2.0: [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0)\n* BSL-1.0: [Boost Software License 1.0](https://www.boost.org/LICENSE_1_0.txt)\n\n#### Not Acceptable Licenses\n\nAll licenses not explicitly included in the above lists are not acceptable terms for a Bitcoin Improvement Proposal.\nHowever, BIPs predating this proposal were accepted under other terms, and should use one of the following identifiers.\n\n* LicenseRef-PD: Placed into the public domain\n* OPUBL-1.0: [Open Publication License 1.0](https://opencontent.org/openpub/)\n\n## BIP Editors\n\nThe current BIP Editors are:\n\n* Bryan Bishop ([kanzure@gmail.com](mailto:kanzure@gmail.com))\n* Jon Atack ([jon@atack.com](mailto:jon@atack.com))\n* Luke Dashjr ([luke_bipeditor@dashjr.org](mailto:luke_bipeditor@dashjr.org))\n* Mark \"Murch\" Erhardt ([murch@murch.one](mailto:murch@murch.one))\n* Olaoluwa Osuntokun ([laolu32@gmail.com](mailto:laolu32@gmail.com))\n* Ruben Somsen ([rsomsen@gmail.com](mailto:rsomsen@gmail.com))\n\n### BIP Editor Responsibilities and Workflow\n\nThe BIP Editors subscribe to the Bitcoin Development Mailing List and watch the [BIPs\nrepository](https://github.com/bitcoin/bips).\n\nWhen either a new BIP idea or an early draft is submitted to the mailing list, BIP Editors and other community members should comment in regard\nto:\n\n* Novelty of the idea\n* Viability, utility, and relevance of the concept\n* Readiness of the proposal\n* On-topic for the Bitcoin community\n\nDiscussion in pull request comments can often be hard to follow as feedback gets marked as resolved when it is addressed\nby authors. Substantive discussion of ideas may be more accessible to a broader audience on the mailing list, where it\nis also more likely to be retained by the community memory.\n\nIf the BIP needs more work, an editor should ensure that constructive, actionable feedback is provided to the authors\nfor revision. Once the BIP is ready it should be submitted as a \"pull request\" to the [BIPs\nrepository](https://github.com/bitcoin/bips) where it may get further feedback.\n\nFor each new BIP pull request that comes in, an editor checks the following:\n\n* The idea has been previously proposed by one of the authors to the Bitcoin Development Mailing List and discussed there\n* The described idea is on-topic for the repository\n* Title accurately describes the content\n* Proposal is of general interest and/or pertains to more than one Bitcoin project/implementation\n* Document is properly formatted\n* Licensing terms are acceptable\n* Motivation, Rationale, and Backward Compatibility have been addressed\n* Specification provides sufficient detail for implementation\n* The defined Layer header must be correctly assigned for the given specification\n* The BIP is ready: it is comprehensible, technically feasible and sound, and all aspects are addressed as necessary\n\nEditors do NOT evaluate whether the proposal is likely to be adopted.\n\nThen, a BIP Editor will:\n\n* Assign a BIP number and BIP type in the pull request\n* Ensure that the BIP is listed in the [README](README.mediawiki)\n* Merge the pull request when it is ready\n\nThe BIP Editors are intended to fulfill administrative and editorial responsibilities. The BIP Editors monitor BIP\nchanges, and update BIP headers as appropriate.\n\nBIP Editors may also, at their option, unilaterally make and merge strictly editorial changes to BIPs, such as\ncorrecting misspellings, mending grammar mistakes, fixing broken links, etc. as long as they do not change the meaning or conflict with the\noriginal intent of the authors. Such a change must be recorded in the Changelog if it\u2019s noteworthy per the criteria\nmentioned in the [Changelog](#changelog) section.\n\n## Backward Compatibility\n\n### Changes from BIP\u202f2\n\n#### Workflow\n\n- Status field values are reduced from nine to four:\n  - Deferred, Obsolete, Rejected, Replaced, and Withdrawn are gathered up into Closed.[^closed]\n  - Final and Active are collapsed into Deployed.\n  - Proposed is renamed to Complete.\n  - The remaining statuses are Draft, Complete, Deployed, and Closed.\n- The comment system is abolished.[^comments]\n- A BIP in Draft or Complete status may no longer be closed solely on grounds of not making progress for three years.[^rejection]\n  - A BIP in Draft status may be updated to Closed status if it appears to have stopped making progress for at least a\n    year and its authors do not assert within four weeks of being contacted that they are still working on it.\n  - Complete BIPs can only be moved to Closed by its authors and may remain in Complete indefinitely.\n- A Changelog section is introduced to track significant changes to BIPs after they have reached the Complete status.\n- Process BIPs are living documents that do not ossify and may be modified indefinitely.\n- Some judgment calls previously required from BIP Editors are reassigned either to the BIP authors or the repository\u2019s\n  audience.\n\n#### BIP Format\n\n- The Standards Track type is superseded by the similar Specification type.[^standard-track]\n- Many sections are declared optional; it is up to the authors and reviewers to judge whether all relevant topics have\n  been comprehensively addressed and which topics require a designated section to do so.\n- \"Other Implementations\" sections are discouraged.[^OtherImplementations]\n- Auxiliary files are only permitted in the corresponding BIP\u2019s subdirectory, as no one used the alternative of labeling\n  them with the BIP number.\n- Tracking of community consensus and adoption is out of scope for the BIPs repository, except to determine\n  whether a BIP is in active use for the move into or out of the Deployed status.\n- The distinction between recommended and acceptable licenses was dropped.\n- Most licenses that have not been used in the BIP process have been dropped from the list of acceptable licenses.\n\n#### Preamble\n\n- \"Comments-URI\" and \"Comment-Summary\" headers are dropped from the preamble.[^comments]\n- The \"Superseded-By\" header is replaced with the \"Proposed-Replacement\" header.\n- The \"Post-History\" header is replaced with the \"Discussion\" header.\n- The optional \"Version\" header is introduced.\n- The \"Discussions-To\" header is dropped, as it has never been used in any BIP.\n- The \"License-Code\" header has been sunset, as it was used by only five BIPs (98, 116, 117, 330, 340) and created more ambiguity than clarity.\n- The \"Created\" header is renamed to \"Assigned\", as the header\u2019s value is the date of number assignment.[^assigned]\n- Introduce Deputies and optional \"Deputies\" header.\n- The BIP \"Title\" header may now contain up to 50 characters (increased from 44 in BIP\u202f2).\n- The \"Layer\" header is optional for Specification BIPs or Informational BIPs, as it does not make sense for all BIPs.[^layer]\n- Rename the \"Author\" field to \"Authors\".\n\n### Updates to Existing BIPs should this BIP be Activated\n\n#### Previous BIP Process\n\nThis BIP replaces BIP\u202f2 as the guideline for the BIP\u202fprocess.\n\n#### BIP Types\n\nStandards Track BIPs and eligible Informational BIPs are assigned the Specification type. The Standards Track type is\nconsidered obsolete. Specification BIPs use the Layer header rules specified in [BIP\u202f123](bip-0123.mediawiki).\n\n#### Comments\n\nThe Comments-URI and Comment-Summary headers should be removed from all BIPs whose comment page in the wiki is empty.\nFor existing BIPs whose comment page has content, BIP Authors may keep both headers or remove both headers at their\ndiscretion. It is recommended that existing wiki pages are not modified due to the activation of this BIP.\n\n#### Status Field\n\nAfter the activation of this BIP, the Status fields of existing BIPs that do not fit the specification in this BIP are\nupdated to the corresponding values prescribed in this BIP. BIPs that have had Draft status for extended periods will be\nmoved to Complete or Deployed as applicable in collaboration with their authors. The authors of incomplete Draft BIPs\nwill be contacted to learn whether the BIPs are still in progress toward Complete, and will otherwise be updated to\nClosed as described in the [Workflow](#workflow) section above.\n\n#### Authors Header\n\nThe Author header is replaced with the Authors header in all BIPs.\n\n#### Discussion Header\n\nThe Post-History header is replaced with the Discussion header in all BIPs.\n\n#### Proposed-Replacement Header\n\nThe Superseded-By header is replaced with the Proposed-Replacement header in all BIPs.\n\n#### Licenses\n\nExisting BIPs retain their license terms unchanged.\nThe License and License-Code headers of BIPs are updated to express those terms using SPDX License Expressions.\n\n## Copyright\n\nThis BIP is licensed under the [BSD-2-Clause License](https://opensource.org/licenses/BSD-2-Clause). Some content was\nadapted from [BIP\u202f2](bip-0002.mediawiki) which was also licensed under the BSD-2-Clause.\n\n## Related Work\n\n- [BIP\u202f1: BIP Purpose and Guidelines](bip-0001.mediawiki)\n- [BIP\u202f2: BIP Process, revised](bip-0002.mediawiki)\n- [BIP\u202f123: BIP Classification](bip-0123.mediawiki)\n- [RFC 822: Standard for ARPA Internet Text Messages](https://datatracker.ietf.org/doc/html/rfc822)\n- [RFC 2223: Instructions to RFC Authors](https://datatracker.ietf.org/doc/html/rfc2223)\n- [RFC 7282: On Consensus and Humming in the IETF](https://tools.ietf.org/html/rfc7282)\n\n## Acknowledgements\n\nWe thank AJ Towns, Jon Atack, Jonas Nick, Larry Ruane, Pieter Wuille, Tim Ruffing, and others for their review,\nfeedback, and helpful comments.\n\n## Rationale\n\n[^assigned]: **Why was the Created header renamed to Assigned?**  \n    Both BIP\u202f1 and BIP\u202f2 described the Created header as \"date created on\" in the preamble template, but followed that\n    up with \"Created header records the date that the BIP was assigned a number\" as the description of the field. This\n    has frequently led to confusion, with authors using the date of opening the pull request, the date they started\n    writing their proposal, the date of number assignment (as prescribed), or various other dates. Aligning the name of\n    the header and the text in the preamble template with the descriptions will reduce the confusion.\n[^capitalization]: **When is Bitcoin capitalized and when is it lowercased?**  \n    This document uses capitalized Bitcoin to refer to the system, network and abstract concept, and only uses lowercase\n    bitcoin to refer to units of the bitcoin currency.\n[^standard-track]: **Why was the Specification type introduced?**  \n    The definitions of Informational and Standards Track BIPs caused some confusion in the past. Due to Informational\n    BIPs being described as optional, Standards Track BIPs were sometimes misunderstood to be generally recommended.\n    This has led to a number of BIPs that propose new features affecting interoperability of implementations being\n    assigned the Informational type. The situation is remedied by introducing a new _Specification BIP_ type that is\n    inclusive of any BIPs that can be implemented and affect interoperability of Bitcoin applications. Since all BIPs\n    are individual recommendations by the authors (even if some may eventually achieve endorsement by the majority of\n    the community), the prior reminder that Informational BIPs are optional is dropped.\n[^comments]: **Why were comments, Comments-URI, and Comment-Summary removed from the process?**  \n    The comments feature saw insignificant adoption. Few BIPs received any comments and barely any more than two with\n    only a handful of contributors commenting at all. This led to many situations in which one or two comments ended up\n    dominating the comment summary. While some of those comments may have been representative of broadly held opinions,\n    it also overstated the importance of individual comments directly in the Preamble of BIPs. As collecting feedback in\n    this accessible fashion failed, the new process puts the onus back on the audience to make their own evaluation.\n[^layer]: **Why is the layer header now permitted for other BIP types?**  \n    The layer header had already been used by many Informational BIPs, so the rule that it is only available to\n    Standards Track BIPs is dropped.\n[^OtherImplementations]: **What is the issue with \"Other Implementations\" sections in BIPs?**  \n    In the past, some BIPs had \"Other Implementations\" sections that caused frequent change requests to existing BIPs.\n    This put an onus on the BIP authors, and frequently led to lingering pull requests due to the corresponding BIPs\u2019\n    authors no longer participating in the process. Many of these alternative implementations eventually became\n    unmaintained or were low-quality to begin with. Therefore, \"Other Implementations\" sections are heavily discouraged.\n[^complete]: **Why was the Proposed status renamed to Complete?**  \n    Some reviewers of this BIP raised that in a process which outlines the workflow of Bitcoin Improvement _Proposals_\n    using \"Proposed\" as a status field value was overloading the term: clearly _proposals_ are proposed at all stages of\n    the process. \"Complete\" expresses that the authors have concluded planned work on all parts of the proposal and are\n    ready to recommend their BIP for adoption. The term \"ready\" was also considered, but considered too subjective.\n[^rejection]: **Why can proposals remain in Draft or Complete indefinitely?**  \n    The automatic 3-year timeout of BIPs has led to some disagreement in the past and seems unnecessary in cases where\n    the authors remain active in the community and still consider their idea worth pursuing. On the other hand,\n    Draft proposals that appear stale may be closed after only one year, which should achieve the main goal of\n    the original rule by limiting the effort and attention spent on proposals that never reach Complete.\n[^closed]: **Why was the Closed Status introduced?**  \n    The Closed Status provides value to the audience by indicating which documents are only of historical significance.\n    Previously, the process had Deferred, Obsolete, Rejected, Replaced, and Withdrawn, which all meant some flavor of\n    \"work has stopped on this.\" The many statuses complicated the process, may have contributed to process fatigue, and\n    may have resulted in BIPs\u2019 statuses not being maintained well. The author of this BIP feels that all of the\n    aforementioned can be represented by _Closed_ without significantly impacting the information quality of the\n    overview table. Where the many Status variants provided minuscule additional information, the simplification is more\n    valuable and the Changelog section now collects specific details.\n[^acceptance]: **When is a BIP \"accepted\"?**  \n    Many standards processes such as the PEPs or the IETF have a mechanism for a proposal to be formally accepted by\n    some council or committee. The BIP Process does not have such a decision body. Bitcoin development and \"acceptance\"\n    of BIPs emerges from the participation of stakeholders across the ecosystem, and refers to some vague notion of community\n    interest and support for a proposal.  \n    BIP\u202f2 had made an attempt to gather community feedback into comment summaries in BIPs directly. Given the low\n    participation and corresponding low information quality of the summaries that resulted from that feature, this BIP\n    instead intends to leave the evaluation of BIPs to the reviewers and users.\n[^adoption]: **Why does the BIPs repository no longer track adoption?**  \n    In the past, some BIPs maintained lists of projects that had implemented the BIP. These lists generated\n    noise for subscribers of the repository, often listed implementations of questionable quality, and quickly\n    grew outdated, therefore providing little value. The repository no longer tracks which projects have implemented\n    BIPs. Instead, it is recommended that projects publish a list of the BIPs they implement.\n[^markdown]: **Which flavor of Markdown is allowed?**  \n    The author of this proposal has no opinion on Markdown flavors, but recommends that proposals stick to the basic\n    Markdown syntax features commonly shared across Markdown dialects.\n[^living-documents]: **Why are Process BIPs living documents?**  \n    In the past years, the existing BIPs process has not always provided a clear approach to all situations. For\n    example, the content of BIP\u202f2 appears to have been penned especially with fork proposals in mind. It seems clear\n    that Bitcoin development will evolve in many surprising ways in the future. Instead of mandating the effort of\n    writing a new process document every time new situations arise, it seems preferable to allow the process to adapt to\n    the concerns of the future in specific aspects. Therefore, Process BIPs are defined as living documents that remain\n    open to amendment. If a Process BIP requires large modifications or even a complete overhaul, a new BIP should be\n    preferred.\n[^new-BIP]: **Why should the specification of an implemented BIP no longer be changed?**  \n    After a Complete or Deployed BIP has been deployed by one or more implementations, breaking changes to the\n    specification could lead to a situation where multiple \"compliant\" implementations fail at being interoperable,\n    because they implemented different versions of the same BIP. Therefore, even changes to the specification of\n    Complete BIPs should be avoided, but Deployed BIPs should never be subject to breaking changes to their\n    specification.\n[^bip-announcements-to-list]: **Why are some BIP status changes announced to the mailing list?**  \n    The BIPs repository does not and cannot track who might be interested in or has deployed a BIP. While concerns were\n    raised that making announcements to the Bitcoin Developer Mailing List would introduce unnecessary noise, our\n    rationale is that 1) moving Complete and Deployed BIPs to the Closed status will be a rare occurrence, 2) status\n    updates will usually not generate a lot of discussion, 3) while the mailing list should preferably only used for\n    getting review for new BIPs, it is the only channel available to us that can be considered a public announcement to\n    the audience of the BIPs repository: even if the authors, implementers, or other parties interested in a BIP do not\n    see the announcement themselves, they may be made aware by someone that does see it.\n[^superseded-by-proposed-replacement]: **Why is Superseded-By replaced with Proposed-Replacement?**  \n    Reviewers asked who should get to decide whether a BIP is superseded in case of a disagreement among the authors of\n    the original BIP, the authors of the new BIP, the editors, or the community? This is addressed by making the\n    \"Replaces\" header part of the recommendation of the authors of the new document, and replacing the \"Superseded-By\"\n    header with the \"Proposed-Replacement\" header that lists any proposals that recommend replacing the original document.\n[^proposes-to-replace]: **Why was \"Replaces\" retained instead of changing it to \"Proposes-to-Replace\"?**  \n    When one BIP proposes to supersede another, it is on the original BIP where things get complicated. The BIP is an\n    author document, but depending on its progress through the workflow, it may meanwhile be co-owned by the community. Who may decide\n    whether the original document should endorse a potential replacement BIP? Is it the original authors, the authors of the new\n    proposal, the BIP Editors, some sort of community process, or a mix of all of the above?  \n    On the new BIP these problems don\u2019t exist in the same manner. As it is freshly written, it is wholly owned by its\n    authors. The community is not yet invested and the original BIP\u2019s authors do not have a privileged role\n    in determining the content of the new BIP. The authors of the new BIP can unilaterally recommend that it be\n    considered a replacement for a prior BIP. From there, the community can evaluate the proposal and adopt or\n    reject it, thus establishing whether it is successful in superseding the original or not.\n[^evidence]: **How is evidence for advancing to Deployed evaluated?**  \n    Whether evidence is deemed convincing to move a BIP to Deployed is up to the BIP Editors and Bitcoin community.\n    Running a single instance of a personal fork of a software project might be rejected, while a small software project with\n    dozens of users may be sufficient. The main point of the Deployed status is to indicate that changes to the BIP\n    could negatively impact users of projects that have already implemented support.\n[^licenses]: **Why were some licenses dropped?**  \n    Among the 141 BIPs with licenses in the repository, only nine licenses have ever been used to license BIPs\n    (although, some BIPs were made available under more than one license) and only one license has been used to license\n    code:\n\n    Licenses used:\n\n    * BSD-2-Clause: 55\n    * PD: 42\n    * CC0-1.0: 23\n    * BSD-3-Clause: 19\n    * OPUBL-1.0: 5\n    * CC-BY-SA-4.0: 4\n    * FSFAP: 3\n    * MIT: 2\n    * CC-BY-4.0: 1\n\n    License-Code used (previous BIP2 format):\n\n    * BSD-2-Clause: 1\n    * CC0-1.0: 1\n    * MIT: 5\n\n    The following previously acceptable licenses were retained per request of reviewers, even though they have so far\n    never been used in the BIPs process:\n\n    * Apache-2.0: [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0)\n    * BSL-1.0: [Boost Software License 1.0](https://www.boost.org/LICENSE_1_0.txt)\n\n    The following previously acceptable licenses have never been used in the BIPs Process and have been dropped:\n\n    * AGPL-3.0+: [GNU Affero General Public License (AGPL) 3](https://www.gnu.org/licenses/agpl-3.0.en.html)\n    * FDL-1.3: [GNU Free Documentation License 1.3](https://www.gnu.org/licenses/fdl-1.3.en.html)\n    * GPL-2.0+: [GNU General Public License (GPL) 2 or newer](https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)\n    * LGPL-2.1+: [GNU Lesser General Public License (LGPL) 2.1 or newer](https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html)\n\n    Why are software licenses included?\n\n    * Some BIPs, in particular those concerning the consensus layer, may include literal code in the BIP itself which\n      may not be available under the license terms the authors wish to use for the BIP.\n    * The author of this BIP has been provided with a learned opinion indicating that software licenses are perfectly\n      acceptable for licensing \"human code\" i.e., text as well as Markdown or MediaWiki code.\n\n    Why is CC-BY-SA-4.0 no longer acceptable for new BIPs?\n\n    * Specification BIPs are required to have a Reference Implementation and Test Vectors to be advanced to Complete. As\n      the BIPs repository is aiming to make proposals easily adoptable, the intention is for the reference\n      implementation and test vectors to be as accessible as possible. Copyleft licenses may introduce friction here,\n      and therefore CC-BY-SA-4.0 (and the GPL-flavors) is no longer considered acceptable for new BIPs. As mentioned\n      above, existing BIPs will retain their original licensing.\n\n    Why are Open Publication License and Public Domain no longer acceptable for new BIPs?\n\n    * Public domain is not universally recognised as a legitimate action, thus it is inadvisable.\n    * The Open Publication License is generally regarded as obsolete, and not a license suitable for new publications.\n", "content_length": 52830}
{"bip_number": 39, "filename": "bip-0039-wordlists.md", "content": "# Wordlists\n\n* [English](english.txt)\n* [Japanese](japanese.txt)\n* [Korean](korean.txt)\n* [Spanish](spanish.txt)\n* [Chinese (Simplified)](chinese_simplified.txt)\n* [Chinese (Traditional)](chinese_traditional.txt)\n* [French](french.txt)\n* [Italian](italian.txt)\n* [Czech](czech.txt)\n* [Portuguese](portuguese.txt)\n\n## Wordlists (Special Considerations)\n\n### Japanese\n\n1. **Developers implementing phrase generation or checksum verification must separate words using ideographic spaces / accommodate users inputting ideographic spaces.**\n(UTF-8 bytes: **0xE38080**; C/C+/Java: **\"\\u3000\"**; Python: **u\"\\u3000\"**)\nHowever, code that only accepts Japanese phrases but does not generate or verify them should be fine as is.\nThis is because when generating the seed, normalization as per the spec will\nautomatically change the ideographic spaces into normal ASCII spaces, so as long as your code never shows the user an ASCII space\nseparated phrase or tries to split the phrase input by the user, dealing with ASCII or Ideographic space is the same.\n\n2. Word-wrapping doesn't work well, so making sure that words only word-wrap at one of the\nideographic spaces may be a necessary step. As a long word split in two could be mistaken easily\nfor two smaller words (This would be a problem with any of the 3 character sets in Japanese)\n\n### Spanish\n\n1. Words can be uniquely determined by typing the first 4 characters (sometimes less).\n\n2. Special Spanish characters like '\u00f1', '\u00fc', '\u00e1', etc... are considered equal to 'n', 'u', 'a', etc... in terms of identifying a word. Therefore, there is no need to use a Spanish keyboard to introduce the passphrase, an application with the Spanish wordlist will be able to identify the words after the first 4 chars have been typed even if the chars with accents have been replaced with the equivalent without accents.\n\n3. There are no words in common between the Spanish wordlist and any other language wordlist, therefore it is possible to detect the language with just one word.\n\n### Chinese\n\n1. Chinese text typically does not use any spaces as word separators. For the sake of\nuniformity, we propose to use normal ASCII spaces (0x20) to separate words as per standard.\n\n### French\n\nCredits: @Kirvx @NicolasDorier @ecdsa @EricLarch\n([The pull request](https://github.com/bitcoin/bips/issues/152))\n\n1.  High priority on simple and common French words.\n2.  Only words with 5-8 letters.\n3.  A word is fully recognizable by typing the first 4 letters (special French characters \"\u00e9-\u00e8\" are considered equal to \"e\", for example \"museau\" and \"mus\u00e9e\" can not be together).\n4.  Only infinitive verbs, adjectives and nouns.\n5.  No pronouns, no adverbs, no prepositions, no conjunctions, no interjections (unless a noun/adjective is also popular than its interjection like \"mince;chouette\").\n6.  No numeral adjectives.\n7.  No words in the plural (except invariable words like \"univers\", or same spelling as singular like \"heureux\").\n8.  No female adjectives (except words with same spelling for male and female adjectives like \"magique\").\n9.  No words with several senses AND different spelling in speaking like \"verre-vert\", unless a word has a meaning much more popular than another like \"perle\" and \"pairle\".\n10. No very similar words with only 1 letter of difference.\n11. No essentially reflexive verbs (unless a verb is also a noun like \"souvenir\").\n12. No words with \"\u00f4;\u00e2;\u00e7;\u00ea;\u0153;\u00e6;\u00ee;\u00ef;\u00fb;\u00f9;\u00e0;\u00eb;\u00ff\".\n13. No words ending by \"\u00e9;\u00e9e;\u00e8;et;ai;ait\".\n14. No demonyms.\n15. No words in conflict with the spelling corrections of 1990 (http://goo.gl/Y8DU4z).\n16. No embarrassing words (in a very, very large scope) or belonging to a particular religion.\n17. No identical words with the Spanish wordlist (as Y75QMO wants).\n\n### Italian\n\nCredits: @paoloaga @Polve\n\nWords chosen using the following rules:\n\n1. Simple and common Italian words.\n2. Length between 4 and 8 characters.\n3. First 4 letters must be unique between all words.\n4. No accents or special characters.\n5. No complex verb forms.\n6. No plural words.\n7. No words that remind negative/sad/bad things.\n8. If both female/male words are available, choose male version.\n9. No words with double vowels (like: lineetta).\n10. No words already used in other language mnemonic sets.\n11. If 3 of the first 4 letters are already used in the same sequence in another mnemonic word, there must be at least other 3 different letters.\n12. If 3 of the first 4 letters are already used in the same sequence in another mnemonic word, there must not be the same sequence of 3 or more letters.\n\nRules 11 and 12 prevent the selection words that are not different enough. This makes each word more recognizable among others and less error prone. For example: the wordlist contains \"atono\", then \"atomo\" is rejected, but \"atomico\" is good.\n\nAll the words have been manually selected and automatically checked against the rules.\n\n### Czech\n\nCredits: @zizelevak (Jan Lansky zizelevak@gmail.com)\n\nWords chosen using the following rules:\n\n1.  Words are 4-8 letters long.\n2.  Words can be uniquely determined by typing the first 4 letters.\n3.  Only words containing all letters without diacritical marks. (It was the hardest task, because one third of all Czech letters has diacritical marks.)\n4.  Only nouns, verbs and adverbs, no other word types. All words are in basic form.\n5.  No personal names or geographical names.\n6.  No very similar words with 1 letter of difference.\n7.  Words are sorted according to English alphabet (Czech sorting has difference in \"ch\").\n8.  No words already used in other language mnemonic sets (english, italian, french, spanish). Letters with diacritical marks from these sets are counted as analogous letters without diacritical marks.\n\n### Portuguese\n\nCredits: @alegotardo @bitmover-studio @brenorb @kuthullu @ninjastic @sabotag3x @Trimegistus\n\n1. Words can be uniquely determined by typing the first 4 characters.\n2. No accents or special characters.\n3. No complex verb forms.\n4. No plural words, unless there's no singular form.\n5. No words with double spelling.\n6. No words with the exact sound as another word with different spelling.\n7. No offensive words.\n8. No words already used in other language mnemonic sets.\n9. The words which have not the same spelling in Brazil and in Portugal are excluded.\n10. No words that remind one of negative/sad/bad things.\n11. No very similar words with only 1 letter of difference.\n", "content_length": 6407}
